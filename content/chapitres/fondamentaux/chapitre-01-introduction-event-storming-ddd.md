---
title: "Chapitre 1 : Introduction au Domain-Driven Design et Event Storming"
description: "D√©couvrir le Domain-Driven Design d'Eric Evans, l'Event Storming et l'Example Mapping pour r√©v√©ler la complexit√© m√©tier"
date: 2024-12-19
draft: false
type: "docs"
weight: 1
---

## üéØ Objectif de ce Chapitre

### Un R√©cit Personnel

Il est 17h30, je viens de passer 3 heures dans xdebug pour un bug qui semblait simple. Le probl√®me ? Une modification 
dans une partie du code a cass√© quelque chose dans une autre partie, √† des kilom√®tres de l√†. Je me demande : "Comment en
sommes-nous arriv√©s l√† ?"

**Cette situation vous dit quelque chose ?**

Moi, je l'ai v√©cue des dizaines de fois :
- J'ajoute une fonctionnalit√© et 3 autres se cassent
- Chaque modification n√©cessite de toucher √† 5 fichiers diff√©rents
- Je ne comprends plus pourquoi le code fait ce qu'il fait
- Les tests passent mais l'application ne fonctionne pas comme attendu
- J'ai peur de modifier du code "qui marche"

### La Complexit√© qui s'installe

Ce n'√©tait pas de ma faute. Mon projet Gyroscops a commenc√© avec de bonnes intentions : une architecture simple, du code
propre, des tests. Mais quelque part sur le chemin, la complexit√© s'est install√©e insidieusement. Elle se cachait
derri√®re des noms de variables trompeurs ou simplistes, des m√©thodes qui faisaient trop de choses, des d√©pendances
cach√©es.

**Le probl√®me fondamental ?** J'ai construit mon logiciel comme si le m√©tier √©tait simple. Lorsque l'on d√©marre un 
projet, on a une vision partielle de ce qui sera n√©cessaire. De fait, j'ai essay√© de forcer la r√©alit√© m√©tier dans des 
structures techniques rigides, et cela a fini par rendre la maintenance insoutenable. Pour ajouter √† cette complexit√©
existante, nous avons voulu fournir notre service sous la forme de SaaS, ce qui a ajout√© un niveau de complexit√©
technique suppl√©mentaire.

**Le r√©sultat ?** J'ai d√ª bloquer toutes les √©volutions du produit pendant 2 mois pour remettre l'application dans un
√©tat qui soit plus facile √† maintenir.

### Ce Chapitre Change la Donne

Ce chapitre pose les fondations de l'approche que l'on a d√©velopp√©e pour √©viter de retomber dans ces pi√®ges :
- **Les principes fondamentaux** du Domain-Driven Design selon Eric Evans
- **Pourquoi le CRUD limite vos mouvements** et vous fait perdre du temps
- **Pourquoi les mod√®les an√©miques** vous emp√™chent d'avancer plus vite
- **Comment l'Impact Mapping** aligne le produit sur les objectifs business
- **Comment l'Event Storming** r√©v√®le la complexit√© m√©tier cach√©e
- **Comment l'Example Mapping** d√©taille les r√®gles m√©tier complexes

### Savoir bien structurer son monolithe modulaire 

**Voici ce que d√©velopper Gyroscops a r√©v√©l√©** : M√™me quand on d√©marre un projet, il est important de construire un
monolithe modulaire bien structur√©. Le sujet des Micro-services a toujours √©t√© exclu dans mon cas, mais je suis tomb√©
dans le pi√®ge de la complexit√© √† cause de contraintes techniques que je n'ai pas tout de suite s√©par√© des contraintes
m√©tiers.

Depuis 2008, j'ai beaucoup travaill√© dans le milieu de l'e-commerce, souvent pour r√©cup√©rer des projets en souffrance.
Quand on fait de l'int√©gration d'une solution existante, on est guid√©, on peut rester dans les rails de ce que l'√©diteur
a pr√©vu pour nous. Cependant, les projets qui √©chouent sont souvent ceux o√π l'√©quipe de d√©veloppement n'a pas pris
suffisamment de temps pour r√©fl√©chir au besoin m√©tier. J'ai souvent vu des √©quipes exploser leur codebase en 15 services
"ind√©pendants" qui finissent par d√©pendre les uns des autres. Je l'ai probablement fait en d√©but de carri√®re.

**Aujourd'hui, je pr√©f√®re un monolithe modulaire** :
- Bien d√©coup√© en domaines fonctionnels clairs
- Avec des interfaces internes bien d√©finies
- Testable, maintenable, lisible
- D√©ployable en un clic

Et le jour o√π un module deviendra vraiment trop gros ou trop critique, l√† je r√©fl√©chirais √† la possibilit√© de l'extraire
en microservice. Mais je pars du besoin, pas du dogme.

**Le microservice doit √™tre un outil. Pas une posture.**

## Le Domain-Driven Design : Une Approche Centr√©e sur le M√©tier

### Les Fondements selon Eric Evans

Le Domain-Driven Design (DDD) est une approche de d√©veloppement logiciel qui place le domaine m√©tier au c≈ìur de la
conception. Eric Evans, dans son livre fondateur "Domain-Driven Design: Tackling Complexity in the Heart of Software",
nous enseigne que :

> "Le logiciel doit refl√©ter le domaine m√©tier, pas l'inverse."

### Les Concepts Cl√©s du DDD

#### 1. Le Langage Ubiquitaire (Ubiquitous Language)

Le langage utilis√© par l'√©quipe de d√©veloppement doit √™tre le m√™me que celui du domaine m√©tier. Pas de traduction, pas 
de jargon technique qui √©loigne du m√©tier. Pas de charge mentale pour se souvenir de chaque d√©finition en fonction du
contexte.

#### 2. Les Bounded Contexts

Chaque contexte m√©tier a ses propres mod√®les, sa propre logique. Un "Client" dans le contexte "Ventes" n'est pas le m√™me
qu'un "Client" dans le contexte "Cloud".

#### 3. Les Agr√©gats

Des grappes d'objets m√©tier qui sont trait√©s comme une unit√© coh√©rente. L'agr√©gat prot√®ge ses invariants m√©tier. 

#### 4. Les Value Objects

Des objets immuables qui repr√©sentent des concepts m√©tier par leur valeur, pas par leur identit√©.

**Exemple concret du projet Gyroscops Cloud** :

```php
use Assert\Assertion;
use Brick\Math\BigDecimal;

// ‚úÖ Value Object - Price
final readonly class Price
{
    public function __construct(
        public BigDecimal $amount,
        public Currencies $currency,
    ) {
        Assertion::true($this->amount->isGreaterThan(0));
    }

    public function substract(self $price): self
    {
        if ($price->currency !== $this->currency) {
            throw new CurrencyMismatchException('Currency conversion is not supported');
        }

        return new self($this->amount->minus($price->amount), $this->currency);
    }

    public function add(self $price): self
    {
        if ($price->currency !== $this->currency) {
            throw new CurrencyMismatchException('Currency conversion is not supported');
        }

        return new self($this->amount->plus($price->amount), $this->currency);
    }

    public function isGreaterThan(self $price): bool
    {
        if ($price->currency !== $this->currency) {
            throw new CurrencyMismatchException('Currency conversion is not supported');
        }

        return $this->amount->isGreaterThan($price->amount);
    }

    public function isGreaterThanOrEqualTo(self $price): bool
    {
        if ($price->currency !== $this->currency) {
            throw new CurrencyMismatchException('Currency conversion is not supported');
        }

        return $this->amount->isGreaterThanOrEqualTo($price->amount);
    }

    public function isLessThan(self $price): bool
    {
        if ($price->currency !== $this->currency) {
            throw new CurrencyMismatchException('Currency conversion is not supported');
        }

        return $this->amount->isLessThan($price->amount);
    }

    public function isLessThanOrEqualTo(self $price): bool
    {
        if ($price->currency !== $this->currency) {
            throw new CurrencyMismatchException('Currency conversion is not supported');
        }

        return $this->amount->isLessThanOrEqualTo($price->amount);
    }

    public function isEqualTo(self $price): bool
    {
        if ($price->currency !== $this->currency) {
            throw new CurrencyMismatchException('Currency conversion is not supported');
        }

        return $this->amount->isEqualTo($price->amount);
    }

    public function isZero(): bool
    {
        return $this->amount->isZero();
    }

    public function multipliedBy(BigNumber|string $number): self
    {
        return new self(
            $this->amount->multipliedBy($number),
            $this->currency,
        );
    }
}
```

**Ce que cet exemple montre** :
- **Immutabilit√©** : `readonly` et constructeur priv√© emp√™chent la modification
- **Validation** : Le constructeur valide que le montant n'est pas n√©gatif
- **Logique m√©tier** : Les op√©rations arithm√©tiques respectent les r√®gles m√©tier
- **Comparaison par valeur** : Deux `Price` avec le m√™me montant et la m√™me devise sont √©gaux
- **Encapsulation** : La logique de calcul des prix est centralis√©e dans le Value Object

### Exemple Concret : Un Syst√®me de Paiement

Voici un exemple r√©el tir√© du projet Gyroscops Cloud, montrant comment l'approche DDD guide la conception :

```php
use Assert\Assertion;

// ‚úÖ Approche DDD - Le domaine m√©tier guide la conception
final class Payment
{
    public function __construct(
        public readonly PaymentId $uuid,
        public readonly RealmId $realmId,
        public readonly OrganizationId $organizationId,
        public readonly SubscriptionId $subscriptionId,
        private ?\DateTimeInterface $creationDate = null,
        private ?\DateTimeInterface $expirationDate = null,
        private ?\DateTimeInterface $completionDate = null,
        private ?Statuses $status = null,
        private ?Gateways $gateway = null,
        private ?Price $subtotal = null,
        private ?Price $discount = null,
        private ?Price $taxes = null,
        private ?Price $total = null,
        private ?Price $captured = null,
        private array $events = [],
        private int $version = 0,
    ) {}

    public static function registerOnlinePayment(
        PaymentId $uuid,
        RealmId $realmId,
        OrganizationId $organizationId,
        SubscriptionId $subscriptionId,
        \DateTimeInterface $creationDate,
        \DateTimeInterface $expirationDate,
        string $customerName,
        string $customerEmail,
        Price $subtotal,
        Price $discount,
        Price $vat,
        Price $total,
    ): self {
        $instance = new self($uuid, $realmId, $organizationId, $subscriptionId);
        
        Assertion::true($this->canTransitionTo(Statuses::Pending));

        $instance->recordThat(new RegisteredPaymentEvent(
            uuid: $uuid,
            version: 1,
            realmId: $realmId,
            organizationId: $organizationId,
            subscriptionId: $subscriptionId,
            creationDate: $creationDate,
            expirationDate: $expirationDate,
            customerName: $customerName,
            customerEmail: $customerEmail,
            status: Statuses::Pending,
            subtotal: $subtotal,
            discount: $discount,
            taxes: $vat,
            total: $total,
        ));

        return $instance;
    }

    public function authorize(Gateways $gateway, Price $amount, \DateTimeInterface $authorizationDate): void
    {
        Assertion::true($this->canTransitionTo(Statuses::Authorized));
        
        $this->recordThat(new CapturedEvent(
            uuid: $this->uuid,
            version: $this->version + 1,
            realmId: $this->realmId,
            organizationId: $this->organizationId,
            subscriptionId: $this->subscriptionId,
            status: Statuses::Authorized,
            gateway: $gateway,
            amount: $amount,
            authorizationDate: $authorizationDate,
        ));
    }

    public function capture(Gateways $gateway, Price $amount, \DateTimeInterface $completionDate): void
    {
        Assertion::true($this->canTransitionTo(Statuses::Completed));
        
        $this->recordThat(new CapturedEvent(
            uuid: $this->uuid,
            version: $this->version + 1,
            realmId: $this->realmId,
            organizationId: $this->organizationId,
            subscriptionId: $this->subscriptionId,
            status: Statuses::Completed,
            gateway: $gateway,
            amount: $amount,
            completionDate: $completionDate,
        ));
    }

    public function fail(Gateways $gateway, Price $amount, \DateTimeInterface $failureDate, string $reason): void
    {
        Assertion::true($this->canTransitionTo(Statuses::Failed));

        $this->recordThat(new FailedEvent(
            uuid: $this->uuid,
            version: $this->version + 1,
            realmId: $this->realmId,
            organizationId: $this->organizationId,
            subscriptionId: $this->subscriptionId,
            status: Statuses::Failed,
            gateway: $gateway,
            amount: $amount,
            failureDate: $failureDate,
            reason: $reason,
        ));
    }

    private function canTransitionTo(Statuses $status): bool
    {
        return match ($this->status) {
            Statuses::Pending => match ($status) {
                null, Statuses::Pending, Statuses::Authorized, Statuses::Completed, Statuses::Cancelled, Statuses::Failed => true,
            },
            Statuses::Authorized => match ($status) {
                Statuses::Authorized, Statuses::Completed, Statuses::Cancelled, Statuses::Failed => true,
                default => false,
            },
            Statuses::Completed => match ($status) {
                Statuses::Completed => true,
                default => false,
            },
            Statuses::Cancelled => match ($status) {
                Statuses::Cancelled => true,
                default => false,
            },
            Statuses::Failed => match ($status) {
                Statuses::Failed => true,
                default => false,
            },
        };
    }
}
```

**Ce que cet exemple montre** :
- **Intention m√©tier claire** : `registerOnlinePayment()`, `capture()`, `authorize()`, `fail()` expriment clairement l'intention
- **Protection des invariants** : `canTransitionTo()` prot√®ge les transitions d'√©tat valides
- **Event Sourcing** : Chaque changement d'√©tat est enregistr√© comme un √©v√©nement
- **Value Objects** : `PaymentId`, `Price`, `Statuses` encapsulent les concepts m√©tier
- **S√©paration des responsabilit√©s** : L'agr√©gat se concentre sur la logique m√©tier, pas sur la persistance

## Pourquoi le CRUD limite vos mouvements

### Mon Pi√®ge : La Simplicit√© Apparente du CRUD

Le CRUD (Create, Read, Update, Delete) semblait √™tre la solution parfaite : simple, direct, facile √† comprendre. "Pourquoi compliquer les choses ?" me demandais-je. Et c'est exactement l√† que le pi√®ge s'est referm√©.

**Voici ce qui s'est pass√© avec Gyroscops** : j'avais un syst√®me de gestion d'utilisateurs. Au d√©but, c'√©tait simple : cr√©er, lire, modifier, supprimer. Puis est arriv√©e la demande : "On veut pouvoir suspendre un utilisateur". Facile, j'ai ajout√© un champ `status`. Puis : "Un utilisateur suspendu ne peut pas se connecter". OK, j'ai ajout√© une v√©rification. Puis : "Un utilisateur suspendu ne peut pas changer son email". Encore une v√©rification. Puis : "Il faut notifier l'utilisateur quand il est suspendu". Une autre v√©rification...

**R√©sultat** : Mon code ressemblait √† un champ de mines. Chaque modification pouvait faire exploser quelque chose d'inattendu.

### Le Pi√®ge du CRUD

Le CRUD est une approche technique qui r√©duit votre domaine m√©tier √† des op√©rations de base de donn√©es. Cette approche m'a emp√™ch√© de :

1. **Comprendre vraiment mon m√©tier** - Je ne voyais que la technique, pas la logique
2. **√âvoluer facilement** - Chaque changement devenait un cauchemar
3. **Maintenir la coh√©rence** - Rien n'emp√™chait les √©tats incoh√©rents
4. **Conserver l'intention utilisateur** (le plus grave) - L'intention se perdait d√®s le contr√¥leur

#### 1. **Comprendre Vraiment Votre M√©tier**
```php
// ‚ùå Approche CRUD - Le m√©tier dispara√Æt
class PaymentController
{
    public function create(Request $request): Response
    {
        $payment = new Payment();
        $payment->setAmount($request->get('amount'));
        $payment->setStatus('pending');
        $this->paymentRepository->save($payment);
        return new Response(['id' => $payment->getId()]);
    }
    
    public function update(Request $request, string $id): Response
    {
        $payment = $this->paymentRepository->find($id);
        $payment->setAmount($request->get('amount'));
        $payment->setStatus($request->get('status'));
        $this->paymentRepository->save($payment);
        return new Response(['success' => true]);
    }
}
```

La logique m√©tier est saupoudr√©e au milieu de concepts techniques. Il est difficile d'identifier qui valide les r√®gles. Toute √©volution est rendue complexe. 

#### 2. **√âvoluer Facilement**
Avec le CRUD, ajouter une nouvelle r√®gle m√©tier devient un un parcours d'obstacles :
1. Modifier le contr√¥leur
2. Modifier les services
3. Modifier les validations
4. Modifier les tests
5. Risque de r√©gression

#### 3. **Maintenir la Coh√©rence**
Le CRUD ne prot√®ge pas les invariants m√©tier. Rien n'emp√™che de cr√©er un paiement avec un montant n√©gatif ou de modifier un paiement d√©j√† trait√©.

#### 4. **Conserver l'Intention Utilisateur**
Le plus grave des pi√®ges du CRUD est la **perte de l'intention utilisateur**. Les m√©thodes `get` et `set` ne sont que le reflet d'une fraction de l'intention, parfois seulement des contraintes techniques.

```php
// ‚ùå CRUD - L'intention est perdue d√®s le contr√¥leur
class PaymentController
{
    public function processPayment(Request $request): Response
    {
        $payment = $this->paymentRepository->find($request->get('id'));
        
        // L'intention "traiter un paiement" devient :
        $payment->setStatus('processing');  // Contrainte technique
        $payment->setProcessedAt(now());    // Contrainte technique
        $payment->setAmount($request->get('amount')); // Donn√©e brute
        
        $this->paymentRepository->save($payment);
        return new Response(['success' => true]);
    }
}
```

**Probl√®me** : 
- L'intention "traiter un paiement" dispara√Æt d√®s les premiers instants
- Impossible de savoir **pourquoi** le paiement a √©t√© trait√©
- L'intention ne peut √™tre que reconstruite ou d√©duite a posteriori
- Aucune trace de l'intention d'origine dans le code

```php
// ‚úÖ DDD - L'intention est pr√©serv√©e et explicite
class ProcessPayment
{
    public function __construct(
        public readonly PaymentId $id,
        public readonly Money $amount,
        public readonly PaymentMethod $method
    ) {}
}

class Payment
{
    public function process(ProcessPayment $command): void
    {
        // L'intention "process" est claire et pr√©serv√©e
        if (!$this->canBeProcessed()) {
            throw new PaymentCannotBeProcessedException();
        }
        
        $this->status = PaymentStatuses::Processing;
        $this->processedAt = new DateTimeImmutable();
        $this->amount = $command->amount;
        
        // L'intention est conserv√©e dans l'√©v√©nement
        $this->recordEvent(new PaymentProcessed($this->id, $command->amount));
    }
}
```

**Avantage** : L'intention m√©tier est **explicite**, **pr√©serv√©e** et **tra√ßable** tout au long du cycle de vie de l'objet.

### La Solution : Des Commandes M√©tier

```php
// ‚úÖ Approche DDD - Le m√©tier guide l'√©volution
class ProcessPayment
{
    public function __construct(
        public readonly PaymentId $id,
        public readonly Money $amount,
        public readonly PaymentMethod $method
    ) {}
}

#[AsMessageHandler('command.bus')]
class ProcessPaymentHandler
{
    public function __invoke(ProcessPayment $command): void
    {
        $payment = $this->paymentRepository->find($command->id);
        $payment->process($command->amount);
        $this->paymentRepository->save($payment);
    }
}
```

**Avantages** :
- La logique m√©tier est centralis√©e
- L'√©volution est guid√©e par le m√©tier
- Les invariants sont prot√©g√©s
- Le code est plus expressif

## Pourquoi les mod√®les an√©miques vous emp√™chent d'avancer plus vite

### Mon Illusion : La S√©paration des Responsabilit√©s

Les mod√®les an√©miques semblaient respecter le principe de s√©paration des responsabilit√©s : "Les entit√©s stockent les donn√©es, les services contiennent la logique". C'est logique, non ? **Non, c'est trompeur !**

**Le probl√®me** : Je s√©parais les donn√©es de leur logique. C'est comme s√©parer le l'autopilote de l'avion : techniquement possible, mais pas tr√®s optimal.

**Voici ce qui s'est pass√© avec Gyroscops** : j'avais un syst√®me de gestion d'utilisateurs. Au d√©but, c'√©tait simple : des entit√©s avec des getters/setters, des services qui faisaient la logique. Puis est arriv√©e la demande : "On veut pouvoir suspendre un utilisateur". Facile, j'ai ajout√© un champ `isSuspended` et une m√©thode dans le service. Puis : "Un utilisateur suspendu ne peut pas se connecter". OK, j'ai ajout√© une v√©rification dans le service. Puis : "Un utilisateur suspendu ne peut pas changer son email". Encore une v√©rification dans le service. Puis : "Il faut notifier l'utilisateur quand il est suspendu". Une autre v√©rification dans le service...

Je n'ai pas encore √©voqu√© les inter-d√©pendances entre les entit√©s lors de l'inscription.

**R√©sultat** : Ma logique m√©tier √©tait √©parpill√©e dans de multiples services diff√©rents. Chaque modification n√©cessitait de toucher √† au moins 5 fichiers. Je ne savais plus o√π √©tait quoi, mes coll√®gues non plus.

### Mon Pi√®ge : Les Mod√®les An√©miques

Un mod√®le an√©mique est un mod√®le qui ne contient que des propri√©t√©s (getters/setters) sans logique m√©tier. Cette approche a limit√© ma capacit√© √† :

1. **Exprimer l'intention m√©tier** - Ma logique √©tait √©parpill√©e dans plusieurs services et la coh√©rence n'√©tait pas syst√©matiquement maintenue
2. **√âvoluer sans casser** - Chaque changement impactait plusieurs services
3. **Tester efficacement** - Mes tests devenaient fragiles et complexes

#### 1. **Exprimer l'Intention M√©tier**
```php
// ‚ùå Mod√®le An√©mique - L'intention dispara√Æt
class User
{
    public function __construct(
        private string $id,
        private string $email,
        private string $firstName,
        private string $lastName,
        private bool $isActive = true
    ) {}

    // Seulement des getters/setters
    public function getId(): string { return $this->id; }
    public function getEmail(): string { return $this->email; }
    public function setEmail(string $email): void { $this->email = $email; }
    // ... autres getters/setters
}
```

**Probl√®me** : Comment savoir si un utilisateur peut se connecter ? Comment valider un email ? Comment g√©rer l'activation ?

**Avec Gyroscops, j'ai v√©cu cette situation** : J'avais un mod√®le `User` avec des getters/setters, et la logique √©tait √©parpill√©e dans 12 services diff√©rents. Quand j'ai voulu ajouter la fonctionnalit√© "suspendre un utilisateur", j'ai d√ª :

**Services li√©s √† l'utilisateur** :
- Modifier le service `UserService` pour la logique de suspension
- Modifier le service `AuthService` pour v√©rifier le statut
- Modifier le service `EmailService` pour les notifications

**Services li√©s √† l'organisation** :
- Modifier le service `OrganizationService` car l'utilisateur appartient √† une organisation
- Modifier le service `BillingService` car l'organisation est l'entit√© factur√©e
- Modifier le service `AuditService` pour l'historique organisationnel

**Services li√©s au workflow** :
- Modifier le service `WorkflowService` car le workflow est l'espace de travail
- Modifier le service `CloudService` car le workflow est d√©ploy√© dans une r√©gion cloud
- Modifier le service `ResourceService` car le workflow comprend des ressources

**Services transversaux** :
- Modifier le service `NotificationService` pour les alertes
- Modifier le service `ReportService` pour les statistiques
- Modifier le service `CacheService` pour l'invalidation

**R√©sultat** : 12 fichiers √† modifier pour une seule fonctionnalit√© ! Et si j'oubliais un service ? Et si les r√®gles √©taient incoh√©rentes entre les services ? Et comment g√©rer les d√©pendances entre User ‚Üí Organization ‚Üí Workflow ‚Üí Cloud Resources ?

La logique m√©tier se retrouve √©parpill√©e dans les services, m√©langeant souvent **r√®gles m√©tier** et **contraintes techniques** :

```php
// ‚ùå Entit√© Doctrine avec contraintes m√©lang√©es
use Doctrine\ORM\Mapping as ORM;
use Symfony\Component\Validator\Constraints as Assert;

#[ORM\Entity]
#[ORM\Table(name: 'users')]
class User
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column(type: 'integer')]
    private ?int $id = null;

    #[ORM\Column(type: 'string', length: 255)]
    #[Assert\Email(message: 'Email invalide')]
    #[Assert\Length(max: 255, maxMessage: 'Email trop long')]
    #[Assert\NotBlank(message: 'Email obligatoire')]
    private string $email;

    #[ORM\Column(type: 'string', length: 50)]
    #[Assert\NotBlank(message: 'Le pr√©nom est obligatoire')]
    #[Assert\Length(min: 2, max: 50, minMessage: 'Pr√©nom trop court')]
    private string $firstName;

    #[ORM\Column(type: 'string', length: 50)]
    #[Assert\NotBlank(message: 'Le nom est obligatoire')]
    #[Assert\Length(min: 2, max: 50, minMessage: 'Nom trop court')]
    private string $lastName;

    #[ORM\Column(type: 'boolean')]
    private bool $isActive = true;

    // Seulement des getters/setters
    public function getId(): ?int { return $this->id; }
    public function getEmail(): string { return $this->email; }
    public function setEmail(string $email): void { $this->email = $email; }
    public function getFirstName(): string { return $this->firstName; }
    public function setFirstName(string $firstName): void { $this->firstName = $firstName; }
    public function getLastName(): string { return $this->lastName; }
    public function setLastName(string $lastName): void { $this->lastName = $lastName; }
    public function isActive(): bool { return $this->isActive; }
    public function setIsActive(bool $isActive): void { $this->isActive = $isActive; }
}

// ‚ùå Service avec logique m√©tier m√©lang√©e
class UserService
{
    public function __construct(
        private ValidatorInterface $validator,
        private UserRepository $userRepository
    ) {}

    public function validateUser(User $user): bool
    {
        // R√®gle m√©tier : L'utilisateur doit √™tre actif
        if (!$user->isActive()) {
            return false;
        }
        
        // Contrainte technique : Validation Symfony (d√©j√† dans l'entit√©)
        $violations = $this->validator->validate($user);
        if (count($violations) > 0) {
            return false;
        }
        
        // R√®gle m√©tier : L'utilisateur ne doit pas √™tre banni
        if ($this->isUserBanned($user->getId())) {
            return false;
        }
        
        return true;
    }
}
```

**Probl√®mes** :
- **M√©lange de responsabilit√©s** : Contraintes techniques (Doctrine/Symfony) et r√®gles m√©tier dans la m√™me entit√©
- **Difficile √† tester** : Comment tester uniquement les r√®gles m√©tier sans les contraintes techniques ?
- **Difficile √† maintenir** : O√π modifier une r√®gle m√©tier sp√©cifique sans impacter les contraintes ?
- **Difficile √† comprendre** : Quelle est l'intention r√©elle de cette validation ?
- **Couplage fort** : L'entit√© est coupl√©e √† la base de donn√©es ET aux r√®gles m√©tier

#### 2. **√âvoluer Sans Casser**
Avec des mod√®les an√©miques, changer une r√®gle m√©tier n√©cessite de :
1. Modifier tous les services qui utilisent le mod√®le
2. Modifier tous les contr√¥leurs
3. Modifier tous les tests
4. Risque de r√©gression √©lev√©

#### 3. **Tester Efficacement**
La logique m√©tier est √©parpill√©e dans les services, rendant les tests complexes et fragiles.

### La Solution : Des Mod√®les Riches

```php
// ‚úÖ Mod√®le Riche - L'intention m√©tier est claire
class User
{
    private function __construct(
        private UserId $id,
        private Email $email,
        private FullName $name,
        private UserStatuses $status
    ) {}

    public static function register(UserId $id, Email $email, FullName $name): self
    {
        return new self($id, $email, $name, UserStatuses::Pending);
    }

    public function activate(): void
    {
        if ($this->status !== UserStatuses::Pending) {
            throw new UserCannotBeActivatedException();
        }
        
        $this->status = UserStatuses::Active;
    }

    public function canLogin(): bool
    {
        return $this->status === UserStatuses::Active;
    }

    public function changeEmail(Email $newEmail): void
    {
        if ($this->status === UserStatuses::Suspended) {
            throw new UserCannotChangeEmailException();
        }
        
        $this->email = $newEmail;
    }
}
```

**Avantages** :
- **S√©paration claire** : R√®gles m√©tier dans le mod√®le, contraintes techniques dans les Value Objects
- **Intention m√©tier explicite** : `register`, `canLogin()`, `activate()`, `changeEmail()` expriment clairement l'intention
- **√âvolution guid√©e par le m√©tier** : Les changements suivent la logique m√©tier
- **Tests plus simples** : Chaque r√®gle m√©tier peut √™tre test√©e ind√©pendamment
- **Coh√©rence garantie** : Les invariants m√©tier sont prot√©g√©s

```php
// ‚úÖ Agr√©gat racine s√©par√© de l'entit√© Doctrine
class User
{
    public private(set) UserId $id;
    public private(set) Email $email;
    public private(set) FullName $name;
    public string $firstName {
        get => $this->name->firstName;
    }
    public string $lastName {
        get => $this->name->lastName;
    }
    public private(set) UserStatuses $status;

    public static function register(Email $email, FullName $name): self
    {
        $user = new self();
        $user->id = UserId::generate();
        $user->email = $email;
        $user->name = $name;
        $user->status = UserStatuses::Pending;
        return $user;
    }

    public function activate(): void
    {
        if ($this->status !== UserStatuses::Pending) {
            throw new UserCannotBeActivatedException();
        }
        
        $this->status = UserStatuses::Active;
    }

    public function canLogin(): bool
    {
        return $this->status === UserStatuses::Active;
    }

    public function changeName(FullName $newName): void
    {
        if ($this->status === UserStatuses::Suspended) {
            throw new UserCannotChangeNameException();
        }
        
        $this->name = $newName;
    }

    public function changeEmail(Email $newEmail): void
    {
        if ($this->status === UserStatuses::Suspended) {
            throw new UserCannotChangeEmailException();
        }
        
        $this->email = $newEmail;
    }

    public function suspend(): void
    {
        if ($this->status === UserStatuses::Suspended) {
            throw new UserAlreadySuspendedException();
        }
        
        $this->status = UserStatuses::Suspended;
    }
}

// ‚úÖ Entit√© Doctrine s√©par√©e pour la persistance
use Doctrine\ORM\Mapping as ORM;
use Symfony\Component\Validator\Constraints as Assert;

#[ORM\Entity]
#[ORM\Table(name: 'users')]
class UserEntity
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;

    #[ORM\Column(type: 'string', length: 255)]
    #[Assert\Email(message: 'Email invalide')]
    #[Assert\Length(max: 255, maxMessage: 'Email trop long')]
    #[Assert\NotBlank(message: 'Email obligatoire')]
    private string $email;

    #[ORM\Column(type: 'string', length: 50)]
    #[Assert\NotBlank(message: 'Le pr√©nom est obligatoire')]
    #[Assert\Length(min: 2, max: 50, minMessage: 'Pr√©nom trop court')]
    private string $firstName;

    #[ORM\Column(type: 'string', length: 50)]
    #[Assert\NotBlank(message: 'Le nom est obligatoire')]
    #[Assert\Length(min: 2, max: 50, minMessage: 'Nom trop court')]
    private string $lastName;

    #[ORM\Column(type: 'string', length: 20)]
    private string $status = 'pending';

    // Getters et setters pour Doctrine
    public function getId(): ?int
    {
        return $this->id;
    }

    public function getEmail(): string
    {
        return $this->email;
    }

    public function setEmail(string $email): self
    {
        $this->email = $email;
        return $this;
    }

    public function getFirstName(): string
    {
        return $this->firstName;
    }

    public function setFirstName(string $firstName): self
    {
        $this->firstName = $firstName;
        return $this;
    }

    public function getLastName(): string
    {
        return $this->lastName;
    }

    public function setLastName(string $lastName): self
    {
        $this->lastName = $lastName;
        return $this;
    }

    public function getStatus(): string
    {
        return $this->status;
    }

    public function setStatus(string $status): self
    {
        $this->status = $status;
        return $this;
    }
}

// ‚úÖ Value Objects pour les contraintes techniques
final readonly class UserId
{
    public function __construct(private string $value)
    {
        if (empty($value)) {
            throw new InvalidUserIdException('ID utilisateur obligatoire');
        }
    }

    public static function generate(): self
    {
        return new self(uniqid('user_', true));
    }

    public function __toString(): string
    {
        return $this->value;
    }
}

final readonly class Email
{
    public function __construct(private string $value)
    {
        if (!filter_var($value, FILTER_VALIDATE_EMAIL)) {
            throw new InvalidEmailException('Email invalide');
        }
        
        if (strlen($value) > 255) {
            throw new InvalidEmailException('Email trop long');
        }
    }
    
    public function __toString(): string
    {
        return $this->value;
    }
}

final readonly class FullName
{
    public function __construct(
        public string $firstName,
        public string $lastName
    ) {
        if (empty($firstName) || empty($lastName)) {
            throw new InvalidNameException('Nom complet obligatoire');
        }
    }
}
```

### **Mapper entre Agr√©gat et Entit√© Doctrine**

```php
// ‚úÖ Mapper pour convertir entre l'agr√©gat et l'entit√© Doctrine
class UserMapper
{
    public function toEntity(User $user): UserEntity
    {
        $entity = new UserEntity();
        $entity->setEmail($user->getEmail()->__toString());
        $entity->setFirstName($user->getFirstName());
        $entity->setLastName($user->getLastName());
        $entity->setStatus($user->getStatus()->value);
        
        return $entity;
    }

    public function toAggregate(UserEntity $entity): User
    {
        $user = new User();
        $user->id = new UserId($entity->getId());
        $user->email = new Email($entity->getEmail());
        $user->firstName = $entity->getFirstName();
        $user->lastName = $entity->getLastName();
        $user->status = UserStatuses::from($entity->getStatus());
        
        return $user;
    }
}
```

**R√©sultat** : 
- **S√©paration claire** : Agr√©gat m√©tier s√©par√© de l'entit√© de persistance
- **Agr√©gat pur** : Pas de d√©pendance √† Doctrine dans le mod√®le m√©tier
- **Entit√© Doctrine** : Gestion de la persistance avec validation Symfony
- **Mapper d√©di√©** : Conversion explicite entre les deux repr√©sentations
- **Testabilit√©** : L'agr√©gat peut √™tre test√© sans base de donn√©es
- **Flexibilit√©** : Possibilit√© de changer de strat√©gie de persistance

## L'Event Storming : R√©v√©ler la Complexit√© M√©tier

### Mon Probl√®me : Je Ne Voyais Que la Pointe de l'Iceberg

**Voici ce qui s'est pass√©** : J'√©tais en r√©union avec l'√©quipe'. On d√©crivait une nouvelle fonctionnalit√© : "On veut pouvoir suspendre un utilisateur". Simple, non ? J'ajoute un champ `isSuspended` et c'est r√©gl√©.

**Mais attendez...** Que se passe-t-il si l'utilisateur a des paiements en cours ? Et ses abonnements ? Et ses donn√©es personnelles ? Et les notifications ? Et l'audit ? Et la conformit√© RGPD ? Et les int√©grations avec les syst√®mes externes ?

**Soudain, ce qui semblait simple devenait un cauchemar.** Je r√©alisais que je ne comprenais pas vraiment le m√©tier. Je ne voyais que la pointe de l'iceberg.

### Qu'est-ce que l'Event Storming ?

L'Event Storming est une m√©thode de conception collaborative qui permet de :
1. **D√©couvrir le domaine m√©tier** - Voir l'iceberg entier, pas juste la pointe
2. **Identifier les √©v√©nements m√©tier** - Comprendre ce qui se passe vraiment
3. **Mod√©liser les processus** - Voir comment tout s'articule
4. **Concevoir l'architecture** - Construire sur des bases solides

### Pourquoi l'Event Storming ?

#### 1. **R√©v√©ler la Vraie Complexit√©** - Mon R√©veil Brutal

L'Event Storming m'a montr√© que mon domaine √©tait plus complexe que je ne le pensais. Cette complexit√© existait, que je la mod√©lise ou non. **La question n'√©tait pas de savoir si elle existait, mais si je voulais la g√©rer ou la subir.**

**Exemple concret avec Gyroscops** : Je pensais qu'un "paiement" √©tait simple. Puis l'Event Storming a r√©v√©l√© :
- Paiement initi√©
- Paiement en attente de validation
- Paiement valid√© par la banque
- Paiement trait√© par le syst√®me
- Paiement notifi√© au client
- Paiement enregistr√© pour l'audit
- Paiement synchronis√© avec la comptabilit√©
- Paiement affich√© dans le tableau de bord
- Paiement export√© pour les rapports
- Paiement archiv√© pour la conformit√©

**Soudain, j'ai compris pourquoi mon code √©tait si complexe !**

#### 2. **Alignement de l'√âquipe** - La Fin des Malentendus

Toute l'√©quipe (d√©veloppeurs, product owners, experts m√©tier) partage la m√™me compr√©hension du domaine. **Fini les "Ah, je pensais que..." et les "Non, mais moi je croyais que..."**

**Exemple concret avec Gyroscops** : Pendant un Event Storming sur la gestion des utilisateurs. Voici ce qui est ressorti :

- **Moi (d√©veloppeur)** : "Un utilisateur suspendu ne peut pas se connecter"
- **Le product owner** : "Non, il peut se connecter mais ne peut pas faire d'achats"
- **L'expert m√©tier** : "Il peut se connecter et faire des achats mais ne peut pas changer son email"
- **Le responsable s√©curit√©** : "Il ne peut pas acc√©der aux donn√©es sensibles"
- **Le responsable comptabilit√©** : "Il ne peut pas t√©l√©charger de factures"
- **Le responsable cloud** : "Il ne peut pas acc√©der aux workflows d√©ploy√©s"
- **Le responsable facturation** : "L'organisation doit continuer √† √™tre factur√©e m√™me si l'utilisateur est suspendu"

**R√©sultat de l'Event Storming** : Nous avons d√©couvert que "suspendre un utilisateur" n'√©tait pas un seul √©v√©nement, mais plusieurs, avec des implications sur toute la cha√Æne :

**√âv√©nements li√©s √† l'utilisateur** :
- `UserSuspended` (acc√®s restreint)
- `UserBillingSuspended` (pas d'achats)
- `UserDataAccessSuspended` (pas de donn√©es sensibles)
- `UserEmailChangeSuspended` (pas de changement d'email)

**√âv√©nements li√©s √† l'organisation** :
- `OrganizationBillingMaintained` (l'organisation continue d'√™tre factur√©e)
- `OrganizationAccessRestricted` (acc√®s restreint aux donn√©es organisationnelles)

**√âv√©nements li√©s au workflow** :
- `WorkflowAccessSuspended` (pas d'acc√®s aux workflows)
- `WorkflowResourcesMaintained` (les ressources restent actives)
- `WorkflowBillingMaintained` (la facturation du workflow continue)

**Qui avait raison ?** Tout le monde ! Chacun avait une vision partielle de la r√©alit√© m√©tier, et nous avons d√©couvert que suspendre un utilisateur avait des implications sur l'organisation, le workflow, et m√™me les ressources cloud.

#### 3. **Conception Collaborative** - Briser les Silos

L'Event Storming brise les silos et permet une conception vraiment collaborative. **Fini les "sp√©cifications" √©crites par les uns et interpr√©t√©es par les autres.**

### Les 7 √âtapes de l'Event Storming

1. **Identifier les √âv√©nements** : Qu'est-ce qui se passe dans le domaine ?
2. **Identifier les Acteurs** : Qui d√©clenche ces √©v√©nements ?
3. **Identifier les Commandes** : Quelles actions d√©clenchent les √©v√©nements ?
4. **Identifier les Agr√©gats** : Quelles entit√©s sont concern√©es ?
5. **Identifier les Syst√®mes Externes** : Quelles int√©grations sont n√©cessaires ?
6. **Identifier les Vues de Lecture** : Quelles donn√©es sont n√©cessaires pour l'affichage ?
7. **Concevoir l'Architecture** : Comment organiser le code ?

### Exemple d'Event Storming : Syst√®me de Paiement

```
√âv√©nements (Post-its Orange) :
- PaymentRequested
- PaymentProcessed
- PaymentFailed
- PaymentRefunded

Acteurs (Post-its Jaunes) :
- Customer
- PaymentGateway
- Admin

Commandes (Post-its Bleus) :
- ProcessPayment
- RefundPayment
- CancelPayment

Agr√©gats (Post-its Jaunes avec bordure) :
- Payment
- Customer
- Order
```


## Architecture R√©sultante

### Structure par Bounded Context

Voici la structure r√©elle du projet Gyroscops Cloud, organis√©e par Bounded Context :

```
api/src/
‚îú‚îÄ‚îÄ Accounting/           # Contexte Comptabilit√©
‚îÇ   ‚îú‚îÄ‚îÄ Domain/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Payment/      # Agr√©gat Payment
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Command/  # Mod√®les de commande
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Query/    # Mod√®les de requ√™te
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Subscription/ # Agr√©gat Subscription
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Offer/        # Agr√©gat Offer
‚îÇ   ‚îî‚îÄ‚îÄ Infrastructure/   # Impl√©mentations techniques
‚îú‚îÄ‚îÄ Authentication/       # Contexte Authentification
‚îÇ   ‚îú‚îÄ‚îÄ Domain/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ User/         # Agr√©gat User
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Organization/ # Agr√©gat Organization
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Role/         # Agr√©gat Role
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Realm/        # Agr√©gat Realm
‚îÇ   ‚îî‚îÄ‚îÄ Infrastructure/
‚îú‚îÄ‚îÄ ...
‚îî‚îÄ‚îÄ Platform/             # Contexte Plateforme
    ‚îú‚îÄ‚îÄ Domain/
    ‚îÇ   ‚îî‚îÄ‚îÄ FeatureRollout/ # Agr√©gat FeatureRollout
    ‚îî‚îÄ‚îÄ Infrastructure/
```

### Le Monolithe Modulaire : La Vraie Solution

**Voici ce que j'ai appris avec Gyroscops** : Dans 80% des cas, les microservices sont une r√©ponse hors sujet. La vraie dette technique, ce n'est pas le monolithe. C'est un monolithe mal structur√©.

J'ai vu trop d'√©quipes exploser leur codebase en 15 services "ind√©pendants" qui finissent par d√©pendre les uns des autres, se synchroniser √† coups de webhooks bancals, et mettre 40 minutes √† d√©boguer un simple flux m√©tier.

**Avec les Bounded Contexts, j'ai cr√©√© un monolithe modulaire** :
- **Bien d√©coup√© en domaines fonctionnels clairs** : Chaque Bounded Context correspond √† un domaine m√©tier
- **Avec des interfaces internes bien d√©finies** : Les UseCases exposent des interfaces claires
- **Testable, maintenable, lisible** : Chaque contexte peut √™tre test√© et maintenu ind√©pendamment
- **D√©ployable en un clic** : Un seul d√©ploiement pour toute l'application

**Le r√©sultat** : J'ai √©vit√© le pi√®ge des microservices pr√©matur√©s. J'ai un syst√®me coh√©rent, maintenable, et √©volutif. Et quand un module devient vraiment trop gros ou trop critique, l√† je peux l'extraire en microservice. Mais je pars du besoin, pas du dogme.

**Comme le dit [Jean-Vincent Quilichini](https://www.linkedin.com/posts/jeanvincentquilichini_je-ne-fais-presque-plus-de-microservices-activity-7375767071550423040-Kivq) : "Le microservice doit √™tre un outil. Pas une posture."**

### R√©f√©rences aux ADR du projet Gyroscops Cloud

Cette architecture suit les principes d√©finis dans les Architecture Decision Records (ADR) du projet Gyroscops Cloud :

- **HIVE040** : Enhanced Models with Property Access Patterns - Utilisation de propri√©t√©s publiques en lecture seule
- **HIVE041** : Cross-Cutting Concerns Architecture - S√©paration claire des responsabilit√©s
- **HIVE005** : Common Identifier Model Interfaces - Interfaces standardis√©es pour les identifiants
- **HIVE010** : Repositories - Patterns de repository avec int√©gration Event Bus
- **HIVE023** : Repository Testing Strategies - Strat√©gies de test pour les repositories
- **HIVE027** : PHPUnit Testing Standards - Standards de test PHPUnit

### Int√©gration avec API Platform

```php
// Exemple d'int√©gration API Platform
use ApiPlatform\Metadata\Get;
use ApiPlatform\Metadata\Post;
use ApiPlatform\Metadata\Put;
use ApiPlatform\Metadata\Delete;

#[Get]
#[GetCollection]
#[Post]
#[Patch]
class Payment
{
    public function __construct(
        public readonly PaymentId $id,
        public readonly Money $amount,
        public readonly PaymentMethods $method,
        public readonly PaymentStatus $status,
        public readonly DateTime $createdAt
    ) {}
}
```

{{< chapter-nav >}}
  {{< chapter-option 
    letter="A" 
    color="green" 
    title="Je veux aligner le produit sur les objectifs business avec l'Impact Mapping" 
    subtitle="Vous voulez recentrer le p√©rim√®tre du projet autour d'objectifs business pr√©cis"
    criteria="Objectifs business √† clarifier,Besoin d'aligner business et technique,√âquipe avec business owners disponibles,Temps pour la planification strat√©gique"
    time="2-3 heures"
    chapter="2"
    chapter-title="L'Impact Mapping - Aligner le Produit sur les Objectifs Business"
    chapter-url="/chapitres/fondamentaux/chapitre-02-impact-mapping/"
  >}}
  
  {{< chapter-option 
    letter="B" 
    color="yellow" 
    title="Je veux apprendre la m√©thode Event Storming" 
    subtitle="Vous voulez ma√Ætriser la technique de conception collaborative"
    criteria="√âquipe de 3-8 personnes,Besoin de conception collaborative,Projet complexe √† mod√©liser,Temps disponible pour un atelier"
    time="30-45 minutes"
    chapter="3"
    chapter-title="L'Atelier Event Storming - Guide Pratique"
    chapter-url="/chapitres/fondamentaux/chapitre-03-atelier-event-storming/"
  >}}
  
  {{< chapter-option 
    letter="C" 
    color="red" 
    title="Je veux d√©tailler les r√®gles m√©tier avec l'Example Mapping" 
    subtitle="Vous voulez explorer les r√®gles complexes d√©couvertes lors de l'Event Storming"
    criteria="R√®gles m√©tier complexes identifi√©es,Besoin de clarifier les cas limites,√âquipe avec expert m√©tier disponible,Temps pour approfondir les d√©tails"
    time="30-45 minutes"
    chapter="4"
    chapter-title="L'Example Mapping - D√©tailer les R√®gles M√©tier"
    chapter-url="/chapitres/fondamentaux/chapitre-04-example-mapping/"
  >}}
  
  {{< chapter-option 
    letter="D" 
    color="blue" 
    title="Je veux comprendre la complexit√© architecturale" 
    subtitle="Vous voulez savoir quand utiliser quels patterns"
    criteria="√âquipe exp√©riment√©e,Besoin de choisir une architecture,Projet avec contraintes techniques,D√©cision architecturale √† prendre"
    time="20-30 minutes"
    chapter="5"
    chapter-title="Complexit√© Accidentelle vs Essentielle"
    chapter-url="/chapitres/fondamentaux/chapitre-05-complexite-accidentelle-essentielle/"
  >}}
  
  {{< chapter-option 
    letter="E" 
    color="purple" 
    title="Je veux voir des exemples concrets de mod√®les" 
    subtitle="Vous voulez comprendre la diff√©rence entre mod√®les riches et an√©miques"
    criteria="D√©veloppeur avec exp√©rience,Besoin d'exemples pratiques,Compr√©hension des patterns de code,Impl√©mentation √† faire"
    time="25-35 minutes"
    chapter="7"
    chapter-title="Mod√®les Riches vs Mod√®les An√©miques"
    chapter-url="/chapitres/fondamentaux/chapitre-07-modeles-riches-vs-anemiques/"
  >}}
{{< /chapter-nav >}}

**üí° Conseil** : Si vous n'√™tes pas s√ªr, choisissez l'option A pour commencer par l'Impact Mapping, puis continuez avec les autres chapitres dans l'ordre.

**üîÑ Alternative** : Si vous voulez tout voir dans l'ordre, commencez par le [Chapitre 2](/chapitres/fondamentaux/chapitre-02-impact-mapping/).
