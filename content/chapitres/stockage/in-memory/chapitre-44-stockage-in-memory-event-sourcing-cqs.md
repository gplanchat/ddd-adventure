---
title: "Stockage In-Memory - Event Sourcing + CQS"
description: "Implémentation Event Sourcing avec Command Query Separation pour In-Memory"
date: 2024-12-19
draft: true
type: "docs"
weight: 44
---
## 🎯 **Contexte et Objectifs**### **Pourquoi Event Sourcing + CQS avec In-Memory ?**Cette combinaison offre le meilleur des deux mondes : l'audit trail complet de l'Event Sourcing avec la séparation optimisée des responsabilités du CQS, le tout sur une plateforme de performance maximale.#### **Avantages de cette Combinaison**- **Audit trail complet** : Historique de tous les événements- **Performance optimisée** : Séparation claire entre écriture et lecture- **Debugging avancé** : Possibilité de rejouer les événements- **Flexibilité** : Requêtes optimisées pour chaque usage- **Cache efficace** : Mise en cache des requêtes### **Contexte Gyroscops**Dans notre écosystème **User → Organization → Workflow → Cloud Resources → Billing**, Event Sourcing + CQS avec In-Memory est idéal pour :- **Cache d'événements** : Séparation des écritures et lectures d'événements- **Sessions utilisateur** : Gestion optimisée des sessions avec audit trail- **Métriques en temps réel** : Traçabilité des métriques avec analytics- **Tests et développement** : Environnements de test avec audit trail et performance## 🏗️ **Architecture Event Sourcing + CQS**### **Séparation des Responsabilités**#### **Côté Commande (Write)**- **Command Handlers** : Traitement des commandes métier- **Event Store** : Persistance des événements dans In-Memory- **Event Handlers** : Gestion des événements de domaine- **Bulk Operations** : Optimisation des écritures#### **Côté Requête (Read)**- **Query Handlers** : Traitement des requêtes- **Event Search** : Recherche dans les événements- **Analytics Services** : Services d'analytics temporelles- **Caches** : Optimisation des performances### **Flux de Données Complet**```mermaidgraph TD    A[Command] --> B[Command Handler]    B --> C[Aggregate]    C --> D[Events]    D --> E[Event Store In-Memory]    E --> F[Event Handlers]    F --> G[Projections]    G --> H[Read Models]        I[Query] --> J[Query Handler]    J --> K[Event Search]    K --> E    E --> L[Search Results]    L --> M[Response]        N[Analytics] --> O[Analytics Service]    O --> E    E --> P[Historical Data]    P --> Q[Analytics Results]```## 💻 **Implémentation Pratique**### **1. Command Side Implementation**#### **Event Store In-Memory Avancé**```php<?phpnamespace App\Infrastructure\EventStore;use App\Domain\Event\DomainEvent;use App\Domain\Event\EventStoreInterface;use Psr\Log\LoggerInterface;class InMemoryEventStore implements EventStoreInterface{    private array $events = [];    private array $indexes = [];    private LoggerInterface $logger;    private array $bulkBuffer = [];    private int $bulkSize;    public function __construct(LoggerInterface $logger, int $bulkSize = 100)    {        $this->logger = $logger;        $this->bulkSize = $bulkSize;    }    public function appendEvents(string $aggregateId, array $events, int $expectedVersion): void    {        try {            // Vérifier la version attendue            $lastEvent = $this->getLastEvent($aggregateId);                        if ($lastEvent && $lastEvent['version'] !== $expectedVersion) {                throw new ConcurrencyException('Version mismatch');            }                        // Préparer les événements pour l'insertion            $version = $expectedVersion + 1;                        foreach ($events as $event) {                $this->bulkBuffer[] = [                    'eventId' => $event->getId(),                    'aggregateId' => $aggregateId,                    'aggregateType' => $event->getAggregateType(),                    'eventType' => $event->getEventType(),                    'eventData' => $event->toArray(),                    'version' => $version++,                    'timestamp' => $event->getTimestamp(),                    'correlationId' => $event->getCorrelationId(),                    'causationId' => $event->getCausationId(),                    'metadata' => $event->getMetadata()                ];                                if (count($this->bulkBuffer) >= $this->bulkSize) {                    $this->flushBulk();                }            }                        $this->flushBulk();                    } catch (\Exception $e) {            $this->logger->error('Failed to append events', [                'aggregateId' => $aggregateId,                'events' => count($events),                'error' => $e->getMessage()            ]);                        throw $e;        }    }    public function getEvents(string $aggregateId, int $fromVersion = 0): array    {        $events = [];                foreach ($this->events as $event) {            if ($event['aggregateId'] === $aggregateId && $event['version'] >= $fromVersion) {                $events[] = $this->deserializeEvent($event);            }        }                // Trier par version        usort($events, fn($a, $b) => $a->getVersion() <=> $b->getVersion());                return $events;    }    public function searchEvents(array $criteria): array    {        $events = [];                foreach ($this->events as $event) {            if ($this->matchesCriteria($event, $criteria)) {                $events[] = $this->deserializeEvent($event);            }        }                // Trier par timestamp        usort($events, fn($a, $b) => $a->getTimestamp() <=> $b->getTimestamp());                return $events;    }    private function getLastEvent(string $aggregateId): ?array    {        $lastEvent = null;        $lastVersion = -1;                foreach ($this->events as $event) {            if ($event['aggregateId'] === $aggregateId && $event['version'] > $lastVersion) {                $lastEvent = $event;                $lastVersion = $event['version'];            }        }                return $lastEvent;    }    private function flushBulk(): void    {        if (empty($this->bulkBuffer)) {            return;        }        try {            foreach ($this->bulkBuffer as $eventData) {                $this->events[$eventData['eventId']] = $eventData;                $this->updateIndexes($eventData);            }            $this->logger->info('Bulk events inserted', [                'events' => count($this->bulkBuffer)            ]);            $this->bulkBuffer = [];        } catch (\Exception $e) {            $this->logger->error('Bulk events insertion failed', [                'error' => $e->getMessage(),                'events' => count($this->bulkBuffer)            ]);            throw $e;        }    }    private function updateIndexes(array $eventData): void    {        // Index par type d'événement        $this->indexes['eventType'][$eventData['eventType']][] = $eventData['eventId'];                // Index par agrégat        $this->indexes['aggregateId'][$eventData['aggregateId']][] = $eventData['eventId'];                // Index par corrélation        if ($eventData['correlationId']) {            $this->indexes['correlationId'][$eventData['correlationId']][] = $eventData['eventId'];        }                // Index par timestamp        $date = $eventData['timestamp']->format('Y-m-d');        $this->indexes['date'][$date][] = $eventData['eventId'];    }    private function matchesCriteria(array $event, array $criteria): bool    {        foreach ($criteria as $field => $expectedValue) {            if (!$this->fieldMatches($event, $field, $expectedValue)) {                return false;            }        }                return true;    }    private function fieldMatches(array $event, string $field, mixed $expectedValue): bool    {        $fieldValue = $event[$field] ?? null;                if (is_array($expectedValue)) {            return in_array($fieldValue, $expectedValue);        }                return $fieldValue === $expectedValue;    }    private function deserializeEvent(array $eventData): DomainEvent    {        $eventClass = $eventData['eventType'];        return $eventClass::fromArray($eventData['eventData']);    }}```#### **Command Handler avec Event Sourcing**```php<?phpnamespace App\Application\Command\Payment;use App\Domain\Payment\PaymentAggregate;use App\Domain\Event\EventStoreInterface;use App\Domain\Event\EventBusInterface;use Psr\Log\LoggerInterface;class ProcessPaymentCommandHandler{    public function __construct(        private EventStoreInterface $eventStore,        private EventBusInterface $eventBus,        private LoggerInterface $logger    ) {}    public function handle(ProcessPaymentCommand $command): void    {        try {            // Charger l'agrégat depuis les événements            $events = $this->eventStore->getEvents($command->getPaymentId());            $payment = PaymentAggregate::fromEvents($events);                        // Exécuter la commande            $payment->processPayment($command->getAmount(), $command->getCurrency());                        // Sauvegarder les événements            $this->eventStore->appendEvents(                $command->getPaymentId(),                $payment->getUncommittedEvents(),                $payment->getVersion()            );                        // Publier les événements            foreach ($payment->getUncommittedEvents() as $event) {                $this->eventBus->publish($event);            }                        // Nettoyer les événements non commités            $payment->markEventsAsCommitted();                        $this->logger->info('Payment processed with event sourcing', [                'paymentId' => $command->getPaymentId(),                'amount' => $command->getAmount(),                'currency' => $command->getCurrency(),                'events' => count($payment->getUncommittedEvents())            ]);                    } catch (\Exception $e) {            $this->logger->error('Payment processing failed', [                'paymentId' => $command->getPaymentId(),                'error' => $e->getMessage()            ]);                        throw $e;        }    }}```### **2. Query Side Implementation**#### **Event Search Service**```php<?phpnamespace App\Infrastructure\InMemory\Query;use App\Infrastructure\EventStore\InMemoryEventStore;use Psr\Log\LoggerInterface;use Psr\Cache\CacheItemPoolInterface;class EventSearchService{    private InMemoryEventStore $eventStore;    private LoggerInterface $logger;    private CacheItemPoolInterface $cache;    public function __construct(        InMemoryEventStore $eventStore,        LoggerInterface $logger,        CacheItemPoolInterface $cache    ) {        $this->eventStore = $eventStore;        $this->logger = $logger;        $this->cache = $cache;    }    public function searchEvents(array $query, string $cacheKey = null): array    {        // Vérifier le cache        if ($cacheKey) {            $cachedItem = $this->cache->getItem($cacheKey);            if ($cachedItem->isHit()) {                $this->logger->debug('Event search result served from cache', [                    'query' => $query,                    'cacheKey' => $cacheKey                ]);                return $cachedItem->get();            }        }        $results = $this->eventStore->searchEvents($query);        // Mettre en cache        if ($cacheKey) {            $cachedItem->set($results);            $cachedItem->expiresAfter(300); // 5 minutes            $this->cache->save($cachedItem);        }        $this->logger->info('Event search executed', [            'query' => $query,            'results' => count($results)        ]);        return $results;    }    public function getEventById(string $eventId): ?array    {        $event = $this->eventStore->getEventById($eventId);                if (!$event) {            return null;        }                return [            'eventId' => $event->getId(),            'aggregateId' => $event->getAggregateId(),            'eventType' => $event->getEventType(),            'timestamp' => $event->getTimestamp(),            'data' => $event->toArray(),            'metadata' => $event->getMetadata()        ];    }    public function getEventsByAggregate(string $aggregateId, int $fromVersion = 0): array    {        $events = $this->eventStore->getEvents($aggregateId, $fromVersion);                $results = [];        foreach ($events as $event) {            $results[] = [                'eventId' => $event->getId(),                'aggregateId' => $event->getAggregateId(),                'eventType' => $event->getEventType(),                'timestamp' => $event->getTimestamp(),                'data' => $event->toArray(),                'metadata' => $event->getMetadata()            ];        }                return $results;    }    public function getEventsByType(string $eventType, \DateTime $from = null, \DateTime $to = null): array    {        $events = $this->eventStore->getEventsByType($eventType, $from, $to);                $results = [];        foreach ($events as $event) {            $results[] = [                'eventId' => $event->getId(),                'aggregateId' => $event->getAggregateId(),                'eventType' => $event->getEventType(),                'timestamp' => $event->getTimestamp(),                'data' => $event->toArray(),                'metadata' => $event->getMetadata()            ];        }                return $results;    }    public function getEventStatistics(string $eventType, \DateTime $from, \DateTime $to): array    {        $events = $this->eventStore->getEventsByType($eventType, $from, $to);                $statistics = [            'total' => count($events),            'byHour' => [],            'byDay' => [],            'byOrganization' => [],            'byUser' => []        ];                foreach ($events as $event) {            $hour = $event->getTimestamp()->format('Y-m-d H:00:00');            $day = $event->getTimestamp()->format('Y-m-d');            $orgId = $event->getMetadata()['organizationId'] ?? 'unknown';            $userId = $event->getMetadata()['userId'] ?? 'unknown';                        $statistics['byHour'][$hour] = ($statistics['byHour'][$hour] ?? 0) + 1;            $statistics['byDay'][$day] = ($statistics['byDay'][$day] ?? 0) + 1;            $statistics['byOrganization'][$orgId] = ($statistics['byOrganization'][$orgId] ?? 0) + 1;            $statistics['byUser'][$userId] = ($statistics['byUser'][$userId] ?? 0) + 1;        }                return $statistics;    }}```#### **Query Handler pour les Événements**```php<?phpnamespace App\Application\Query\Payment;use App\Infrastructure\InMemory\Query\EventSearchService;use App\Domain\Payment\Payment;use Psr\Log\LoggerInterface;class PaymentEventQueryHandler{    private EventSearchService $eventSearch;    private LoggerInterface $logger;    public function __construct(EventSearchService $eventSearch, LoggerInterface $logger)    {        $this->eventSearch = $eventSearch;        $this->logger = $logger;    }    public function handle(GetPaymentHistoryQuery $query): array    {        $events = $this->eventSearch->getEventsByAggregate($query->getPaymentId());                $history = [];        foreach ($events as $event) {            $history[] = [                'eventId' => $event['eventId'],                'eventType' => $event['eventType'],                'timestamp' => $event['timestamp'],                'data' => $event['data'],                'metadata' => $event['metadata']            ];        }                return $history;    }    public function handle(SearchPaymentEventsQuery $query): array    {        $searchQuery = [            'aggregateType' => 'Payment'        ];                if ($query->getEventType()) {            $searchQuery['eventType'] = $query->getEventType();        }                if ($query->getFrom() || $query->getTo()) {            $searchQuery['timestamp'] = [];            if ($query->getFrom()) {                $searchQuery['timestamp']['gte'] = $query->getFrom();            }            if ($query->getTo()) {                $searchQuery['timestamp']['lte'] = $query->getTo();            }        }                $cacheKey = 'payment_events_' . md5(serialize($query));        $results = $this->eventSearch->searchEvents($searchQuery, $cacheKey);                $events = [];        foreach ($results as $event) {            $events[] = [                'eventId' => $event->getId(),                'aggregateId' => $event->getAggregateId(),                'eventType' => $event->getEventType(),                'timestamp' => $event->getTimestamp(),                'data' => $event->toArray(),                'metadata' => $event->getMetadata()            ];        }                return $events;    }    public function handle(GetPaymentEventStatisticsQuery $query): array    {        return $this->eventSearch->getEventStatistics(            $query->getEventType(),            $query->getFrom(),            $query->getTo()        );    }    public function handle(ReplayPaymentEventsQuery $query): Payment    {        $events = $this->eventSearch->getEventsByAggregate($query->getPaymentId());                // Reconstruire l'agrégat depuis les événements        $payment = PaymentAggregate::fromEvents($events);                return $payment->toPayment();    }}```### **3. Service d'Analytics Avancées**#### **Service d'Analytics des Événements**```php<?phpnamespace App\Application\Service\InMemory;use App\Infrastructure\InMemory\Query\EventSearchService;use Psr\Log\LoggerInterface;class EventAnalyticsService{    private EventSearchService $eventSearch;    private LoggerInterface $logger;    public function __construct(EventSearchService $eventSearch, LoggerInterface $logger)    {        $this->eventSearch = $eventSearch;        $this->logger = $logger;    }    public function getEventTrends(string $eventType, \DateTime $from, \DateTime $to, string $interval = 'day'): array    {        $events = $this->eventSearch->getEventsByType($eventType, $from, $to);                $trends = [];        foreach ($events as $event) {            $key = $this->getIntervalKey($event['timestamp'], $interval);            $trends[$key] = ($trends[$key] ?? 0) + 1;        }                ksort($trends);        return $trends;    }    public function getEventCorrelations(string $correlationId): array    {        $events = $this->eventSearch->getEventsByCorrelationId($correlationId);                $correlations = [];        foreach ($events as $event) {            $correlations[] = [                'eventType' => $event['eventType'],                'aggregateId' => $event['aggregateId'],                'timestamp' => $event['timestamp'],                'data' => $event['data']            ];        }                return $correlations;    }    public function getEventHeatmap(string $eventType, \DateTime $from, \DateTime $to): array    {        $events = $this->eventSearch->getEventsByType($eventType, $from, $to);                $heatmap = [            'byHour' => [],            'byDay' => []        ];                foreach ($events as $event) {            $hour = $event['timestamp']->format('Y-m-d H:00:00');            $day = $event['timestamp']->format('Y-m-d');                        $heatmap['byHour'][$hour] = ($heatmap['byHour'][$hour] ?? 0) + 1;            $heatmap['byDay'][$day] = ($heatmap['byDay'][$day] ?? 0) + 1;        }                return $heatmap;    }    public function searchEventData(string $searchText, array $filters = []): array    {        $query = [];                if (isset($filters['aggregateType'])) {            $query['aggregateType'] = $filters['aggregateType'];        }                if (isset($filters['eventType'])) {            $query['eventType'] = $filters['eventType'];        }                if (isset($filters['from']) || isset($filters['to'])) {            $query['timestamp'] = [];            if (isset($filters['from'])) {                $query['timestamp']['gte'] = $filters['from'];            }            if (isset($filters['to'])) {                $query['timestamp']['lte'] = $filters['to'];            }        }                $events = $this->eventSearch->searchEvents($query);                // Filtrer par texte de recherche        if ($searchText) {            $events = array_filter($events, function($event) use ($searchText) {                $data = $event->toArray();                return stripos(json_encode($data), $searchText) !== false;            });        }                $results = [];        foreach ($events as $event) {            $results[] = [                'eventId' => $event->getId(),                'aggregateId' => $event->getAggregateId(),                'eventType' => $event->getEventType(),                'timestamp' => $event->getTimestamp(),                'data' => $event->toArray(),                'metadata' => $event->getMetadata()            ];        }                return $results;    }    private function getIntervalKey(\DateTime $timestamp, string $interval): string    {        switch ($interval) {            case 'hour':                return $timestamp->format('Y-m-d H:00:00');            case 'day':                return $timestamp->format('Y-m-d');            case 'week':                return $timestamp->format('Y-W');            case 'month':                return $timestamp->format('Y-m');            default:                return $timestamp->format('Y-m-d');        }    }}```## 🧪 **Tests et Validation**### **Tests d'Intégration Event Sourcing + CQS**```php<?phpnamespace App\Tests\Integration\InMemory;use App\Application\Command\Payment\ProcessPaymentCommand;use App\Application\Command\Payment\ProcessPaymentCommandHandler;use App\Application\Query\Payment\GetPaymentHistoryQuery;use App\Application\Query\Payment\PaymentEventQueryHandler;use App\Infrastructure\EventStore\InMemoryEventStore;use App\Infrastructure\InMemory\Query\EventSearchService;class InMemoryEventSourcingCqsTest extends TestCase{    private InMemoryEventStore $eventStore;    private EventSearchService $eventSearch;    private ProcessPaymentCommandHandler $commandHandler;    private PaymentEventQueryHandler $queryHandler;    protected function setUp(): void    {        $this->eventStore = new InMemoryEventStore($this->createMock(LoggerInterface::class));        $this->eventSearch = new EventSearchService($this->eventStore, $this->createMock(LoggerInterface::class), $this->createMock(CacheItemPoolInterface::class));                $this->commandHandler = new ProcessPaymentCommandHandler(            $this->eventStore,            $this->createMock(EventBusInterface::class),            $this->createMock(LoggerInterface::class)        );                $this->queryHandler = new PaymentEventQueryHandler($this->eventSearch, $this->createMock(LoggerInterface::class));    }    public function testEventSourcingCqsFlow(): void    {        // Exécuter une commande        $command = new ProcessPaymentCommand(            'payment-123',            100.00,            'EUR'        );                $this->commandHandler->handle($command);                // Vérifier l'historique des événements        $query = new GetPaymentHistoryQuery('payment-123');        $history = $this->queryHandler->handle($query);                $this->assertNotEmpty($history);        $this->assertCount(1, $history);        $this->assertEquals('PaymentProcessed', $history[0]['eventType']);    }    public function testEventSearchWithAnalytics(): void    {        // Créer plusieurs événements        $commands = [            new ProcessPaymentCommand('payment-1', 100.00, 'EUR'),            new ProcessPaymentCommand('payment-2', 200.00, 'USD'),            new ProcessPaymentCommand('payment-3', 300.00, 'EUR')        ];                foreach ($commands as $command) {            $this->commandHandler->handle($command);        }                // Rechercher les événements        $searchQuery = new SearchPaymentEventsQuery(            new \DateTime('2024-01-01'),            new \DateTime('2024-12-31')        );                $results = $this->queryHandler->handle($searchQuery);                $this->assertCount(3, $results);        $this->assertEquals('PaymentProcessed', $results[0]['eventType']);    }}```## 📊 **Performance et Optimisation**### **Stratégies d'Optimisation Event Sourcing + CQS**#### **1. Cache Multi-Niveaux**```phppublic function searchEventsWithCache(array $query, string $cacheKey = null): array{    // Cache L1: Mémoire    if (isset($this->memoryCache[$cacheKey])) {        return $this->memoryCache[$cacheKey];    }        // Cache L2: Redis    if ($cached = $this->redis->get("event_search:{$cacheKey}")) {        $result = json_decode($cached, true);        $this->memoryCache[$cacheKey] = $result;        return $result;    }        // In-Memory    $result = $this->searchEvents($query);        // Mettre en cache    $this->memoryCache[$cacheKey] = $result;    $this->redis->setex("event_search:{$cacheKey}", 300, json_encode($result));        return $result;}```#### **2. Projections Asynchrones**```phppublic function handleEventAsync(DomainEvent $event): void{    // Mettre en queue pour traitement asynchrone    $this->messageBus->dispatch(new ProcessProjectionCommand($event));}```#### **3. Index Optimisés**```phppublic function optimizeIndexes(): void{    // Nettoyer les index orphelins    $this->cleanOrphanedIndexes();        // Compacter les index    $this->compactIndexes();        // Forcer le garbage collection    gc_collect_cycles();}```## 🎯 **Critères d'Adoption**### **Quand Utiliser Event Sourcing + CQS avec In-Memory**#### **✅ Avantages**- **Audit trail complet** : Historique de tous les événements- **Performance optimisée** : Séparation claire entre écriture et lecture- **Debugging avancé** : Possibilité de rejouer les événements- **Flexibilité** : Requêtes optimisées pour chaque usage- **Cache efficace** : Mise en cache des requêtes#### **❌ Inconvénients**- **Complexité élevée** : Architecture très complexe- **Volatilité** : Données perdues au redémarrage- **Limitation mémoire** : Contraint par la RAM disponible- **Expertise** : Équipe très expérimentée requise#### **🎯 Critères d'Adoption**- **Audit trail critique** : Besoin de traçabilité complète- **Performance importante** : Besoins de performance élevée- **Debugging complexe** : Besoin de rejouer les événements- **Données temporaires** : Cache, sessions, métriques- **Équipe très expérimentée** : Maîtrise d'Event Sourcing, CQS et In-Memory- **Mémoire suffisante** : RAM disponible pour tous les événements## 🚀 **Votre Prochaine Étape**{{< chapter-nav >}}  {{< chapter-option     letter="A"     color="green"     title="Je veux voir l'approche Event Sourcing + CQRS avec In-Memory"     subtitle="Vous voulez comprendre la combinaison complète Event Sourcing et CQRS"    criteria="Architecture maximale,Équipe très expérimentée,Performance critique,Scalabilité maximale"    time="45-60 minutes"    chapter="45"    chapter-title="Stockage In-Memory - Event Sourcing + CQRS"    chapter-url="/chapitres/stockage/in-memory/chapitre-45-stockage-in-memory-event-sourcing-cqrs/"  >}}    {{< chapter-option     letter="B"     color="yellow"     title="Je veux explorer les autres types de stockage"     subtitle="Vous voulez voir les alternatives à In-Memory"    criteria="Comparaison nécessaire,Choix de stockage,Architecture à définir,Performance à optimiser"    time="30-40 minutes"    chapter="10"    chapter-title="Choix du Type de Stockage"    chapter-url="/chapitres/fondamentaux/chapitre-10-choix-type-stockage/"  >}}    {{< chapter-option     letter="C"     color="blue"     title="Je veux voir des exemples concrets"     subtitle="Vous voulez comprendre les implémentations pratiques"    criteria="Développeur expérimenté,Besoin d'exemples pratiques,Implémentation à faire,Code à écrire"    time="Variable"    chapter="0"    chapter-title="Exemples et Implémentations"    chapter-url="/examples/"  >}}    {{< chapter-option     letter="D"     color="purple"     title="Je veux revenir aux fondamentaux"     subtitle="Vous voulez comprendre les concepts de base"    criteria="Développeur débutant,Besoin de comprendre les concepts,Projet à structurer,Équipe à former"    time="45-60 minutes"    chapter="1"    chapter-title="Introduction au Domain-Driven Design et Event Storming"    chapter-url="/chapitres/fondamentaux/chapitre-01-introduction-event-storming-ddd/"  >}}{{< /chapter-nav >}}---*Event Sourcing + CQS avec In-Memory offre une approche sophistiquée pour l'audit trail et la performance, parfaitement adaptée aux besoins les plus exigeants de Gyroscops.*