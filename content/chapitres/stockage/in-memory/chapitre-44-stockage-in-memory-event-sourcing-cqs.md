---
title: "Stockage In-Memory - Event Sourcing + CQS"
description: "Impl√©mentation Event Sourcing avec Command Query Separation pour In-Memory"
date: 2024-12-19
draft: true
type: "docs"
weight: 44
---
## üéØ **Contexte et Objectifs**### **Pourquoi Event Sourcing + CQS avec In-Memory ?**Cette combinaison offre le meilleur des deux mondes : l'audit trail complet de l'Event Sourcing avec la s√©paration optimis√©e des responsabilit√©s du CQS, le tout sur une plateforme de performance maximale.#### **Avantages de cette Combinaison**- **Audit trail complet** : Historique de tous les √©v√©nements- **Performance optimis√©e** : S√©paration claire entre √©criture et lecture- **Debugging avanc√©** : Possibilit√© de rejouer les √©v√©nements- **Flexibilit√©** : Requ√™tes optimis√©es pour chaque usage- **Cache efficace** : Mise en cache des requ√™tes### **Contexte Gyroscops**Dans notre √©cosyst√®me **User ‚Üí Organization ‚Üí Workflow ‚Üí Cloud Resources ‚Üí Billing**, Event Sourcing + CQS avec In-Memory est id√©al pour :- **Cache d'√©v√©nements** : S√©paration des √©critures et lectures d'√©v√©nements- **Sessions utilisateur** : Gestion optimis√©e des sessions avec audit trail- **M√©triques en temps r√©el** : Tra√ßabilit√© des m√©triques avec analytics- **Tests et d√©veloppement** : Environnements de test avec audit trail et performance## üèóÔ∏è **Architecture Event Sourcing + CQS**### **S√©paration des Responsabilit√©s**#### **C√¥t√© Commande (Write)**- **Command Handlers** : Traitement des commandes m√©tier- **Event Store** : Persistance des √©v√©nements dans In-Memory- **Event Handlers** : Gestion des √©v√©nements de domaine- **Bulk Operations** : Optimisation des √©critures#### **C√¥t√© Requ√™te (Read)**- **Query Handlers** : Traitement des requ√™tes- **Event Search** : Recherche dans les √©v√©nements- **Analytics Services** : Services d'analytics temporelles- **Caches** : Optimisation des performances### **Flux de Donn√©es Complet**```mermaidgraph TD    A[Command] --> B[Command Handler]    B --> C[Aggregate]    C --> D[Events]    D --> E[Event Store In-Memory]    E --> F[Event Handlers]    F --> G[Projections]    G --> H[Read Models]        I[Query] --> J[Query Handler]    J --> K[Event Search]    K --> E    E --> L[Search Results]    L --> M[Response]        N[Analytics] --> O[Analytics Service]    O --> E    E --> P[Historical Data]    P --> Q[Analytics Results]```## üíª **Impl√©mentation Pratique**### **1. Command Side Implementation**#### **Event Store In-Memory Avanc√©**```php<?phpnamespace App\Infrastructure\EventStore;use App\Domain\Event\DomainEvent;use App\Domain\Event\EventStoreInterface;use Psr\Log\LoggerInterface;class InMemoryEventStore implements EventStoreInterface{    private array $events = [];    private array $indexes = [];    private LoggerInterface $logger;    private array $bulkBuffer = [];    private int $bulkSize;    public function __construct(LoggerInterface $logger, int $bulkSize = 100)    {        $this->logger = $logger;        $this->bulkSize = $bulkSize;    }    public function appendEvents(string $aggregateId, array $events, int $expectedVersion): void    {        try {            // V√©rifier la version attendue            $lastEvent = $this->getLastEvent($aggregateId);                        if ($lastEvent && $lastEvent['version'] !== $expectedVersion) {                throw new ConcurrencyException('Version mismatch');            }                        // Pr√©parer les √©v√©nements pour l'insertion            $version = $expectedVersion + 1;                        foreach ($events as $event) {                $this->bulkBuffer[] = [                    'eventId' => $event->getId(),                    'aggregateId' => $aggregateId,                    'aggregateType' => $event->getAggregateType(),                    'eventType' => $event->getEventType(),                    'eventData' => $event->toArray(),                    'version' => $version++,                    'timestamp' => $event->getTimestamp(),                    'correlationId' => $event->getCorrelationId(),                    'causationId' => $event->getCausationId(),                    'metadata' => $event->getMetadata()                ];                                if (count($this->bulkBuffer) >= $this->bulkSize) {                    $this->flushBulk();                }            }                        $this->flushBulk();                    } catch (\Exception $e) {            $this->logger->error('Failed to append events', [                'aggregateId' => $aggregateId,                'events' => count($events),                'error' => $e->getMessage()            ]);                        throw $e;        }    }    public function getEvents(string $aggregateId, int $fromVersion = 0): array    {        $events = [];                foreach ($this->events as $event) {            if ($event['aggregateId'] === $aggregateId && $event['version'] >= $fromVersion) {                $events[] = $this->deserializeEvent($event);            }        }                // Trier par version        usort($events, fn($a, $b) => $a->getVersion() <=> $b->getVersion());                return $events;    }    public function searchEvents(array $criteria): array    {        $events = [];                foreach ($this->events as $event) {            if ($this->matchesCriteria($event, $criteria)) {                $events[] = $this->deserializeEvent($event);            }        }                // Trier par timestamp        usort($events, fn($a, $b) => $a->getTimestamp() <=> $b->getTimestamp());                return $events;    }    private function getLastEvent(string $aggregateId): ?array    {        $lastEvent = null;        $lastVersion = -1;                foreach ($this->events as $event) {            if ($event['aggregateId'] === $aggregateId && $event['version'] > $lastVersion) {                $lastEvent = $event;                $lastVersion = $event['version'];            }        }                return $lastEvent;    }    private function flushBulk(): void    {        if (empty($this->bulkBuffer)) {            return;        }        try {            foreach ($this->bulkBuffer as $eventData) {                $this->events[$eventData['eventId']] = $eventData;                $this->updateIndexes($eventData);            }            $this->logger->info('Bulk events inserted', [                'events' => count($this->bulkBuffer)            ]);            $this->bulkBuffer = [];        } catch (\Exception $e) {            $this->logger->error('Bulk events insertion failed', [                'error' => $e->getMessage(),                'events' => count($this->bulkBuffer)            ]);            throw $e;        }    }    private function updateIndexes(array $eventData): void    {        // Index par type d'√©v√©nement        $this->indexes['eventType'][$eventData['eventType']][] = $eventData['eventId'];                // Index par agr√©gat        $this->indexes['aggregateId'][$eventData['aggregateId']][] = $eventData['eventId'];                // Index par corr√©lation        if ($eventData['correlationId']) {            $this->indexes['correlationId'][$eventData['correlationId']][] = $eventData['eventId'];        }                // Index par timestamp        $date = $eventData['timestamp']->format('Y-m-d');        $this->indexes['date'][$date][] = $eventData['eventId'];    }    private function matchesCriteria(array $event, array $criteria): bool    {        foreach ($criteria as $field => $expectedValue) {            if (!$this->fieldMatches($event, $field, $expectedValue)) {                return false;            }        }                return true;    }    private function fieldMatches(array $event, string $field, mixed $expectedValue): bool    {        $fieldValue = $event[$field] ?? null;                if (is_array($expectedValue)) {            return in_array($fieldValue, $expectedValue);        }                return $fieldValue === $expectedValue;    }    private function deserializeEvent(array $eventData): DomainEvent    {        $eventClass = $eventData['eventType'];        return $eventClass::fromArray($eventData['eventData']);    }}```#### **Command Handler avec Event Sourcing**```php<?phpnamespace App\Application\Command\Payment;use App\Domain\Payment\PaymentAggregate;use App\Domain\Event\EventStoreInterface;use App\Domain\Event\EventBusInterface;use Psr\Log\LoggerInterface;class ProcessPaymentCommandHandler{    public function __construct(        private EventStoreInterface $eventStore,        private EventBusInterface $eventBus,        private LoggerInterface $logger    ) {}    public function handle(ProcessPaymentCommand $command): void    {        try {            // Charger l'agr√©gat depuis les √©v√©nements            $events = $this->eventStore->getEvents($command->getPaymentId());            $payment = PaymentAggregate::fromEvents($events);                        // Ex√©cuter la commande            $payment->processPayment($command->getAmount(), $command->getCurrency());                        // Sauvegarder les √©v√©nements            $this->eventStore->appendEvents(                $command->getPaymentId(),                $payment->getUncommittedEvents(),                $payment->getVersion()            );                        // Publier les √©v√©nements            foreach ($payment->getUncommittedEvents() as $event) {                $this->eventBus->publish($event);            }                        // Nettoyer les √©v√©nements non commit√©s            $payment->markEventsAsCommitted();                        $this->logger->info('Payment processed with event sourcing', [                'paymentId' => $command->getPaymentId(),                'amount' => $command->getAmount(),                'currency' => $command->getCurrency(),                'events' => count($payment->getUncommittedEvents())            ]);                    } catch (\Exception $e) {            $this->logger->error('Payment processing failed', [                'paymentId' => $command->getPaymentId(),                'error' => $e->getMessage()            ]);                        throw $e;        }    }}```### **2. Query Side Implementation**#### **Event Search Service**```php<?phpnamespace App\Infrastructure\InMemory\Query;use App\Infrastructure\EventStore\InMemoryEventStore;use Psr\Log\LoggerInterface;use Psr\Cache\CacheItemPoolInterface;class EventSearchService{    private InMemoryEventStore $eventStore;    private LoggerInterface $logger;    private CacheItemPoolInterface $cache;    public function __construct(        InMemoryEventStore $eventStore,        LoggerInterface $logger,        CacheItemPoolInterface $cache    ) {        $this->eventStore = $eventStore;        $this->logger = $logger;        $this->cache = $cache;    }    public function searchEvents(array $query, string $cacheKey = null): array    {        // V√©rifier le cache        if ($cacheKey) {            $cachedItem = $this->cache->getItem($cacheKey);            if ($cachedItem->isHit()) {                $this->logger->debug('Event search result served from cache', [                    'query' => $query,                    'cacheKey' => $cacheKey                ]);                return $cachedItem->get();            }        }        $results = $this->eventStore->searchEvents($query);        // Mettre en cache        if ($cacheKey) {            $cachedItem->set($results);            $cachedItem->expiresAfter(300); // 5 minutes            $this->cache->save($cachedItem);        }        $this->logger->info('Event search executed', [            'query' => $query,            'results' => count($results)        ]);        return $results;    }    public function getEventById(string $eventId): ?array    {        $event = $this->eventStore->getEventById($eventId);                if (!$event) {            return null;        }                return [            'eventId' => $event->getId(),            'aggregateId' => $event->getAggregateId(),            'eventType' => $event->getEventType(),            'timestamp' => $event->getTimestamp(),            'data' => $event->toArray(),            'metadata' => $event->getMetadata()        ];    }    public function getEventsByAggregate(string $aggregateId, int $fromVersion = 0): array    {        $events = $this->eventStore->getEvents($aggregateId, $fromVersion);                $results = [];        foreach ($events as $event) {            $results[] = [                'eventId' => $event->getId(),                'aggregateId' => $event->getAggregateId(),                'eventType' => $event->getEventType(),                'timestamp' => $event->getTimestamp(),                'data' => $event->toArray(),                'metadata' => $event->getMetadata()            ];        }                return $results;    }    public function getEventsByType(string $eventType, \DateTime $from = null, \DateTime $to = null): array    {        $events = $this->eventStore->getEventsByType($eventType, $from, $to);                $results = [];        foreach ($events as $event) {            $results[] = [                'eventId' => $event->getId(),                'aggregateId' => $event->getAggregateId(),                'eventType' => $event->getEventType(),                'timestamp' => $event->getTimestamp(),                'data' => $event->toArray(),                'metadata' => $event->getMetadata()            ];        }                return $results;    }    public function getEventStatistics(string $eventType, \DateTime $from, \DateTime $to): array    {        $events = $this->eventStore->getEventsByType($eventType, $from, $to);                $statistics = [            'total' => count($events),            'byHour' => [],            'byDay' => [],            'byOrganization' => [],            'byUser' => []        ];                foreach ($events as $event) {            $hour = $event->getTimestamp()->format('Y-m-d H:00:00');            $day = $event->getTimestamp()->format('Y-m-d');            $orgId = $event->getMetadata()['organizationId'] ?? 'unknown';            $userId = $event->getMetadata()['userId'] ?? 'unknown';                        $statistics['byHour'][$hour] = ($statistics['byHour'][$hour] ?? 0) + 1;            $statistics['byDay'][$day] = ($statistics['byDay'][$day] ?? 0) + 1;            $statistics['byOrganization'][$orgId] = ($statistics['byOrganization'][$orgId] ?? 0) + 1;            $statistics['byUser'][$userId] = ($statistics['byUser'][$userId] ?? 0) + 1;        }                return $statistics;    }}```#### **Query Handler pour les √âv√©nements**```php<?phpnamespace App\Application\Query\Payment;use App\Infrastructure\InMemory\Query\EventSearchService;use App\Domain\Payment\Payment;use Psr\Log\LoggerInterface;class PaymentEventQueryHandler{    private EventSearchService $eventSearch;    private LoggerInterface $logger;    public function __construct(EventSearchService $eventSearch, LoggerInterface $logger)    {        $this->eventSearch = $eventSearch;        $this->logger = $logger;    }    public function handle(GetPaymentHistoryQuery $query): array    {        $events = $this->eventSearch->getEventsByAggregate($query->getPaymentId());                $history = [];        foreach ($events as $event) {            $history[] = [                'eventId' => $event['eventId'],                'eventType' => $event['eventType'],                'timestamp' => $event['timestamp'],                'data' => $event['data'],                'metadata' => $event['metadata']            ];        }                return $history;    }    public function handle(SearchPaymentEventsQuery $query): array    {        $searchQuery = [            'aggregateType' => 'Payment'        ];                if ($query->getEventType()) {            $searchQuery['eventType'] = $query->getEventType();        }                if ($query->getFrom() || $query->getTo()) {            $searchQuery['timestamp'] = [];            if ($query->getFrom()) {                $searchQuery['timestamp']['gte'] = $query->getFrom();            }            if ($query->getTo()) {                $searchQuery['timestamp']['lte'] = $query->getTo();            }        }                $cacheKey = 'payment_events_' . md5(serialize($query));        $results = $this->eventSearch->searchEvents($searchQuery, $cacheKey);                $events = [];        foreach ($results as $event) {            $events[] = [                'eventId' => $event->getId(),                'aggregateId' => $event->getAggregateId(),                'eventType' => $event->getEventType(),                'timestamp' => $event->getTimestamp(),                'data' => $event->toArray(),                'metadata' => $event->getMetadata()            ];        }                return $events;    }    public function handle(GetPaymentEventStatisticsQuery $query): array    {        return $this->eventSearch->getEventStatistics(            $query->getEventType(),            $query->getFrom(),            $query->getTo()        );    }    public function handle(ReplayPaymentEventsQuery $query): Payment    {        $events = $this->eventSearch->getEventsByAggregate($query->getPaymentId());                // Reconstruire l'agr√©gat depuis les √©v√©nements        $payment = PaymentAggregate::fromEvents($events);                return $payment->toPayment();    }}```### **3. Service d'Analytics Avanc√©es**#### **Service d'Analytics des √âv√©nements**```php<?phpnamespace App\Application\Service\InMemory;use App\Infrastructure\InMemory\Query\EventSearchService;use Psr\Log\LoggerInterface;class EventAnalyticsService{    private EventSearchService $eventSearch;    private LoggerInterface $logger;    public function __construct(EventSearchService $eventSearch, LoggerInterface $logger)    {        $this->eventSearch = $eventSearch;        $this->logger = $logger;    }    public function getEventTrends(string $eventType, \DateTime $from, \DateTime $to, string $interval = 'day'): array    {        $events = $this->eventSearch->getEventsByType($eventType, $from, $to);                $trends = [];        foreach ($events as $event) {            $key = $this->getIntervalKey($event['timestamp'], $interval);            $trends[$key] = ($trends[$key] ?? 0) + 1;        }                ksort($trends);        return $trends;    }    public function getEventCorrelations(string $correlationId): array    {        $events = $this->eventSearch->getEventsByCorrelationId($correlationId);                $correlations = [];        foreach ($events as $event) {            $correlations[] = [                'eventType' => $event['eventType'],                'aggregateId' => $event['aggregateId'],                'timestamp' => $event['timestamp'],                'data' => $event['data']            ];        }                return $correlations;    }    public function getEventHeatmap(string $eventType, \DateTime $from, \DateTime $to): array    {        $events = $this->eventSearch->getEventsByType($eventType, $from, $to);                $heatmap = [            'byHour' => [],            'byDay' => []        ];                foreach ($events as $event) {            $hour = $event['timestamp']->format('Y-m-d H:00:00');            $day = $event['timestamp']->format('Y-m-d');                        $heatmap['byHour'][$hour] = ($heatmap['byHour'][$hour] ?? 0) + 1;            $heatmap['byDay'][$day] = ($heatmap['byDay'][$day] ?? 0) + 1;        }                return $heatmap;    }    public function searchEventData(string $searchText, array $filters = []): array    {        $query = [];                if (isset($filters['aggregateType'])) {            $query['aggregateType'] = $filters['aggregateType'];        }                if (isset($filters['eventType'])) {            $query['eventType'] = $filters['eventType'];        }                if (isset($filters['from']) || isset($filters['to'])) {            $query['timestamp'] = [];            if (isset($filters['from'])) {                $query['timestamp']['gte'] = $filters['from'];            }            if (isset($filters['to'])) {                $query['timestamp']['lte'] = $filters['to'];            }        }                $events = $this->eventSearch->searchEvents($query);                // Filtrer par texte de recherche        if ($searchText) {            $events = array_filter($events, function($event) use ($searchText) {                $data = $event->toArray();                return stripos(json_encode($data), $searchText) !== false;            });        }                $results = [];        foreach ($events as $event) {            $results[] = [                'eventId' => $event->getId(),                'aggregateId' => $event->getAggregateId(),                'eventType' => $event->getEventType(),                'timestamp' => $event->getTimestamp(),                'data' => $event->toArray(),                'metadata' => $event->getMetadata()            ];        }                return $results;    }    private function getIntervalKey(\DateTime $timestamp, string $interval): string    {        switch ($interval) {            case 'hour':                return $timestamp->format('Y-m-d H:00:00');            case 'day':                return $timestamp->format('Y-m-d');            case 'week':                return $timestamp->format('Y-W');            case 'month':                return $timestamp->format('Y-m');            default:                return $timestamp->format('Y-m-d');        }    }}```## üß™ **Tests et Validation**### **Tests d'Int√©gration Event Sourcing + CQS**```php<?phpnamespace App\Tests\Integration\InMemory;use App\Application\Command\Payment\ProcessPaymentCommand;use App\Application\Command\Payment\ProcessPaymentCommandHandler;use App\Application\Query\Payment\GetPaymentHistoryQuery;use App\Application\Query\Payment\PaymentEventQueryHandler;use App\Infrastructure\EventStore\InMemoryEventStore;use App\Infrastructure\InMemory\Query\EventSearchService;class InMemoryEventSourcingCqsTest extends TestCase{    private InMemoryEventStore $eventStore;    private EventSearchService $eventSearch;    private ProcessPaymentCommandHandler $commandHandler;    private PaymentEventQueryHandler $queryHandler;    protected function setUp(): void    {        $this->eventStore = new InMemoryEventStore($this->createMock(LoggerInterface::class));        $this->eventSearch = new EventSearchService($this->eventStore, $this->createMock(LoggerInterface::class), $this->createMock(CacheItemPoolInterface::class));                $this->commandHandler = new ProcessPaymentCommandHandler(            $this->eventStore,            $this->createMock(EventBusInterface::class),            $this->createMock(LoggerInterface::class)        );                $this->queryHandler = new PaymentEventQueryHandler($this->eventSearch, $this->createMock(LoggerInterface::class));    }    public function testEventSourcingCqsFlow(): void    {        // Ex√©cuter une commande        $command = new ProcessPaymentCommand(            'payment-123',            100.00,            'EUR'        );                $this->commandHandler->handle($command);                // V√©rifier l'historique des √©v√©nements        $query = new GetPaymentHistoryQuery('payment-123');        $history = $this->queryHandler->handle($query);                $this->assertNotEmpty($history);        $this->assertCount(1, $history);        $this->assertEquals('PaymentProcessed', $history[0]['eventType']);    }    public function testEventSearchWithAnalytics(): void    {        // Cr√©er plusieurs √©v√©nements        $commands = [            new ProcessPaymentCommand('payment-1', 100.00, 'EUR'),            new ProcessPaymentCommand('payment-2', 200.00, 'USD'),            new ProcessPaymentCommand('payment-3', 300.00, 'EUR')        ];                foreach ($commands as $command) {            $this->commandHandler->handle($command);        }                // Rechercher les √©v√©nements        $searchQuery = new SearchPaymentEventsQuery(            new \DateTime('2024-01-01'),            new \DateTime('2024-12-31')        );                $results = $this->queryHandler->handle($searchQuery);                $this->assertCount(3, $results);        $this->assertEquals('PaymentProcessed', $results[0]['eventType']);    }}```## üìä **Performance et Optimisation**### **Strat√©gies d'Optimisation Event Sourcing + CQS**#### **1. Cache Multi-Niveaux**```phppublic function searchEventsWithCache(array $query, string $cacheKey = null): array{    // Cache L1: M√©moire    if (isset($this->memoryCache[$cacheKey])) {        return $this->memoryCache[$cacheKey];    }        // Cache L2: Redis    if ($cached = $this->redis->get("event_search:{$cacheKey}")) {        $result = json_decode($cached, true);        $this->memoryCache[$cacheKey] = $result;        return $result;    }        // In-Memory    $result = $this->searchEvents($query);        // Mettre en cache    $this->memoryCache[$cacheKey] = $result;    $this->redis->setex("event_search:{$cacheKey}", 300, json_encode($result));        return $result;}```#### **2. Projections Asynchrones**```phppublic function handleEventAsync(DomainEvent $event): void{    // Mettre en queue pour traitement asynchrone    $this->messageBus->dispatch(new ProcessProjectionCommand($event));}```#### **3. Index Optimis√©s**```phppublic function optimizeIndexes(): void{    // Nettoyer les index orphelins    $this->cleanOrphanedIndexes();        // Compacter les index    $this->compactIndexes();        // Forcer le garbage collection    gc_collect_cycles();}```## üéØ **Crit√®res d'Adoption**### **Quand Utiliser Event Sourcing + CQS avec In-Memory**#### **‚úÖ Avantages**- **Audit trail complet** : Historique de tous les √©v√©nements- **Performance optimis√©e** : S√©paration claire entre √©criture et lecture- **Debugging avanc√©** : Possibilit√© de rejouer les √©v√©nements- **Flexibilit√©** : Requ√™tes optimis√©es pour chaque usage- **Cache efficace** : Mise en cache des requ√™tes#### **‚ùå Inconv√©nients**- **Complexit√© √©lev√©e** : Architecture tr√®s complexe- **Volatilit√©** : Donn√©es perdues au red√©marrage- **Limitation m√©moire** : Contraint par la RAM disponible- **Expertise** : √âquipe tr√®s exp√©riment√©e requise#### **üéØ Crit√®res d'Adoption**- **Audit trail critique** : Besoin de tra√ßabilit√© compl√®te- **Performance importante** : Besoins de performance √©lev√©e- **Debugging complexe** : Besoin de rejouer les √©v√©nements- **Donn√©es temporaires** : Cache, sessions, m√©triques- **√âquipe tr√®s exp√©riment√©e** : Ma√Ætrise d'Event Sourcing, CQS et In-Memory- **M√©moire suffisante** : RAM disponible pour tous les √©v√©nements## üöÄ **Votre Prochaine √âtape**{{< chapter-nav >}}  {{< chapter-option     letter="A"     color="green"     title="Je veux voir l'approche Event Sourcing + CQRS avec In-Memory"     subtitle="Vous voulez comprendre la combinaison compl√®te Event Sourcing et CQRS"    criteria="Architecture maximale,√âquipe tr√®s exp√©riment√©e,Performance critique,Scalabilit√© maximale"    time="45-60 minutes"    chapter="45"    chapter-title="Stockage In-Memory - Event Sourcing + CQRS"    chapter-url="/chapitres/stockage/in-memory/chapitre-45-stockage-in-memory-event-sourcing-cqrs/"  >}}    {{< chapter-option     letter="B"     color="yellow"     title="Je veux explorer les autres types de stockage"     subtitle="Vous voulez voir les alternatives √† In-Memory"    criteria="Comparaison n√©cessaire,Choix de stockage,Architecture √† d√©finir,Performance √† optimiser"    time="30-40 minutes"    chapter="10"    chapter-title="Choix du Type de Stockage"    chapter-url="/chapitres/fondamentaux/chapitre-10-choix-type-stockage/"  >}}    {{< chapter-option     letter="C"     color="blue"     title="Je veux voir des exemples concrets"     subtitle="Vous voulez comprendre les impl√©mentations pratiques"    criteria="D√©veloppeur exp√©riment√©,Besoin d'exemples pratiques,Impl√©mentation √† faire,Code √† √©crire"    time="Variable"    chapter="0"    chapter-title="Exemples et Impl√©mentations"    chapter-url="/examples/"  >}}    {{< chapter-option     letter="D"     color="purple"     title="Je veux revenir aux fondamentaux"     subtitle="Vous voulez comprendre les concepts de base"    criteria="D√©veloppeur d√©butant,Besoin de comprendre les concepts,Projet √† structurer,√âquipe √† former"    time="45-60 minutes"    chapter="1"    chapter-title="Introduction au Domain-Driven Design et Event Storming"    chapter-url="/chapitres/fondamentaux/chapitre-01-introduction-event-storming-ddd/"  >}}{{< /chapter-nav >}}---*Event Sourcing + CQS avec In-Memory offre une approche sophistiqu√©e pour l'audit trail et la performance, parfaitement adapt√©e aux besoins les plus exigeants de Gyroscops.*