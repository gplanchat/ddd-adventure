---
title: "Stockage ElasticSearch - CQRS"
description: "Impl√©mentation compl√®te CQRS avec ElasticSearch pour une architecture hautement scalable"
date: 2024-12-19
draft: true
type: "docs"
weight: 36
---
## üéØ **Contexte et Objectifs**### **L'Approche CQRS Compl√®te avec ElasticSearch**Nous arrivons maintenant √† l'approche la plus sophistiqu√©e : **CQRS complet avec ElasticSearch**. Cette combinaison offre une architecture hautement scalable et flexible, parfaite pour les syst√®mes complexes n√©cessitant recherche et analytics.#### **Pourquoi CQRS avec ElasticSearch ?**- **S√©paration totale** : Commandes et requ√™tes compl√®tement d√©coupl√©es- **Scalabilit√© maximale** : Possibilit√© de scaler ind√©pendamment chaque c√¥t√©- **Flexibilit√©** : Projections multiples pour diff√©rents besoins- **Performance optimale** : Chaque c√¥t√© optimis√© pour son usage- **Analytics avanc√©es** : Agr√©gations complexes et rapports### **Contexte Gyroscops**Dans notre √©cosyst√®me **User ‚Üí Organization ‚Üí Workflow ‚Üí Cloud Resources ‚Üí Billing**, CQRS avec ElasticSearch est id√©al pour :- **Syst√®me de facturation** : Commandes de paiement, requ√™tes d'analytics- **Logs d'application** : √âcriture des logs, analyse et monitoring- **M√©triques de performance** : Collecte des m√©triques, dashboards- **Recherche avanc√©e** : Full-text search avec scoring et suggestions## üèóÔ∏è **Architecture CQRS avec ElasticSearch**### **S√©paration Compl√®te des Responsabilit√©s**#### **Command Side (Write)**- **Command Handlers** : Traitement des commandes m√©tier- **ElasticSearch Writer** : Indexation des documents- **Event Handlers** : Gestion des √©v√©nements de domaine- **Command Bus** : Orchestration des commandes- **Bulk Operations** : Optimisation des √©critures#### **Query Side (Read)**- **Query Handlers** : Traitement des requ√™tes- **ElasticSearch Reader** : Requ√™tes optimis√©es- **Search Services** : Services de recherche sp√©cialis√©s- **Query Bus** : Orchestration des requ√™tes- **Caches** : Optimisation des performances### **Flux de Donn√©es Complet**```mermaidgraph TD    A[Command] --> B[Command Bus]    B --> C[Command Handler]    C --> D[ElasticSearch Writer]    D --> E[ElasticSearch Cluster]    E --> F[Index Document]        G[Query] --> H[Query Bus]    H --> I[Query Handler]    I --> J[ElasticSearch Reader]    J --> E    E --> K[Search Results]    K --> L[Response]        M[Event] --> N[Event Handler]    N --> D        O[Projection] --> P[ElasticSearch Writer]    P --> E```## üíª **Impl√©mentation Compl√®te**### **1. Command Side Implementation**#### **Command Bus avec Middleware**```php<?phpnamespace App\Application\CommandBus;use App\Domain\Command\CommandInterface;use App\Domain\Command\CommandHandlerInterface;use Psr\Log\LoggerInterface;class CommandBus{    private array $handlers = [];    private array $middleware = [];    private LoggerInterface $logger;    public function __construct(LoggerInterface $logger)    {        $this->logger = $logger;    }    public function registerHandler(string $commandClass, CommandHandlerInterface $handler): void    {        $this->handlers[$commandClass] = $handler;    }    public function addMiddleware(callable $middleware): void    {        $this->middleware[] = $middleware;    }    public function handle(CommandInterface $command): void    {        $commandClass = get_class($command);                if (!isset($this->handlers[$commandClass])) {            throw new \InvalidArgumentException("No handler registered for command: $commandClass");        }        $handler = $this->handlers[$commandClass];                // Ex√©cuter les middleware        $this->executeMiddleware($command, function() use ($handler, $command) {            $this->logger->info('Executing command', [                'command' => get_class($command),                'data' => $command->toArray()            ]);                        $handler->handle($command);        });    }    private function executeMiddleware(CommandInterface $command, callable $next): void    {        $middleware = array_reverse($this->middleware);                foreach ($middleware as $mw) {            $next = function() use ($mw, $command, $next) {                return $mw($command, $next);            };        }                $next();    }}```#### **ElasticSearch Writer Avanc√©**```php<?phpnamespace App\Infrastructure\ElasticSearch\Command;use Elasticsearch\Client;use Psr\Log\LoggerInterface;class ElasticSearchWriter{    private Client $client;    private string $index;    private LoggerInterface $logger;    private array $bulkBuffer = [];    private int $bulkSize;    private string $routingField;    public function __construct(        Client $client,         string $index,         LoggerInterface $logger,         int $bulkSize = 100,        string $routingField = 'organizationId'    ) {        $this->client = $client;        $this->index = $index;        $this->logger = $logger;        $this->bulkSize = $bulkSize;        $this->routingField = $routingField;    }    public function indexDocument(string $id, array $document, string $routing = null): void    {        $operation = [            'index' => [                '_index' => $this->index,                '_id' => $id            ]        ];        if ($routing) {            $operation['index']['routing'] = $routing;        }        $this->bulkBuffer[] = $operation;        $this->bulkBuffer[] = $document;        if (count($this->bulkBuffer) >= $this->bulkSize * 2) {            $this->flushBulk();        }    }    public function updateDocument(string $id, array $document, string $routing = null): void    {        $operation = [            'update' => [                '_index' => $this->index,                '_id' => $id            ]        ];        if ($routing) {            $operation['update']['routing'] = $routing;        }        $this->bulkBuffer[] = $operation;        $this->bulkBuffer[] = [            'doc' => $document,            'doc_as_upsert' => true        ];        if (count($this->bulkBuffer) >= $this->bulkSize * 2) {            $this->flushBulk();        }    }    public function deleteDocument(string $id, string $routing = null): void    {        $operation = [            'delete' => [                '_index' => $this->index,                '_id' => $id            ]        ];        if ($routing) {            $operation['delete']['routing'] = $routing;        }        $this->bulkBuffer[] = $operation;        if (count($this->bulkBuffer) >= $this->bulkSize * 2) {            $this->flushBulk();        }    }    public function flushBulk(): void    {        if (empty($this->bulkBuffer)) {            return;        }        try {            $response = $this->client->bulk([                'body' => $this->bulkBuffer,                'refresh' => false            ]);            $this->logger->info('Bulk operation completed', [                'index' => $this->index,                'operations' => count($this->bulkBuffer) / 2,                'errors' => $response['errors']            ]);            $this->bulkBuffer = [];        } catch (\Exception $e) {            $this->logger->error('Bulk operation failed', [                'index' => $this->index,                'error' => $e->getMessage(),                'operations' => count($this->bulkBuffer) / 2            ]);            throw $e;        }    }    public function createIndexWithMapping(array $mapping): void    {        $params = [            'index' => $this->index,            'body' => [                'settings' => [                    'number_of_shards' => 3,                    'number_of_replicas' => 1,                    'refresh_interval' => '30s',                    'analysis' => [                        'analyzer' => [                            'payment_analyzer' => [                                'type' => 'custom',                                'tokenizer' => 'standard',                                'filter' => ['lowercase', 'stop']                            ]                        ]                    ]                ],                'mappings' => $mapping            ]        ];        try {            $this->client->indices()->create($params);            $this->logger->info('Index created with mapping', ['index' => $this->index]);        } catch (\Exception $e) {            $this->logger->error('Failed to create index', [                'index' => $this->index,                'error' => $e->getMessage()            ]);            throw $e;        }    }}```#### **Command Handler pour les Paiements**```php<?phpnamespace App\Application\Command\Payment;use App\Domain\Payment\Payment;use App\Domain\Payment\PaymentRepositoryInterface;use App\Infrastructure\ElasticSearch\Command\ElasticSearchWriter;use App\Domain\Event\EventBusInterface;use Psr\Log\LoggerInterface;class ProcessPaymentCommandHandler implements CommandHandlerInterface{    public function __construct(        private PaymentRepositoryInterface $paymentRepository,        private ElasticSearchWriter $elasticSearchWriter,        private EventBusInterface $eventBus,        private LoggerInterface $logger    ) {}    public function handle(ProcessPaymentCommand $command): void    {        try {            // Charger le paiement            $payment = $this->paymentRepository->findById($command->getPaymentId());                        if (!$payment) {                throw new \InvalidArgumentException("Payment not found: {$command->getPaymentId()}");            }            // Traiter le paiement            $payment->processPayment($command->getAmount(), $command->getCurrency());                        // Sauvegarder dans le repository principal            $this->paymentRepository->save($payment);            // Indexer dans ElasticSearch pour la recherche            $this->indexPaymentForSearch($payment);            // Publier l'√©v√©nement            $event = new PaymentProcessedEvent(                $payment->getId(),                $payment->getAmount(),                $payment->getCurrency(),                $payment->getOrganizationId()            );                        $this->eventBus->publish($event);            $this->logger->info('Payment processed and indexed', [                'paymentId' => $payment->getId(),                'organizationId' => $payment->getOrganizationId(),                'amount' => $payment->getAmount()            ]);        } catch (\Exception $e) {            $this->logger->error('Payment processing failed', [                'paymentId' => $command->getPaymentId(),                'error' => $e->getMessage()            ]);            throw $e;        }    }    private function indexPaymentForSearch(Payment $payment): void    {        $document = [            'paymentId' => $payment->getId(),            'organizationId' => $payment->getOrganizationId(),            'userId' => $payment->getUserId(),            'amount' => $payment->getAmount(),            'currency' => $payment->getCurrency(),            'status' => $payment->getStatus(),            'description' => $payment->getDescription(),            'processedAt' => $payment->getProcessedAt()->format('c'),            'metadata' => $payment->getMetadata(),            'indexedAt' => (new \DateTime())->format('c')        ];        $this->elasticSearchWriter->indexDocument(            $payment->getId(),            $document,            $payment->getOrganizationId()        );    }}```### **2. Query Side Implementation**#### **Query Bus avec Cache**```php<?phpnamespace App\Application\QueryBus;use App\Domain\Query\QueryInterface;use App\Domain\Query\QueryHandlerInterface;use Psr\Cache\CacheItemPoolInterface;use Psr\Log\LoggerInterface;class QueryBus{    private array $handlers = [];    private CacheItemPoolInterface $cache;    private LoggerInterface $logger;    public function __construct(CacheItemPoolInterface $cache, LoggerInterface $logger)    {        $this->cache = $cache;        $this->logger = $logger;    }    public function registerHandler(string $queryClass, QueryHandlerInterface $handler): void    {        $this->handlers[$queryClass] = $handler;    }    public function handle(QueryInterface $query): mixed    {        $queryClass = get_class($query);                if (!isset($this->handlers[$queryClass])) {            throw new \InvalidArgumentException("No handler registered for query: $queryClass");        }        // V√©rifier le cache        $cacheKey = $this->generateCacheKey($query);        $cachedItem = $this->cache->getItem($cacheKey);                if ($cachedItem->isHit()) {            $this->logger->debug('Query result served from cache', [                'query' => $queryClass,                'cacheKey' => $cacheKey            ]);                        return $cachedItem->get();        }        // Ex√©cuter la requ√™te        $handler = $this->handlers[$queryClass];        $result = $handler->handle($query);                // Mettre en cache        $cachedItem->set($result);        $cachedItem->expiresAfter(300); // 5 minutes        $this->cache->save($cachedItem);                $this->logger->info('Query executed and cached', [            'query' => $queryClass,            'cacheKey' => $cacheKey        ]);                return $result;    }    private function generateCacheKey(QueryInterface $query): string    {        return 'query_' . md5(serialize($query));    }}```#### **ElasticSearch Reader Avanc√©**```php<?phpnamespace App\Infrastructure\ElasticSearch\Query;use Elasticsearch\Client;use Psr\Log\LoggerInterface;use Psr\Cache\CacheItemPoolInterface;class ElasticSearchReader{    private Client $client;    private string $index;    private LoggerInterface $logger;    private CacheItemPoolInterface $cache;    public function __construct(        Client $client,         string $index,         LoggerInterface $logger,        CacheItemPoolInterface $cache    ) {        $this->client = $client;        $this->index = $index;        $this->logger = $logger;        $this->cache = $cache;    }    public function search(array $query, string $cacheKey = null): array    {        // V√©rifier le cache        if ($cacheKey) {            $cachedItem = $this->cache->getItem($cacheKey);            if ($cachedItem->isHit()) {                $this->logger->debug('Search result served from cache', [                    'index' => $this->index,                    'cacheKey' => $cacheKey                ]);                return $cachedItem->get();            }        }        try {            $response = $this->client->search([                'index' => $this->index,                'body' => $query            ]);            // Mettre en cache            if ($cacheKey) {                $cachedItem->set($response);                $cachedItem->expiresAfter(300); // 5 minutes                $this->cache->save($cachedItem);            }            $this->logger->info('Search executed', [                'index' => $this->index,                'hits' => $response['hits']['total']['value'],                'took' => $response['took']            ]);            return $response;        } catch (\Exception $e) {            $this->logger->error('Search failed', [                'index' => $this->index,                'query' => $query,                'error' => $e->getMessage()            ]);            throw $e;        }    }    public function getDocument(string $id, string $routing = null): ?array    {        $params = [            'index' => $this->index,            'id' => $id        ];        if ($routing) {            $params['routing'] = $routing;        }        try {            $response = $this->client->get($params);            return $response['_source'];        } catch (\Elasticsearch\Common\Exceptions\Missing404Exception $e) {            return null;        } catch (\Exception $e) {            $this->logger->error('Failed to get document', [                'index' => $this->index,                'id' => $id,                'error' => $e->getMessage()            ]);            throw $e;        }    }    public function getSuggestions(string $query, string $field = 'description', int $size = 10): array    {        $searchQuery = [            'suggest' => [                'payment_suggestions' => [                    'prefix' => $query,                    'completion' => [                        'field' => $field . '.suggest',                        'size' => $size                    ]                ]            ],            'size' => 0        ];        $response = $this->search($searchQuery);        $suggestions = [];        if (isset($response['suggest']['payment_suggestions'][0]['options'])) {            foreach ($response['suggest']['payment_suggestions'][0]['options'] as $option) {                $suggestions[] = [                    'text' => $option['text'],                    'score' => $option['score']                ];            }        }        return $suggestions;    }    public function getAnalytics(array $query): array    {        $query['size'] = 0; // Pas besoin des documents, seulement les agr√©gations                $response = $this->search($query);                return $response['aggregations'] ?? [];    }}```#### **Query Handler pour les Paiements**```php<?phpnamespace App\Application\Query\Payment;use App\Infrastructure\ElasticSearch\Query\ElasticSearchReader;use App\Domain\Payment\Payment;use Psr\Log\LoggerInterface;class PaymentQueryHandler implements QueryHandlerInterface{    private ElasticSearchReader $reader;    private LoggerInterface $logger;    public function __construct(ElasticSearchReader $reader, LoggerInterface $logger)    {        $this->reader = $reader;        $this->logger = $logger;    }    public function handle(GetPaymentByIdQuery $query): ?Payment    {        $document = $this->reader->getDocument(            $query->getPaymentId(),            $query->getOrganizationId()        );                if (!$document) {            return null;        }                return $this->documentToPayment($document);    }    public function handle(SearchPaymentsQuery $query): PaymentSearchResult    {        $searchQuery = $this->buildSearchQuery($query);        $cacheKey = $this->generateCacheKey($query);                $response = $this->reader->search($searchQuery, $cacheKey);                $payments = [];        foreach ($response['hits']['hits'] as $hit) {            $payments[] = $this->documentToPayment($hit['_source']);        }                return new PaymentSearchResult(            $payments,            $response['hits']['total']['value'],            $query->getPage(),            $query->getSize()        );    }    public function handle(GetPaymentStatisticsQuery $query): array    {        $searchQuery = [            'query' => [                'bool' => [                    'must' => [                        ['term' => ['organizationId' => $query->getOrganizationId()]],                        ['range' => [                            'processedAt' => [                                'gte' => $query->getFrom()->format('c'),                                'lte' => $query->getTo()->format('c')                            ]                        ]]                    ]                ]            ],            'aggs' => [                'status_stats' => [                    'terms' => ['field' => 'status'],                    'aggs' => [                        'total_amount' => ['sum' => ['field' => 'amount']],                        'avg_amount' => ['avg' => ['field' => 'amount']]                    ]                ],                'currency_stats' => [                    'terms' => ['field' => 'currency'],                    'aggs' => [                        'total_amount' => ['sum' => ['field' => 'amount']]                    ]                ],                'daily_stats' => [                    'date_histogram' => [                        'field' => 'processedAt',                        'calendar_interval' => 'day'                    ],                    'aggs' => [                        'total_amount' => ['sum' => ['field' => 'amount']],                        'count' => ['value_count' => ['field' => 'paymentId']]                    ]                ]            ]        ];                $cacheKey = 'payment_stats_' . md5(serialize($query));        $response = $this->reader->search($searchQuery, $cacheKey);                return [            'status_stats' => $response['aggregations']['status_stats']['buckets'],            'currency_stats' => $response['aggregations']['currency_stats']['buckets'],            'daily_stats' => $response['aggregations']['daily_stats']['buckets']        ];    }    public function handle(GetPaymentSuggestionsQuery $query): array    {        return $this->reader->getSuggestions(            $query->getQuery(),            'description',            $query->getSize()        );    }    private function buildSearchQuery(SearchPaymentsQuery $query): array    {        $searchQuery = [            'query' => [                'bool' => [                    'must' => []                ]            ],            'sort' => [                ['_score' => ['order' => 'desc']],                ['processedAt' => ['order' => 'desc']]            ],            'from' => $query->getOffset(),            'size' => $query->getSize()        ];                // Filtres obligatoires        if ($query->getOrganizationId()) {            $searchQuery['query']['bool']['must'][] = [                'term' => ['organizationId' => $query->getOrganizationId()]            ];        }                // Recherche textuelle        if ($query->getSearchText()) {            $searchQuery['query']['bool']['must'][] = [                'multi_match' => [                    'query' => $query->getSearchText(),                    'fields' => ['description^2', 'paymentId', 'metadata.tags'],                    'type' => 'best_fields',                    'fuzziness' => 'AUTO'                ]            ];        }                // Filtres de statut        if ($query->getStatuses()) {            $searchQuery['query']['bool']['must'][] = [                'terms' => ['status' => $query->getStatuses()]            ];        }                // Filtres de devise        if ($query->getCurrencies()) {            $searchQuery['query']['bool']['must'][] = [                'terms' => ['currency' => $query->getCurrencies()]            ];        }                // Filtres de montant        if ($query->getMinAmount() || $query->getMaxAmount()) {            $range = [];            if ($query->getMinAmount()) {                $range['gte'] = $query->getMinAmount();            }            if ($query->getMaxAmount()) {                $range['lte'] = $query->getMaxAmount();            }                        $searchQuery['query']['bool']['must'][] = [                'range' => ['amount' => $range]            ];        }                // Filtres de date        if ($query->getFrom() || $query->getTo()) {            $range = [];            if ($query->getFrom()) {                $range['gte'] = $query->getFrom()->format('c');            }            if ($query->getTo()) {                $range['lte'] = $query->getTo()->format('c');            }                        $searchQuery['query']['bool']['must'][] = [                'range' => ['processedAt' => $range]            ];        }                return $searchQuery;    }    private function generateCacheKey(SearchPaymentsQuery $query): string    {        return 'payment_search_' . md5(serialize($query));    }    private function documentToPayment(array $document): Payment    {        return new Payment(            $document['paymentId'],            $document['organizationId'],            $document['userId'],            $document['amount'],            $document['currency'],            $document['status'],            $document['description'],            new \DateTime($document['processedAt']),            $document['metadata'] ?? []        );    }}```### **3. Service de Projection**#### **Service de Projection pour les Analytics**```php<?phpnamespace App\Application\Service\ElasticSearch;use App\Domain\Event\DomainEvent;use App\Infrastructure\ElasticSearch\Command\ElasticSearchWriter;use Psr\Log\LoggerInterface;class PaymentProjectionService{    private ElasticSearchWriter $writer;    private LoggerInterface $logger;    public function __construct(ElasticSearchWriter $writer, LoggerInterface $logger)    {        $this->writer = $writer;        $this->logger = $logger;    }    public function handleEvent(DomainEvent $event): void    {        switch ($event->getEventType()) {            case 'PaymentProcessed':                $this->handlePaymentProcessed($event);                break;            case 'PaymentFailed':                $this->handlePaymentFailed($event);                break;            case 'PaymentRefunded':                $this->handlePaymentRefunded($event);                break;        }    }    private function handlePaymentProcessed(DomainEvent $event): void    {        $update = [            'status' => 'completed',            'processedAt' => $event->getTimestamp()->format('c'),            'updatedAt' => (new \DateTime())->format('c')        ];        $this->writer->updateDocument(            $event->getAggregateId(),            $update,            $event->getMetadata()['organizationId'] ?? null        );        $this->logger->info('Payment processed projection updated', [            'paymentId' => $event->getAggregateId(),            'status' => 'completed'        ]);    }    private function handlePaymentFailed(DomainEvent $event): void    {        $update = [            'status' => 'failed',            'error' => $event->getData()['error'],            'failedAt' => $event->getTimestamp()->format('c'),            'updatedAt' => (new \DateTime())->format('c')        ];        $this->writer->updateDocument(            $event->getAggregateId(),            $update,            $event->getMetadata()['organizationId'] ?? null        );        $this->logger->info('Payment failed projection updated', [            'paymentId' => $event->getAggregateId(),            'status' => 'failed'        ]);    }    private function handlePaymentRefunded(DomainEvent $event): void    {        $update = [            'status' => 'refunded',            'refundAmount' => $event->getData()['refundAmount'],            'refundedAt' => $event->getTimestamp()->format('c'),            'updatedAt' => (new \DateTime())->format('c')        ];        $this->writer->updateDocument(            $event->getAggregateId(),            $update,            $event->getMetadata()['organizationId'] ?? null        );        $this->logger->info('Payment refunded projection updated', [            'paymentId' => $event->getAggregateId(),            'status' => 'refunded'        ]);    }}```## üß™ **Tests et Validation**### **Tests d'Int√©gration CQRS**```php<?phpnamespace App\Tests\Integration\ElasticSearch;use App\Application\Command\Payment\ProcessPaymentCommand;use App\Application\Command\Payment\ProcessPaymentCommandHandler;use App\Application\Query\Payment\GetPaymentByIdQuery;use App\Application\Query\Payment\SearchPaymentsQuery;use App\Application\Query\Payment\PaymentQueryHandler;use App\Infrastructure\ElasticSearch\Command\ElasticSearchWriter;use App\Infrastructure\ElasticSearch\Query\ElasticSearchReader;use Elasticsearch\ClientBuilder;class ElasticSearchCqrsTest extends TestCase{    private ElasticSearchWriter $writer;    private ElasticSearchReader $reader;    private ProcessPaymentCommandHandler $commandHandler;    private PaymentQueryHandler $queryHandler;    protected function setUp(): void    {        $client = ClientBuilder::create()->setHosts(['localhost:9200'])->build();                $this->writer = new ElasticSearchWriter($client, 'test-payments', $this->createMock(LoggerInterface::class));        $this->reader = new ElasticSearchReader($client, 'test-payments', $this->createMock(LoggerInterface::class), $this->createMock(CacheItemPoolInterface::class));                $this->commandHandler = new ProcessPaymentCommandHandler(            $this->createMock(PaymentRepositoryInterface::class),            $this->writer,            $this->createMock(EventBusInterface::class),            $this->createMock(LoggerInterface::class)        );                $this->queryHandler = new PaymentQueryHandler($this->reader, $this->createMock(LoggerInterface::class));    }    public function testCqrsSeparation(): void    {        // Ex√©cuter une commande        $command = new ProcessPaymentCommand(            'payment-123',            100.00,            'EUR',            'org-456'        );                $this->commandHandler->handle($command);                // V√©rifier avec une requ√™te        $query = new GetPaymentByIdQuery('payment-123', 'org-456');        $payment = $this->queryHandler->handle($query);                $this->assertNotNull($payment);        $this->assertEquals('payment-123', $payment->getId());        $this->assertEquals(100.00, $payment->getAmount());    }    public function testSearchWithAnalytics(): void    {        // Cr√©er plusieurs paiements        $payments = [            new ProcessPaymentCommand('payment-1', 100.00, 'EUR', 'org-456'),            new ProcessPaymentCommand('payment-2', 200.00, 'USD', 'org-456'),            new ProcessPaymentCommand('payment-3', 300.00, 'EUR', 'org-789')        ];                foreach ($payments as $command) {            $this->commandHandler->handle($command);        }                // Rechercher avec analytics        $searchQuery = new SearchPaymentsQuery('org-456', 0, 10);        $result = $this->queryHandler->handle($searchQuery);                $this->assertCount(2, $result->getPayments());        $this->assertEquals(2, $result->getTotal());    }}```## üìä **Performance et Optimisation**### **Strat√©gies d'Optimisation CQRS**#### **1. Index Optimis√©s avec Routing**```json{  "mappings": {    "properties": {      "paymentId": { "type": "keyword" },      "organizationId": { "type": "keyword" },      "description": {         "type": "text",        "analyzer": "payment_analyzer",        "fields": {          "suggest": { "type": "completion" }        }      },      "processedAt": { "type": "date" },      "amount": { "type": "double" }    }  },  "settings": {    "number_of_shards": 3,    "number_of_replicas": 1,    "refresh_interval": "30s"  }}```#### **2. Cache Multi-Niveaux**```phppublic function searchWithMultiLevelCache(SearchPaymentsQuery $query): PaymentSearchResult{    // Cache L1: M√©moire    if (isset($this->memoryCache[$query->getCacheKey()])) {        return $this->memoryCache[$query->getCacheKey()];    }        // Cache L2: Redis    $cached = $this->redis->get("payment_search:{$query->getCacheKey()}");    if ($cached) {        $result = PaymentSearchResult::fromArray(json_decode($cached, true));        $this->memoryCache[$query->getCacheKey()] = $result;        return $result;    }        // ElasticSearch    $result = $this->searchPayments($query);        // Mettre en cache    $this->memoryCache[$query->getCacheKey()] = $result;    $this->redis->setex("payment_search:{$query->getCacheKey()}", 300, json_encode($result->toArray()));        return $result;}```#### **3. Projections Asynchrones**```phppublic function handleEventAsync(DomainEvent $event): void{    // Mettre en queue pour traitement asynchrone    $this->messageBus->dispatch(new ProcessProjectionCommand($event));}```## üéØ **Crit√®res d'Adoption**### **Quand Utiliser CQRS avec ElasticSearch**#### **‚úÖ Avantages**- **Scalabilit√© maximale** : Possibilit√© de scaler ind√©pendamment- **Performance optimale** : Chaque c√¥t√© optimis√© pour son usage- **Flexibilit√©** : Projections multiples pour diff√©rents besoins- **Analytics avanc√©es** : Agr√©gations complexes et rapports- **Recherche puissante** : Full-text search avec scoring#### **‚ùå Inconv√©nients**- **Complexit√© maximale** : Architecture tr√®s complexe- **Latence** : D√©lai entre √©criture et lecture- **Synchronisation** : Besoin de synchroniser les donn√©es- **Expertise** : √âquipe tr√®s exp√©riment√©e requise- **Co√ªt** : Infrastructure plus co√ªteuse#### **üéØ Crit√®res d'Adoption**- **Syst√®me tr√®s complexe** : Besoins de scalabilit√© maximale- **√âquipe tr√®s exp√©riment√©e** : Ma√Ætrise d'ElasticSearch et CQRS- **Budget important** : Investissement en complexit√© justifi√©- **Performance critique** : Besoins de performance maximale- **Analytics avanc√©es** : Besoins de rapports complexes- **Recherche complexe** : Besoins de recherche full-text avanc√©e## üöÄ **Votre Prochaine √âtape**{{< chapter-nav >}}  {{< chapter-option     letter="A"     color="green"     title="Je veux voir l'approche Event Sourcing avec ElasticSearch"     subtitle="Vous voulez comprendre l'Event Sourcing avec ElasticSearch"    criteria="Audit trail critique,√âquipe tr√®s exp√©riment√©e,Architecture complexe,Historique complet"    time="45-60 minutes"    chapter="37"    chapter-title="Stockage ElasticSearch - Event Sourcing"    chapter-url="/chapitres/stockage/elasticsearch/chapitre-37-stockage-elasticsearch-event-sourcing/"  >}}    {{< chapter-option     letter="B"     color="yellow"     title="Je veux explorer les autres types de stockage"     subtitle="Vous voulez voir les alternatives √† ElasticSearch"    criteria="Comparaison n√©cessaire,Choix de stockage,Architecture √† d√©finir,Performance √† optimiser"    time="30-40 minutes"    chapter="10"    chapter-title="Choix du Type de Stockage"    chapter-url="/chapitres/fondamentaux/chapitre-10-choix-type-stockage/"  >}}    {{< chapter-option     letter="C"     color="blue"     title="Je veux voir des exemples concrets"     subtitle="Vous voulez comprendre les impl√©mentations pratiques"    criteria="D√©veloppeur exp√©riment√©,Besoin d'exemples pratiques,Impl√©mentation √† faire,Code √† √©crire"    time="Variable"    chapter="0"    chapter-title="Exemples et Impl√©mentations"    chapter-url="/examples/"  >}}    {{< chapter-option     letter="D"     color="purple"     title="Je veux revenir aux fondamentaux"     subtitle="Vous voulez comprendre les concepts de base"    criteria="D√©veloppeur d√©butant,Besoin de comprendre les concepts,Projet √† structurer,√âquipe √† former"    time="45-60 minutes"    chapter="1"    chapter-title="Introduction au Domain-Driven Design et Event Storming"    chapter-url="/chapitres/fondamentaux/chapitre-01-introduction-event-storming-ddd/"  >}}{{< /chapter-nav >}}---*CQRS avec ElasticSearch repr√©sente l'√©tat de l'art en mati√®re d'architecture scalable pour la recherche et l'analytics, parfaitement adapt√© aux besoins les plus exigeants de Gyroscops.*