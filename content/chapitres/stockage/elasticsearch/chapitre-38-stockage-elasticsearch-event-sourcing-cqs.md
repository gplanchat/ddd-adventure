---
title: "Stockage ElasticSearch - Event Sourcing + CQS"
description: "Implémentation Event Sourcing avec Command Query Separation pour ElasticSearch"
date: 2024-12-19
draft: true
type: "docs"
weight: 38
---
## 🎯 **Contexte et Objectifs**### **Pourquoi Event Sourcing + CQS avec ElasticSearch ?**Cette combinaison offre le meilleur des deux mondes : l'audit trail complet de l'Event Sourcing avec la séparation optimisée des responsabilités du CQS, le tout sur une plateforme de recherche et d'analytics puissante.#### **Avantages de cette Combinaison**- **Audit trail complet** : Historique de tous les événements- **Performance optimisée** : Séparation claire entre écriture et lecture- **Recherche avancée** : Full-text search sur les événements- **Analytics temporelles** : Analyse des tendances dans le temps- **Scalabilité** : Possibilité de scaler indépendamment### **Contexte Gyroscops**Dans notre écosystème **User → Organization → Workflow → Cloud Resources → Billing**, Event Sourcing + CQS avec ElasticSearch est idéal pour :- **Système de facturation** : Audit trail des paiements avec recherche avancée- **Logs d'application** : Historique complet avec analytics- **Métriques de performance** : Traçabilité des performances dans le temps- **Workflows** : Historique des étapes avec recherche et analytics## 🏗️ **Architecture Event Sourcing + CQS**### **Séparation des Responsabilités**#### **Command Side (Write)**- **Command Handlers** : Traitement des commandes métier- **Event Store** : Persistance des événements dans ElasticSearch- **Event Handlers** : Gestion des événements de domaine- **Bulk Operations** : Optimisation des écritures#### **Query Side (Read)**- **Query Handlers** : Traitement des requêtes- **Event Search** : Recherche dans les événements- **Analytics Services** : Services d'analytics temporelles- **Caches** : Optimisation des performances### **Flux de Données Complet**```mermaidgraph TD    A[Command] --> B[Command Handler]    B --> C[Aggregate]    C --> D[Events]    D --> E[Event Store ElasticSearch]    E --> F[Event Handlers]    F --> G[Projections]    G --> H[Read Models]        I[Query] --> J[Query Handler]    J --> K[Event Search]    K --> E    E --> L[Search Results]    L --> M[Response]        N[Analytics] --> O[Analytics Service]    O --> E    E --> P[Historical Data]    P --> Q[Analytics Results]```## 💻 **Implémentation Pratique**### **1. Command Side Implementation**#### **Event Store ElasticSearch Avancé**```php<?phpnamespace App\Infrastructure\EventStore;use Elasticsearch\Client;use App\Domain\Event\DomainEvent;use App\Domain\Event\EventStoreInterface;use Psr\Log\LoggerInterface;class ElasticSearchEventStore implements EventStoreInterface{    private Client $client;    private string $index;    private LoggerInterface $logger;    private array $bulkBuffer = [];    private int $bulkSize;    public function __construct(        Client $client,         string $index,         LoggerInterface $logger,        int $bulkSize = 100    ) {        $this->client = $client;        $this->index = $index;        $this->logger = $logger;        $this->bulkSize = $bulkSize;    }    public function appendEvents(string $aggregateId, array $events, int $expectedVersion): void    {        try {            // Vérifier la version attendue            $lastEvent = $this->getLastEvent($aggregateId);                        if ($lastEvent && $lastEvent['version'] !== $expectedVersion) {                throw new ConcurrencyException('Version mismatch');            }                        // Préparer les événements pour l'insertion            $version = $expectedVersion + 1;                        foreach ($events as $event) {                $this->bulkBuffer[] = [                    'index' => [                        '_index' => $this->index,                        '_id' => $event->getId()                    ]                ];                                $this->bulkBuffer[] = [                    'eventId' => $event->getId(),                    'aggregateId' => $aggregateId,                    'aggregateType' => $event->getAggregateType(),                    'eventType' => $event->getEventType(),                    'eventData' => $event->toArray(),                    'version' => $version++,                    'timestamp' => $event->getTimestamp()->format('c'),                    'correlationId' => $event->getCorrelationId(),                    'causationId' => $event->getCausationId(),                    'metadata' => $event->getMetadata()                ];                                if (count($this->bulkBuffer) >= $this->bulkSize * 2) {                    $this->flushBulk();                }            }                        $this->flushBulk();                    } catch (\Exception $e) {            $this->logger->error('Failed to append events', [                'aggregateId' => $aggregateId,                'events' => count($events),                'error' => $e->getMessage()            ]);                        throw $e;        }    }    public function getEvents(string $aggregateId, int $fromVersion = 0): array    {        $query = [            'query' => [                'bool' => [                    'must' => [                        ['term' => ['aggregateId' => $aggregateId]],                        ['range' => ['version' => ['gte' => $fromVersion]]]                    ]                ]            ],            'sort' => [['version' => ['order' => 'asc']]]        ];                $response = $this->client->search([            'index' => $this->index,            'body' => $query        ]);                $events = [];        foreach ($response['hits']['hits'] as $hit) {            $events[] = $this->deserializeEvent($hit['_source']);        }                return $events;    }    public function searchEvents(array $criteria): array    {        $query = [            'query' => [                'bool' => [                    'must' => []                ]            ],            'sort' => [['timestamp' => ['order' => 'desc']]]        ];                if (isset($criteria['aggregateType'])) {            $query['query']['bool']['must'][] = [                'term' => ['aggregateType' => $criteria['aggregateType']]            ];        }                if (isset($criteria['eventType'])) {            $query['query']['bool']['must'][] = [                'term' => ['eventType' => $criteria['eventType']]            ];        }                if (isset($criteria['searchText'])) {            $query['query']['bool']['must'][] = [                'multi_match' => [                    'query' => $criteria['searchText'],                    'fields' => ['eventData.*', 'metadata.*']                ]            ];        }                if (isset($criteria['from']) || isset($criteria['to'])) {            $range = [];            if (isset($criteria['from'])) {                $range['gte'] = $criteria['from']->format('c');            }            if (isset($criteria['to'])) {                $range['lte'] = $criteria['to']->format('c');            }                        $query['query']['bool']['must'][] = [                'range' => ['timestamp' => $range]            ];        }                $response = $this->client->search([            'index' => $this->index,            'body' => $query        ]);                $events = [];        foreach ($response['hits']['hits'] as $hit) {            $events[] = $this->deserializeEvent($hit['_source']);        }                return $events;    }    private function getLastEvent(string $aggregateId): ?array    {        $query = [            'query' => [                'term' => ['aggregateId' => $aggregateId]            ],            'sort' => [['version' => ['order' => 'desc']]],            'size' => 1        ];                $response = $this->client->search([            'index' => $this->index,            'body' => $query        ]);                if (empty($response['hits']['hits'])) {            return null;        }                return $response['hits']['hits'][0]['_source'];    }    private function flushBulk(): void    {        if (empty($this->bulkBuffer)) {            return;        }        try {            $response = $this->client->bulk([                'body' => $this->bulkBuffer,                'refresh' => false            ]);            $this->logger->info('Bulk events inserted', [                'index' => $this->index,                'operations' => count($this->bulkBuffer) / 2,                'errors' => $response['errors']            ]);            $this->bulkBuffer = [];        } catch (\Exception $e) {            $this->logger->error('Bulk events insertion failed', [                'index' => $this->index,                'error' => $e->getMessage(),                'operations' => count($this->bulkBuffer) / 2            ]);            throw $e;        }    }    private function deserializeEvent(array $document): DomainEvent    {        $eventClass = $document['eventType'];        return $eventClass::fromArray($document['eventData']);    }}```#### **Command Handler avec Event Sourcing**```php<?phpnamespace App\Application\Command\Payment;use App\Domain\Payment\PaymentAggregate;use App\Domain\Event\EventStoreInterface;use App\Domain\Event\EventBusInterface;use Psr\Log\LoggerInterface;class ProcessPaymentCommandHandler{    public function __construct(        private EventStoreInterface $eventStore,        private EventBusInterface $eventBus,        private LoggerInterface $logger    ) {}    public function handle(ProcessPaymentCommand $command): void    {        try {            // Charger l'agrégat depuis les événements            $events = $this->eventStore->getEvents($command->getPaymentId());            $payment = PaymentAggregate::fromEvents($events);                        // Exécuter la commande            $payment->processPayment($command->getAmount(), $command->getCurrency());                        // Sauvegarder les événements            $this->eventStore->appendEvents(                $command->getPaymentId(),                $payment->getUncommittedEvents(),                $payment->getVersion()            );                        // Publier les événements            foreach ($payment->getUncommittedEvents() as $event) {                $this->eventBus->publish($event);            }                        // Nettoyer les événements non commités            $payment->markEventsAsCommitted();                        $this->logger->info('Payment processed with event sourcing', [                'paymentId' => $command->getPaymentId(),                'amount' => $command->getAmount(),                'currency' => $command->getCurrency(),                'events' => count($payment->getUncommittedEvents())            ]);                    } catch (\Exception $e) {            $this->logger->error('Payment processing failed', [                'paymentId' => $command->getPaymentId(),                'error' => $e->getMessage()            ]);                        throw $e;        }    }}```### **2. Query Side Implementation**#### **Event Search Service**```php<?phpnamespace App\Infrastructure\ElasticSearch\Query;use Elasticsearch\Client;use Psr\Log\LoggerInterface;use Psr\Cache\CacheItemPoolInterface;class EventSearchService{    private Client $client;    private string $index;    private LoggerInterface $logger;    private CacheItemPoolInterface $cache;    public function __construct(        Client $client,         string $index,         LoggerInterface $logger,        CacheItemPoolInterface $cache    ) {        $this->client = $client;        $this->index = $index;        $this->logger = $logger;        $this->cache = $cache;    }    public function searchEvents(array $query, string $cacheKey = null): array    {        // Vérifier le cache        if ($cacheKey) {            $cachedItem = $this->cache->getItem($cacheKey);            if ($cachedItem->isHit()) {                $this->logger->debug('Event search result served from cache', [                    'index' => $this->index,                    'cacheKey' => $cacheKey                ]);                return $cachedItem->get();            }        }        try {            $response = $this->client->search([                'index' => $this->index,                'body' => $query            ]);            // Mettre en cache            if ($cacheKey) {                $cachedItem->set($response);                $cachedItem->expiresAfter(300); // 5 minutes                $this->cache->save($cachedItem);            }            $this->logger->info('Event search executed', [                'index' => $this->index,                'hits' => $response['hits']['total']['value'],                'took' => $response['took']            ]);            return $response;        } catch (\Exception $e) {            $this->logger->error('Event search failed', [                'index' => $this->index,                'query' => $query,                'error' => $e->getMessage()            ]);            throw $e;        }    }    public function getEventById(string $eventId): ?array    {        try {            $response = $this->client->get([                'index' => $this->index,                'id' => $eventId            ]);            return $response['_source'];        } catch (\Elasticsearch\Common\Exceptions\Missing404Exception $e) {            return null;        } catch (\Exception $e) {            $this->logger->error('Failed to get event', [                'index' => $this->index,                'eventId' => $eventId,                'error' => $e->getMessage()            ]);            throw $e;        }    }    public function getEventsByAggregate(string $aggregateId, int $fromVersion = 0): array    {        $query = [            'query' => [                'bool' => [                    'must' => [                        ['term' => ['aggregateId' => $aggregateId]],                        ['range' => ['version' => ['gte' => $fromVersion]]]                    ]                ]            ],            'sort' => [['version' => ['order' => 'asc']]]        ];                $response = $this->searchEvents($query);                $events = [];        foreach ($response['hits']['hits'] as $hit) {            $events[] = $hit['_source'];        }                return $events;    }    public function getEventsByType(string $eventType, \DateTime $from = null, \DateTime $to = null): array    {        $query = [            'query' => [                'bool' => [                    'must' => [                        ['term' => ['eventType' => $eventType]]                    ]                ]            ],            'sort' => [['timestamp' => ['order' => 'desc']]]        ];                if ($from || $to) {            $range = [];            if ($from) {                $range['gte'] = $from->format('c');            }            if ($to) {                $range['lte'] = $to->format('c');            }                        $query['query']['bool']['must'][] = [                'range' => ['timestamp' => $range]            ];        }                $response = $this->searchEvents($query);                $events = [];        foreach ($response['hits']['hits'] as $hit) {            $events[] = $hit['_source'];        }                return $events;    }    public function getEventStatistics(string $eventType, \DateTime $from, \DateTime $to): array    {        $query = [            'query' => [                'bool' => [                    'must' => [                        ['term' => ['eventType' => $eventType]],                        ['range' => [                            'timestamp' => [                                'gte' => $from->format('c'),                                'lte' => $to->format('c')                            ]                        ]]                    ]                ]            ],            'aggs' => [                'by_hour' => [                    'date_histogram' => [                        'field' => 'timestamp',                        'calendar_interval' => 'hour'                    ]                ],                'by_organization' => [                    'terms' => [                        'field' => 'metadata.organizationId'                    ]                ],                'by_user' => [                    'terms' => [                        'field' => 'metadata.userId'                    ]                ]            ],            'size' => 0        ];                $cacheKey = "event_stats_{$eventType}_{$from->getTimestamp()}_{$to->getTimestamp()}";        $response = $this->searchEvents($query, $cacheKey);                return [            'total' => $response['hits']['total']['value'],            'by_hour' => $response['aggregations']['by_hour']['buckets'],            'by_organization' => $response['aggregations']['by_organization']['buckets'],            'by_user' => $response['aggregations']['by_user']['buckets']        ];    }}```#### **Query Handler pour les Événements**```php<?phpnamespace App\Application\Query\Payment;use App\Infrastructure\ElasticSearch\Query\EventSearchService;use App\Domain\Payment\Payment;use Psr\Log\LoggerInterface;class PaymentEventQueryHandler{    private EventSearchService $eventSearch;    private LoggerInterface $logger;    public function __construct(EventSearchService $eventSearch, LoggerInterface $logger)    {        $this->eventSearch = $eventSearch;        $this->logger = $logger;    }    public function handle(GetPaymentHistoryQuery $query): array    {        $events = $this->eventSearch->getEventsByAggregate($query->getPaymentId());                $history = [];        foreach ($events as $event) {            $history[] = [                'eventId' => $event['eventId'],                'eventType' => $event['eventType'],                'timestamp' => $event['timestamp'],                'data' => $event['eventData'],                'metadata' => $event['metadata']            ];        }                return $history;    }    public function handle(SearchPaymentEventsQuery $query): array    {        $searchQuery = [            'query' => [                'bool' => [                    'must' => [                        ['term' => ['aggregateType' => 'Payment']]                    ]                ]            ],            'sort' => [['timestamp' => ['order' => 'desc']]],            'from' => $query->getOffset(),            'size' => $query->getSize()        ];                if ($query->getEventType()) {            $searchQuery['query']['bool']['must'][] = [                'term' => ['eventType' => $query->getEventType()]            ];        }                if ($query->getSearchText()) {            $searchQuery['query']['bool']['must'][] = [                'multi_match' => [                    'query' => $query->getSearchText(),                    'fields' => ['eventData.*', 'metadata.*']                ]            ];        }                if ($query->getFrom() || $query->getTo()) {            $range = [];            if ($query->getFrom()) {                $range['gte'] = $query->getFrom()->format('c');            }            if ($query->getTo()) {                $range['lte'] = $query->getTo()->format('c');            }                        $searchQuery['query']['bool']['must'][] = [                'range' => ['timestamp' => $range]            ];        }                $cacheKey = 'payment_events_' . md5(serialize($query));        $response = $this->eventSearch->searchEvents($searchQuery, $cacheKey);                $results = [];        foreach ($response['hits']['hits'] as $hit) {            $results[] = [                'eventId' => $hit['_source']['eventId'],                'aggregateId' => $hit['_source']['aggregateId'],                'eventType' => $hit['_source']['eventType'],                'timestamp' => $hit['_source']['timestamp'],                'data' => $hit['_source']['eventData'],                'metadata' => $hit['_source']['metadata']            ];        }                return $results;    }    public function handle(GetPaymentEventStatisticsQuery $query): array    {        return $this->eventSearch->getEventStatistics(            $query->getEventType(),            $query->getFrom(),            $query->getTo()        );    }    public function handle(ReplayPaymentEventsQuery $query): Payment    {        $events = $this->eventSearch->getEventsByAggregate($query->getPaymentId());                // Reconstruire l'agrégat depuis les événements        $payment = PaymentAggregate::fromEvents($events);                return $payment->toPayment();    }}```### **3. Service d'Analytics Avancées**#### **Service d'Analytics des Événements**```php<?phpnamespace App\Application\Service\ElasticSearch;use App\Infrastructure\ElasticSearch\Query\EventSearchService;use Psr\Log\LoggerInterface;class EventAnalyticsService{    private EventSearchService $eventSearch;    private LoggerInterface $logger;    public function __construct(EventSearchService $eventSearch, LoggerInterface $logger)    {        $this->eventSearch = $eventSearch;        $this->logger = $logger;    }    public function getEventTrends(string $eventType, \DateTime $from, \DateTime $to, string $interval = 'day'): array    {        $query = [            'query' => [                'bool' => [                    'must' => [                        ['term' => ['eventType' => $eventType]],                        ['range' => [                            'timestamp' => [                                'gte' => $from->format('c'),                                'lte' => $to->format('c')                            ]                        ]]                    ]                ]            ],            'aggs' => [                'trends' => [                    'date_histogram' => [                        'field' => 'timestamp',                        'calendar_interval' => $interval                    ]                ]            ],            'size' => 0        ];                $cacheKey = "event_trends_{$eventType}_{$interval}_{$from->getTimestamp()}_{$to->getTimestamp()}";        $response = $this->eventSearch->searchEvents($query, $cacheKey);                $trends = [];        foreach ($response['aggregations']['trends']['buckets'] as $bucket) {            $trends[] = [                'date' => $bucket['key_as_string'],                'count' => $bucket['doc_count']            ];        }                return $trends;    }    public function getEventCorrelations(string $correlationId): array    {        $query = [            'query' => [                'term' => ['correlationId' => $correlationId]            ],            'sort' => [['timestamp' => ['order' => 'asc']]]        ];                $response = $this->eventSearch->searchEvents($query);                $correlations = [];        foreach ($response['hits']['hits'] as $hit) {            $correlations[] = [                'eventType' => $hit['_source']['eventType'],                'aggregateId' => $hit['_source']['aggregateId'],                'timestamp' => $hit['_source']['timestamp'],                'data' => $hit['_source']['eventData']            ];        }                return $correlations;    }    public function getEventHeatmap(string $eventType, \DateTime $from, \DateTime $to): array    {        $query = [            'query' => [                'bool' => [                    'must' => [                        ['term' => ['eventType' => $eventType]],                        ['range' => [                            'timestamp' => [                                'gte' => $from->format('c'),                                'lte' => $to->format('c')                            ]                        ]]                    ]                ]            ],            'aggs' => [                'by_hour' => [                    'date_histogram' => [                        'field' => 'timestamp',                        'calendar_interval' => 'hour'                    ]                ],                'by_day' => [                    'date_histogram' => [                        'field' => 'timestamp',                        'calendar_interval' => 'day'                    ]                ]            ],            'size' => 0        ];                $cacheKey = "event_heatmap_{$eventType}_{$from->getTimestamp()}_{$to->getTimestamp()}";        $response = $this->eventSearch->searchEvents($query, $cacheKey);                return [            'by_hour' => $response['aggregations']['by_hour']['buckets'],            'by_day' => $response['aggregations']['by_day']['buckets']        ];    }    public function searchEventData(string $searchText, array $filters = []): array    {        $query = [            'query' => [                'bool' => [                    'must' => [                        ['multi_match' => [                            'query' => $searchText,                            'fields' => ['eventData.*', 'metadata.*']                        ]]                    ]                ]            ],            'sort' => [['timestamp' => ['order' => 'desc']]]        ];                if (isset($filters['aggregateType'])) {            $query['query']['bool']['must'][] = [                'term' => ['aggregateType' => $filters['aggregateType']]            ];        }                if (isset($filters['eventType'])) {            $query['query']['bool']['must'][] = [                'term' => ['eventType' => $filters['eventType']]            ];        }                if (isset($filters['from']) || isset($filters['to'])) {            $range = [];            if (isset($filters['from'])) {                $range['gte'] = $filters['from']->format('c');            }            if (isset($filters['to'])) {                $range['lte'] = $filters['to']->format('c');            }                        $query['query']['bool']['must'][] = [                'range' => ['timestamp' => $range]            ];        }                $cacheKey = 'event_search_' . md5($searchText . serialize($filters));        $response = $this->eventSearch->searchEvents($query, $cacheKey);                $results = [];        foreach ($response['hits']['hits'] as $hit) {            $results[] = [                'eventId' => $hit['_source']['eventId'],                'aggregateId' => $hit['_source']['aggregateId'],                'eventType' => $hit['_source']['eventType'],                'timestamp' => $hit['_source']['timestamp'],                'data' => $hit['_source']['eventData'],                'metadata' => $hit['_source']['metadata']            ];        }                return $results;    }}```## 🧪 **Tests et Validation**### **Tests d'Intégration Event Sourcing + CQS**```php<?phpnamespace App\Tests\Integration\ElasticSearch;use App\Application\Command\Payment\ProcessPaymentCommand;use App\Application\Command\Payment\ProcessPaymentCommandHandler;use App\Application\Query\Payment\GetPaymentHistoryQuery;use App\Application\Query\Payment\PaymentEventQueryHandler;use App\Infrastructure\EventStore\ElasticSearchEventStore;use App\Infrastructure\ElasticSearch\Query\EventSearchService;use Elasticsearch\ClientBuilder;class ElasticSearchEventSourcingCqsTest extends TestCase{    private ElasticSearchEventStore $eventStore;    private EventSearchService $eventSearch;    private ProcessPaymentCommandHandler $commandHandler;    private PaymentEventQueryHandler $queryHandler;    protected function setUp(): void    {        $client = ClientBuilder::create()->setHosts(['localhost:9200'])->build();                $this->eventStore = new ElasticSearchEventStore($client, 'test-events', $this->createMock(LoggerInterface::class));        $this->eventSearch = new EventSearchService($client, 'test-events', $this->createMock(LoggerInterface::class), $this->createMock(CacheItemPoolInterface::class));                $this->commandHandler = new ProcessPaymentCommandHandler(            $this->eventStore,            $this->createMock(EventBusInterface::class),            $this->createMock(LoggerInterface::class)        );                $this->queryHandler = new PaymentEventQueryHandler($this->eventSearch, $this->createMock(LoggerInterface::class));    }    public function testEventSourcingCqsFlow(): void    {        // Exécuter une commande        $command = new ProcessPaymentCommand(            'payment-123',            100.00,            'EUR'        );                $this->commandHandler->handle($command);                // Vérifier l'historique des événements        $query = new GetPaymentHistoryQuery('payment-123');        $history = $this->queryHandler->handle($query);                $this->assertNotEmpty($history);        $this->assertCount(1, $history);        $this->assertEquals('PaymentProcessed', $history[0]['eventType']);    }    public function testEventSearchWithAnalytics(): void    {        // Créer plusieurs événements        $commands = [            new ProcessPaymentCommand('payment-1', 100.00, 'EUR'),            new ProcessPaymentCommand('payment-2', 200.00, 'USD'),            new ProcessPaymentCommand('payment-3', 300.00, 'EUR')        ];                foreach ($commands as $command) {            $this->commandHandler->handle($command);        }                // Rechercher les événements        $searchQuery = new SearchPaymentEventsQuery(            new \DateTime('2024-01-01'),            new \DateTime('2024-12-31')        );                $results = $this->queryHandler->handle($searchQuery);                $this->assertCount(3, $results);        $this->assertEquals('PaymentProcessed', $results[0]['eventType']);    }}```## 📊 **Performance et Optimisation**### **Stratégies d'Optimisation Event Sourcing + CQS**#### **1. Index Optimisés pour les Événements**```json{  "mappings": {    "properties": {      "eventId": { "type": "keyword" },      "aggregateId": { "type": "keyword" },      "aggregateType": { "type": "keyword" },      "eventType": { "type": "keyword" },      "eventData": { "type": "object" },      "version": { "type": "integer" },      "timestamp": { "type": "date" },      "correlationId": { "type": "keyword" },      "causationId": { "type": "keyword" },      "metadata": { "type": "object" }    }  },  "settings": {    "number_of_shards": 3,    "number_of_replicas": 1,    "refresh_interval": "30s"  }}```#### **2. Cache Multi-Niveaux**```phppublic function searchEventsWithCache(array $query, string $cacheKey = null): array{    // Cache L1: Mémoire    if (isset($this->memoryCache[$cacheKey])) {        return $this->memoryCache[$cacheKey];    }        // Cache L2: Redis    if ($cached = $this->redis->get("event_search:{$cacheKey}")) {        $result = json_decode($cached, true);        $this->memoryCache[$cacheKey] = $result;        return $result;    }        // ElasticSearch    $result = $this->searchEvents($query);        // Mettre en cache    $this->memoryCache[$cacheKey] = $result;    $this->redis->setex("event_search:{$cacheKey}", 300, json_encode($result));        return $result;}```#### **3. Bulk Operations Optimisées**```phppublic function appendEventsBulk(array $aggregateEvents): void{    $bulk = [];        foreach ($aggregateEvents as $aggregateId => $events) {        foreach ($events as $event) {            $bulk[] = [                'index' => [                    '_index' => $this->index,                    '_id' => $event->getId()                ]            ];            $bulk[] = $this->eventToDocument($event);        }    }        $this->client->bulk([        'body' => $bulk,        'refresh' => false    ]);}```## 🎯 **Critères d'Adoption**### **Quand Utiliser Event Sourcing + CQS avec ElasticSearch**#### **✅ Avantages**- **Audit trail complet** : Historique de tous les événements- **Performance optimisée** : Séparation claire entre écriture et lecture- **Recherche avancée** : Full-text search sur les événements- **Analytics temporelles** : Analyse des tendances dans le temps- **Scalabilité** : Possibilité de scaler indépendamment#### **❌ Inconvénients**- **Complexité élevée** : Architecture très complexe- **Stockage important** : Beaucoup d'espace disque nécessaire- **Performance** : Requêtes plus lentes sur de gros volumes- **Expertise** : Équipe très expérimentée requise#### **🎯 Critères d'Adoption**- **Audit trail critique** : Besoin de traçabilité complète- **Recherche avancée** : Besoin de rechercher dans les événements- **Analytics temporelles** : Besoin d'analyser les tendances- **Performance importante** : Besoins de performance élevée- **Équipe très expérimentée** : Maîtrise d'Event Sourcing, CQS et ElasticSearch- **Budget important** : Investissement en complexité justifié## 🚀 **Votre Prochaine Étape**{{< chapter-nav >}}  {{< chapter-option     letter="A"     color="green"     title="Je veux voir l'approche Event Sourcing + CQRS avec ElasticSearch"     subtitle="Vous voulez comprendre la combinaison complète Event Sourcing et CQRS"    criteria="Architecture maximale,Équipe très expérimentée,Performance critique,Scalabilité maximale"    time="45-60 minutes"    chapter="39"    chapter-title="Stockage ElasticSearch - Event Sourcing + CQRS"    chapter-url="/chapitres/stockage/elasticsearch/chapitre-39-stockage-elasticsearch-event-sourcing-cqrs/"  >}}    {{< chapter-option     letter="B"     color="yellow"     title="Je veux explorer les autres types de stockage"     subtitle="Vous voulez voir les alternatives à ElasticSearch"    criteria="Comparaison nécessaire,Choix de stockage,Architecture à définir,Performance à optimiser"    time="30-40 minutes"    chapter="10"    chapter-title="Choix du Type de Stockage"    chapter-url="/chapitres/fondamentaux/chapitre-10-choix-type-stockage/"  >}}    {{< chapter-option     letter="C"     color="blue"     title="Je veux voir des exemples concrets"     subtitle="Vous voulez comprendre les implémentations pratiques"    criteria="Développeur expérimenté,Besoin d'exemples pratiques,Implémentation à faire,Code à écrire"    time="Variable"    chapter="0"    chapter-title="Exemples et Implémentations"    chapter-url="/examples/"  >}}    {{< chapter-option     letter="D"     color="purple"     title="Je veux revenir aux fondamentaux"     subtitle="Vous voulez comprendre les concepts de base"    criteria="Développeur débutant,Besoin de comprendre les concepts,Projet à structurer,Équipe à former"    time="45-60 minutes"    chapter="1"    chapter-title="Introduction au Domain-Driven Design et Event Storming"    chapter-url="/chapitres/fondamentaux/chapitre-01-introduction-event-storming-ddd/"  >}}{{< /chapter-nav >}}---*Event Sourcing + CQS avec ElasticSearch offre une approche sophistiquée pour l'audit trail et la recherche avancée, parfaitement adaptée aux besoins les plus exigeants de Gyroscops.*