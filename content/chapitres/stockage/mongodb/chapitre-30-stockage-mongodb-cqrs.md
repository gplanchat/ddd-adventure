---
title: "Chapitre 30 : Stockage MongoDB - Approche CQRS"
weight: 30
draft: true
---
## üéØ **Objectif de ce Chapitre**Dans ce chapitre, vous allez d√©couvrir comment impl√©menter CQRS (Command Query Responsibility Segregation) avec MongoDB, en s√©parant compl√®tement les mod√®les de lecture et d'√©criture pour une architecture distribu√©e et √©volutive.## üìñ **Mon Exp√©rience avec Gyroscops**Avec Gyroscops, nous avions atteint les limites de l'approche CQS classique. Nos √©quipes de d√©veloppement et d'analytics avaient des besoins compl√®tement diff√©rents, et nous avions besoin d'une s√©paration plus radicale.### **Le Probl√®me avec CQS**Notre collection `billing_queries` √©tait devenue un monstre :- Structure complexe pour satisfaire tous les cas d'usage- Index contradictoires entre les √©quipes- Performance d√©grad√©e par la polyvalence### **La R√©volution CQRS**J'ai d√©couvert que CQRS permettait de cr√©er des mod√®les compl√®tement diff√©rents :- **Mod√®le de commande** : Optimis√© pour les √©critures- **Mod√®les de requ√™te** : Sp√©cialis√©s par cas d'usage- **D√©couplage total** : √âquipes ind√©pendantes## üèóÔ∏è **Architecture CQRS avec MongoDB**### **S√©paration Compl√®te des Mod√®les**```javascript// Mod√®le de commande (√©criture)const InvoiceCommand = {  _id: ObjectId(),  type: "CreateInvoice",  aggregateId: "invoice_123",  data: {    customerId: "cust_456",    amount: 1500.00,    currency: "EUR",    items: [      { description: "Cloud Resources", amount: 1200.00 },      { description: "Support", amount: 300.00 }    ]  },  timestamp: new Date(),  version: 1,  metadata: {    userId: "user_789",    correlationId: "corr_abc"  }};// Mod√®le de requ√™te - Vue facturationconst InvoiceBillingView = {  _id: "invoice_123",  invoiceNumber: "INV-2024-001",  customer: {    id: "cust_456",    name: "Acme Corp",    billingAddress: "123 Main St, Paris"  },  totalAmount: 1500.00,  currency: "EUR",  status: "pending",  dueDate: new Date("2024-02-15"),  createdAt: new Date()};// Mod√®le de requ√™te - Vue analyticsconst InvoiceAnalyticsView = {  _id: "invoice_123",  customerSegment: "enterprise",  revenue: 1500.00,  currency: "EUR",  month: "2024-01",  region: "europe",  productCategory: "cloud",  createdAt: new Date()};```### **Collections Sp√©cialis√©es**```javascript// Collection de commandesdb.invoice_commands.createIndex({ "aggregateId": 1, "version": 1 });db.invoice_commands.createIndex({ "timestamp": 1 });db.invoice_commands.createIndex({ "type": 1 });// Collection de vues facturationdb.invoice_billing_views.createIndex({ "customer.id": 1, "status": 1 });db.invoice_billing_views.createIndex({ "dueDate": 1 });db.invoice_billing_views.createIndex({ "createdAt": -1 });// Collection de vues analyticsdb.invoice_analytics_views.createIndex({ "customerSegment": 1, "month": 1 });db.invoice_analytics_views.createIndex({ "region": 1, "productCategory": 1 });db.invoice_analytics_views.createIndex({ "revenue": -1 });```## üîÑ **Projection des Vues**### **Projection en Temps R√©el**```javascript// Change Stream pour les commandesconst changeStream = db.invoice_commands.watch([  { $match: { "operationType": "insert" } }]);changeStream.on('change', async (change) => {  const command = change.fullDocument;    try {    // Projeter vers la vue facturation    await projectToBillingView(command);        // Projeter vers la vue analytics    await projectToAnalyticsView(command);        console.log(`Command ${command._id} projected successfully`);  } catch (error) {    console.error(`Projection failed for command ${command._id}:`, error);    // G√©rer l'erreur (retry, dead letter queue, etc.)  }});```### **Projection vers la Vue Facturation**```javascriptasync function projectToBillingView(command) {  const invoiceData = command.data;    // Enrichir les donn√©es client  const customer = await db.customers.findOne({ _id: invoiceData.customerId });    // Cr√©er la vue facturation  const billingView = {    _id: command.aggregateId,    invoiceNumber: generateInvoiceNumber(command),    customer: {      id: customer._id,      name: customer.name,      billingAddress: customer.billingAddress    },    totalAmount: invoiceData.amount,    currency: invoiceData.currency,    status: "pending",    dueDate: calculateDueDate(command.timestamp),    createdAt: command.timestamp  };    await db.invoice_billing_views.replaceOne(    { _id: command.aggregateId },    billingView,    { upsert: true }  );}```### **Projection vers la Vue Analytics**```javascriptasync function projectToAnalyticsView(command) {  const invoiceData = command.data;    // Enrichir les donn√©es analytics  const customer = await db.customers.findOne({ _id: invoiceData.customerId });  const customerSegment = determineCustomerSegment(customer);    // Cr√©er la vue analytics  const analyticsView = {    _id: command.aggregateId,    customerSegment: customerSegment,    revenue: invoiceData.amount,    currency: invoiceData.currency,    month: formatMonth(command.timestamp),    region: customer.region,    productCategory: determineProductCategory(invoiceData.items),    createdAt: command.timestamp  };    await db.invoice_analytics_views.replaceOne(    { _id: command.aggregateId },    analyticsView,    { upsert: true }  );}```## üìä **Avantages de CQRS avec MongoDB**### **Performance Optimis√©e par Cas d'Usage**```javascript// Requ√™te facturation ultra-rapideconst pendingInvoices = await db.invoice_billing_views.find({  "customer.id": "cust_456",  "status": "pending"}).sort({ "dueDate": 1 });// Requ√™te analytics complexeconst monthlyRevenue = await db.invoice_analytics_views.aggregate([  { $match: { "month": "2024-01", "region": "europe" } },  { $group: { _id: "$customerSegment", totalRevenue: { $sum: "$revenue" } } },  { $sort: { totalRevenue: -1 } }]);```### **√âvolutivit√© Horizontale**```javascript// Sharding par domaine m√©tiersh.shardCollection("gyroscops.invoice_commands", { "type": 1 });sh.shardCollection("gyroscops.invoice_billing_views", { "customer.id": 1 });sh.shardCollection("gyroscops.invoice_analytics_views", { "month": 1 });```### **D√©couplage des √âquipes**```javascript// √âquipe facturation - Mod√®le simpleconst BillingService = {  async getPendingInvoices(customerId) {    return await db.invoice_billing_views.find({      "customer.id": customerId,      "status": "pending"    });  }};// √âquipe analytics - Mod√®le complexeconst AnalyticsService = {  async getRevenueBySegment(month, region) {    return await db.invoice_analytics_views.aggregate([      { $match: { month, region } },      { $group: { _id: "$customerSegment", revenue: { $sum: "$revenue" } } }    ]);  }};```## ‚ö†Ô∏è **D√©fis et Solutions**### **Coh√©rence √âventuelle**```javascript// V√©rification de coh√©rence entre vuesasync function checkViewConsistency(aggregateId) {  const command = await db.invoice_commands.findOne({ aggregateId });  const billingView = await db.invoice_billing_views.findOne({ _id: aggregateId });  const analyticsView = await db.invoice_analytics_views.findOne({ _id: aggregateId });    if (!command || !billingView || !analyticsView) {    throw new Error(`Inconsistent views for aggregate ${aggregateId}`);  }    return { command, billingView, analyticsView };}```### **Gestion des Erreurs de Projection**```javascript// Dead Letter Queue pour les √©checs de projectionasync function handleProjectionFailure(command, error) {  await db.projection_failures.insertOne({    commandId: command._id,    aggregateId: command.aggregateId,    error: error.message,    timestamp: new Date(),    retryCount: 0  });    // Notifier l'√©quipe de monitoring  await notifyMonitoringTeam(command, error);}```### **Replay des Projections**```javascript// Replay des projections en cas d'erreurasync function replayProjections(fromTimestamp) {  const commands = await db.invoice_commands.find({    timestamp: { $gte: fromTimestamp }  }).sort({ timestamp: 1 });    for (const command of commands) {    try {      await projectToBillingView(command);      await projectToAnalyticsView(command);    } catch (error) {      console.error(`Replay failed for command ${command._id}:`, error);    }  }}```## üéØ **Crit√®res d'Adoption**### **Quand Utiliser CQRS avec MongoDB**- ‚úÖ **√âquipes multiples** : D√©veloppement, analytics, facturation- ‚úÖ **Cas d'usage tr√®s diff√©rents** : Lectures complexes vs √©critures simples- ‚úÖ **Performance critique** : Latence < 50ms requise- ‚úÖ **√âvolutivit√© maximale** : Croissance > 100x pr√©vue### **Quand √âviter CQRS avec MongoDB**- ‚ùå **√âquipe unique** : Pas de s√©paration des responsabilit√©s- ‚ùå **Application simple** : Cas d'usage uniformes- ‚ùå **Coh√©rence forte requise** : Donn√©es financi√®res critiques- ‚ùå **Budget limit√©** : Complexit√© non justifi√©e## üìà **M√©triques de Succ√®s**### **Performance par Vue**```javascriptconst performanceMetrics = {  billingView: {    readLatency: "< 30ms",    writeLatency: "< 100ms",    throughput: "> 20k ops/sec"  },  analyticsView: {    readLatency: "< 100ms",    writeLatency: "< 200ms",    throughput: "> 5k ops/sec"  }};```### **Monitoring des Projections**```javascriptconst projectionMetrics = {  successRate: "> 99.9%",  averageLag: "< 1 second",  errorRate: "< 0.1%",  replayTime: "< 5 minutes"};```## üîÑ **Migration depuis CQS**### **√âtape 1 : Cr√©er les Nouvelles Collections**```javascript// Cr√©er les collections CQRSdb.createCollection("invoice_commands");db.createCollection("invoice_billing_views");db.createCollection("invoice_analytics_views");```### **√âtape 2 : Migrer les Donn√©es Existantes**```javascript// Migration des donn√©es CQS vers CQRSasync function migrateFromCQS() {  const existingQueries = await db.billing_queries.find({});    for (const query of existingQueries) {    // Cr√©er la commande    await db.invoice_commands.insertOne({      type: "migration",      aggregateId: query._id,      data: query,      timestamp: new Date(),      version: 1    });        // Projeter vers les vues    await projectToBillingView({ aggregateId: query._id, data: query });    await projectToAnalyticsView({ aggregateId: query._id, data: query });  }}```### **√âtape 3 : Basculer Progressivement**```javascript// Feature flag pour basculer vers CQRSconst useCQRS = await getFeatureFlag("mongodb_cqrs_enabled");if (useCQRS) {  // Utiliser les vues CQRS  return await queryFromCQRSViews();} else {  // Utiliser l'ancienne collection CQS  return await queryFromCQSCollection();}```## üí° **Conseils Pratiques**### **Design des Vues**1. **Vue facturation** : Structure simple, optimis√©e pour les requ√™tes m√©tier2. **Vue analytics** : Structure complexe, optimis√©e pour les agr√©gations3. **Index sp√©cialis√©s** : Diff√©rents pour chaque vue4. **Sharding** : Strat√©gies diff√©rentes selon l'usage### **Monitoring et Alertes**1. **Lag de projection** : < 1 seconde2. **Taux d'erreur** : < 0.1%3. **Performance** : Latence < 50ms4. **Coh√©rence** : V√©rification quotidienne## üéØ **Votre Prochaine √âtape**Maintenant que vous comprenez l'approche CQRS avec MongoDB, quelle est votre situation ?{{< chapter-nav >}}  {{< chapter-option     letter="A"     color="green"     title="Je veux comprendre l'approche Event Sourcing"     subtitle="Vous voulez voir comment stocker les √©v√©nements"    criteria="Audit trail critique,Debugging complexe,√âquipe tr√®s exp√©riment√©e,Budget important"    time="40-50 minutes"    chapter="31"    chapter-title="Stockage MongoDB - Event Sourcing"    chapter-url="/chapitres/stockage/mongodb/chapitre-31-stockage-mongodb-event-sourcing/"  >}}    {{< chapter-option     letter="B"     color="yellow"     title="Je veux voir CQRS + Event Sourcing"     subtitle="Vous voulez combiner les deux approches"    criteria="Audit trail critique,Debugging complexe,√âquipe tr√®s exp√©riment√©e,Budget important"    time="45-55 minutes"    chapter="32"    chapter-title="Stockage MongoDB - CQRS + Event Sourcing"    chapter-url="/chapitres/stockage/mongodb/chapitre-32-stockage-mongodb-cqrs-event-sourcing/"  >}}    {{< chapter-option     letter="C"     color="red"     title="Je veux revenir √† l'approche CQS"     subtitle="Vous voulez une approche plus simple"    criteria="√âquipe exp√©riment√©e,Besoin d'optimiser les performances,S√©paration des responsabilit√©s importante,√âvolutivit√© importante"    time="30-40 minutes"    chapter="29"    chapter-title="Stockage MongoDB - Approche CQS"    chapter-url="/chapitres/stockage/mongodb/chapitre-29-stockage-mongodb-cqs/"  >}}    {{< chapter-option     letter="D"     color="blue"     title="Je veux explorer d'autres types de stockage"     subtitle="Vous voulez voir les alternatives √† MongoDB"    criteria="Besoin de comparer les options,Choix de stockage √† faire,√âquipe en r√©flexion"    time="30-40 minutes"    chapter="10"    chapter-title="Choix du Type de Stockage"    chapter-url="/chapitres/fondamentaux/chapitre-10-choix-type-stockage/"  >}}{{< /chapter-nav >}}**üí° Conseil** : Si vous n'√™tes pas s√ªr, commencez par l'approche CQS (option C) pour bien comprendre la s√©paration des responsabilit√©s, puis revenez √† CQRS quand vous serez pr√™t.**üîÑ Alternative** : Si vous voulez tout voir dans l'ordre, continuez avec l'approche Event Sourcing (option A).