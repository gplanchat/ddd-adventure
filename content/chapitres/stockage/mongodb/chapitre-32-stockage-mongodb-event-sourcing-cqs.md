---
title: "Stockage MongoDB - Event Sourcing + CQS"
description: "Impl√©mentation Event Sourcing avec CQS pour MongoDB, optimisant les performances et la scalabilit√©"
date: 2024-12-19
draft: true
type: "docs"
weight: 32
---
## üéØ **Contexte et Objectifs**### **Pourquoi Event Sourcing + CQS avec MongoDB ?**Apr√®s avoir explor√© l'Event Sourcing pur avec MongoDB, nous allons maintenant combiner cette approche avec le **Command Query Separation (CQS)** pour optimiser les performances et la scalabilit√©.#### **Avantages de cette Combinaison**- **Performance optimis√©e** : S√©paration claire entre √©criture et lecture- **Scalabilit√©** : Possibilit√© de scaler ind√©pendamment les commandes et requ√™tes- **Flexibilit√©** : Projections multiples pour diff√©rents besoins- **Audit trail** : Historique complet des √©v√©nements### **Contexte Gyroscops**Dans notre √©cosyst√®me **User ‚Üí Organization ‚Üí Workflow ‚Üí Cloud Resources ‚Üí Billing**, cette approche est particuli√®rement pertinente pour :- **Gestion des factures** : Audit trail complet des modifications- **Workflows complexes** : √âv√©nements de progression et d'√©tat- **Ressources cloud** : Historique des changements d'infrastructure## üèóÔ∏è **Architecture Event Sourcing + CQS**### **S√©paration des Responsabilit√©s**#### **C√¥t√© Commande (Write)**- **Event Store** : Stockage des √©v√©nements dans MongoDB- **Command Handlers** : Traitement des commandes m√©tier- **Event Handlers** : Gestion des √©v√©nements g√©n√©r√©s- **Aggregates** : Logique m√©tier et invariants#### **C√¥t√© Requ√™te (Read)**- **Projections** : Vues optimis√©es pour la lecture- **Query Handlers** : Traitement des requ√™tes- **Read Models** : Mod√®les optimis√©s pour l'affichage- **Caches** : Optimisation des performances### **Flux de Donn√©es**```mermaidgraph TD    A[Command] --> B[Command Handler]    B --> C[Aggregate]    C --> D[Events]    D --> E[Event Store MongoDB]    D --> F[Event Handlers]    F --> G[Projections]    G --> H[Read Models]    H --> I[Query Handler]    I --> J[Response]        K[Query] --> I```## üíª **Impl√©mentation Pratique**### **1. Event Store MongoDB**#### **Structure des Collections**```javascript// Collection: events{  _id: ObjectId("..."),  aggregateId: "payment-123",  aggregateType: "Payment",  eventType: "PaymentProcessed",  eventData: {    amount: 100.00,    currency: "EUR",    status: "completed"  },  version: 1,  timestamp: ISODate("2024-12-19T10:00:00Z"),  metadata: {    userId: "user-456",    organizationId: "org-789"  }}// Collection: snapshots{  _id: ObjectId("..."),  aggregateId: "payment-123",  aggregateType: "Payment",  data: {    amount: 100.00,    currency: "EUR",    status: "completed",    processedAt: ISODate("2024-12-19T10:00:00Z")  },  version: 1,  timestamp: ISODate("2024-12-19T10:00:00Z")}```#### **Index MongoDB**```javascript// Index pour les √©v√©nementsdb.events.createIndex({ aggregateId: 1, version: 1 })db.events.createIndex({ aggregateType: 1, timestamp: 1 })db.events.createIndex({ eventType: 1, timestamp: 1 })// Index pour les snapshotsdb.snapshots.createIndex({ aggregateId: 1 })db.snapshots.createIndex({ aggregateType: 1, timestamp: 1 })```### **2. Command Side Implementation**#### **Event Store Repository**```php<?phpnamespace App\Infrastructure\EventStore;use MongoDB\Client;use MongoDB\Collection;use App\Domain\Event\DomainEvent;use App\Domain\Event\EventStoreInterface;class MongoEventStore implements EventStoreInterface{    private Collection $events;    private Collection $snapshots;    public function __construct(Client $mongoClient)    {        $this->events = $mongoClient->selectCollection('Gyroscops Cloud', 'events');        $this->snapshots = $mongoClient->selectCollection('Gyroscops Cloud', 'snapshots');    }    public function appendEvents(string $aggregateId, array $events, int $expectedVersion): void    {        $session = $this->events->getDatabase()->getClient()->startSession();                try {            $session->startTransaction();                        // V√©rifier la version attendue            $lastEvent = $this->events->findOne(                ['aggregateId' => $aggregateId],                ['sort' => ['version' => -1]]            );                        if ($lastEvent && $lastEvent['version'] !== $expectedVersion) {                throw new ConcurrencyException('Version mismatch');            }                        // Ins√©rer les nouveaux √©v√©nements            $documents = [];            $version = $expectedVersion + 1;                        foreach ($events as $event) {                $documents[] = [                    'aggregateId' => $aggregateId,                    'aggregateType' => $event->getAggregateType(),                    'eventType' => $event->getEventType(),                    'eventData' => $event->toArray(),                    'version' => $version++,                    'timestamp' => new \MongoDB\BSON\UTCDateTime(),                    'metadata' => $event->getMetadata()                ];            }                        $this->events->insertMany($documents);            $session->commitTransaction();                    } catch (\Exception $e) {            $session->abortTransaction();            throw $e;        }    }    public function getEvents(string $aggregateId, int $fromVersion = 0): array    {        $cursor = $this->events->find(            [                'aggregateId' => $aggregateId,                'version' => ['$gte' => $fromVersion]            ],            ['sort' => ['version' => 1]]        );                $events = [];        foreach ($cursor as $document) {            $events[] = $this->deserializeEvent($document);        }                return $events;    }    private function deserializeEvent(array $document): DomainEvent    {        $eventClass = $document['eventType'];        return $eventClass::fromArray($document['eventData']);    }}```#### **Command Handler**```php<?phpnamespace App\Application\Command\Payment;use App\Domain\Payment\PaymentAggregate;use App\Domain\Event\EventStoreInterface;use App\Domain\Payment\PaymentRepositoryInterface;class ProcessPaymentCommandHandler{    public function __construct(        private EventStoreInterface $eventStore,        private PaymentRepositoryInterface $paymentRepository    ) {}    public function handle(ProcessPaymentCommand $command): void    {        // Charger l'agr√©gat        $events = $this->eventStore->getEvents($command->getPaymentId());        $payment = PaymentAggregate::fromEvents($events);                // Ex√©cuter la commande        $payment->processPayment($command->getAmount(), $command->getCurrency());                // Sauvegarder les √©v√©nements        $this->eventStore->appendEvents(            $command->getPaymentId(),            $payment->getUncommittedEvents(),            $payment->getVersion()        );                // Nettoyer les √©v√©nements non commit√©s        $payment->markEventsAsCommitted();    }}```### **3. Query Side Implementation**#### **Projection Handler**```php<?phpnamespace App\Application\Projection\Payment;use App\Domain\Event\DomainEvent;use App\Infrastructure\ReadModel\PaymentReadModel;use MongoDB\Client;class PaymentProjectionHandler{    private \MongoDB\Collection $readModel;    public function __construct(Client $mongoClient)    {        $this->readModel = $mongoClient->selectCollection('Gyroscops Cloud', 'payment_read_models');    }    public function handle(DomainEvent $event): void    {        switch ($event->getEventType()) {            case 'PaymentProcessed':                $this->handlePaymentProcessed($event);                break;            case 'PaymentFailed':                $this->handlePaymentFailed($event);                break;        }    }    private function handlePaymentProcessed(DomainEvent $event): void    {        $this->readModel->updateOne(            ['paymentId' => $event->getAggregateId()],            [                '$set' => [                    'paymentId' => $event->getAggregateId(),                    'amount' => $event->getData()['amount'],                    'currency' => $event->getData()['currency'],                    'status' => 'completed',                    'processedAt' => $event->getTimestamp(),                    'updatedAt' => new \MongoDB\BSON\UTCDateTime()                ]            ],            ['upsert' => true]        );    }    private function handlePaymentFailed(DomainEvent $event): void    {        $this->readModel->updateOne(            ['paymentId' => $event->getAggregateId()],            [                '$set' => [                    'status' => 'failed',                    'error' => $event->getData()['error'],                    'updatedAt' => new \MongoDB\BSON\UTCDateTime()                ]            ],            ['upsert' => true]        );    }}```#### **Query Handler**```php<?phpnamespace App\Application\Query\Payment;use App\Infrastructure\ReadModel\PaymentReadModel;use MongoDB\Client;class PaymentQueryHandler{    private \MongoDB\Collection $readModel;    public function __construct(Client $mongoClient)    {        $this->readModel = $mongoClient->selectCollection('Gyroscops Cloud', 'payment_read_models');    }    public function getPaymentById(string $paymentId): ?PaymentReadModel    {        $document = $this->readModel->findOne(['paymentId' => $paymentId]);                if (!$document) {            return null;        }                return PaymentReadModel::fromArray($document);    }    public function getPaymentsByOrganization(string $organizationId, int $limit = 50, int $offset = 0): array    {        $cursor = $this->readModel->find(            ['organizationId' => $organizationId],            [                'sort' => ['processedAt' => -1],                'limit' => $limit,                'skip' => $offset            ]        );                $payments = [];        foreach ($cursor as $document) {            $payments[] = PaymentReadModel::fromArray($document);        }                return $payments;    }    public function getPaymentStatistics(string $organizationId, \DateTime $from, \DateTime $to): array    {        $pipeline = [            [                '$match' => [                    'organizationId' => $organizationId,                    'processedAt' => [                        '$gte' => new \MongoDB\BSON\UTCDateTime($from),                        '$lte' => new \MongoDB\BSON\UTCDateTime($to)                    ]                ]            ],            [                '$group' => [                    '_id' => '$status',                    'count' => ['$sum' => 1],                    'totalAmount' => ['$sum' => '$amount']                ]            ]        ];                $cursor = $this->readModel->aggregate($pipeline);                $statistics = [];        foreach ($cursor as $document) {            $statistics[$document['_id']] = [                'count' => $document['count'],                'totalAmount' => $document['totalAmount']            ];        }                return $statistics;    }}```## üß™ **Tests et Validation**### **Tests Unitaires**```php<?phpnamespace App\Tests\Infrastructure\EventStore;use PHPUnit\Framework\TestCase;use App\Infrastructure\EventStore\MongoEventStore;use App\Domain\Payment\PaymentProcessedEvent;class MongoEventStoreTest extends TestCase{    private MongoEventStore $eventStore;    private \MongoDB\Client $mongoClient;    protected function setUp(): void    {        $this->mongoClient = new \MongoDB\Client('mongodb://localhost:27017');        $this->eventStore = new MongoEventStore($this->mongoClient);                // Nettoyer les collections de test        $this->mongoClient->selectCollection('test', 'events')->drop();        $this->mongoClient->selectCollection('test', 'snapshots')->drop();    }    public function testAppendEvents(): void    {        $paymentId = 'payment-123';        $event = new PaymentProcessedEvent($paymentId, 100.00, 'EUR');                $this->eventStore->appendEvents($paymentId, [$event], 0);                $events = $this->eventStore->getEvents($paymentId);        $this->assertCount(1, $events);        $this->assertInstanceOf(PaymentProcessedEvent::class, $events[0]);    }    public function testConcurrencyControl(): void    {        $paymentId = 'payment-123';        $event1 = new PaymentProcessedEvent($paymentId, 100.00, 'EUR');        $event2 = new PaymentProcessedEvent($paymentId, 200.00, 'EUR');                // Premier append        $this->eventStore->appendEvents($paymentId, [$event1], 0);                // Tentative de concourrence        $this->expectException(ConcurrencyException::class);        $this->eventStore->appendEvents($paymentId, [$event2], 0);    }}```### **Tests d'Int√©gration**```php<?phpnamespace App\Tests\Integration\Payment;use App\Application\Command\Payment\ProcessPaymentCommand;use App\Application\Command\Payment\ProcessPaymentCommandHandler;use App\Application\Query\Payment\PaymentQueryHandler;use App\Infrastructure\EventStore\MongoEventStore;use MongoDB\Client;class PaymentEventSourcingCqsTest extends TestCase{    public function testCompletePaymentFlow(): void    {        $mongoClient = new Client('mongodb://localhost:27017');        $eventStore = new MongoEventStore($mongoClient);                $commandHandler = new ProcessPaymentCommandHandler($eventStore, $this->createMock(PaymentRepositoryInterface::class));        $queryHandler = new PaymentQueryHandler($mongoClient);                // Ex√©cuter la commande        $command = new ProcessPaymentCommand('payment-123', 100.00, 'EUR');        $commandHandler->handle($command);                // V√©rifier la requ√™te        $payment = $queryHandler->getPaymentById('payment-123');        $this->assertNotNull($payment);        $this->assertEquals(100.00, $payment->getAmount());        $this->assertEquals('EUR', $payment->getCurrency());        $this->assertEquals('completed', $payment->getStatus());    }}```## üìä **Performance et Optimisation**### **Strat√©gies d'Optimisation**#### **1. Index MongoDB**```javascript// Index compos√©s pour les requ√™tes fr√©quentesdb.events.createIndex({ aggregateType: 1, timestamp: -1 })db.events.createIndex({ eventType: 1, aggregateId: 1 })db.payment_read_models.createIndex({ organizationId: 1, processedAt: -1 })db.payment_read_models.createIndex({ status: 1, processedAt: -1 })```#### **2. Snapshots**```phppublic function createSnapshot(string $aggregateId, int $version): void{    $events = $this->getEvents($aggregateId, 0);    $aggregate = PaymentAggregate::fromEvents($events);        $this->snapshots->replaceOne(        ['aggregateId' => $aggregateId],        [            'aggregateId' => $aggregateId,            'aggregateType' => 'Payment',            'data' => $aggregate->toSnapshot(),            'version' => $version,            'timestamp' => new \MongoDB\BSON\UTCDateTime()        ],        ['upsert' => true]    );}```#### **3. Projections Asynchrones**```phppublic function handleEventAsync(DomainEvent $event): void{    // Mettre en queue pour traitement asynchrone    $this->messageBus->dispatch(new ProcessProjectionCommand($event));}```## üéØ **Crit√®res d'Adoption**### **Quand Utiliser Event Sourcing + CQS avec MongoDB**#### **‚úÖ Avantages**- **Audit trail complet** : Historique de tous les changements- **Performance optimis√©e** : S√©paration lecture/√©criture- **Scalabilit√©** : Possibilit√© de scaler ind√©pendamment- **Flexibilit√©** : Projections multiples pour diff√©rents besoins- **Debugging** : Possibilit√© de rejouer les √©v√©nements#### **‚ùå Inconv√©nients**- **Complexit√©** : Architecture plus complexe- **Latence** : D√©lai entre √©criture et lecture- **Stockage** : Plus d'espace disque n√©cessaire- **Expertise** : √âquipe exp√©riment√©e requise#### **üéØ Crit√®res d'Adoption**- **Audit trail critique** : Besoin de tra√ßabilit√© compl√®te- **Performance importante** : Lectures et √©critures tr√®s diff√©rentes- **√âquipe exp√©riment√©e** : Ma√Ætrise des patterns avanc√©s- **Budget important** : Investissement en complexit√© justifi√©- **√âvolutivit√©** : Besoin de scaler ind√©pendamment## üöÄ **Votre Prochaine √âtape**{{< chapter-nav >}}  {{< chapter-option     letter="A"     color="green"     title="Je veux voir l'impl√©mentation Event Sourcing + CQRS compl√®te"     subtitle="Vous voulez comprendre l'approche la plus avanc√©e avec CQRS"    criteria="√âquipe tr√®s exp√©riment√©e,Architecture complexe,Performance critique,Audit trail complet"    time="45-60 minutes"    chapter="33"    chapter-title="Stockage MongoDB - Event Sourcing + CQRS"    chapter-url="/chapitres/stockage/mongodb/chapitre-33-stockage-mongodb-event-sourcing-cqrs/"  >}}    {{< chapter-option     letter="B"     color="yellow"     title="Je veux explorer les autres types de stockage"     subtitle="Vous voulez voir les alternatives √† MongoDB"    criteria="Comparaison n√©cessaire,Choix de stockage,Architecture √† d√©finir,Performance √† optimiser"    time="30-40 minutes"    chapter="10"    chapter-title="Choix du Type de Stockage"    chapter-url="/chapitres/fondamentaux/chapitre-10-choix-type-stockage/"  >}}    {{< chapter-option     letter="C"     color="blue"     title="Je veux voir des exemples concrets"     subtitle="Vous voulez comprendre les impl√©mentations pratiques"    criteria="D√©veloppeur exp√©riment√©,Besoin d'exemples pratiques,Impl√©mentation √† faire,Code √† √©crire"    time="Variable"    chapter="0"    chapter-title="Exemples et Impl√©mentations"    chapter-url="/examples/"  >}}    {{< chapter-option     letter="D"     color="purple"     title="Je veux revenir aux fondamentaux"     subtitle="Vous voulez comprendre les concepts de base"    criteria="D√©veloppeur d√©butant,Besoin de comprendre les concepts,Projet √† structurer,√âquipe √† former"    time="45-60 minutes"    chapter="1"    chapter-title="Introduction au Domain-Driven Design et Event Storming"    chapter-url="/chapitres/fondamentaux/chapitre-01-introduction-event-storming-ddd/"  >}}{{< /chapter-nav >}}---*Cette approche Event Sourcing + CQS avec MongoDB offre un √©quilibre optimal entre performance, scalabilit√© et audit trail, parfaitement adapt√© aux besoins complexes de Gyroscops.*