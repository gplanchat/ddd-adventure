---
title: "Chapitre 31 : Stockage MongoDB - Event Sourcing"
weight: 31
draft: true
---

# Chapitre 31 : Stockage MongoDB - Event Sourcing

## üéØ **Objectif de ce Chapitre**

Dans ce chapitre, vous allez d√©couvrir comment impl√©menter Event Sourcing avec MongoDB, en stockant les √©v√©nements comme source de v√©rit√© et en reconstruisant l'√©tat √† partir de ces √©v√©nements.

## üìñ **Mon Exp√©rience avec Gyroscops**

Avec Gyroscops, nous avions un besoin critique d'audit trail pour nos donn√©es financi√®res. Les r√©gulateurs exigeaient de pouvoir tracer chaque modification, et nous avions besoin de comprendre l'historique complet des transactions.

### **Le Probl√®me avec l'√âtat Actuel**

Notre collection `billing_documents` ne gardait que l'√©tat final :
- Impossible de savoir qui avait modifi√© quoi et quand
- Pas de possibilit√© de "rejouer" l'historique
- Audit trail incomplet pour la conformit√©

### **La R√©volution Event Sourcing**

J'ai d√©couvert qu'Event Sourcing permettait de stocker l'historique complet :
- **√âv√©nements immutables** : Chaque changement est un √©v√©nement
- **Audit trail complet** : Tra√ßabilit√© totale
- **Replay possible** : Reconstruction de l'√©tat √† tout moment

## üèóÔ∏è **Architecture Event Sourcing avec MongoDB**

### **Stockage des √âv√©nements**

```javascript
// √âv√©nement de cr√©ation de facture
const InvoiceCreatedEvent = {
  _id: ObjectId(),
  aggregateId: "invoice_123",
  aggregateType: "Invoice",
  eventType: "InvoiceCreated",
  eventVersion: 1,
  eventData: {
    invoiceNumber: "INV-2024-001",
    customerId: "cust_456",
    amount: 1500.00,
    currency: "EUR",
    items: [
      { description: "Cloud Resources", amount: 1200.00 },
      { description: "Support", amount: 300.00 }
    ]
  },
  metadata: {
    userId: "user_789",
    correlationId: "corr_abc",
    causationId: "cause_def"
  },
  timestamp: new Date(),
  sequenceNumber: 1
};

// √âv√©nement de paiement
const InvoicePaidEvent = {
  _id: ObjectId(),
  aggregateId: "invoice_123",
  aggregateType: "Invoice",
  eventType: "InvoicePaid",
  eventVersion: 1,
  eventData: {
    paymentId: "pay_789",
    paymentMethod: "credit_card",
    paidAmount: 1500.00,
    paidAt: new Date()
  },
  metadata: {
    userId: "user_789",
    correlationId: "corr_abc",
    causationId: "cause_ghi"
  },
  timestamp: new Date(),
  sequenceNumber: 2
};
```

### **Index Optimis√©s pour Event Sourcing**

```javascript
// Index pour les requ√™tes par agr√©gat
db.events.createIndex({ "aggregateId": 1, "sequenceNumber": 1 });
db.events.createIndex({ "aggregateId": 1, "eventType": 1 });

// Index pour les requ√™tes temporelles
db.events.createIndex({ "timestamp": 1 });
db.events.createIndex({ "eventType": 1, "timestamp": 1 });

// Index pour les requ√™tes de corr√©lation
db.events.createIndex({ "metadata.correlationId": 1 });
db.events.createIndex({ "metadata.userId": 1 });
```

## üîÑ **Reconstruction de l'√âtat**

### **Reconstruction Compl√®te**

```javascript
// Reconstruire l'√©tat complet d'un agr√©gat
async function reconstructAggregate(aggregateId) {
  const events = await db.events.find({
    aggregateId: aggregateId
  }).sort({ sequenceNumber: 1 });
  
  let aggregate = {
    id: aggregateId,
    version: 0,
    state: {}
  };
  
  for (const event of events) {
    aggregate = applyEvent(aggregate, event);
  }
  
  return aggregate;
}

// Appliquer un √©v√©nement √† l'agr√©gat
function applyEvent(aggregate, event) {
  switch (event.eventType) {
    case "InvoiceCreated":
      return {
        ...aggregate,
        version: event.sequenceNumber,
        state: {
          ...aggregate.state,
          invoiceNumber: event.eventData.invoiceNumber,
          customerId: event.eventData.customerId,
          amount: event.eventData.amount,
          currency: event.eventData.currency,
          items: event.eventData.items,
          status: "pending",
          createdAt: event.timestamp
        }
      };
    
    case "InvoicePaid":
      return {
        ...aggregate,
        version: event.sequenceNumber,
        state: {
          ...aggregate.state,
          status: "paid",
          paymentId: event.eventData.paymentId,
          paymentMethod: event.eventData.paymentMethod,
          paidAt: event.eventData.paidAt
        }
      };
    
    default:
      return aggregate;
  }
}
```

### **Reconstruction Incr√©mentale**

```javascript
// Reconstruire √† partir d'une version sp√©cifique
async function reconstructFromVersion(aggregateId, fromVersion) {
  const events = await db.events.find({
    aggregateId: aggregateId,
    sequenceNumber: { $gt: fromVersion }
  }).sort({ sequenceNumber: 1 });
  
  let aggregate = await getSnapshot(aggregateId, fromVersion);
  
  for (const event of events) {
    aggregate = applyEvent(aggregate, event);
  }
  
  return aggregate;
}
```

## üìä **Snapshots pour Performance**

### **Cr√©ation de Snapshots**

```javascript
// Cr√©er un snapshot de l'agr√©gat
async function createSnapshot(aggregateId, version) {
  const aggregate = await reconstructAggregate(aggregateId);
  
  const snapshot = {
    _id: `${aggregateId}_${version}`,
    aggregateId: aggregateId,
    version: version,
    state: aggregate.state,
    timestamp: new Date()
  };
  
  await db.snapshots.replaceOne(
    { _id: snapshot._id },
    snapshot,
    { upsert: true }
  );
  
  return snapshot;
}

// R√©cup√©rer un snapshot
async function getSnapshot(aggregateId, version) {
  const snapshot = await db.snapshots.findOne({
    aggregateId: aggregateId,
    version: { $lte: version }
  }).sort({ version: -1 });
  
  if (snapshot) {
    return {
      id: aggregateId,
      version: snapshot.version,
      state: snapshot.state
    };
  }
  
  return {
    id: aggregateId,
    version: 0,
    state: {}
  };
}
```

### **Strat√©gie de Snapshot**

```javascript
// Cr√©er des snapshots tous les N √©v√©nements
const SNAPSHOT_FREQUENCY = 100;

async function shouldCreateSnapshot(aggregateId) {
  const eventCount = await db.events.countDocuments({
    aggregateId: aggregateId
  });
  
  return eventCount % SNAPSHOT_FREQUENCY === 0;
}
```

## üîç **Requ√™tes sur les √âv√©nements**

### **Requ√™tes Temporelles**

```javascript
// Tous les √©v√©nements d'un type sur une p√©riode
async function getEventsByType(eventType, startDate, endDate) {
  return await db.events.find({
    eventType: eventType,
    timestamp: {
      $gte: startDate,
      $lte: endDate
    }
  }).sort({ timestamp: 1 });
}

// √âv√©nements par utilisateur
async function getEventsByUser(userId, limit = 100) {
  return await db.events.find({
    "metadata.userId": userId
  }).sort({ timestamp: -1 }).limit(limit);
}
```

### **Requ√™tes de Corr√©lation**

```javascript
// Tous les √©v√©nements d'une corr√©lation
async function getEventsByCorrelation(correlationId) {
  return await db.events.find({
    "metadata.correlationId": correlationId
  }).sort({ timestamp: 1 });
}

// Tracer le flux d'une commande
async function traceCommandFlow(correlationId) {
  const events = await getEventsByCorrelation(correlationId);
  
  const flow = events.map(event => ({
    timestamp: event.timestamp,
    aggregateId: event.aggregateId,
    eventType: event.eventType,
    userId: event.metadata.userId
  }));
  
  return flow;
}
```

## ‚ö†Ô∏è **D√©fis et Solutions**

### **Gestion des Conflits**

```javascript
// V√©rifier la version avant d'ajouter un √©v√©nement
async function appendEvent(aggregateId, eventType, eventData, expectedVersion) {
  const session = await client.startSession();
  
  try {
    await session.withTransaction(async () => {
      // V√©rifier la version actuelle
      const currentVersion = await db.events.findOne(
        { aggregateId: aggregateId },
        { sort: { sequenceNumber: -1 } }
      );
      
      if (currentVersion && currentVersion.sequenceNumber !== expectedVersion) {
        throw new Error(`Version conflict: expected ${expectedVersion}, got ${currentVersion.sequenceNumber}`);
      }
      
      // Ajouter l'√©v√©nement
      const event = {
        _id: ObjectId(),
        aggregateId: aggregateId,
        aggregateType: "Invoice",
        eventType: eventType,
        eventVersion: 1,
        eventData: eventData,
        timestamp: new Date(),
        sequenceNumber: (currentVersion?.sequenceNumber || 0) + 1
      };
      
      await db.events.insertOne(event);
    });
  } finally {
    await session.endSession();
  }
}
```

### **Gestion des Erreurs**

```javascript
// Retry automatique en cas d'√©chec
async function appendEventWithRetry(aggregateId, eventType, eventData, expectedVersion, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      await appendEvent(aggregateId, eventType, eventData, expectedVersion);
      return;
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      
      // Attendre avant de retry
      await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i)));
    }
  }
}
```

### **Nettoyage des Anciens √âv√©nements**

```javascript
// Archiver les anciens √©v√©nements
async function archiveOldEvents(olderThanDays = 365) {
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - olderThanDays);
  
  const oldEvents = await db.events.find({
    timestamp: { $lt: cutoffDate }
  }).toArray();
  
  // Archiver vers une collection s√©par√©e
  if (oldEvents.length > 0) {
    await db.events_archive.insertMany(oldEvents);
    await db.events.deleteMany({
      _id: { $in: oldEvents.map(e => e._id) }
    });
  }
}
```

## üéØ **Crit√®res d'Adoption**

### **Quand Utiliser Event Sourcing avec MongoDB**

- ‚úÖ **Audit trail critique** : Conformit√© r√©glementaire requise
- ‚úÖ **Debugging complexe** : Besoin de comprendre l'historique
- ‚úÖ **√âquipe tr√®s exp√©riment√©e** : Connaissance d'Event Sourcing
- ‚úÖ **Budget important** : Complexit√© justifi√©e par les besoins

### **Quand √âviter Event Sourcing avec MongoDB**

- ‚ùå **Application simple** : Pas de besoin d'audit trail
- ‚ùå **√âquipe junior** : Complexit√© trop √©lev√©e
- ‚ùå **Performance critique** : Latence < 10ms requise
- ‚ùå **Budget limit√©** : Complexit√© non justifi√©e

## üìà **M√©triques de Succ√®s**

### **Performance**

```javascript
const performanceMetrics = {
  eventAppendLatency: "< 50ms",
  aggregateReconstruction: "< 200ms",
  snapshotCreation: "< 1s",
  eventQueryLatency: "< 100ms"
};
```

### **Monitoring**

```javascript
const monitoringMetrics = {
  eventsPerSecond: "> 1k",
  averageAggregateSize: "< 100 events",
  snapshotFrequency: "Every 100 events",
  archiveFrequency: "Daily"
};
```

## üîÑ **Migration vers Event Sourcing**

### **√âtape 1 : Cr√©er les Collections**

```javascript
// Cr√©er les collections Event Sourcing
db.createCollection("events");
db.createCollection("snapshots");
db.createCollection("events_archive");
```

### **√âtape 2 : Migrer les Donn√©es Existantes**

```javascript
// Migration des donn√©es existantes vers Event Sourcing
async function migrateToEventSourcing() {
  const existingDocuments = await db.billing_documents.find({});
  
  for (const doc of existingDocuments) {
    // Cr√©er l'√©v√©nement de migration
    await db.events.insertOne({
      _id: ObjectId(),
      aggregateId: doc._id,
      aggregateType: "Invoice",
      eventType: "InvoiceMigrated",
      eventVersion: 1,
      eventData: doc,
      timestamp: new Date(),
      sequenceNumber: 1
    });
  }
}
```

### **√âtape 3 : Basculer Progressivement**

```javascript
// Feature flag pour basculer vers Event Sourcing
const useEventSourcing = await getFeatureFlag("mongodb_event_sourcing_enabled");

if (useEventSourcing) {
  // Utiliser Event Sourcing
  return await reconstructAggregate(aggregateId);
} else {
  // Utiliser l'ancienne collection
  return await db.billing_documents.findOne({ _id: aggregateId });
}
```

## üí° **Conseils Pratiques**

### **Design des √âv√©nements**

1. **Immutables** : Jamais de modification apr√®s cr√©ation
2. **Versionn√©s** : Support des √©volutions de sch√©ma
3. **M√©tadonn√©es** : CorrelationId, CausationId, UserId
4. **Granularit√©** : Un √©v√©nement par action m√©tier

### **Monitoring et Alertes**

1. **Lag de reconstruction** : < 200ms
2. **Taux d'erreur** : < 0.1%
3. **Performance** : Latence < 50ms
4. **Coh√©rence** : V√©rification quotidienne

## üéØ **Votre Prochaine √âtape**

Maintenant que vous comprenez l'approche Event Sourcing avec MongoDB, quelle est votre situation ?

{{< chapter-nav >}}
  {{< chapter-option 
    letter="A" 
    color="green" 
    title="Je veux comprendre CQRS + Event Sourcing" 
    subtitle="Vous voulez combiner les deux approches"
    criteria="Audit trail critique,Debugging complexe,√âquipe tr√®s exp√©riment√©e,Budget important"
    time="45-55 minutes"
    chapter="32"
    chapter-title="Stockage MongoDB - CQRS + Event Sourcing"
    chapter-url="/chapitres/stockage/mongodb/chapitre-32-stockage-mongodb-cqrs-event-sourcing/"
  >}}
  
  {{< chapter-option 
    letter="B" 
    color="yellow" 
    title="Je veux voir l'approche CQRS" 
    subtitle="Vous voulez comprendre la s√©paration des mod√®les"
    criteria="√âquipes multiples,Cas d'usage tr√®s diff√©rents,Performance critique,√âvolutivit√© maximale"
    time="35-45 minutes"
    chapter="30"
    chapter-title="Stockage MongoDB - Approche CQRS"
    chapter-url="/chapitres/stockage/mongodb/chapitre-30-stockage-mongodb-cqrs/"
  >}}
  
  {{< chapter-option 
    letter="C" 
    color="red" 
    title="Je veux revenir √† l'approche CQS" 
    subtitle="Vous voulez une approche plus simple"
    criteria="√âquipe exp√©riment√©e,Besoin d'optimiser les performances,S√©paration des responsabilit√©s importante,√âvolutivit√© importante"
    time="30-40 minutes"
    chapter="29"
    chapter-title="Stockage MongoDB - Approche CQS"
    chapter-url="/chapitres/stockage/mongodb/chapitre-29-stockage-mongodb-cqs/"
  >}}
  
  {{< chapter-option 
    letter="D" 
    color="blue" 
    title="Je veux explorer d'autres types de stockage" 
    subtitle="Vous voulez voir les alternatives √† MongoDB"
    criteria="Besoin de comparer les options,Choix de stockage √† faire,√âquipe en r√©flexion"
    time="30-40 minutes"
    chapter="10"
    chapter-title="Choix du Type de Stockage"
    chapter-url="/chapitres/fondamentaux/chapitre-10-choix-type-stockage/"
  >}}
{{< /chapter-nav >}}

**üí° Conseil** : Si vous n'√™tes pas s√ªr, commencez par l'approche CQS (option C) pour bien comprendre la s√©paration des responsabilit√©s, puis revenez √† Event Sourcing quand vous serez pr√™t.

**üîÑ Alternative** : Si vous voulez tout voir dans l'ordre, continuez avec l'approche CQRS + Event Sourcing (option A).
