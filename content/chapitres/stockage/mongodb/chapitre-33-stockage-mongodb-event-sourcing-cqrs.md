---
title: "Stockage MongoDB - Event Sourcing + CQRS"
description: "Impl√©mentation compl√®te Event Sourcing + CQRS avec MongoDB pour une architecture hautement scalable"
date: 2024-12-19
draft: true
type: "docs"
weight: 33
---
## üéØ **Contexte et Objectifs**### **L'Approche la Plus Avanc√©e**Nous arrivons maintenant √† l'approche la plus sophistiqu√©e : **Event Sourcing + CQRS avec MongoDB**. Cette combinaison offre une architecture hautement scalable et flexible, parfaite pour les syst√®mes complexes.#### **Pourquoi cette Approche ?**- **S√©paration totale** : Commandes et requ√™tes compl√®tement d√©coupl√©es- **Scalabilit√© maximale** : Possibilit√© de scaler ind√©pendamment chaque c√¥t√©- **Flexibilit√©** : Projections multiples pour diff√©rents besoins- **Audit trail complet** : Historique de tous les changements- **Performance optimale** : Chaque c√¥t√© optimis√© pour son usage### **Contexte Gyroscops**Dans notre √©cosyst√®me **User ‚Üí Organization ‚Üí Workflow ‚Üí Cloud Resources ‚Üí Billing**, cette approche est id√©ale pour :- **Syst√®me de facturation** : Audit trail complet et projections multiples- **Workflows complexes** : √âv√©nements de progression et √©tats- **Ressources cloud** : Historique des changements et m√©triques- **Analytics** : Projections sp√©cialis√©es pour les rapports## üèóÔ∏è **Architecture Event Sourcing + CQRS**### **S√©paration Compl√®te des Responsabilit√©s**#### **Command Side (Write)**- **Event Store** : Stockage des √©v√©nements dans MongoDB- **Command Handlers** : Traitement des commandes m√©tier- **Aggregates** : Logique m√©tier et invariants- **Event Handlers** : Gestion des √©v√©nements g√©n√©r√©s- **Command Bus** : Orchestration des commandes#### **Query Side (Read)**- **Projections** : Vues optimis√©es pour la lecture- **Query Handlers** : Traitement des requ√™tes- **Read Models** : Mod√®les optimis√©s pour l'affichage- **Query Bus** : Orchestration des requ√™tes- **Caches** : Optimisation des performances### **Flux de Donn√©es Complet**```mermaidgraph TD    A[Command] --> B[Command Bus]    B --> C[Command Handler]    C --> D[Aggregate]    D --> E[Events]    E --> F[Event Store MongoDB]    E --> G[Event Bus]    G --> H[Event Handlers]    H --> I[Projections]    I --> J[Read Models]    J --> K[Query Bus]    K --> L[Query Handler]    L --> M[Response]        N[Query] --> K    O[Cache] --> L```## üíª **Impl√©mentation Compl√®te**### **1. Event Store Avanc√©**#### **Structure des Collections Optimis√©e**```javascript// Collection: events{  _id: ObjectId("..."),  aggregateId: "payment-123",  aggregateType: "Payment",  eventType: "PaymentProcessed",  eventData: {    amount: 100.00,    currency: "EUR",    status: "completed",    metadata: {      userId: "user-456",      organizationId: "org-789"    }  },  version: 1,  timestamp: ISODate("2024-12-19T10:00:00Z"),  correlationId: "corr-789",  causationId: "cmd-456"}// Collection: snapshots{  _id: ObjectId("..."),  aggregateId: "payment-123",  aggregateType: "Payment",  data: {    amount: 100.00,    currency: "EUR",    status: "completed",    processedAt: ISODate("2024-12-19T10:00:00Z")  },  version: 1,  timestamp: ISODate("2024-12-19T10:00:00Z")}// Collection: projections_metadata{  _id: ObjectId("..."),  projectionName: "PaymentReadModel",  lastProcessedEventId: ObjectId("..."),  lastProcessedTimestamp: ISODate("2024-12-19T10:00:00Z"),  version: 1}```#### **Index MongoDB Optimis√©s**```javascript// Index pour les √©v√©nementsdb.events.createIndex({ aggregateId: 1, version: 1 })db.events.createIndex({ aggregateType: 1, timestamp: 1 })db.events.createIndex({ eventType: 1, timestamp: 1 })db.events.createIndex({ correlationId: 1 })db.events.createIndex({ timestamp: 1 }, { expireAfterSeconds: 31536000 }) // 1 an// Index pour les snapshotsdb.snapshots.createIndex({ aggregateId: 1 })db.snapshots.createIndex({ aggregateType: 1, timestamp: 1 })// Index pour les projectionsdb.payment_read_models.createIndex({ organizationId: 1, processedAt: -1 })db.payment_read_models.createIndex({ status: 1, processedAt: -1 })db.payment_read_models.createIndex({ amount: 1, processedAt: -1 })```### **2. Command Side Implementation**#### **Event Store avec Gestion des M√©tadonn√©es**```php<?phpnamespace App\Infrastructure\EventStore;use MongoDB\Client;use MongoDB\Collection;use App\Domain\Event\DomainEvent;use App\Domain\Event\EventStoreInterface;class MongoEventStore implements EventStoreInterface{    private Collection $events;    private Collection $snapshots;    private Collection $projectionsMetadata;    public function __construct(Client $mongoClient)    {        $this->events = $mongoClient->selectCollection('Gyroscops Cloud', 'events');        $this->snapshots = $mongoClient->selectCollection('Gyroscops Cloud', 'snapshots');        $this->projectionsMetadata = $mongoClient->selectCollection('Gyroscops Cloud', 'projections_metadata');    }    public function appendEvents(string $aggregateId, array $events, int $expectedVersion, string $correlationId = null): void    {        $session = $this->events->getDatabase()->getClient()->startSession();                try {            $session->startTransaction();                        // V√©rifier la version attendue            $lastEvent = $this->events->findOne(                ['aggregateId' => $aggregateId],                ['sort' => ['version' => -1]]            );                        if ($lastEvent && $lastEvent['version'] !== $expectedVersion) {                throw new ConcurrencyException('Version mismatch');            }                        // Ins√©rer les nouveaux √©v√©nements            $documents = [];            $version = $expectedVersion + 1;            $causationId = $correlationId;                        foreach ($events as $event) {                $documents[] = [                    'aggregateId' => $aggregateId,                    'aggregateType' => $event->getAggregateType(),                    'eventType' => $event->getEventType(),                    'eventData' => $event->toArray(),                    'version' => $version++,                    'timestamp' => new \MongoDB\BSON\UTCDateTime(),                    'correlationId' => $correlationId,                    'causationId' => $causationId,                    'metadata' => $event->getMetadata()                ];            }                        $this->events->insertMany($documents);            $session->commitTransaction();                    } catch (\Exception $e) {            $session->abortTransaction();            throw $e;        }    }    public function getEvents(string $aggregateId, int $fromVersion = 0): array    {        $cursor = $this->events->find(            [                'aggregateId' => $aggregateId,                'version' => ['$gte' => $fromVersion]            ],            ['sort' => ['version' => 1]]        );                $events = [];        foreach ($cursor as $document) {            $events[] = $this->deserializeEvent($document);        }                return $events;    }    public function getEventsByCorrelationId(string $correlationId): array    {        $cursor = $this->events->find(            ['correlationId' => $correlationId],            ['sort' => ['timestamp' => 1]]        );                $events = [];        foreach ($cursor as $document) {            $events[] = $this->deserializeEvent($document);        }                return $events;    }    private function deserializeEvent(array $document): DomainEvent    {        $eventClass = $document['eventType'];        return $eventClass::fromArray($document['eventData']);    }}```#### **Command Bus avec Middleware**```php<?phpnamespace App\Application\CommandBus;use App\Domain\Command\CommandInterface;use App\Domain\Command\CommandHandlerInterface;use Psr\Log\LoggerInterface;class CommandBus{    private array $handlers = [];    private array $middleware = [];    private LoggerInterface $logger;    public function __construct(LoggerInterface $logger)    {        $this->logger = $logger;    }    public function registerHandler(string $commandClass, CommandHandlerInterface $handler): void    {        $this->handlers[$commandClass] = $handler;    }    public function addMiddleware(callable $middleware): void    {        $this->middleware[] = $middleware;    }    public function handle(CommandInterface $command): void    {        $commandClass = get_class($command);                if (!isset($this->handlers[$commandClass])) {            throw new \InvalidArgumentException("No handler registered for command: $commandClass");        }        $handler = $this->handlers[$commandClass];                // Ex√©cuter les middleware        $this->executeMiddleware($command, function() use ($handler, $command) {            $this->logger->info('Executing command', [                'command' => get_class($command),                'data' => $command->toArray()            ]);                        $handler->handle($command);        });    }    private function executeMiddleware(CommandInterface $command, callable $next): void    {        $middleware = array_reverse($this->middleware);                foreach ($middleware as $mw) {            $next = function() use ($mw, $command, $next) {                return $mw($command, $next);            };        }                $next();    }}```#### **Command Handler Avanc√©**```php<?phpnamespace App\Application\Command\Payment;use App\Domain\Payment\PaymentAggregate;use App\Domain\Event\EventStoreInterface;use App\Domain\Event\EventBusInterface;use App\Domain\Payment\PaymentRepositoryInterface;use Psr\Log\LoggerInterface;class ProcessPaymentCommandHandler implements CommandHandlerInterface{    public function __construct(        private EventStoreInterface $eventStore,        private EventBusInterface $eventBus,        private PaymentRepositoryInterface $paymentRepository,        private LoggerInterface $logger    ) {}    public function handle(ProcessPaymentCommand $command): void    {        try {            // Charger l'agr√©gat            $events = $this->eventStore->getEvents($command->getPaymentId());            $payment = PaymentAggregate::fromEvents($events);                        // Ex√©cuter la commande            $payment->processPayment($command->getAmount(), $command->getCurrency());                        // Sauvegarder les √©v√©nements            $this->eventStore->appendEvents(                $command->getPaymentId(),                $payment->getUncommittedEvents(),                $payment->getVersion(),                $command->getCorrelationId()            );                        // Publier les √©v√©nements            foreach ($payment->getUncommittedEvents() as $event) {                $this->eventBus->publish($event);            }                        // Nettoyer les √©v√©nements non commit√©s            $payment->markEventsAsCommitted();                        $this->logger->info('Payment processed successfully', [                'paymentId' => $command->getPaymentId(),                'amount' => $command->getAmount(),                'currency' => $command->getCurrency()            ]);                    } catch (\Exception $e) {            $this->logger->error('Payment processing failed', [                'paymentId' => $command->getPaymentId(),                'error' => $e->getMessage(),                'trace' => $e->getTraceAsString()            ]);                        throw $e;        }    }}```### **3. Query Side Implementation**#### **Query Bus avec Cache**```php<?phpnamespace App\Application\QueryBus;use App\Domain\Query\QueryInterface;use App\Domain\Query\QueryHandlerInterface;use Psr\Cache\CacheItemPoolInterface;use Psr\Log\LoggerInterface;class QueryBus{    private array $handlers = [];    private CacheItemPoolInterface $cache;    private LoggerInterface $logger;    public function __construct(CacheItemPoolInterface $cache, LoggerInterface $logger)    {        $this->cache = $cache;        $this->logger = $logger;    }    public function registerHandler(string $queryClass, QueryHandlerInterface $handler): void    {        $this->handlers[$queryClass] = $handler;    }    public function handle(QueryInterface $query): mixed    {        $queryClass = get_class($query);                if (!isset($this->handlers[$queryClass])) {            throw new \InvalidArgumentException("No handler registered for query: $queryClass");        }        // V√©rifier le cache        $cacheKey = $this->generateCacheKey($query);        $cachedItem = $this->cache->getItem($cacheKey);                if ($cachedItem->isHit()) {            $this->logger->debug('Query result served from cache', [                'query' => $queryClass,                'cacheKey' => $cacheKey            ]);                        return $cachedItem->get();        }        // Ex√©cuter la requ√™te        $handler = $this->handlers[$queryClass];        $result = $handler->handle($query);                // Mettre en cache        $cachedItem->set($result);        $cachedItem->expiresAfter(300); // 5 minutes        $this->cache->save($cachedItem);                $this->logger->info('Query executed and cached', [            'query' => $queryClass,            'cacheKey' => $cacheKey        ]);                return $result;    }    private function generateCacheKey(QueryInterface $query): string    {        return 'query_' . md5(serialize($query));    }}```#### **Projection Handler avec Gestion des M√©tadonn√©es**```php<?phpnamespace App\Application\Projection\Payment;use App\Domain\Event\DomainEvent;use App\Infrastructure\ReadModel\PaymentReadModel;use MongoDB\Client;use Psr\Log\LoggerInterface;class PaymentProjectionHandler{    private \MongoDB\Collection $readModel;    private \MongoDB\Collection $projectionsMetadata;    private LoggerInterface $logger;    public function __construct(Client $mongoClient, LoggerInterface $logger)    {        $this->readModel = $mongoClient->selectCollection('Gyroscops Cloud', 'payment_read_models');        $this->projectionsMetadata = $mongoClient->selectCollection('Gyroscops Cloud', 'projections_metadata');        $this->logger = $logger;    }    public function handle(DomainEvent $event): void    {        try {            switch ($event->getEventType()) {                case 'PaymentProcessed':                    $this->handlePaymentProcessed($event);                    break;                case 'PaymentFailed':                    $this->handlePaymentFailed($event);                    break;                case 'PaymentRefunded':                    $this->handlePaymentRefunded($event);                    break;            }                        // Mettre √† jour les m√©tadonn√©es de projection            $this->updateProjectionMetadata($event);                    } catch (\Exception $e) {            $this->logger->error('Projection handling failed', [                'event' => $event->getEventType(),                'aggregateId' => $event->getAggregateId(),                'error' => $e->getMessage()            ]);                        throw $e;        }    }    private function handlePaymentProcessed(DomainEvent $event): void    {        $this->readModel->updateOne(            ['paymentId' => $event->getAggregateId()],            [                '$set' => [                    'paymentId' => $event->getAggregateId(),                    'amount' => $event->getData()['amount'],                    'currency' => $event->getData()['currency'],                    'status' => 'completed',                    'processedAt' => $event->getTimestamp(),                    'organizationId' => $event->getMetadata()['organizationId'],                    'userId' => $event->getMetadata()['userId'],                    'updatedAt' => new \MongoDB\BSON\UTCDateTime()                ]            ],            ['upsert' => true]        );    }    private function handlePaymentFailed(DomainEvent $event): void    {        $this->readModel->updateOne(            ['paymentId' => $event->getAggregateId()],            [                '$set' => [                    'status' => 'failed',                    'error' => $event->getData()['error'],                    'failedAt' => $event->getTimestamp(),                    'updatedAt' => new \MongoDB\BSON\UTCDateTime()                ]            ],            ['upsert' => true]        );    }    private function handlePaymentRefunded(DomainEvent $event): void    {        $this->readModel->updateOne(            ['paymentId' => $event->getAggregateId()],            [                '$set' => [                    'status' => 'refunded',                    'refundAmount' => $event->getData()['refundAmount'],                    'refundedAt' => $event->getTimestamp(),                    'updatedAt' => new \MongoDB\BSON\UTCDateTime()                ]            ],            ['upsert' => true]        );    }    private function updateProjectionMetadata(DomainEvent $event): void    {        $this->projectionsMetadata->updateOne(            ['projectionName' => 'PaymentReadModel'],            [                '$set' => [                    'projectionName' => 'PaymentReadModel',                    'lastProcessedEventId' => $event->getId(),                    'lastProcessedTimestamp' => $event->getTimestamp(),                    'version' => $event->getVersion(),                    'updatedAt' => new \MongoDB\BSON\UTCDateTime()                ]            ],            ['upsert' => true]        );    }}```#### **Query Handler Avanc√© avec Analytics**```php<?phpnamespace App\Application\Query\Payment;use App\Infrastructure\ReadModel\PaymentReadModel;use MongoDB\Client;use Psr\Log\LoggerInterface;class PaymentQueryHandler implements QueryHandlerInterface{    private \MongoDB\Collection $readModel;    private LoggerInterface $logger;    public function __construct(Client $mongoClient, LoggerInterface $logger)    {        $this->readModel = $mongoClient->selectCollection('Gyroscops Cloud', 'payment_read_models');        $this->logger = $logger;    }    public function handle(GetPaymentByIdQuery $query): ?PaymentReadModel    {        $document = $this->readModel->findOne(['paymentId' => $query->getPaymentId()]);                if (!$document) {            return null;        }                return PaymentReadModel::fromArray($document);    }    public function handle(GetPaymentsByOrganizationQuery $query): array    {        $cursor = $this->readModel->find(            ['organizationId' => $query->getOrganizationId()],            [                'sort' => ['processedAt' => -1],                'limit' => $query->getLimit(),                'skip' => $query->getOffset()            ]        );                $payments = [];        foreach ($cursor as $document) {            $payments[] = PaymentReadModel::fromArray($document);        }                return $payments;    }    public function handle(GetPaymentStatisticsQuery $query): array    {        $pipeline = [            [                '$match' => [                    'organizationId' => $query->getOrganizationId(),                    'processedAt' => [                        '$gte' => new \MongoDB\BSON\UTCDateTime($query->getFrom()),                        '$lte' => new \MongoDB\BSON\UTCDateTime($query->getTo())                    ]                ]            ],            [                '$group' => [                    '_id' => [                        'status' => '$status',                        'currency' => '$currency'                    ],                    'count' => ['$sum' => 1],                    'totalAmount' => ['$sum' => '$amount'],                    'averageAmount' => ['$avg' => '$amount']                ]            ],            [                '$sort' => ['_id.status' => 1, '_id.currency' => 1]            ]        ];                $cursor = $this->readModel->aggregate($pipeline);                $statistics = [];        foreach ($cursor as $document) {            $status = $document['_id']['status'];            $currency = $document['_id']['currency'];                        if (!isset($statistics[$status])) {                $statistics[$status] = [];            }                        $statistics[$status][$currency] = [                'count' => $document['count'],                'totalAmount' => $document['totalAmount'],                'averageAmount' => $document['averageAmount']            ];        }                return $statistics;    }    public function handle(GetPaymentTrendsQuery $query): array    {        $pipeline = [            [                '$match' => [                    'organizationId' => $query->getOrganizationId(),                    'processedAt' => [                        '$gte' => new \MongoDB\BSON\UTCDateTime($query->getFrom()),                        '$lte' => new \MongoDB\BSON\UTCDateTime($query->getTo())                    ]                ]            ],            [                '$group' => [                    '_id' => [                        'year' => ['$year' => '$processedAt'],                        'month' => ['$month' => '$processedAt'],                        'day' => ['$dayOfMonth' => '$processedAt']                    ],                    'count' => ['$sum' => 1],                    'totalAmount' => ['$sum' => '$amount']                ]            ],            [                '$sort' => ['_id.year' => 1, '_id.month' => 1, '_id.day' => 1]            ]        ];                $cursor = $this->readModel->aggregate($pipeline);                $trends = [];        foreach ($cursor as $document) {            $date = sprintf('%04d-%02d-%02d',                 $document['_id']['year'],                $document['_id']['month'],                $document['_id']['day']            );                        $trends[$date] = [                'count' => $document['count'],                'totalAmount' => $document['totalAmount']            ];        }                return $trends;    }}```## üß™ **Tests et Validation**### **Tests d'Int√©gration Complets**```php<?phpnamespace App\Tests\Integration\Payment;use App\Application\Command\Payment\ProcessPaymentCommand;use App\Application\Command\Payment\ProcessPaymentCommandHandler;use App\Application\Query\Payment\GetPaymentByIdQuery;use App\Application\Query\Payment\GetPaymentStatisticsQuery;use App\Application\Query\Payment\PaymentQueryHandler;use App\Infrastructure\EventStore\MongoEventStore;use App\Infrastructure\EventBus\EventBus;use MongoDB\Client;class PaymentEventSourcingCqrsTest extends TestCase{    public function testCompleteEventSourcingCqrsFlow(): void    {        $mongoClient = new Client('mongodb://localhost:27017');        $eventStore = new MongoEventStore($mongoClient);        $eventBus = new EventBus();                $commandHandler = new ProcessPaymentCommandHandler(            $eventStore,             $eventBus,             $this->createMock(PaymentRepositoryInterface::class),            $this->createMock(LoggerInterface::class)        );                $queryHandler = new PaymentQueryHandler($mongoClient, $this->createMock(LoggerInterface::class));                // Ex√©cuter la commande        $command = new ProcessPaymentCommand('payment-123', 100.00, 'EUR', 'org-456');        $commandHandler->handle($command);                // V√©rifier la requ√™te        $query = new GetPaymentByIdQuery('payment-123');        $payment = $queryHandler->handle($query);                $this->assertNotNull($payment);        $this->assertEquals(100.00, $payment->getAmount());        $this->assertEquals('EUR', $payment->getCurrency());        $this->assertEquals('completed', $payment->getStatus());    }    public function testPaymentStatistics(): void    {        $mongoClient = new Client('mongodb://localhost:27017');        $queryHandler = new PaymentQueryHandler($mongoClient, $this->createMock(LoggerInterface::class));                $query = new GetPaymentStatisticsQuery(            'org-456',            new \DateTime('2024-01-01'),            new \DateTime('2024-12-31')        );                $statistics = $queryHandler->handle($query);                $this->assertIsArray($statistics);        $this->assertArrayHasKey('completed', $statistics);        $this->assertArrayHasKey('EUR', $statistics['completed']);    }}```## üìä **Performance et Optimisation**### **Strat√©gies d'Optimisation Avanc√©es**#### **1. Index MongoDB Optimis√©s**```javascript// Index compos√©s pour les requ√™tes complexesdb.events.createIndex({ aggregateType: 1, timestamp: -1, eventType: 1 })db.events.createIndex({ correlationId: 1, timestamp: 1 })db.payment_read_models.createIndex({ organizationId: 1, status: 1, processedAt: -1 })db.payment_read_models.createIndex({ amount: 1, processedAt: -1 })db.payment_read_models.createIndex({ currency: 1, status: 1 })// Index partiels pour les requ√™tes fr√©quentesdb.payment_read_models.createIndex(    { organizationId: 1, processedAt: -1 },    { partialFilterExpression: { status: 'completed' } })```#### **2. Projections Asynchrones**```phppublic function handleEventAsync(DomainEvent $event): void{    // Mettre en queue pour traitement asynchrone    $this->messageBus->dispatch(new ProcessProjectionCommand($event));}```#### **3. Cache Multi-Niveaux**```phppublic function handle(GetPaymentByIdQuery $query): ?PaymentReadModel{    // Cache L1: M√©moire    if (isset($this->memoryCache[$query->getPaymentId()])) {        return $this->memoryCache[$query->getPaymentId()];    }        // Cache L2: Redis    $cached = $this->redis->get("payment:{$query->getPaymentId()}");    if ($cached) {        $payment = PaymentReadModel::fromArray(json_decode($cached, true));        $this->memoryCache[$query->getPaymentId()] = $payment;        return $payment;    }        // Base de donn√©es    $payment = $this->getFromDatabase($query->getPaymentId());    if ($payment) {        $this->memoryCache[$query->getPaymentId()] = $payment;        $this->redis->setex("payment:{$query->getPaymentId()}", 300, json_encode($payment->toArray()));    }        return $payment;}```## üéØ **Crit√®res d'Adoption**### **Quand Utiliser Event Sourcing + CQRS avec MongoDB**#### **‚úÖ Avantages**- **Scalabilit√© maximale** : Possibilit√© de scaler ind√©pendamment- **Performance optimale** : Chaque c√¥t√© optimis√© pour son usage- **Flexibilit√©** : Projections multiples pour diff√©rents besoins- **Audit trail complet** : Historique de tous les changements- **Debugging avanc√©** : Possibilit√© de rejouer les √©v√©nements- **Analytics** : Projections sp√©cialis√©es pour les rapports#### **‚ùå Inconv√©nients**- **Complexit√© maximale** : Architecture tr√®s complexe- **Latence** : D√©lai entre √©criture et lecture- **Stockage** : Beaucoup d'espace disque n√©cessaire- **Expertise** : √âquipe tr√®s exp√©riment√©e requise- **Co√ªt** : Investissement important en complexit√©#### **üéØ Crit√®res d'Adoption**- **Syst√®me tr√®s complexe** : Besoins de scalabilit√© maximale- **√âquipe tr√®s exp√©riment√©e** : Ma√Ætrise des patterns avanc√©s- **Budget important** : Investissement en complexit√© justifi√©- **Performance critique** : Besoins de performance maximale- **Analytics avanc√©es** : Besoins de rapports complexes- **Audit trail complet** : Tra√ßabilit√© absolue requise## üöÄ **Votre Prochaine √âtape**{{< chapter-nav >}}  {{< chapter-option     letter="A"     color="green"     title="Je veux explorer les autres types de stockage"     subtitle="Vous voulez voir les alternatives √† MongoDB"    criteria="Comparaison n√©cessaire,Choix de stockage,Architecture √† d√©finir,Performance √† optimiser"    time="30-40 minutes"    chapter="10"    chapter-title="Choix du Type de Stockage"    chapter-url="/chapitres/fondamentaux/chapitre-10-choix-type-stockage/"  >}}    {{< chapter-option     letter="B"     color="yellow"     title="Je veux voir des exemples concrets"     subtitle="Vous voulez comprendre les impl√©mentations pratiques"    criteria="D√©veloppeur exp√©riment√©,Besoin d'exemples pratiques,Impl√©mentation √† faire,Code √† √©crire"    time="Variable"    chapter="0"    chapter-title="Exemples et Impl√©mentations"    chapter-url="/examples/"  >}}    {{< chapter-option     letter="C"     color="blue"     title="Je veux comprendre les techniques avanc√©es"     subtitle="Vous voulez voir les aspects techniques d'optimisation"    criteria="Performance critique,Optimisation n√©cessaire,√âquipe exp√©riment√©e,Architecture complexe"    time="45-60 minutes"    chapter="58"    chapter-title="Gestion des Donn√©es et Validation"    chapter-url="/chapitres/techniques/chapitre-58-gestion-donnees-validation/"  >}}    {{< chapter-option     letter="D"     color="purple"     title="Je veux revenir aux fondamentaux"     subtitle="Vous voulez comprendre les concepts de base"    criteria="D√©veloppeur d√©butant,Besoin de comprendre les concepts,Projet √† structurer,√âquipe √† former"    time="45-60 minutes"    chapter="1"    chapter-title="Introduction au Domain-Driven Design et Event Storming"    chapter-url="/chapitres/fondamentaux/chapitre-01-introduction-event-storming-ddd/"  >}}{{< /chapter-nav >}}---*Cette approche Event Sourcing + CQRS avec MongoDB repr√©sente l'√©tat de l'art en mati√®re d'architecture scalable et flexible, parfaitement adapt√©e aux besoins les plus exigeants de Gyroscops.*