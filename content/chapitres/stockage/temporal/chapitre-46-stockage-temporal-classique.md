---
title: "Stockage Temporal - Approche Classique"
description: "Impl√©mentation d'un stockage avec Temporal Workflows pour l'orchestration de processus m√©tier"
date: 2024-12-19
draft: true
type: "docs"
weight: 46
---
## üéØ **Contexte et Objectifs**### **Pourquoi Temporal pour le Stockage ?**Temporal Workflows offre une approche unique pour le stockage en g√©rant l'√©tat des processus m√©tier complexes de mani√®re durable et r√©siliente. Cette approche est particuli√®rement adapt√©e aux workflows qui n√©cessitent de la persistance, de la reprise sur panne et de l'orchestration.#### **Avantages du Stockage Temporal**- **Durabilit√©** : √âtat des workflows persist√© automatiquement- **R√©silience** : Reprise automatique apr√®s panne- **Orchestration** : Gestion complexe des processus m√©tier- **Observabilit√©** : Visibilit√© compl√®te sur l'ex√©cution- **Scalabilit√©** : Ex√©cution distribu√©e des workflows### **Contexte Gyroscops**Dans notre √©cosyst√®me **User ‚Üí Organization ‚Üí Workflow ‚Üí Cloud Resources ‚Üí Billing**, Temporal est particuli√®rement pertinent pour :- **Workflows de provisioning** : Orchestration des ressources cloud- **Processus de facturation** : Gestion des cycles de facturation- **Int√©grations complexes** : Orchestration des int√©grations API- **Processus m√©tier longs** : Workflows qui s'√©talent sur plusieurs jours## üèóÔ∏è **Architecture Temporal Classique**### **Structure des Workflows**#### **Workflow de Base**```php<?phpnamespace App\Workflow\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;#[WorkflowInterface]interface PaymentWorkflowInterface{    #[WorkflowMethod]    public function processPayment(PaymentRequest $request): PaymentResult;}#[ActivityInterface]interface PaymentActivityInterface{    #[ActivityMethod]    public function validatePayment(PaymentRequest $request): ValidationResult;        #[ActivityMethod]    public function chargePayment(PaymentRequest $request): ChargeResult;        #[ActivityMethod]    public function sendNotification(PaymentResult $result): void;}class PaymentWorkflow implements PaymentWorkflowInterface{    private PaymentActivityInterface $paymentActivity;    public function __construct()    {        $this->paymentActivity = Workflow::newActivityStub(PaymentActivityInterface::class);    }    public function processPayment(PaymentRequest $request): PaymentResult    {        // Validation du paiement        $validation = yield $this->paymentActivity->validatePayment($request);                if (!$validation->isValid()) {            return new PaymentResult(false, $validation->getError());        }                // Traitement du paiement        $charge = yield $this->paymentActivity->chargePayment($request);                if (!$charge->isSuccess()) {            return new PaymentResult(false, $charge->getError());        }                // Notification        yield $this->paymentActivity->sendNotification(            new PaymentResult(true, 'Payment processed successfully')        );                return new PaymentResult(true, 'Payment processed successfully');    }}```#### **Activit√©s de Persistance**```php<?phpnamespace App\Workflow\Payment;use Temporal\Activity\ActivityInterface;use Temporal\Activity\ActivityMethod;use App\Domain\Payment\PaymentRepositoryInterface;use App\Domain\Payment\Payment;use Psr\Log\LoggerInterface;class PaymentActivity implements PaymentActivityInterface{    private PaymentRepositoryInterface $paymentRepository;    private LoggerInterface $logger;    public function __construct(        PaymentRepositoryInterface $paymentRepository,        LoggerInterface $logger    ) {        $this->paymentRepository = $paymentRepository;        $this->logger = $logger;    }    #[ActivityMethod]    public function validatePayment(PaymentRequest $request): ValidationResult    {        try {            $this->logger->info('Validating payment', [                'paymentId' => $request->getPaymentId(),                'amount' => $request->getAmount()            ]);                        // Validation m√©tier            if ($request->getAmount() <= 0) {                return new ValidationResult(false, 'Invalid amount');            }                        if (empty($request->getCurrency())) {                return new ValidationResult(false, 'Currency required');            }                        // V√©rification de l'organisation            if (!$this->paymentRepository->organizationExists($request->getOrganizationId())) {                return new ValidationResult(false, 'Organization not found');            }                        return new ValidationResult(true);                    } catch (\Exception $e) {            $this->logger->error('Payment validation failed', [                'paymentId' => $request->getPaymentId(),                'error' => $e->getMessage()            ]);                        return new ValidationResult(false, $e->getMessage());        }    }    #[ActivityMethod]    public function chargePayment(PaymentRequest $request): ChargeResult    {        try {            $this->logger->info('Charging payment', [                'paymentId' => $request->getPaymentId(),                'amount' => $request->getAmount()            ]);                        // Cr√©er le paiement            $payment = new Payment(                $request->getPaymentId(),                $request->getOrganizationId(),                $request->getUserId(),                $request->getAmount(),                $request->getCurrency(),                'processing',                $request->getDescription(),                new \DateTime()            );                        // Sauvegarder le paiement            $this->paymentRepository->save($payment);                        // Simuler le traitement du paiement            // Dans un vrai syst√®me, ceci appellerait un service de paiement            $this->simulatePaymentProcessing($request);                        // Mettre √† jour le statut            $payment->markAsCompleted();            $this->paymentRepository->save($payment);                        return new ChargeResult(true, 'Payment charged successfully');                    } catch (\Exception $e) {            $this->logger->error('Payment charging failed', [                'paymentId' => $request->getPaymentId(),                'error' => $e->getMessage()            ]);                        return new ChargeResult(false, $e->getMessage());        }    }    #[ActivityMethod]    public function sendNotification(PaymentResult $result): void    {        try {            $this->logger->info('Sending payment notification', [                'success' => $result->isSuccess(),                'message' => $result->getMessage()            ]);                        // Envoyer une notification (email, webhook, etc.)            $this->sendEmailNotification($result);            $this->sendWebhookNotification($result);                    } catch (\Exception $e) {            $this->logger->error('Notification sending failed', [                'error' => $e->getMessage()            ]);        }    }    private function simulatePaymentProcessing(PaymentRequest $request): void    {        // Simuler un d√©lai de traitement        sleep(2);                // Simuler une √©chec al√©atoire (5% de chance)        if (rand(1, 100) <= 5) {            throw new \Exception('Payment processing failed');        }    }    private function sendEmailNotification(PaymentResult $result): void    {        // Impl√©mentation de l'envoi d'email    }    private function sendWebhookNotification(PaymentResult $result): void    {        // Impl√©mentation de l'envoi de webhook    }}```### **Flux de Donn√©es**```mermaidgraph TD    A[Client Request] --> B[Temporal Client]    B --> C[Workflow Execution]    C --> D[Activity 1: Validation]    D --> E[Activity 2: Charging]    E --> F[Activity 3: Notification]    F --> G[Workflow Complete]        H[Persistence Layer] --> I[Payment Repository]    I --> J[Database]        C --> H    D --> H    E --> H    F --> H        K[Temporal Server] --> L[Workflow State]    L --> M[Activity State]    M --> N[Event History]```## üíª **Impl√©mentation Pratique**### **1. Configuration Temporal**#### **Configuration du Client**```php<?phpnamespace App\Infrastructure\Temporal;use Temporal\Client\WorkflowClient;use Temporal\Client\WorkflowClientInterface;use Temporal\Client\WorkflowOptions;use Temporal\DataConverter\DataConverter;use Temporal\DataConverter\JsonDataConverter;class TemporalClientFactory{    private string $host;    private int $port;    private string $namespace;    public function __construct(string $host = 'localhost', int $port = 7233, string $namespace = 'default')    {        $this->host = $host;        $this->port = $port;        $this->namespace = $namespace;    }    public function createClient(): WorkflowClientInterface    {        $dataConverter = new DataConverter(            new JsonDataConverter()        );        return WorkflowClient::create(            $this->host . ':' . $this->port,            [                'namespace' => $this->namespace,                'dataConverter' => $dataConverter,            ]        );    }    public function createWorkflowOptions(): WorkflowOptions    {        return WorkflowOptions::new()            ->withWorkflowId('payment-workflow-' . uniqid())            ->withWorkflowExecutionTimeout(300) // 5 minutes            ->withWorkflowRunTimeout(300)            ->withWorkflowTaskTimeout(60);    }}```#### **Service de Workflow**```php<?phpnamespace App\Application\Service\Temporal;use App\Workflow\Payment\PaymentWorkflowInterface;use App\Workflow\Payment\PaymentRequest;use App\Workflow\Payment\PaymentResult;use Temporal\Client\WorkflowClientInterface;use Temporal\Client\WorkflowOptions;use Psr\Log\LoggerInterface;class PaymentWorkflowService{    private WorkflowClientInterface $workflowClient;    private LoggerInterface $logger;    public function __construct(        WorkflowClientInterface $workflowClient,        LoggerInterface $logger    ) {        $this->workflowClient = $workflowClient;        $this->logger = $logger;    }    public function processPayment(PaymentRequest $request): PaymentResult    {        try {            $this->logger->info('Starting payment workflow', [                'paymentId' => $request->getPaymentId(),                'amount' => $request->getAmount()            ]);            $workflowOptions = WorkflowOptions::new()                ->withWorkflowId('payment-' . $request->getPaymentId())                ->withWorkflowExecutionTimeout(300)                ->withWorkflowRunTimeout(300)                ->withWorkflowTaskTimeout(60);            $workflow = $this->workflowClient->newWorkflowStub(                PaymentWorkflowInterface::class,                $workflowOptions            );            $result = $workflow->processPayment($request);            $this->logger->info('Payment workflow completed', [                'paymentId' => $request->getPaymentId(),                'success' => $result->isSuccess()            ]);            return $result;        } catch (\Exception $e) {            $this->logger->error('Payment workflow failed', [                'paymentId' => $request->getPaymentId(),                'error' => $e->getMessage()            ]);            throw $e;        }    }    public function getWorkflowStatus(string $workflowId): array    {        try {            $workflow = $this->workflowClient->newWorkflowStub(                PaymentWorkflowInterface::class,                $workflowId            );            $status = $workflow->getStatus();            return [                'workflowId' => $workflowId,                'status' => $status,                'isRunning' => $status === 'RUNNING',                'isCompleted' => $status === 'COMPLETED',                'isFailed' => $status === 'FAILED'            ];        } catch (\Exception $e) {            $this->logger->error('Failed to get workflow status', [                'workflowId' => $workflowId,                'error' => $e->getMessage()            ]);            throw $e;        }    }    public function cancelWorkflow(string $workflowId): void    {        try {            $workflow = $this->workflowClient->newWorkflowStub(                PaymentWorkflowInterface::class,                $workflowId            );            $workflow->cancel();            $this->logger->info('Workflow cancelled', [                'workflowId' => $workflowId            ]);        } catch (\Exception $e) {            $this->logger->error('Failed to cancel workflow', [                'workflowId' => $workflowId,                'error' => $e->getMessage()            ]);            throw $e;        }    }}```### **2. Repository Temporal**#### **Repository avec Persistance Temporal**```php<?phpnamespace App\Infrastructure\Temporal\Repository;use App\Domain\Payment\Payment;use App\Domain\Payment\PaymentRepositoryInterface;use App\Infrastructure\Temporal\TemporalClientFactory;use Psr\Log\LoggerInterface;class TemporalPaymentRepository implements PaymentRepositoryInterface{    private TemporalClientFactory $temporalFactory;    private LoggerInterface $logger;    private array $cache = [];    public function __construct(        TemporalClientFactory $temporalFactory,        LoggerInterface $logger    ) {        $this->temporalFactory = $temporalFactory;        $this->logger = $logger;    }    public function save(Payment $payment): void    {        try {            $workflowId = 'payment-' . $payment->getId();                        // Cr√©er un workflow de persistance            $workflowOptions = $this->temporalFactory->createWorkflowOptions()                ->withWorkflowId($workflowId);                        $workflow = $this->temporalFactory->createClient()                ->newWorkflowStub(PaymentPersistenceWorkflowInterface::class, $workflowOptions);                        // Ex√©cuter le workflow de persistance            $workflow->persistPayment($payment);                        // Mettre en cache            $this->cache[$payment->getId()] = $payment;                        $this->logger->info('Payment persisted via Temporal', [                'paymentId' => $payment->getId(),                'workflowId' => $workflowId            ]);                    } catch (\Exception $e) {            $this->logger->error('Failed to persist payment via Temporal', [                'paymentId' => $payment->getId(),                'error' => $e->getMessage()            ]);                        throw $e;        }    }    public function findById(string $id): ?Payment    {        // V√©rifier le cache d'abord        if (isset($this->cache[$id])) {            return $this->cache[$id];        }                try {            $workflowId = 'payment-' . $id;                        // R√©cup√©rer depuis Temporal            $workflow = $this->temporalFactory->createClient()                ->newWorkflowStub(PaymentPersistenceWorkflowInterface::class, $workflowId);                        $payment = $workflow->getPayment($id);                        if ($payment) {                $this->cache[$id] = $payment;            }                        return $payment;                    } catch (\Exception $e) {            $this->logger->error('Failed to retrieve payment from Temporal', [                'paymentId' => $id,                'error' => $e->getMessage()            ]);                        return null;        }    }    public function findByOrganization(string $organizationId): array    {        try {            $workflowId = 'payment-search-' . $organizationId . '-' . uniqid();                        // Cr√©er un workflow de recherche            $workflowOptions = $this->temporalFactory->createWorkflowOptions()                ->withWorkflowId($workflowId);                        $workflow = $this->temporalFactory->createClient()                ->newWorkflowStub(PaymentSearchWorkflowInterface::class, $workflowOptions);                        $payments = $workflow->searchByOrganization($organizationId);                        // Mettre en cache            foreach ($payments as $payment) {                $this->cache[$payment->getId()] = $payment;            }                        return $payments;                    } catch (\Exception $e) {            $this->logger->error('Failed to search payments via Temporal', [                'organizationId' => $organizationId,                'error' => $e->getMessage()            ]);                        return [];        }    }    public function delete(string $id): void    {        try {            $workflowId = 'payment-delete-' . $id;                        // Cr√©er un workflow de suppression            $workflowOptions = $this->temporalFactory->createWorkflowOptions()                ->withWorkflowId($workflowId);                        $workflow = $this->temporalFactory->createClient()                ->newWorkflowStub(PaymentPersistenceWorkflowInterface::class, $workflowOptions);                        $workflow->deletePayment($id);                        // Supprimer du cache            unset($this->cache[$id]);                        $this->logger->info('Payment deleted via Temporal', [                'paymentId' => $id,                'workflowId' => $workflowId            ]);                    } catch (\Exception $e) {            $this->logger->error('Failed to delete payment via Temporal', [                'paymentId' => $id,                'error' => $e->getMessage()            ]);                        throw $e;        }    }    public function count(): int    {        try {            $workflowId = 'payment-count-' . uniqid();                        // Cr√©er un workflow de comptage            $workflowOptions = $this->temporalFactory->createWorkflowOptions()                ->withWorkflowId($workflowId);                        $workflow = $this->temporalFactory->createClient()                ->newWorkflowStub(PaymentSearchWorkflowInterface::class, $workflowOptions);                        return $workflow->getPaymentCount();                    } catch (\Exception $e) {            $this->logger->error('Failed to count payments via Temporal', [                'error' => $e->getMessage()            ]);                        return 0;        }    }}```### **3. Workflows de Persistance**#### **Workflow de Persistance des Paiements**```php<?phpnamespace App\Workflow\Persistence;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Domain\Payment\Payment;#[WorkflowInterface]interface PaymentPersistenceWorkflowInterface{    #[WorkflowMethod]    public function persistPayment(Payment $payment): void;        #[WorkflowMethod]    public function getPayment(string $paymentId): ?Payment;        #[WorkflowMethod]    public function deletePayment(string $paymentId): void;}#[ActivityInterface]interface PaymentPersistenceActivityInterface{    #[ActivityMethod]    public function saveToDatabase(Payment $payment): void;        #[ActivityMethod]    public function loadFromDatabase(string $paymentId): ?Payment;        #[ActivityMethod]    public function deleteFromDatabase(string $paymentId): void;}class PaymentPersistenceWorkflow implements PaymentPersistenceWorkflowInterface{    private PaymentPersistenceActivityInterface $persistenceActivity;    public function __construct()    {        $this->persistenceActivity = Workflow::newActivityStub(PaymentPersistenceActivityInterface::class);    }    public function persistPayment(Payment $payment): void    {        yield $this->persistenceActivity->saveToDatabase($payment);    }    public function getPayment(string $paymentId): ?Payment    {        return yield $this->persistenceActivity->loadFromDatabase($paymentId);    }    public function deletePayment(string $paymentId): void    {        yield $this->persistenceActivity->deleteFromDatabase($paymentId);    }}```## üß™ **Tests et Validation**### **Tests d'Int√©gration Temporal**```php<?phpnamespace App\Tests\Integration\Temporal;use App\Workflow\Payment\PaymentRequest;use App\Application\Service\Temporal\PaymentWorkflowService;use App\Infrastructure\Temporal\TemporalClientFactory;class TemporalPaymentWorkflowTest extends TestCase{    private PaymentWorkflowService $workflowService;    private TemporalClientFactory $temporalFactory;    protected function setUp(): void    {        $this->temporalFactory = new TemporalClientFactory('localhost', 7233, 'test');        $this->workflowService = new PaymentWorkflowService(            $this->temporalFactory->createClient(),            $this->createMock(LoggerInterface::class)        );    }    public function testPaymentWorkflowExecution(): void    {        $request = new PaymentRequest(            'payment-123',            'org-456',            'user-789',            100.00,            'EUR',            'Test payment'        );                $result = $this->workflowService->processPayment($request);                $this->assertTrue($result->isSuccess());        $this->assertEquals('Payment processed successfully', $result->getMessage());    }    public function testWorkflowStatus(): void    {        $request = new PaymentRequest(            'payment-456',            'org-789',            'user-123',            200.00,            'USD',            'Test payment 2'        );                $this->workflowService->processPayment($request);                $status = $this->workflowService->getWorkflowStatus('payment-payment-456');                $this->assertArrayHasKey('workflowId', $status);        $this->assertArrayHasKey('status', $status);        $this->assertArrayHasKey('isCompleted', $status);    }}```## üìä **Performance et Optimisation**### **Strat√©gies d'Optimisation Temporal**#### **1. Configuration des Timeouts**```phppublic function createOptimizedWorkflowOptions(): WorkflowOptions{    return WorkflowOptions::new()        ->withWorkflowId('payment-workflow-' . uniqid())        ->withWorkflowExecutionTimeout(600) // 10 minutes        ->withWorkflowRunTimeout(600)        ->withWorkflowTaskTimeout(120)        ->withRetryOptions([            'initialInterval' => '1s',            'maximumInterval' => '60s',            'backoffCoefficient' => 2.0,            'maximumAttempts' => 3        ]);}```#### **2. Cache des Workflows**```phppublic function getWorkflowWithCache(string $workflowId): PaymentWorkflowInterface{    if (isset($this->workflowCache[$workflowId])) {        return $this->workflowCache[$workflowId];    }        $workflow = $this->workflowClient->newWorkflowStub(        PaymentWorkflowInterface::class,        $workflowId    );        $this->workflowCache[$workflowId] = $workflow;        return $workflow;}```#### **3. Monitoring et Observabilit√©**```phppublic function getWorkflowMetrics(): array{    return [        'activeWorkflows' => $this->getActiveWorkflowCount(),        'completedWorkflows' => $this->getCompletedWorkflowCount(),        'failedWorkflows' => $this->getFailedWorkflowCount(),        'averageExecutionTime' => $this->getAverageExecutionTime()    ];}```## üéØ **Crit√®res d'Adoption**### **Quand Utiliser Temporal Classique**#### **‚úÖ Avantages**- **Durabilit√©** : √âtat des workflows persist√© automatiquement- **R√©silience** : Reprise automatique apr√®s panne- **Orchestration** : Gestion complexe des processus m√©tier- **Observabilit√©** : Visibilit√© compl√®te sur l'ex√©cution- **Scalabilit√©** : Ex√©cution distribu√©e des workflows#### **‚ùå Inconv√©nients**- **Complexit√©** : Courbe d'apprentissage importante- **Infrastructure** : N√©cessite un serveur Temporal- **Latence** : Overhead pour les op√©rations simples- **Expertise** : √âquipe exp√©riment√©e requise#### **üéØ Crit√®res d'Adoption**- **Processus m√©tier complexes** : Workflows qui n√©cessitent de l'orchestration- **R√©silience critique** : Besoin de reprise automatique apr√®s panne- **Processus longs** : Workflows qui s'√©talent sur plusieurs jours- **Int√©grations multiples** : Orchestration de plusieurs services- **√âquipe exp√©riment√©e** : Ma√Ætrise de Temporal et des workflows- **Infrastructure disponible** : Serveur Temporal op√©rationnel## üöÄ **Votre Prochaine √âtape**{{< chapter-nav >}}  {{< chapter-option     letter="A"     color="green"     title="Je veux voir l'approche CQS avec Temporal"     subtitle="Vous voulez comprendre la s√©paration des responsabilit√©s avec Temporal"    criteria="Performance critique,√âquipe exp√©riment√©e,Architecture complexe,Scalabilit√©"    time="40-50 minutes"    chapter="47"    chapter-title="Stockage Temporal - CQS"    chapter-url="/chapitres/stockage/temporal/chapitre-47-stockage-temporal-cqs/"  >}}    {{< chapter-option     letter="B"     color="yellow"     title="Je veux explorer les autres types de stockage"     subtitle="Vous voulez voir les alternatives √† Temporal"    criteria="Comparaison n√©cessaire,Choix de stockage,Architecture √† d√©finir,Performance √† optimiser"    time="30-40 minutes"    chapter="10"    chapter-title="Choix du Type de Stockage"    chapter-url="/chapitres/fondamentaux/chapitre-10-choix-type-stockage/"  >}}    {{< chapter-option     letter="C"     color="blue"     title="Je veux voir des exemples concrets"     subtitle="Vous voulez comprendre les impl√©mentations pratiques"    criteria="D√©veloppeur exp√©riment√©,Besoin d'exemples pratiques,Impl√©mentation √† faire,Code √† √©crire"    time="Variable"    chapter="0"    chapter-title="Exemples et Impl√©mentations"    chapter-url="/examples/"  >}}    {{< chapter-option     letter="D"     color="purple"     title="Je veux revenir aux fondamentaux"     subtitle="Vous voulez comprendre les concepts de base"    criteria="D√©veloppeur d√©butant,Besoin de comprendre les concepts,Projet √† structurer,√âquipe √† former"    time="45-60 minutes"    chapter="1"    chapter-title="Introduction au Domain-Driven Design et Event Storming"    chapter-url="/chapitres/fondamentaux/chapitre-01-introduction-event-storming-ddd/"  >}}{{< /chapter-nav >}}---*Temporal classique offre une approche puissante pour l'orchestration de processus m√©tier complexes, parfaitement adapt√©e aux besoins de workflows de Gyroscops.*