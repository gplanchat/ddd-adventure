---
title: "Stockage Multi-sources - CQRS"
description: "Impl√©mentation compl√®te CQRS avec Multi-sources pour une architecture hautement scalable"
date: 2024-12-19
draft: true
type: "docs"
weight: 54
---
## üéØ **Contexte et Objectifs**### **L'Architecture Maximale : CQRS avec Multi-sources**Nous arrivons maintenant √† l'approche la plus sophistiqu√©e pour Multi-sources : **CQRS complet**. Cette combinaison offre une architecture hautement scalable et flexible, parfaite pour les syst√®mes n√©cessitant s√©paration maximale des responsabilit√©s et optimisation des performances.#### **Pourquoi CQRS avec Multi-sources ?**- **S√©paration totale** : Commandes et requ√™tes compl√®tement d√©coupl√©es- **Flexibilit√© maximale** : Choix du meilleur stockage pour chaque op√©ration- **Scalabilit√© maximale** : Possibilit√© de scaler ind√©pendamment chaque c√¥t√©- **Performance optimale** : Chaque c√¥t√© optimis√© pour son usage- **R√©silience** : Redondance et failover entre sources- **Maintenabilit√©** : Code plus clair et organis√©### **Contexte Gyroscops**Dans notre √©cosyst√®me **User ‚Üí Organization ‚Üí Workflow ‚Üí Cloud Resources ‚Üí Billing**, CQRS avec Multi-sources est la solution ultime pour :- **Workflows de commande** : Orchestration des processus de modification avec sources optimis√©es- **Workflows de requ√™te** : Optimisation des lectures avec sources sp√©cialis√©es- **Processus de facturation** : S√©paration compl√®te des √©critures et lectures de facturation- **Int√©grations complexes** : Orchestration des int√©grations avec sources multiples## üèóÔ∏è **Architecture CQRS avec Multi-sources**### **S√©paration Compl√®te des Responsabilit√©s**#### **Command Side (Write) avec Multi-sources**- **Command Workflows** : Orchestration des processus de modification- **Command Activities** : Ex√©cution des activit√©s de modification- **Event Handlers** : Gestion des √©v√©nements de domaine- **Command Bus** : Orchestration des commandes- **Write Sources** : Sources optimis√©es pour les √©critures- **Command Models** : Mod√®les optimis√©s pour les √©critures- **Projections** : Mise √† jour des vues mat√©rialis√©es#### **Query Side (Read) avec Multi-sources**- **Query Workflows** : Orchestration des processus de lecture- **Query Activities** : Ex√©cution des activit√©s de lecture- **Search Services** : Services de recherche sp√©cialis√©s- **Query Bus** : Orchestration des requ√™tes- **Read Sources** : Sources optimis√©es pour les lectures- **Query Models** : Mod√®les optimis√©s pour les lectures- **Caches** : Optimisation des performances### **Flux de Donn√©es Complet**```mermaidgraph TD    A[Command] --> B[Command Bus]    B --> C[Command Workflow]    C --> D[Command Activities]    D --> E[Write Sources]    E --> F[SQL Database]    E --> G[Redis Cache]    E --> H[File System]    E --> I[Event Store]        J[Query] --> K[Query Bus]    K --> L[Query Workflow]    L --> M[Query Activities]    M --> N[Read Sources]    N --> O[ElasticSearch]    N --> P[Redis Cache]    N --> Q[SQL Database]    N --> R[Read Models]        S[Event] --> T[Event Handler]    T --> C        U[Projection] --> V[Read Model Update]    V --> R        W[Command Model] --> X[Write Optimization]    X --> E        Y[Query Model] --> Z[Read Optimization]    Z --> N```## üíª **Impl√©mentation Compl√®te**### **1. Command Side avec Multi-sources**#### **Command Bus avec Multi-sources**```php<?phpnamespace App\Application\CommandBus\MultiSource;use App\Domain\Command\CommandInterface;use App\Domain\Command\CommandHandlerInterface;use App\Infrastructure\MultiSource\SourceRouter;use Psr\Log\LoggerInterface;class MultiSourceCqrsCommandBus{    private array $handlers = [];    private array $middleware = [];    private SourceRouter $sourceRouter;    private LoggerInterface $logger;    public function __construct(        SourceRouter $sourceRouter,        LoggerInterface $logger    ) {        $this->sourceRouter = $sourceRouter;        $this->logger = $logger;    }    public function registerHandler(string $commandClass, CommandHandlerInterface $handler): void    {        $this->handlers[$commandClass] = $handler;    }    public function addMiddleware(callable $middleware): void    {        $this->middleware[] = $middleware;    }    public function handle(CommandInterface $command): void    {        $commandClass = get_class($command);                if (!isset($this->handlers[$commandClass])) {            throw new \InvalidArgumentException("No handler registered for command: $commandClass");        }        $handler = $this->handlers[$commandClass];                // Ex√©cuter les middleware        $this->executeMiddleware($command, function() use ($handler, $command) {            $this->logger->info('Executing command via Multi-source CQRS', [                'command' => get_class($command),                'data' => $command->toArray()            ]);                        $handler->handle($command);        });    }    private function executeMiddleware(CommandInterface $command, callable $next): void    {        $middleware = array_reverse($this->middleware);                foreach ($middleware as $mw) {            $next = function() use ($mw, $command, $next) {                return $mw($command, $next);            };        }                $next();    }}```#### **Command Workflow avec Multi-sources**```php<?phpnamespace App\Workflow\Command\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Infrastructure\MultiSource\SourceRouter;#[WorkflowInterface]interface PaymentMultiSourceCqrsCommandWorkflowInterface{    #[WorkflowMethod]    public function processPaymentCommandWithMultiSourceCqrs(PaymentCommandRequest $request): PaymentCommandResult;        #[WorkflowMethod]    public function updatePaymentCommandWithMultiSourceCqrs(PaymentUpdateCommandRequest $request): PaymentCommandResult;        #[WorkflowMethod]    public function deletePaymentCommandWithMultiSourceCqrs(PaymentDeleteCommandRequest $request): PaymentCommandResult;}#[ActivityInterface]interface PaymentMultiSourceCqrsCommandActivityInterface{    #[ActivityMethod]    public function validatePaymentCommand(PaymentCommandRequest $request): ValidationResult;        #[ActivityMethod]    public function executePaymentCommand(PaymentCommandRequest $request): CommandExecutionResult;        #[ActivityMethod]    public function persistToWriteSources(Payment $payment, array $sources): void;        #[ActivityMethod]    public function updateProjections(Payment $payment): void;        #[ActivityMethod]    public function updateCommandModels(Payment $payment): void;}class PaymentMultiSourceCqrsCommandWorkflow implements PaymentMultiSourceCqrsCommandWorkflowInterface{    private PaymentMultiSourceCqrsCommandActivityInterface $commandActivity;    private SourceRouter $sourceRouter;    public function __construct()    {        $this->commandActivity = Workflow::newActivityStub(PaymentMultiSourceCqrsCommandActivityInterface::class);        $this->sourceRouter = Workflow::newActivityStub(SourceRouter::class);    }    public function processPaymentCommandWithMultiSourceCqrs(PaymentCommandRequest $request): PaymentCommandResult    {        try {            // Validation de la commande            $validation = yield $this->commandActivity->validatePaymentCommand($request);                        if (!$validation->isValid()) {                return new PaymentCommandResult(false, $validation->getError());            }                        // Ex√©cution de la commande            $execution = yield $this->commandActivity->executePaymentCommand($request);                        if (!$execution->isSuccess()) {                return new PaymentCommandResult(false, $execution->getError());            }                        // D√©terminer les sources d'√©criture optimales            $writeSources = yield $this->sourceRouter->routeWrite('save', $execution->getPayment());                        // Persister dans les sources d'√©criture            yield $this->commandActivity->persistToWriteSources($execution->getPayment(), $writeSources);                        // Mettre √† jour les projections            yield $this->commandActivity->updateProjections($execution->getPayment());                        // Mettre √† jour les mod√®les de commande            yield $this->commandActivity->updateCommandModels($execution->getPayment());                        return new PaymentCommandResult(true, 'Payment command processed with Multi-source CQRS');                    } catch (\Exception $e) {            return new PaymentCommandResult(false, $e->getMessage());        }    }    public function updatePaymentCommandWithMultiSourceCqrs(PaymentUpdateCommandRequest $request): PaymentCommandResult    {        try {            // Validation de la commande de mise √† jour            $validation = yield $this->commandActivity->validatePaymentCommand($request);                        if (!$validation->isValid()) {                return new PaymentCommandResult(false, $validation->getError());            }                        // Ex√©cution de la mise √† jour            $execution = yield $this->commandActivity->executePaymentCommand($request);                        if (!$execution->isSuccess()) {                return new PaymentCommandResult(false, $execution->getError());            }                        // D√©terminer les sources d'√©criture optimales            $writeSources = yield $this->sourceRouter->routeWrite('update', $execution->getPayment());                        // Persister dans les sources d'√©criture            yield $this->commandActivity->persistToWriteSources($execution->getPayment(), $writeSources);                        // Mettre √† jour les projections            yield $this->commandActivity->updateProjections($execution->getPayment());                        // Mettre √† jour les mod√®les de commande            yield $this->commandActivity->updateCommandModels($execution->getPayment());                        return new PaymentCommandResult(true, 'Payment update command processed with Multi-source CQRS');                    } catch (\Exception $e) {            return new PaymentCommandResult(false, $e->getMessage());        }    }    public function deletePaymentCommandWithMultiSourceCqrs(PaymentDeleteCommandRequest $request): PaymentCommandResult    {        try {            // Validation de la commande de suppression            $validation = yield $this->commandActivity->validatePaymentCommand($request);                        if (!$validation->isValid()) {                return new PaymentCommandResult(false, $validation->getError());            }                        // Ex√©cution de la suppression            $execution = yield $this->commandActivity->executePaymentCommand($request);                        if (!$execution->isSuccess()) {                return new PaymentCommandResult(false, $execution->getError());            }                        // D√©terminer les sources d'√©criture optimales            $writeSources = yield $this->sourceRouter->routeWrite('delete', $execution->getPayment());                        // Persister dans les sources d'√©criture            yield $this->commandActivity->persistToWriteSources($execution->getPayment(), $writeSources);                        // Mettre √† jour les projections            yield $this->commandActivity->updateProjections($execution->getPayment());                        // Mettre √† jour les mod√®les de commande            yield $this->commandActivity->updateCommandModels($execution->getPayment());                        return new PaymentCommandResult(true, 'Payment delete command processed with Multi-source CQRS');                    } catch (\Exception $e) {            return new PaymentCommandResult(false, $e->getMessage());        }    }}```### **2. Query Side avec Multi-sources**#### **Query Bus avec Cache et Multi-sources**```php<?phpnamespace App\Application\QueryBus\MultiSource;use App\Domain\Query\QueryInterface;use App\Domain\Query\QueryHandlerInterface;use App\Infrastructure\MultiSource\SourceRouter;use App\Infrastructure\MultiSource\MultiSourceCacheManager;use Psr\Log\LoggerInterface;class MultiSourceCqrsQueryBus{    private array $handlers = [];    private SourceRouter $sourceRouter;    private MultiSourceCacheManager $cacheManager;    private LoggerInterface $logger;    public function __construct(        SourceRouter $sourceRouter,        MultiSourceCacheManager $cacheManager,        LoggerInterface $logger    ) {        $this->sourceRouter = $sourceRouter;        $this->cacheManager = $cacheManager;        $this->logger = $logger;    }    public function registerHandler(string $queryClass, QueryHandlerInterface $handler): void    {        $this->handlers[$queryClass] = $handler;    }    public function handle(QueryInterface $query): mixed    {        $queryClass = get_class($query);                if (!isset($this->handlers[$queryClass])) {            throw new \InvalidArgumentException("No handler registered for query: $queryClass");        }        // V√©rifier le cache        $cacheKey = $this->generateCacheKey($query);        $cachedResult = $this->cacheManager->get($cacheKey);                if ($cachedResult !== null) {            $this->logger->debug('Query result served from cache', [                'query' => $queryClass,                'cacheKey' => $cacheKey            ]);                        return $cachedResult;        }        // D√©terminer la source de lecture optimale        $readSource = $this->sourceRouter->routeRead($queryClass, $query->toArray());                // Ex√©cuter la requ√™te via la source optimale        $handler = $this->handlers[$queryClass];        $result = $handler->handle($query, $readSource);                // Mettre en cache        $this->cacheManager->set($cacheKey, $result, 300);                $this->logger->info('Query executed and cached via Multi-source CQRS', [            'query' => $queryClass,            'source' => $readSource,            'cacheKey' => $cacheKey        ]);                return $result;    }    private function generateCacheKey(QueryInterface $query): string    {        return 'multi_source_cqrs_query_' . md5(serialize($query));    }}```#### **Query Workflow avec Multi-sources**```php<?phpnamespace App\Workflow\Query\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Infrastructure\MultiSource\SourceRouter;#[WorkflowInterface]interface PaymentMultiSourceCqrsQueryWorkflowInterface{    #[WorkflowMethod]    public function searchPaymentsWithMultiSourceCqrs(PaymentSearchQuery $query): PaymentSearchResult;        #[WorkflowMethod]    public function getPaymentByIdWithMultiSourceCqrs(PaymentByIdQuery $query): ?Payment;        #[WorkflowMethod]    public function getPaymentStatisticsWithMultiSourceCqrs(PaymentStatisticsQuery $query): array;        #[WorkflowMethod]    public function getPaymentAnalyticsWithMultiSourceCqrs(PaymentAnalyticsQuery $query): array;        #[WorkflowMethod]    public function getPaymentTimelineWithMultiSourceCqrs(PaymentTimelineQuery $query): array;}#[ActivityInterface]interface PaymentMultiSourceCqrsQueryActivityInterface{    #[ActivityMethod]    public function searchPaymentsInSource(PaymentSearchQuery $query, string $source): array;        #[ActivityMethod]    public function getPaymentFromSource(string $paymentId, string $source): ?Payment;        #[ActivityMethod]    public function calculatePaymentStatisticsInSource(PaymentStatisticsQuery $query, string $source): array;        #[ActivityMethod]    public function generatePaymentAnalyticsInSource(PaymentAnalyticsQuery $query, string $source): array;        #[ActivityMethod]    public function getEventsByCorrelationId(string $correlationId, string $source): array;        #[ActivityMethod]    public function updateQueryModels(array $events): void;}class PaymentMultiSourceCqrsQueryWorkflow implements PaymentMultiSourceCqrsQueryWorkflowInterface{    private PaymentMultiSourceCqrsQueryActivityInterface $queryActivity;    private SourceRouter $sourceRouter;    public function __construct()    {        $this->queryActivity = Workflow::newActivityStub(PaymentMultiSourceCqrsQueryActivityInterface::class);        $this->sourceRouter = Workflow::newActivityStub(SourceRouter::class);    }    public function searchPaymentsWithMultiSourceCqrs(PaymentSearchQuery $query): PaymentSearchResult    {        try {            // D√©terminer la source de lecture optimale            $readSource = yield $this->sourceRouter->routeRead('search', $query->toArray());                        // Recherche dans la source optimale            $payments = yield $this->queryActivity->searchPaymentsInSource($query, $readSource);                        // Filtrage et tri            $filteredPayments = $this->filterPayments($payments, $query);            $sortedPayments = $this->sortPayments($filteredPayments, $query);                        // Pagination            $paginatedPayments = $this->paginatePayments($sortedPayments, $query);                        return new PaymentSearchResult(                $paginatedPayments,                count($filteredPayments),                $query->getPage(),                $query->getSize()            );                    } catch (\Exception $e) {            return new PaymentSearchResult([], 0, $query->getPage(), $query->getSize());        }    }    public function getPaymentByIdWithMultiSourceCqrs(PaymentByIdQuery $query): ?Payment    {        try {            // D√©terminer la source de lecture optimale            $readSource = yield $this->sourceRouter->routeRead('findById', ['id' => $query->getPaymentId()]);                        return yield $this->queryActivity->getPaymentFromSource($query->getPaymentId(), $readSource);        } catch (\Exception $e) {            return null;        }    }    public function getPaymentStatisticsWithMultiSourceCqrs(PaymentStatisticsQuery $query): array    {        try {            // D√©terminer la source de lecture optimale            $readSource = yield $this->sourceRouter->routeRead('statistics', $query->toArray());                        return yield $this->queryActivity->calculatePaymentStatisticsInSource($query, $readSource);        } catch (\Exception $e) {            return [];        }    }    public function getPaymentAnalyticsWithMultiSourceCqrs(PaymentAnalyticsQuery $query): array    {        try {            // D√©terminer la source de lecture optimale            $readSource = yield $this->sourceRouter->routeRead('analytics', $query->toArray());                        return yield $this->queryActivity->generatePaymentAnalyticsInSource($query, $readSource);        } catch (\Exception $e) {            return [];        }    }    public function getPaymentTimelineWithMultiSourceCqrs(PaymentTimelineQuery $query): array    {        try {            // D√©terminer la source de lecture optimale            $readSource = yield $this->sourceRouter->routeRead('timeline', $query->toArray());                        $events = yield $this->queryActivity->getEventsByCorrelationId($query->getCorrelationId(), $readSource);                        $timeline = [];            foreach ($events as $event) {                $timeline[] = [                    'eventId' => $event->getId(),                    'aggregateId' => $event->getAggregateId(),                    'eventType' => $event->getEventType(),                    'timestamp' => $event->getTimestamp(),                    'data' => $event->toArray(),                    'metadata' => $event->getMetadata()                ];            }                        return $timeline;                    } catch (\Exception $e) {            return [];        }    }    private function filterPayments(array $payments, PaymentSearchQuery $query): array    {        return array_filter($payments, function($payment) use ($query) {            if ($query->getOrganizationId() && $payment->getOrganizationId() !== $query->getOrganizationId()) {                return false;            }                        if ($query->getStatus() && $payment->getStatus() !== $query->getStatus()) {                return false;            }                        if ($query->getMinAmount() && $payment->getAmount() < $query->getMinAmount()) {                return false;            }                        if ($query->getMaxAmount() && $payment->getAmount() > $query->getMaxAmount()) {                return false;            }                        return true;        });    }    private function sortPayments(array $payments, PaymentSearchQuery $query): array    {        $sortField = $query->getSortField() ?? 'createdAt';        $sortDirection = $query->getSortDirection() ?? 'desc';                usort($payments, function($a, $b) use ($sortField, $sortDirection) {            $valueA = $this->getFieldValue($a, $sortField);            $valueB = $this->getFieldValue($b, $sortField);                        if ($sortDirection === 'asc') {                return $valueA <=> $valueB;            } else {                return $valueB <=> $valueA;            }        });                return $payments;    }    private function paginatePayments(array $payments, PaymentSearchQuery $query): array    {        $page = $query->getPage() ?? 1;        $size = $query->getSize() ?? 10;        $offset = ($page - 1) * $size;                return array_slice($payments, $offset, $size);    }    private function getFieldValue(Payment $payment, string $field): mixed    {        switch ($field) {            case 'amount':                return $payment->getAmount();            case 'createdAt':                return $payment->getCreatedAt();            case 'status':                return $payment->getStatus();            default:                return $payment->getCreatedAt();        }    }}```### **3. Service de Projection Avanc√© avec Multi-sources**#### **Service de Projection avec Multi-sources**```php<?phpnamespace App\Application\Service\MultiSource;use App\Domain\Event\DomainEvent;use App\Infrastructure\MultiSource\SourceRouter;use App\Infrastructure\MultiSource\MultiSourceCacheManager;use Psr\Log\LoggerInterface;class MultiSourceCqrsProjectionService{    private SourceRouter $sourceRouter;    private MultiSourceCacheManager $cacheManager;    private LoggerInterface $logger;    public function __construct(        SourceRouter $sourceRouter,        MultiSourceCacheManager $cacheManager,        LoggerInterface $logger    ) {        $this->sourceRouter = $sourceRouter;        $this->cacheManager = $cacheManager;        $this->logger = $logger;    }    public function handleEvent(DomainEvent $event): void    {        try {            $this->logger->info('Handling event via Multi-source CQRS', [                'eventType' => $event->getEventType(),                'eventId' => $event->getId()            ]);            // D√©terminer les sources affect√©es            $affectedSources = $this->determineAffectedSources($event);                        // Mettre √† jour chaque source            foreach ($affectedSources as $source) {                $this->updateSource($source, $event);            }                        // Invalider le cache si n√©cessaire            if ($this->shouldInvalidateCache($event)) {                $this->invalidateCache($event);            }                    } catch (\Exception $e) {            $this->logger->error('Failed to handle event via Multi-source CQRS', [                'eventType' => $event->getEventType(),                'error' => $e->getMessage()            ]);                        throw $e;        }    }    public function rebuildProjection(string $projectionType): void    {        try {            $this->logger->info('Rebuilding projection via Multi-source CQRS', [                'projectionType' => $projectionType            ]);                        // Reconstruire la projection dans toutes les sources pertinentes            $sources = $this->getProjectionSources($projectionType);                        foreach ($sources as $source) {                $this->rebuildProjectionInSource($projectionType, $source);            }                        $this->logger->info('Projection rebuilt successfully via Multi-source CQRS', [                'projectionType' => $projectionType            ]);                    } catch (\Exception $e) {            $this->logger->error('Failed to rebuild projection via Multi-source CQRS', [                'projectionType' => $projectionType,                'error' => $e->getMessage()            ]);                        throw $e;        }    }    private function determineAffectedSources(DomainEvent $event): array    {        $sources = [];                // Toujours affecter la base de donn√©es pour les √©v√©nements critiques        if ($this->isCriticalEvent($event)) {            $sources[] = 'database';        }                // Affecter le cache pour les √©v√©nements de lecture        if ($this->isReadEvent($event)) {            $sources[] = 'cache';        }                // Affecter ElasticSearch pour les √©v√©nements de recherche        if ($this->isSearchEvent($event)) {            $sources[] = 'elasticsearch';        }                // Affecter les Read Models pour les projections        if ($this->isProjectionEvent($event)) {            $sources[] = 'read_models';        }                return $sources;    }    private function updateSource(string $source, DomainEvent $event): void    {        $this->logger->debug('Updating source', [            'source' => $source,            'eventType' => $event->getEventType()        ]);                // Impl√©mentation sp√©cifique √† chaque source        switch ($source) {            case 'database':                $this->updateDatabase($event);                break;            case 'cache':                $this->updateCache($event);                break;            case 'elasticsearch':                $this->updateElasticSearch($event);                break;            case 'read_models':                $this->updateReadModels($event);                break;        }    }    private function shouldInvalidateCache(DomainEvent $event): bool    {        return in_array($event->getEventType(), [            'PaymentUpdated',            'PaymentDeleted',            'PaymentStatusChanged'        ]);    }    private function invalidateCache(DomainEvent $event): void    {        $this->logger->debug('Invalidating cache', [            'eventType' => $event->getEventType()        ]);                // Invalider les caches pertinents        if (isset($event->getData()['paymentId'])) {            $this->cacheManager->deletePayment($event->getData()['paymentId']);        }    }    private function isCriticalEvent(DomainEvent $event): bool    {        return in_array($event->getEventType(), [            'PaymentCreated',            'PaymentUpdated',            'PaymentDeleted'        ]);    }    private function isReadEvent(DomainEvent $event): bool    {        return in_array($event->getEventType(), [            'PaymentViewed',            'PaymentSearched'        ]);    }    private function isSearchEvent(DomainEvent $event): bool    {        return in_array($event->getEventType(), [            'PaymentCreated',            'PaymentUpdated',            'PaymentDeleted'        ]);    }    private function isProjectionEvent(DomainEvent $event): bool    {        return in_array($event->getEventType(), [            'PaymentCreated',            'PaymentUpdated',            'PaymentDeleted',            'PaymentStatusChanged'        ]);    }    private function getProjectionSources(string $projectionType): array    {        switch ($projectionType) {            case 'payment_summary':                return ['database', 'cache', 'elasticsearch'];            case 'payment_analytics':                return ['elasticsearch', 'read_models'];            case 'payment_timeline':                return ['read_models', 'cache'];            default:                return ['database'];        }    }    private function rebuildProjectionInSource(string $projectionType, string $source): void    {        $this->logger->debug('Rebuilding projection in source', [            'projectionType' => $projectionType,            'source' => $source        ]);                // Impl√©mentation sp√©cifique √† chaque source        switch ($source) {            case 'database':                $this->rebuildDatabaseProjection($projectionType);                break;            case 'cache':                $this->rebuildCacheProjection($projectionType);                break;            case 'elasticsearch':                $this->rebuildElasticSearchProjection($projectionType);                break;            case 'read_models':                $this->rebuildReadModelsProjection($projectionType);                break;        }    }    private function updateDatabase(DomainEvent $event): void    {        // Impl√©mentation de la mise √† jour de la base de donn√©es    }    private function updateCache(DomainEvent $event): void    {        // Impl√©mentation de la mise √† jour du cache    }    private function updateElasticSearch(DomainEvent $event): void    {        // Impl√©mentation de la mise √† jour d'ElasticSearch    }    private function updateReadModels(DomainEvent $event): void    {        // Impl√©mentation de la mise √† jour des Read Models    }    private function rebuildDatabaseProjection(string $projectionType): void    {        // Impl√©mentation de la reconstruction de la projection en base de donn√©es    }    private function rebuildCacheProjection(string $projectionType): void    {        // Impl√©mentation de la reconstruction de la projection en cache    }    private function rebuildElasticSearchProjection(string $projectionType): void    {        // Impl√©mentation de la reconstruction de la projection en ElasticSearch    }    private function rebuildReadModelsProjection(string $projectionType): void    {        // Impl√©mentation de la reconstruction de la projection dans les Read Models    }}```## üß™ **Tests et Validation**### **Tests d'Int√©gration CQRS Multi-Sources**```php<?phpnamespace App\Tests\Integration\MultiSource;use App\Workflow\Command\Payment\PaymentCommandRequest;use App\Workflow\Query\Payment\PaymentSearchQuery;use App\Application\CommandBus\MultiSource\MultiSourceCqrsCommandBus;use App\Application\QueryBus\MultiSource\MultiSourceCqrsQueryBus;use App\Infrastructure\MultiSource\SourceRouter;class MultiSourceCqrsTest extends TestCase{    private MultiSourceCqrsCommandBus $commandBus;    private MultiSourceCqrsQueryBus $queryBus;    private SourceRouter $sourceRouter;    protected function setUp(): void    {        $this->sourceRouter = $this->createMock(SourceRouter::class);        $this->commandBus = new MultiSourceCqrsCommandBus(            $this->sourceRouter,            $this->createMock(LoggerInterface::class)        );        $this->queryBus = new MultiSourceCqrsQueryBus(            $this->sourceRouter,            $this->createMock(MultiSourceCacheManager::class),            $this->createMock(LoggerInterface::class)        );    }    public function testCqrsSeparationWithMultiSource(): void    {        // Ex√©cuter une commande avec Multi-source CQRS        $command = new PaymentCommandRequest(            'CREATE',            'payment-123',            'org-456',            'user-789',            100.00,            'EUR',            'Test payment'        );                $this->commandBus->handle($command);                // V√©rifier avec une requ√™te        $query = new PaymentSearchQuery('org-456', 0, 10);        $result = $this->queryBus->handle($query);                $this->assertGreaterThan(0, $result->getTotal());    }    public function testQueryCachingWithMultiSource(): void    {        $query = new PaymentSearchQuery('org-456', 0, 10);                // Premi√®re recherche        $result1 = $this->queryBus->handle($query);                // Deuxi√®me recherche (devrait utiliser le cache)        $result2 = $this->queryBus->handle($query);                $this->assertEquals($result1->getTotal(), $result2->getTotal());    }}```## üìä **Performance et Optimisation**### **Strat√©gies d'Optimisation CQRS Multi-Sources**#### **1. Cache Multi-Niveaux avec Multi-sources**```phppublic function searchPaymentsWithCache(PaymentSearchQuery $query): PaymentSearchResult{    // Cache L1: M√©moire    if (isset($this->memoryCache[$query->getCacheKey()])) {        return $this->memoryCache[$query->getCacheKey()];    }        // Cache L2: Redis    if ($cached = $this->redis->get("payment_search_ms_cqrs:{$query->getCacheKey()}")) {        $result = PaymentSearchResult::fromArray(json_decode($cached, true));        $this->memoryCache[$query->getCacheKey()] = $result;        return $result;    }        // Multi-source CQRS    $result = $this->searchPaymentsWithMultiSourceCqrs($query);        // Mettre en cache    $this->memoryCache[$query->getCacheKey()] = $result;    $this->redis->setex("payment_search_ms_cqrs:{$query->getCacheKey()}", 300, json_encode($result->toArray()));        return $result;}```#### **2. Projections Asynchrones avec Multi-sources**```phppublic function handleEventAsync(DomainEvent $event): void{    // Mettre en queue pour traitement asynchrone    $this->messageBus->dispatch(new ProcessMultiSourceCqrsProjectionCommand($event));}```#### **3. Monitoring des Sources Multi-sources**```phppublic function getMultiSourceCqrsMetrics(): array{    return [        'commandSources' => $this->getCommandSourceMetrics(),        'querySources' => $this->getQuerySourceMetrics(),        'projections' => $this->getProjectionMetrics(),        'cacheHitRate' => $this->getCacheHitRate(),        'sourceHealth' => $this->getSourceHealth(),        'averageExecutionTime' => $this->getAverageExecutionTime()    ];}```## üéØ **Crit√®res d'Adoption**### **Quand Utiliser CQRS avec Multi-sources**#### **‚úÖ Avantages**- **S√©paration totale** : Commandes et requ√™tes compl√®tement d√©coupl√©es- **Flexibilit√© maximale** : Choix du meilleur stockage pour chaque op√©ration- **Scalabilit√© maximale** : Possibilit√© de scaler ind√©pendamment- **Performance optimale** : Chaque c√¥t√© optimis√© pour son usage- **R√©silience** : Redondance et failover entre sources- **Maintenabilit√©** : Code plus clair et organis√©#### **‚ùå Inconv√©nients**- **Complexit√© maximale** : Gestion de plusieurs sources de donn√©es- **Coh√©rence** : Risque d'incoh√©rence entre sources- **Maintenance** : Plus de sources √† maintenir- **Expertise** : √âquipe tr√®s exp√©riment√©e requise- **Co√ªt** : Infrastructure tr√®s co√ªteuse#### **üéØ Crit√®res d'Adoption**- **Syst√®me tr√®s complexe** : Besoins de scalabilit√© maximale- **Donn√©es h√©t√©rog√®nes** : Types de donn√©es diff√©rents n√©cessitant diff√©rents stockages- **Performance critique** : Besoins de performance maximale- **S√©paration des responsabilit√©s** : Besoin de s√©parer clairement les commandes et requ√™tes- **√âquipe tr√®s exp√©riment√©e** : Ma√Ætrise de plusieurs technologies de stockage et CQRS- **Budget important** : Investissement en infrastructure multiple- **Temps de d√©veloppement** : Suffisant pour impl√©menter cette complexit√©- **Maintenance** : √âquipe capable de maintenir cette complexit√©## üöÄ **Votre Prochaine √âtape**{{< chapter-nav >}}  {{< chapter-option     letter="A"     color="green"     title="Je veux voir l'approche Event Sourcing avec Multi-sources"     subtitle="Vous voulez comprendre l'Event Sourcing avec Multi-sources"    criteria="Audit trail critique,√âquipe tr√®s exp√©riment√©e,Architecture complexe,Historique complet"    time="45-60 minutes"    chapter="55"    chapter-title="Stockage Multi-sources - Event Sourcing"    chapter-url="/chapitres/stockage/multi-sources/chapitre-55-stockage-multi-sources-event-sourcing/"  >}}    {{< chapter-option     letter="B"     color="yellow"     title="Je veux explorer les autres types de stockage"     subtitle="Vous voulez voir les alternatives √† Multi-sources"    criteria="Comparaison n√©cessaire,Choix de stockage,Architecture √† d√©finir,Performance √† optimiser"    time="30-40 minutes"    chapter="10"    chapter-title="Choix du Type de Stockage"    chapter-url="/chapitres/fondamentaux/chapitre-10-choix-type-stockage/"  >}}    {{< chapter-option     letter="C"     color="blue"     title="Je veux voir des exemples concrets"     subtitle="Vous voulez comprendre les impl√©mentations pratiques"    criteria="D√©veloppeur exp√©riment√©,Besoin d'exemples pratiques,Impl√©mentation √† faire,Code √† √©crire"    time="Variable"    chapter="0"    chapter-title="Exemples et Impl√©mentations"    chapter-url="/examples/"  >}}    {{< chapter-option     letter="D"     color="purple"     title="Je veux revenir aux fondamentaux"     subtitle="Vous voulez comprendre les concepts de base"    criteria="D√©veloppeur d√©butant,Besoin de comprendre les concepts,Projet √† structurer,√âquipe √† former"    time="45-60 minutes"    chapter="1"    chapter-title="Introduction au Domain-Driven Design et Event Storming"    chapter-url="/chapitres/fondamentaux/chapitre-01-introduction-event-storming-ddd/"  >}}{{< /chapter-nav >}}---*CQRS avec Multi-sources repr√©sente l'√©tat de l'art en mati√®re d'architecture scalable et flexible pour l'orchestration, parfaitement adapt√© aux besoins les plus exigeants de Gyroscops.*