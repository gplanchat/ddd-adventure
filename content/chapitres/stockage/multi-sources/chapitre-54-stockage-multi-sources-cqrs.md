---
title: "Stockage Multi-sources - CQRS"
description: "Implémentation complète CQRS avec Multi-sources pour une architecture hautement scalable"
date: 2024-12-19
draft: true
type: "docs"
weight: 54
---
## 🎯 **Contexte et Objectifs**### **L'Architecture Maximale : CQRS avec Multi-sources**Nous arrivons maintenant à l'approche la plus sophistiquée pour Multi-sources : **CQRS complet**. Cette combinaison offre une architecture hautement scalable et flexible, parfaite pour les systèmes nécessitant séparation maximale des responsabilités et optimisation des performances.#### **Pourquoi CQRS avec Multi-sources ?**- **Séparation totale** : Commandes et requêtes complètement découplées- **Flexibilité maximale** : Choix du meilleur stockage pour chaque opération- **Scalabilité maximale** : Possibilité de scaler indépendamment chaque côté- **Performance optimale** : Chaque côté optimisé pour son usage- **Résilience** : Redondance et failover entre sources- **Maintenabilité** : Code plus clair et organisé### **Contexte Gyroscops**Dans notre écosystème **User → Organization → Workflow → Cloud Resources → Billing**, CQRS avec Multi-sources est la solution ultime pour :- **Workflows de commande** : Orchestration des processus de modification avec sources optimisées- **Workflows de requête** : Optimisation des lectures avec sources spécialisées- **Processus de facturation** : Séparation complète des écritures et lectures de facturation- **Intégrations complexes** : Orchestration des intégrations avec sources multiples## 🏗️ **Architecture CQRS avec Multi-sources**### **Séparation Complète des Responsabilités**#### **Command Side (Write) avec Multi-sources**- **Command Workflows** : Orchestration des processus de modification- **Command Activities** : Exécution des activités de modification- **Event Handlers** : Gestion des événements de domaine- **Command Bus** : Orchestration des commandes- **Write Sources** : Sources optimisées pour les écritures- **Command Models** : Modèles optimisés pour les écritures- **Projections** : Mise à jour des vues matérialisées#### **Query Side (Read) avec Multi-sources**- **Query Workflows** : Orchestration des processus de lecture- **Query Activities** : Exécution des activités de lecture- **Search Services** : Services de recherche spécialisés- **Query Bus** : Orchestration des requêtes- **Read Sources** : Sources optimisées pour les lectures- **Query Models** : Modèles optimisés pour les lectures- **Caches** : Optimisation des performances### **Flux de Données Complet**```mermaidgraph TD    A[Command] --> B[Command Bus]    B --> C[Command Workflow]    C --> D[Command Activities]    D --> E[Write Sources]    E --> F[SQL Database]    E --> G[Redis Cache]    E --> H[File System]    E --> I[Event Store]        J[Query] --> K[Query Bus]    K --> L[Query Workflow]    L --> M[Query Activities]    M --> N[Read Sources]    N --> O[ElasticSearch]    N --> P[Redis Cache]    N --> Q[SQL Database]    N --> R[Read Models]        S[Event] --> T[Event Handler]    T --> C        U[Projection] --> V[Read Model Update]    V --> R        W[Command Model] --> X[Write Optimization]    X --> E        Y[Query Model] --> Z[Read Optimization]    Z --> N```## 💻 **Implémentation Complète**### **1. Command Side avec Multi-sources**#### **Command Bus avec Multi-sources**```php<?phpnamespace App\Application\CommandBus\MultiSource;use App\Domain\Command\CommandInterface;use App\Domain\Command\CommandHandlerInterface;use App\Infrastructure\MultiSource\SourceRouter;use Psr\Log\LoggerInterface;class MultiSourceCqrsCommandBus{    private array $handlers = [];    private array $middleware = [];    private SourceRouter $sourceRouter;    private LoggerInterface $logger;    public function __construct(        SourceRouter $sourceRouter,        LoggerInterface $logger    ) {        $this->sourceRouter = $sourceRouter;        $this->logger = $logger;    }    public function registerHandler(string $commandClass, CommandHandlerInterface $handler): void    {        $this->handlers[$commandClass] = $handler;    }    public function addMiddleware(callable $middleware): void    {        $this->middleware[] = $middleware;    }    public function handle(CommandInterface $command): void    {        $commandClass = get_class($command);                if (!isset($this->handlers[$commandClass])) {            throw new \InvalidArgumentException("No handler registered for command: $commandClass");        }        $handler = $this->handlers[$commandClass];                // Exécuter les middleware        $this->executeMiddleware($command, function() use ($handler, $command) {            $this->logger->info('Executing command via Multi-source CQRS', [                'command' => get_class($command),                'data' => $command->toArray()            ]);                        $handler->handle($command);        });    }    private function executeMiddleware(CommandInterface $command, callable $next): void    {        $middleware = array_reverse($this->middleware);                foreach ($middleware as $mw) {            $next = function() use ($mw, $command, $next) {                return $mw($command, $next);            };        }                $next();    }}```#### **Command Workflow avec Multi-sources**```php<?phpnamespace App\Workflow\Command\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Infrastructure\MultiSource\SourceRouter;#[WorkflowInterface]interface PaymentMultiSourceCqrsCommandWorkflowInterface{    #[WorkflowMethod]    public function processPaymentCommandWithMultiSourceCqrs(PaymentCommandRequest $request): PaymentCommandResult;        #[WorkflowMethod]    public function updatePaymentCommandWithMultiSourceCqrs(PaymentUpdateCommandRequest $request): PaymentCommandResult;        #[WorkflowMethod]    public function deletePaymentCommandWithMultiSourceCqrs(PaymentDeleteCommandRequest $request): PaymentCommandResult;}#[ActivityInterface]interface PaymentMultiSourceCqrsCommandActivityInterface{    #[ActivityMethod]    public function validatePaymentCommand(PaymentCommandRequest $request): ValidationResult;        #[ActivityMethod]    public function executePaymentCommand(PaymentCommandRequest $request): CommandExecutionResult;        #[ActivityMethod]    public function persistToWriteSources(Payment $payment, array $sources): void;        #[ActivityMethod]    public function updateProjections(Payment $payment): void;        #[ActivityMethod]    public function updateCommandModels(Payment $payment): void;}class PaymentMultiSourceCqrsCommandWorkflow implements PaymentMultiSourceCqrsCommandWorkflowInterface{    private PaymentMultiSourceCqrsCommandActivityInterface $commandActivity;    private SourceRouter $sourceRouter;    public function __construct()    {        $this->commandActivity = Workflow::newActivityStub(PaymentMultiSourceCqrsCommandActivityInterface::class);        $this->sourceRouter = Workflow::newActivityStub(SourceRouter::class);    }    public function processPaymentCommandWithMultiSourceCqrs(PaymentCommandRequest $request): PaymentCommandResult    {        try {            // Validation de la commande            $validation = yield $this->commandActivity->validatePaymentCommand($request);                        if (!$validation->isValid()) {                return new PaymentCommandResult(false, $validation->getError());            }                        // Exécution de la commande            $execution = yield $this->commandActivity->executePaymentCommand($request);                        if (!$execution->isSuccess()) {                return new PaymentCommandResult(false, $execution->getError());            }                        // Déterminer les sources d'écriture optimales            $writeSources = yield $this->sourceRouter->routeWrite('save', $execution->getPayment());                        // Persister dans les sources d'écriture            yield $this->commandActivity->persistToWriteSources($execution->getPayment(), $writeSources);                        // Mettre à jour les projections            yield $this->commandActivity->updateProjections($execution->getPayment());                        // Mettre à jour les modèles de commande            yield $this->commandActivity->updateCommandModels($execution->getPayment());                        return new PaymentCommandResult(true, 'Payment command processed with Multi-source CQRS');                    } catch (\Exception $e) {            return new PaymentCommandResult(false, $e->getMessage());        }    }    public function updatePaymentCommandWithMultiSourceCqrs(PaymentUpdateCommandRequest $request): PaymentCommandResult    {        try {            // Validation de la commande de mise à jour            $validation = yield $this->commandActivity->validatePaymentCommand($request);                        if (!$validation->isValid()) {                return new PaymentCommandResult(false, $validation->getError());            }                        // Exécution de la mise à jour            $execution = yield $this->commandActivity->executePaymentCommand($request);                        if (!$execution->isSuccess()) {                return new PaymentCommandResult(false, $execution->getError());            }                        // Déterminer les sources d'écriture optimales            $writeSources = yield $this->sourceRouter->routeWrite('update', $execution->getPayment());                        // Persister dans les sources d'écriture            yield $this->commandActivity->persistToWriteSources($execution->getPayment(), $writeSources);                        // Mettre à jour les projections            yield $this->commandActivity->updateProjections($execution->getPayment());                        // Mettre à jour les modèles de commande            yield $this->commandActivity->updateCommandModels($execution->getPayment());                        return new PaymentCommandResult(true, 'Payment update command processed with Multi-source CQRS');                    } catch (\Exception $e) {            return new PaymentCommandResult(false, $e->getMessage());        }    }    public function deletePaymentCommandWithMultiSourceCqrs(PaymentDeleteCommandRequest $request): PaymentCommandResult    {        try {            // Validation de la commande de suppression            $validation = yield $this->commandActivity->validatePaymentCommand($request);                        if (!$validation->isValid()) {                return new PaymentCommandResult(false, $validation->getError());            }                        // Exécution de la suppression            $execution = yield $this->commandActivity->executePaymentCommand($request);                        if (!$execution->isSuccess()) {                return new PaymentCommandResult(false, $execution->getError());            }                        // Déterminer les sources d'écriture optimales            $writeSources = yield $this->sourceRouter->routeWrite('delete', $execution->getPayment());                        // Persister dans les sources d'écriture            yield $this->commandActivity->persistToWriteSources($execution->getPayment(), $writeSources);                        // Mettre à jour les projections            yield $this->commandActivity->updateProjections($execution->getPayment());                        // Mettre à jour les modèles de commande            yield $this->commandActivity->updateCommandModels($execution->getPayment());                        return new PaymentCommandResult(true, 'Payment delete command processed with Multi-source CQRS');                    } catch (\Exception $e) {            return new PaymentCommandResult(false, $e->getMessage());        }    }}```### **2. Query Side avec Multi-sources**#### **Query Bus avec Cache et Multi-sources**```php<?phpnamespace App\Application\QueryBus\MultiSource;use App\Domain\Query\QueryInterface;use App\Domain\Query\QueryHandlerInterface;use App\Infrastructure\MultiSource\SourceRouter;use App\Infrastructure\MultiSource\MultiSourceCacheManager;use Psr\Log\LoggerInterface;class MultiSourceCqrsQueryBus{    private array $handlers = [];    private SourceRouter $sourceRouter;    private MultiSourceCacheManager $cacheManager;    private LoggerInterface $logger;    public function __construct(        SourceRouter $sourceRouter,        MultiSourceCacheManager $cacheManager,        LoggerInterface $logger    ) {        $this->sourceRouter = $sourceRouter;        $this->cacheManager = $cacheManager;        $this->logger = $logger;    }    public function registerHandler(string $queryClass, QueryHandlerInterface $handler): void    {        $this->handlers[$queryClass] = $handler;    }    public function handle(QueryInterface $query): mixed    {        $queryClass = get_class($query);                if (!isset($this->handlers[$queryClass])) {            throw new \InvalidArgumentException("No handler registered for query: $queryClass");        }        // Vérifier le cache        $cacheKey = $this->generateCacheKey($query);        $cachedResult = $this->cacheManager->get($cacheKey);                if ($cachedResult !== null) {            $this->logger->debug('Query result served from cache', [                'query' => $queryClass,                'cacheKey' => $cacheKey            ]);                        return $cachedResult;        }        // Déterminer la source de lecture optimale        $readSource = $this->sourceRouter->routeRead($queryClass, $query->toArray());                // Exécuter la requête via la source optimale        $handler = $this->handlers[$queryClass];        $result = $handler->handle($query, $readSource);                // Mettre en cache        $this->cacheManager->set($cacheKey, $result, 300);                $this->logger->info('Query executed and cached via Multi-source CQRS', [            'query' => $queryClass,            'source' => $readSource,            'cacheKey' => $cacheKey        ]);                return $result;    }    private function generateCacheKey(QueryInterface $query): string    {        return 'multi_source_cqrs_query_' . md5(serialize($query));    }}```#### **Query Workflow avec Multi-sources**```php<?phpnamespace App\Workflow\Query\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Infrastructure\MultiSource\SourceRouter;#[WorkflowInterface]interface PaymentMultiSourceCqrsQueryWorkflowInterface{    #[WorkflowMethod]    public function searchPaymentsWithMultiSourceCqrs(PaymentSearchQuery $query): PaymentSearchResult;        #[WorkflowMethod]    public function getPaymentByIdWithMultiSourceCqrs(PaymentByIdQuery $query): ?Payment;        #[WorkflowMethod]    public function getPaymentStatisticsWithMultiSourceCqrs(PaymentStatisticsQuery $query): array;        #[WorkflowMethod]    public function getPaymentAnalyticsWithMultiSourceCqrs(PaymentAnalyticsQuery $query): array;        #[WorkflowMethod]    public function getPaymentTimelineWithMultiSourceCqrs(PaymentTimelineQuery $query): array;}#[ActivityInterface]interface PaymentMultiSourceCqrsQueryActivityInterface{    #[ActivityMethod]    public function searchPaymentsInSource(PaymentSearchQuery $query, string $source): array;        #[ActivityMethod]    public function getPaymentFromSource(string $paymentId, string $source): ?Payment;        #[ActivityMethod]    public function calculatePaymentStatisticsInSource(PaymentStatisticsQuery $query, string $source): array;        #[ActivityMethod]    public function generatePaymentAnalyticsInSource(PaymentAnalyticsQuery $query, string $source): array;        #[ActivityMethod]    public function getEventsByCorrelationId(string $correlationId, string $source): array;        #[ActivityMethod]    public function updateQueryModels(array $events): void;}class PaymentMultiSourceCqrsQueryWorkflow implements PaymentMultiSourceCqrsQueryWorkflowInterface{    private PaymentMultiSourceCqrsQueryActivityInterface $queryActivity;    private SourceRouter $sourceRouter;    public function __construct()    {        $this->queryActivity = Workflow::newActivityStub(PaymentMultiSourceCqrsQueryActivityInterface::class);        $this->sourceRouter = Workflow::newActivityStub(SourceRouter::class);    }    public function searchPaymentsWithMultiSourceCqrs(PaymentSearchQuery $query): PaymentSearchResult    {        try {            // Déterminer la source de lecture optimale            $readSource = yield $this->sourceRouter->routeRead('search', $query->toArray());                        // Recherche dans la source optimale            $payments = yield $this->queryActivity->searchPaymentsInSource($query, $readSource);                        // Filtrage et tri            $filteredPayments = $this->filterPayments($payments, $query);            $sortedPayments = $this->sortPayments($filteredPayments, $query);                        // Pagination            $paginatedPayments = $this->paginatePayments($sortedPayments, $query);                        return new PaymentSearchResult(                $paginatedPayments,                count($filteredPayments),                $query->getPage(),                $query->getSize()            );                    } catch (\Exception $e) {            return new PaymentSearchResult([], 0, $query->getPage(), $query->getSize());        }    }    public function getPaymentByIdWithMultiSourceCqrs(PaymentByIdQuery $query): ?Payment    {        try {            // Déterminer la source de lecture optimale            $readSource = yield $this->sourceRouter->routeRead('findById', ['id' => $query->getPaymentId()]);                        return yield $this->queryActivity->getPaymentFromSource($query->getPaymentId(), $readSource);        } catch (\Exception $e) {            return null;        }    }    public function getPaymentStatisticsWithMultiSourceCqrs(PaymentStatisticsQuery $query): array    {        try {            // Déterminer la source de lecture optimale            $readSource = yield $this->sourceRouter->routeRead('statistics', $query->toArray());                        return yield $this->queryActivity->calculatePaymentStatisticsInSource($query, $readSource);        } catch (\Exception $e) {            return [];        }    }    public function getPaymentAnalyticsWithMultiSourceCqrs(PaymentAnalyticsQuery $query): array    {        try {            // Déterminer la source de lecture optimale            $readSource = yield $this->sourceRouter->routeRead('analytics', $query->toArray());                        return yield $this->queryActivity->generatePaymentAnalyticsInSource($query, $readSource);        } catch (\Exception $e) {            return [];        }    }    public function getPaymentTimelineWithMultiSourceCqrs(PaymentTimelineQuery $query): array    {        try {            // Déterminer la source de lecture optimale            $readSource = yield $this->sourceRouter->routeRead('timeline', $query->toArray());                        $events = yield $this->queryActivity->getEventsByCorrelationId($query->getCorrelationId(), $readSource);                        $timeline = [];            foreach ($events as $event) {                $timeline[] = [                    'eventId' => $event->getId(),                    'aggregateId' => $event->getAggregateId(),                    'eventType' => $event->getEventType(),                    'timestamp' => $event->getTimestamp(),                    'data' => $event->toArray(),                    'metadata' => $event->getMetadata()                ];            }                        return $timeline;                    } catch (\Exception $e) {            return [];        }    }    private function filterPayments(array $payments, PaymentSearchQuery $query): array    {        return array_filter($payments, function($payment) use ($query) {            if ($query->getOrganizationId() && $payment->getOrganizationId() !== $query->getOrganizationId()) {                return false;            }                        if ($query->getStatus() && $payment->getStatus() !== $query->getStatus()) {                return false;            }                        if ($query->getMinAmount() && $payment->getAmount() < $query->getMinAmount()) {                return false;            }                        if ($query->getMaxAmount() && $payment->getAmount() > $query->getMaxAmount()) {                return false;            }                        return true;        });    }    private function sortPayments(array $payments, PaymentSearchQuery $query): array    {        $sortField = $query->getSortField() ?? 'createdAt';        $sortDirection = $query->getSortDirection() ?? 'desc';                usort($payments, function($a, $b) use ($sortField, $sortDirection) {            $valueA = $this->getFieldValue($a, $sortField);            $valueB = $this->getFieldValue($b, $sortField);                        if ($sortDirection === 'asc') {                return $valueA <=> $valueB;            } else {                return $valueB <=> $valueA;            }        });                return $payments;    }    private function paginatePayments(array $payments, PaymentSearchQuery $query): array    {        $page = $query->getPage() ?? 1;        $size = $query->getSize() ?? 10;        $offset = ($page - 1) * $size;                return array_slice($payments, $offset, $size);    }    private function getFieldValue(Payment $payment, string $field): mixed    {        switch ($field) {            case 'amount':                return $payment->getAmount();            case 'createdAt':                return $payment->getCreatedAt();            case 'status':                return $payment->getStatus();            default:                return $payment->getCreatedAt();        }    }}```### **3. Service de Projection Avancé avec Multi-sources**#### **Service de Projection avec Multi-sources**```php<?phpnamespace App\Application\Service\MultiSource;use App\Domain\Event\DomainEvent;use App\Infrastructure\MultiSource\SourceRouter;use App\Infrastructure\MultiSource\MultiSourceCacheManager;use Psr\Log\LoggerInterface;class MultiSourceCqrsProjectionService{    private SourceRouter $sourceRouter;    private MultiSourceCacheManager $cacheManager;    private LoggerInterface $logger;    public function __construct(        SourceRouter $sourceRouter,        MultiSourceCacheManager $cacheManager,        LoggerInterface $logger    ) {        $this->sourceRouter = $sourceRouter;        $this->cacheManager = $cacheManager;        $this->logger = $logger;    }    public function handleEvent(DomainEvent $event): void    {        try {            $this->logger->info('Handling event via Multi-source CQRS', [                'eventType' => $event->getEventType(),                'eventId' => $event->getId()            ]);            // Déterminer les sources affectées            $affectedSources = $this->determineAffectedSources($event);                        // Mettre à jour chaque source            foreach ($affectedSources as $source) {                $this->updateSource($source, $event);            }                        // Invalider le cache si nécessaire            if ($this->shouldInvalidateCache($event)) {                $this->invalidateCache($event);            }                    } catch (\Exception $e) {            $this->logger->error('Failed to handle event via Multi-source CQRS', [                'eventType' => $event->getEventType(),                'error' => $e->getMessage()            ]);                        throw $e;        }    }    public function rebuildProjection(string $projectionType): void    {        try {            $this->logger->info('Rebuilding projection via Multi-source CQRS', [                'projectionType' => $projectionType            ]);                        // Reconstruire la projection dans toutes les sources pertinentes            $sources = $this->getProjectionSources($projectionType);                        foreach ($sources as $source) {                $this->rebuildProjectionInSource($projectionType, $source);            }                        $this->logger->info('Projection rebuilt successfully via Multi-source CQRS', [                'projectionType' => $projectionType            ]);                    } catch (\Exception $e) {            $this->logger->error('Failed to rebuild projection via Multi-source CQRS', [                'projectionType' => $projectionType,                'error' => $e->getMessage()            ]);                        throw $e;        }    }    private function determineAffectedSources(DomainEvent $event): array    {        $sources = [];                // Toujours affecter la base de données pour les événements critiques        if ($this->isCriticalEvent($event)) {            $sources[] = 'database';        }                // Affecter le cache pour les événements de lecture        if ($this->isReadEvent($event)) {            $sources[] = 'cache';        }                // Affecter ElasticSearch pour les événements de recherche        if ($this->isSearchEvent($event)) {            $sources[] = 'elasticsearch';        }                // Affecter les Read Models pour les projections        if ($this->isProjectionEvent($event)) {            $sources[] = 'read_models';        }                return $sources;    }    private function updateSource(string $source, DomainEvent $event): void    {        $this->logger->debug('Updating source', [            'source' => $source,            'eventType' => $event->getEventType()        ]);                // Implémentation spécifique à chaque source        switch ($source) {            case 'database':                $this->updateDatabase($event);                break;            case 'cache':                $this->updateCache($event);                break;            case 'elasticsearch':                $this->updateElasticSearch($event);                break;            case 'read_models':                $this->updateReadModels($event);                break;        }    }    private function shouldInvalidateCache(DomainEvent $event): bool    {        return in_array($event->getEventType(), [            'PaymentUpdated',            'PaymentDeleted',            'PaymentStatusChanged'        ]);    }    private function invalidateCache(DomainEvent $event): void    {        $this->logger->debug('Invalidating cache', [            'eventType' => $event->getEventType()        ]);                // Invalider les caches pertinents        if (isset($event->getData()['paymentId'])) {            $this->cacheManager->deletePayment($event->getData()['paymentId']);        }    }    private function isCriticalEvent(DomainEvent $event): bool    {        return in_array($event->getEventType(), [            'PaymentCreated',            'PaymentUpdated',            'PaymentDeleted'        ]);    }    private function isReadEvent(DomainEvent $event): bool    {        return in_array($event->getEventType(), [            'PaymentViewed',            'PaymentSearched'        ]);    }    private function isSearchEvent(DomainEvent $event): bool    {        return in_array($event->getEventType(), [            'PaymentCreated',            'PaymentUpdated',            'PaymentDeleted'        ]);    }    private function isProjectionEvent(DomainEvent $event): bool    {        return in_array($event->getEventType(), [            'PaymentCreated',            'PaymentUpdated',            'PaymentDeleted',            'PaymentStatusChanged'        ]);    }    private function getProjectionSources(string $projectionType): array    {        switch ($projectionType) {            case 'payment_summary':                return ['database', 'cache', 'elasticsearch'];            case 'payment_analytics':                return ['elasticsearch', 'read_models'];            case 'payment_timeline':                return ['read_models', 'cache'];            default:                return ['database'];        }    }    private function rebuildProjectionInSource(string $projectionType, string $source): void    {        $this->logger->debug('Rebuilding projection in source', [            'projectionType' => $projectionType,            'source' => $source        ]);                // Implémentation spécifique à chaque source        switch ($source) {            case 'database':                $this->rebuildDatabaseProjection($projectionType);                break;            case 'cache':                $this->rebuildCacheProjection($projectionType);                break;            case 'elasticsearch':                $this->rebuildElasticSearchProjection($projectionType);                break;            case 'read_models':                $this->rebuildReadModelsProjection($projectionType);                break;        }    }    private function updateDatabase(DomainEvent $event): void    {        // Implémentation de la mise à jour de la base de données    }    private function updateCache(DomainEvent $event): void    {        // Implémentation de la mise à jour du cache    }    private function updateElasticSearch(DomainEvent $event): void    {        // Implémentation de la mise à jour d'ElasticSearch    }    private function updateReadModels(DomainEvent $event): void    {        // Implémentation de la mise à jour des Read Models    }    private function rebuildDatabaseProjection(string $projectionType): void    {        // Implémentation de la reconstruction de la projection en base de données    }    private function rebuildCacheProjection(string $projectionType): void    {        // Implémentation de la reconstruction de la projection en cache    }    private function rebuildElasticSearchProjection(string $projectionType): void    {        // Implémentation de la reconstruction de la projection en ElasticSearch    }    private function rebuildReadModelsProjection(string $projectionType): void    {        // Implémentation de la reconstruction de la projection dans les Read Models    }}```## 🧪 **Tests et Validation**### **Tests d'Intégration CQRS Multi-Sources**```php<?phpnamespace App\Tests\Integration\MultiSource;use App\Workflow\Command\Payment\PaymentCommandRequest;use App\Workflow\Query\Payment\PaymentSearchQuery;use App\Application\CommandBus\MultiSource\MultiSourceCqrsCommandBus;use App\Application\QueryBus\MultiSource\MultiSourceCqrsQueryBus;use App\Infrastructure\MultiSource\SourceRouter;class MultiSourceCqrsTest extends TestCase{    private MultiSourceCqrsCommandBus $commandBus;    private MultiSourceCqrsQueryBus $queryBus;    private SourceRouter $sourceRouter;    protected function setUp(): void    {        $this->sourceRouter = $this->createMock(SourceRouter::class);        $this->commandBus = new MultiSourceCqrsCommandBus(            $this->sourceRouter,            $this->createMock(LoggerInterface::class)        );        $this->queryBus = new MultiSourceCqrsQueryBus(            $this->sourceRouter,            $this->createMock(MultiSourceCacheManager::class),            $this->createMock(LoggerInterface::class)        );    }    public function testCqrsSeparationWithMultiSource(): void    {        // Exécuter une commande avec Multi-source CQRS        $command = new PaymentCommandRequest(            'CREATE',            'payment-123',            'org-456',            'user-789',            100.00,            'EUR',            'Test payment'        );                $this->commandBus->handle($command);                // Vérifier avec une requête        $query = new PaymentSearchQuery('org-456', 0, 10);        $result = $this->queryBus->handle($query);                $this->assertGreaterThan(0, $result->getTotal());    }    public function testQueryCachingWithMultiSource(): void    {        $query = new PaymentSearchQuery('org-456', 0, 10);                // Première recherche        $result1 = $this->queryBus->handle($query);                // Deuxième recherche (devrait utiliser le cache)        $result2 = $this->queryBus->handle($query);                $this->assertEquals($result1->getTotal(), $result2->getTotal());    }}```## 📊 **Performance et Optimisation**### **Stratégies d'Optimisation CQRS Multi-Sources**#### **1. Cache Multi-Niveaux avec Multi-sources**```phppublic function searchPaymentsWithCache(PaymentSearchQuery $query): PaymentSearchResult{    // Cache L1: Mémoire    if (isset($this->memoryCache[$query->getCacheKey()])) {        return $this->memoryCache[$query->getCacheKey()];    }        // Cache L2: Redis    if ($cached = $this->redis->get("payment_search_ms_cqrs:{$query->getCacheKey()}")) {        $result = PaymentSearchResult::fromArray(json_decode($cached, true));        $this->memoryCache[$query->getCacheKey()] = $result;        return $result;    }        // Multi-source CQRS    $result = $this->searchPaymentsWithMultiSourceCqrs($query);        // Mettre en cache    $this->memoryCache[$query->getCacheKey()] = $result;    $this->redis->setex("payment_search_ms_cqrs:{$query->getCacheKey()}", 300, json_encode($result->toArray()));        return $result;}```#### **2. Projections Asynchrones avec Multi-sources**```phppublic function handleEventAsync(DomainEvent $event): void{    // Mettre en queue pour traitement asynchrone    $this->messageBus->dispatch(new ProcessMultiSourceCqrsProjectionCommand($event));}```#### **3. Monitoring des Sources Multi-sources**```phppublic function getMultiSourceCqrsMetrics(): array{    return [        'commandSources' => $this->getCommandSourceMetrics(),        'querySources' => $this->getQuerySourceMetrics(),        'projections' => $this->getProjectionMetrics(),        'cacheHitRate' => $this->getCacheHitRate(),        'sourceHealth' => $this->getSourceHealth(),        'averageExecutionTime' => $this->getAverageExecutionTime()    ];}```## 🎯 **Critères d'Adoption**### **Quand Utiliser CQRS avec Multi-sources**#### **✅ Avantages**- **Séparation totale** : Commandes et requêtes complètement découplées- **Flexibilité maximale** : Choix du meilleur stockage pour chaque opération- **Scalabilité maximale** : Possibilité de scaler indépendamment- **Performance optimale** : Chaque côté optimisé pour son usage- **Résilience** : Redondance et failover entre sources- **Maintenabilité** : Code plus clair et organisé#### **❌ Inconvénients**- **Complexité maximale** : Gestion de plusieurs sources de données- **Cohérence** : Risque d'incohérence entre sources- **Maintenance** : Plus de sources à maintenir- **Expertise** : Équipe très expérimentée requise- **Coût** : Infrastructure très coûteuse#### **🎯 Critères d'Adoption**- **Système très complexe** : Besoins de scalabilité maximale- **Données hétérogènes** : Types de données différents nécessitant différents stockages- **Performance critique** : Besoins de performance maximale- **Séparation des responsabilités** : Besoin de séparer clairement les commandes et requêtes- **Équipe très expérimentée** : Maîtrise de plusieurs technologies de stockage et CQRS- **Budget important** : Investissement en infrastructure multiple- **Temps de développement** : Suffisant pour implémenter cette complexité- **Maintenance** : Équipe capable de maintenir cette complexité## 🚀 **Votre Prochaine Étape**{{< chapter-nav >}}  {{< chapter-option     letter="A"     color="green"     title="Je veux voir l'approche Event Sourcing avec Multi-sources"     subtitle="Vous voulez comprendre l'Event Sourcing avec Multi-sources"    criteria="Audit trail critique,Équipe très expérimentée,Architecture complexe,Historique complet"    time="45-60 minutes"    chapter="55"    chapter-title="Stockage Multi-sources - Event Sourcing"    chapter-url="/chapitres/stockage/multi-sources/chapitre-55-stockage-multi-sources-event-sourcing/"  >}}    {{< chapter-option     letter="B"     color="yellow"     title="Je veux explorer les autres types de stockage"     subtitle="Vous voulez voir les alternatives à Multi-sources"    criteria="Comparaison nécessaire,Choix de stockage,Architecture à définir,Performance à optimiser"    time="30-40 minutes"    chapter="10"    chapter-title="Choix du Type de Stockage"    chapter-url="/chapitres/fondamentaux/chapitre-10-choix-type-stockage/"  >}}    {{< chapter-option     letter="C"     color="blue"     title="Je veux voir des exemples concrets"     subtitle="Vous voulez comprendre les implémentations pratiques"    criteria="Développeur expérimenté,Besoin d'exemples pratiques,Implémentation à faire,Code à écrire"    time="Variable"    chapter="0"    chapter-title="Exemples et Implémentations"    chapter-url="/examples/"  >}}    {{< chapter-option     letter="D"     color="purple"     title="Je veux revenir aux fondamentaux"     subtitle="Vous voulez comprendre les concepts de base"    criteria="Développeur débutant,Besoin de comprendre les concepts,Projet à structurer,Équipe à former"    time="45-60 minutes"    chapter="1"    chapter-title="Introduction au Domain-Driven Design et Event Storming"    chapter-url="/chapitres/fondamentaux/chapitre-01-introduction-event-storming-ddd/"  >}}{{< /chapter-nav >}}---*CQRS avec Multi-sources représente l'état de l'art en matière d'architecture scalable et flexible pour l'orchestration, parfaitement adapté aux besoins les plus exigeants de Gyroscops.*