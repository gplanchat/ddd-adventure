---
title: "Stockage Multi-sources - CQS"
description: "Impl√©mentation Command Query Separation avec Multi-sources pour optimiser les performances"
date: 2024-12-19
draft: true
type: "docs"
weight: 53
---
## üéØ **Contexte et Objectifs**### **Pourquoi CQS avec Multi-sources ?**La combinaison CQS avec Multi-sources offre une architecture optimis√©e qui s√©pare clairement les responsabilit√©s tout en exploitant les avantages de diff√©rents types de stockage. Cette approche permet d'optimiser chaque c√¥t√© (commandes et requ√™tes) avec les sources les plus appropri√©es.#### **Avantages de CQS avec Multi-sources**- **Performance optimis√©e** : S√©paration claire entre √©criture et lecture- **Flexibilit√© maximale** : Choix du meilleur stockage pour chaque op√©ration- **Scalabilit√©** : Possibilit√© de scaler ind√©pendamment chaque c√¥t√©- **R√©silience** : Redondance et failover entre sources- **Maintenabilit√©** : Code plus clair et organis√©### **Contexte Gyroscops**Dans notre √©cosyst√®me **User ‚Üí Organization ‚Üí Workflow ‚Üí Cloud Resources ‚Üí Billing**, CQS avec Multi-sources est particuli√®rement pertinent pour :- **Workflows de commande** : Orchestration des processus de modification avec sources optimis√©es- **Workflows de requ√™te** : Optimisation des lectures avec sources sp√©cialis√©es- **Processus de facturation** : S√©paration des √©critures et lectures de facturation- **Int√©grations complexes** : Orchestration des int√©grations avec sources multiples## üèóÔ∏è **Architecture CQS avec Multi-sources**### **S√©paration des Responsabilit√©s**#### **C√¥t√© Commande (Write) avec Multi-sources**- **Command Workflows** : Orchestration des processus de modification- **Command Activities** : Ex√©cution des activit√©s de modification- **Event Handlers** : Gestion des √©v√©nements de domaine- **Command Bus** : Orchestration des commandes- **Write Sources** : Sources optimis√©es pour les √©critures- **Command Models** : Mod√®les optimis√©s pour les √©critures#### **C√¥t√© Requ√™te (Read) avec Multi-sources**- **Query Workflows** : Orchestration des processus de lecture- **Query Activities** : Ex√©cution des activit√©s de lecture- **Search Services** : Services de recherche sp√©cialis√©s- **Query Bus** : Orchestration des requ√™tes- **Read Sources** : Sources optimis√©es pour les lectures- **Query Models** : Mod√®les optimis√©s pour les lectures### **Flux de Donn√©es**```mermaidgraph TD    A[Command] --> B[Command Bus]    B --> C[Command Workflow]    C --> D[Command Activities]    D --> E[Write Sources]    E --> F[SQL Database]    E --> G[Redis Cache]    E --> H[File System]        I[Query] --> J[Query Bus]    J --> K[Query Workflow]    K --> L[Query Activities]    L --> M[Read Sources]    M --> N[ElasticSearch]    M --> O[Redis Cache]    M --> P[SQL Database]        Q[Event] --> R[Event Handler]    R --> C        S[Projection] --> T[Read Model Update]    T --> M```## üíª **Impl√©mentation Pratique**### **1. Command Side avec Multi-sources**#### **Command Bus avec Multi-sources**```php<?phpnamespace App\Application\CommandBus\MultiSource;use App\Domain\Command\CommandInterface;use App\Domain\Command\CommandHandlerInterface;use App\Infrastructure\MultiSource\SourceRouter;use Psr\Log\LoggerInterface;class MultiSourceCommandBus{    private array $handlers = [];    private array $middleware = [];    private SourceRouter $sourceRouter;    private LoggerInterface $logger;    public function __construct(        SourceRouter $sourceRouter,        LoggerInterface $logger    ) {        $this->sourceRouter = $sourceRouter;        $this->logger = $logger;    }    public function registerHandler(string $commandClass, CommandHandlerInterface $handler): void    {        $this->handlers[$commandClass] = $handler;    }    public function addMiddleware(callable $middleware): void    {        $this->middleware[] = $middleware;    }    public function handle(CommandInterface $command): void    {        $commandClass = get_class($command);                if (!isset($this->handlers[$commandClass])) {            throw new \InvalidArgumentException("No handler registered for command: $commandClass");        }        $handler = $this->handlers[$commandClass];                // Ex√©cuter les middleware        $this->executeMiddleware($command, function() use ($handler, $command) {            $this->logger->info('Executing command via Multi-source CQS', [                'command' => get_class($command),                'data' => $command->toArray()            ]);                        $handler->handle($command);        });    }    private function executeMiddleware(CommandInterface $command, callable $next): void    {        $middleware = array_reverse($this->middleware);                foreach ($middleware as $mw) {            $next = function() use ($mw, $command, $next) {                return $mw($command, $next);            };        }                $next();    }}```#### **Command Workflow avec Multi-sources**```php<?phpnamespace App\Workflow\Command\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Infrastructure\MultiSource\SourceRouter;#[WorkflowInterface]interface PaymentMultiSourceCommandWorkflowInterface{    #[WorkflowMethod]    public function processPaymentCommandWithMultiSource(PaymentCommandRequest $request): PaymentCommandResult;        #[WorkflowMethod]    public function updatePaymentCommandWithMultiSource(PaymentUpdateCommandRequest $request): PaymentCommandResult;        #[WorkflowMethod]    public function deletePaymentCommandWithMultiSource(PaymentDeleteCommandRequest $request): PaymentCommandResult;}#[ActivityInterface]interface PaymentMultiSourceCommandActivityInterface{    #[ActivityMethod]    public function validatePaymentCommand(PaymentCommandRequest $request): ValidationResult;        #[ActivityMethod]    public function executePaymentCommand(PaymentCommandRequest $request): CommandExecutionResult;        #[ActivityMethod]    public function persistToWriteSources(Payment $payment, array $sources): void;        #[ActivityMethod]    public function updateCommandModels(Payment $payment): void;}class PaymentMultiSourceCommandWorkflow implements PaymentMultiSourceCommandWorkflowInterface{    private PaymentMultiSourceCommandActivityInterface $commandActivity;    private SourceRouter $sourceRouter;    public function __construct()    {        $this->commandActivity = Workflow::newActivityStub(PaymentMultiSourceCommandActivityInterface::class);        $this->sourceRouter = Workflow::newActivityStub(SourceRouter::class);    }    public function processPaymentCommandWithMultiSource(PaymentCommandRequest $request): PaymentCommandResult    {        try {            // Validation de la commande            $validation = yield $this->commandActivity->validatePaymentCommand($request);                        if (!$validation->isValid()) {                return new PaymentCommandResult(false, $validation->getError());            }                        // Ex√©cution de la commande            $execution = yield $this->commandActivity->executePaymentCommand($request);                        if (!$execution->isSuccess()) {                return new PaymentCommandResult(false, $execution->getError());            }                        // D√©terminer les sources d'√©criture optimales            $writeSources = yield $this->sourceRouter->routeWrite('save', $execution->getPayment());                        // Persister dans les sources d'√©criture            yield $this->commandActivity->persistToWriteSources($execution->getPayment(), $writeSources);                        // Mettre √† jour les mod√®les de commande            yield $this->commandActivity->updateCommandModels($execution->getPayment());                        return new PaymentCommandResult(true, 'Payment command processed with Multi-source CQS');                    } catch (\Exception $e) {            return new PaymentCommandResult(false, $e->getMessage());        }    }    public function updatePaymentCommandWithMultiSource(PaymentUpdateCommandRequest $request): PaymentCommandResult    {        try {            // Validation de la commande de mise √† jour            $validation = yield $this->commandActivity->validatePaymentCommand($request);                        if (!$validation->isValid()) {                return new PaymentCommandResult(false, $validation->getError());            }                        // Ex√©cution de la mise √† jour            $execution = yield $this->commandActivity->executePaymentCommand($request);                        if (!$execution->isSuccess()) {                return new PaymentCommandResult(false, $execution->getError());            }                        // D√©terminer les sources d'√©criture optimales            $writeSources = yield $this->sourceRouter->routeWrite('update', $execution->getPayment());                        // Persister dans les sources d'√©criture            yield $this->commandActivity->persistToWriteSources($execution->getPayment(), $writeSources);                        // Mettre √† jour les mod√®les de commande            yield $this->commandActivity->updateCommandModels($execution->getPayment());                        return new PaymentCommandResult(true, 'Payment update command processed with Multi-source CQS');                    } catch (\Exception $e) {            return new PaymentCommandResult(false, $e->getMessage());        }    }    public function deletePaymentCommandWithMultiSource(PaymentDeleteCommandRequest $request): PaymentCommandResult    {        try {            // Validation de la commande de suppression            $validation = yield $this->commandActivity->validatePaymentCommand($request);                        if (!$validation->isValid()) {                return new PaymentCommandResult(false, $validation->getError());            }                        // Ex√©cution de la suppression            $execution = yield $this->commandActivity->executePaymentCommand($request);                        if (!$execution->isSuccess()) {                return new PaymentCommandResult(false, $execution->getError());            }                        // D√©terminer les sources d'√©criture optimales            $writeSources = yield $this->sourceRouter->routeWrite('delete', $execution->getPayment());                        // Persister dans les sources d'√©criture            yield $this->commandActivity->persistToWriteSources($execution->getPayment(), $writeSources);                        // Mettre √† jour les mod√®les de commande            yield $this->commandActivity->updateCommandModels($execution->getPayment());                        return new PaymentCommandResult(true, 'Payment delete command processed with Multi-source CQS');                    } catch (\Exception $e) {            return new PaymentCommandResult(false, $e->getMessage());        }    }}```### **2. Query Side avec Multi-sources**#### **Query Bus avec Cache et Multi-sources**```php<?phpnamespace App\Application\QueryBus\MultiSource;use App\Domain\Query\QueryInterface;use App\Domain\Query\QueryHandlerInterface;use App\Infrastructure\MultiSource\SourceRouter;use App\Infrastructure\MultiSource\MultiSourceCacheManager;use Psr\Log\LoggerInterface;class MultiSourceQueryBus{    private array $handlers = [];    private SourceRouter $sourceRouter;    private MultiSourceCacheManager $cacheManager;    private LoggerInterface $logger;    public function __construct(        SourceRouter $sourceRouter,        MultiSourceCacheManager $cacheManager,        LoggerInterface $logger    ) {        $this->sourceRouter = $sourceRouter;        $this->cacheManager = $cacheManager;        $this->logger = $logger;    }    public function registerHandler(string $queryClass, QueryHandlerInterface $handler): void    {        $this->handlers[$queryClass] = $handler;    }    public function handle(QueryInterface $query): mixed    {        $queryClass = get_class($query);                if (!isset($this->handlers[$queryClass])) {            throw new \InvalidArgumentException("No handler registered for query: $queryClass");        }        // V√©rifier le cache        $cacheKey = $this->generateCacheKey($query);        $cachedResult = $this->cacheManager->get($cacheKey);                if ($cachedResult !== null) {            $this->logger->debug('Query result served from cache', [                'query' => $queryClass,                'cacheKey' => $cacheKey            ]);                        return $cachedResult;        }        // D√©terminer la source de lecture optimale        $readSource = $this->sourceRouter->routeRead($queryClass, $query->toArray());                // Ex√©cuter la requ√™te via la source optimale        $handler = $this->handlers[$queryClass];        $result = $handler->handle($query, $readSource);                // Mettre en cache        $this->cacheManager->set($cacheKey, $result, 300);                $this->logger->info('Query executed and cached via Multi-source CQS', [            'query' => $queryClass,            'source' => $readSource,            'cacheKey' => $cacheKey        ]);                return $result;    }    private function generateCacheKey(QueryInterface $query): string    {        return 'multi_source_query_' . md5(serialize($query));    }}```#### **Query Workflow avec Multi-sources**```php<?phpnamespace App\Workflow\Query\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Infrastructure\MultiSource\SourceRouter;#[WorkflowInterface]interface PaymentMultiSourceQueryWorkflowInterface{    #[WorkflowMethod]    public function searchPaymentsWithMultiSource(PaymentSearchQuery $query): PaymentSearchResult;        #[WorkflowMethod]    public function getPaymentByIdWithMultiSource(PaymentByIdQuery $query): ?Payment;        #[WorkflowMethod]    public function getPaymentStatisticsWithMultiSource(PaymentStatisticsQuery $query): array;        #[WorkflowMethod]    public function getPaymentAnalyticsWithMultiSource(PaymentAnalyticsQuery $query): array;}#[ActivityInterface]interface PaymentMultiSourceQueryActivityInterface{    #[ActivityMethod]    public function searchPaymentsInSource(PaymentSearchQuery $query, string $source): array;        #[ActivityMethod]    public function getPaymentFromSource(string $paymentId, string $source): ?Payment;        #[ActivityMethod]    public function calculatePaymentStatisticsInSource(PaymentStatisticsQuery $query, string $source): array;        #[ActivityMethod]    public function generatePaymentAnalyticsInSource(PaymentAnalyticsQuery $query, string $source): array;}class PaymentMultiSourceQueryWorkflow implements PaymentMultiSourceQueryWorkflowInterface{    private PaymentMultiSourceQueryActivityInterface $queryActivity;    private SourceRouter $sourceRouter;    public function __construct()    {        $this->queryActivity = Workflow::newActivityStub(PaymentMultiSourceQueryActivityInterface::class);        $this->sourceRouter = Workflow::newActivityStub(SourceRouter::class);    }    public function searchPaymentsWithMultiSource(PaymentSearchQuery $query): PaymentSearchResult    {        try {            // D√©terminer la source de lecture optimale            $readSource = yield $this->sourceRouter->routeRead('search', $query->toArray());                        // Recherche dans la source optimale            $payments = yield $this->queryActivity->searchPaymentsInSource($query, $readSource);                        // Filtrage et tri            $filteredPayments = $this->filterPayments($payments, $query);            $sortedPayments = $this->sortPayments($filteredPayments, $query);                        // Pagination            $paginatedPayments = $this->paginatePayments($sortedPayments, $query);                        return new PaymentSearchResult(                $paginatedPayments,                count($filteredPayments),                $query->getPage(),                $query->getSize()            );                    } catch (\Exception $e) {            return new PaymentSearchResult([], 0, $query->getPage(), $query->getSize());        }    }    public function getPaymentByIdWithMultiSource(PaymentByIdQuery $query): ?Payment    {        try {            // D√©terminer la source de lecture optimale            $readSource = yield $this->sourceRouter->routeRead('findById', ['id' => $query->getPaymentId()]);                        return yield $this->queryActivity->getPaymentFromSource($query->getPaymentId(), $readSource);        } catch (\Exception $e) {            return null;        }    }    public function getPaymentStatisticsWithMultiSource(PaymentStatisticsQuery $query): array    {        try {            // D√©terminer la source de lecture optimale            $readSource = yield $this->sourceRouter->routeRead('statistics', $query->toArray());                        return yield $this->queryActivity->calculatePaymentStatisticsInSource($query, $readSource);        } catch (\Exception $e) {            return [];        }    }    public function getPaymentAnalyticsWithMultiSource(PaymentAnalyticsQuery $query): array    {        try {            // D√©terminer la source de lecture optimale            $readSource = yield $this->sourceRouter->routeRead('analytics', $query->toArray());                        return yield $this->queryActivity->generatePaymentAnalyticsInSource($query, $readSource);        } catch (\Exception $e) {            return [];        }    }    private function filterPayments(array $payments, PaymentSearchQuery $query): array    {        return array_filter($payments, function($payment) use ($query) {            if ($query->getOrganizationId() && $payment->getOrganizationId() !== $query->getOrganizationId()) {                return false;            }                        if ($query->getStatus() && $payment->getStatus() !== $query->getStatus()) {                return false;            }                        if ($query->getMinAmount() && $payment->getAmount() < $query->getMinAmount()) {                return false;            }                        if ($query->getMaxAmount() && $payment->getAmount() > $query->getMaxAmount()) {                return false;            }                        return true;        });    }    private function sortPayments(array $payments, PaymentSearchQuery $query): array    {        $sortField = $query->getSortField() ?? 'createdAt';        $sortDirection = $query->getSortDirection() ?? 'desc';                usort($payments, function($a, $b) use ($sortField, $sortDirection) {            $valueA = $this->getFieldValue($a, $sortField);            $valueB = $this->getFieldValue($b, $sortField);                        if ($sortDirection === 'asc') {                return $valueA <=> $valueB;            } else {                return $valueB <=> $valueA;            }        });                return $payments;    }    private function paginatePayments(array $payments, PaymentSearchQuery $query): array    {        $page = $query->getPage() ?? 1;        $size = $query->getSize() ?? 10;        $offset = ($page - 1) * $size;                return array_slice($payments, $offset, $size);    }    private function getFieldValue(Payment $payment, string $field): mixed    {        switch ($field) {            case 'amount':                return $payment->getAmount();            case 'createdAt':                return $payment->getCreatedAt();            case 'status':                return $payment->getStatus();            default:                return $payment->getCreatedAt();        }    }}```### **3. Service de Synchronisation Multi-Sources**#### **Service de Synchronisation CQS**```php<?phpnamespace App\Application\Service\MultiSource;use App\Domain\Event\DomainEvent;use App\Infrastructure\MultiSource\SourceRouter;use App\Infrastructure\MultiSource\MultiSourceCacheManager;use Psr\Log\LoggerInterface;class MultiSourceCqsSynchronizationService{    private SourceRouter $sourceRouter;    private MultiSourceCacheManager $cacheManager;    private LoggerInterface $logger;    public function __construct(        SourceRouter $sourceRouter,        MultiSourceCacheManager $cacheManager,        LoggerInterface $logger    ) {        $this->sourceRouter = $sourceRouter;        $this->cacheManager = $cacheManager;        $this->logger = $logger;    }    public function handleEvent(DomainEvent $event): void    {        try {            $this->logger->info('Handling event via Multi-source CQS', [                'eventType' => $event->getEventType(),                'eventId' => $event->getId()            ]);            // D√©terminer les sources affect√©es            $affectedSources = $this->determineAffectedSources($event);                        // Mettre √† jour chaque source            foreach ($affectedSources as $source) {                $this->updateSource($source, $event);            }                        // Invalider le cache si n√©cessaire            if ($this->shouldInvalidateCache($event)) {                $this->invalidateCache($event);            }                    } catch (\Exception $e) {            $this->logger->error('Failed to handle event via Multi-source CQS', [                'eventType' => $event->getEventType(),                'error' => $e->getMessage()            ]);                        throw $e;        }    }    public function synchronizeSources(): void    {        try {            $this->logger->info('Synchronizing sources via Multi-source CQS');                        // Synchroniser les sources de lecture avec les sources d'√©criture            $this->synchronizeReadSources();                        // Nettoyer les caches expir√©s            $this->cleanExpiredCaches();                        $this->logger->info('Sources synchronized successfully via Multi-source CQS');                    } catch (\Exception $e) {            $this->logger->error('Failed to synchronize sources via Multi-source CQS', [                'error' => $e->getMessage()            ]);                        throw $e;        }    }    private function determineAffectedSources(DomainEvent $event): array    {        $sources = [];                // Toujours affecter la base de donn√©es pour les √©v√©nements critiques        if ($this->isCriticalEvent($event)) {            $sources[] = 'database';        }                // Affecter le cache pour les √©v√©nements de lecture        if ($this->isReadEvent($event)) {            $sources[] = 'cache';        }                // Affecter ElasticSearch pour les √©v√©nements de recherche        if ($this->isSearchEvent($event)) {            $sources[] = 'elasticsearch';        }                return $sources;    }    private function updateSource(string $source, DomainEvent $event): void    {        $this->logger->debug('Updating source', [            'source' => $source,            'eventType' => $event->getEventType()        ]);                // Impl√©mentation sp√©cifique √† chaque source        switch ($source) {            case 'database':                $this->updateDatabase($event);                break;            case 'cache':                $this->updateCache($event);                break;            case 'elasticsearch':                $this->updateElasticSearch($event);                break;        }    }    private function shouldInvalidateCache(DomainEvent $event): bool    {        return in_array($event->getEventType(), [            'PaymentUpdated',            'PaymentDeleted',            'PaymentStatusChanged'        ]);    }    private function invalidateCache(DomainEvent $event): void    {        $this->logger->debug('Invalidating cache', [            'eventType' => $event->getEventType()        ]);                // Invalider les caches pertinents        if (isset($event->getData()['paymentId'])) {            $this->cacheManager->deletePayment($event->getData()['paymentId']);        }    }    private function isCriticalEvent(DomainEvent $event): bool    {        return in_array($event->getEventType(), [            'PaymentCreated',            'PaymentUpdated',            'PaymentDeleted'        ]);    }    private function isReadEvent(DomainEvent $event): bool    {        return in_array($event->getEventType(), [            'PaymentViewed',            'PaymentSearched'        ]);    }    private function isSearchEvent(DomainEvent $event): bool    {        return in_array($event->getEventType(), [            'PaymentCreated',            'PaymentUpdated',            'PaymentDeleted'        ]);    }    private function updateDatabase(DomainEvent $event): void    {        // Impl√©mentation de la mise √† jour de la base de donn√©es    }    private function updateCache(DomainEvent $event): void    {        // Impl√©mentation de la mise √† jour du cache    }    private function updateElasticSearch(DomainEvent $event): void    {        // Impl√©mentation de la mise √† jour d'ElasticSearch    }    private function synchronizeReadSources(): void    {        // Impl√©mentation de la synchronisation des sources de lecture    }    private function cleanExpiredCaches(): void    {        // Impl√©mentation du nettoyage des caches expir√©s    }}```## üß™ **Tests et Validation**### **Tests d'Int√©gration CQS Multi-Sources**```php<?phpnamespace App\Tests\Integration\MultiSource;use App\Workflow\Command\Payment\PaymentCommandRequest;use App\Workflow\Query\Payment\PaymentSearchQuery;use App\Application\CommandBus\MultiSource\MultiSourceCommandBus;use App\Application\QueryBus\MultiSource\MultiSourceQueryBus;use App\Infrastructure\MultiSource\SourceRouter;class MultiSourceCqsTest extends TestCase{    private MultiSourceCommandBus $commandBus;    private MultiSourceQueryBus $queryBus;    private SourceRouter $sourceRouter;    protected function setUp(): void    {        $this->sourceRouter = $this->createMock(SourceRouter::class);        $this->commandBus = new MultiSourceCommandBus(            $this->sourceRouter,            $this->createMock(LoggerInterface::class)        );        $this->queryBus = new MultiSourceQueryBus(            $this->sourceRouter,            $this->createMock(MultiSourceCacheManager::class),            $this->createMock(LoggerInterface::class)        );    }    public function testCqsSeparationWithMultiSource(): void    {        // Ex√©cuter une commande avec Multi-source CQS        $command = new PaymentCommandRequest(            'CREATE',            'payment-123',            'org-456',            'user-789',            100.00,            'EUR',            'Test payment'        );                $this->commandBus->handle($command);                // V√©rifier avec une requ√™te        $query = new PaymentSearchQuery('org-456', 0, 10);        $result = $this->queryBus->handle($query);                $this->assertGreaterThan(0, $result->getTotal());    }    public function testQueryCachingWithMultiSource(): void    {        $query = new PaymentSearchQuery('org-456', 0, 10);                // Premi√®re recherche        $result1 = $this->queryBus->handle($query);                // Deuxi√®me recherche (devrait utiliser le cache)        $result2 = $this->queryBus->handle($query);                $this->assertEquals($result1->getTotal(), $result2->getTotal());    }}```## üìä **Performance et Optimisation**### **Strat√©gies d'Optimisation CQS Multi-Sources**#### **1. Cache Strat√©gique Multi-Sources**```phppublic function searchPaymentsWithCache(PaymentSearchQuery $query): PaymentSearchResult{    $cacheKey = 'multi_source_payment_search_' . md5(serialize($query));        if ($cached = $this->cacheManager->get($cacheKey)) {        return $cached;    }        $result = $this->searchPaymentsWithMultiSource($query);    $this->cacheManager->set($cacheKey, $result, 300);        return $result;}```#### **2. Load Balancing Multi-Sources**```phppublic function getOptimalSourceForOperation(string $operation, array $criteria = []): string{    $sourceLoads = $this->getSourceLoads();    $optimalSource = array_keys($sourceLoads, min($sourceLoads))[0];        $this->logger->debug('Selected optimal source for operation', [        'operation' => $operation,        'source' => $optimalSource,        'loads' => $sourceLoads    ]);        return $optimalSource;}```#### **3. Monitoring des Sources Multi-Sources**```phppublic function getMultiSourceMetrics(): array{    return [        'commandSources' => $this->getCommandSourceMetrics(),        'querySources' => $this->getQuerySourceMetrics(),        'cacheHitRate' => $this->getCacheHitRate(),        'sourceHealth' => $this->getSourceHealth(),        'averageExecutionTime' => $this->getAverageExecutionTime()    ];}```## üéØ **Crit√®res d'Adoption**### **Quand Utiliser CQS avec Multi-sources**#### **‚úÖ Avantages**- **Performance optimis√©e** : S√©paration claire entre √©criture et lecture- **Flexibilit√© maximale** : Choix du meilleur stockage pour chaque op√©ration- **Scalabilit√©** : Possibilit√© de scaler ind√©pendamment chaque c√¥t√©- **R√©silience** : Redondance et failover entre sources- **Maintenabilit√©** : Code plus clair et organis√©#### **‚ùå Inconv√©nients**- **Complexit√© √©lev√©e** : Gestion de plusieurs sources de donn√©es- **Coh√©rence** : Risque d'incoh√©rence entre sources- **Maintenance** : Plus de sources √† maintenir- **Expertise** : √âquipe exp√©riment√©e requise#### **üéØ Crit√®res d'Adoption**- **Syst√®me complexe** : Besoins de performance diff√©rents par type d'op√©ration- **Donn√©es h√©t√©rog√®nes** : Types de donn√©es diff√©rents n√©cessitant diff√©rents stockages- **Performance critique** : Besoins de performance optimale- **S√©paration des responsabilit√©s** : Besoin de s√©parer clairement les commandes et requ√™tes- **√âquipe exp√©riment√©e** : Ma√Ætrise de plusieurs technologies de stockage et CQS- **Budget suffisant** : Investissement en infrastructure multiple- **Temps de d√©veloppement** : Suffisant pour impl√©menter cette complexit√©## üöÄ **Votre Prochaine √âtape**{{< chapter-nav >}}  {{< chapter-option     letter="A"     color="green"     title="Je veux voir l'approche CQRS avec Multi-sources"     subtitle="Vous voulez comprendre la s√©paration compl√®te des responsabilit√©s"    criteria="Architecture complexe,√âquipe tr√®s exp√©riment√©e,Performance critique,Scalabilit√© maximale"    time="45-60 minutes"    chapter="54"    chapter-title="Stockage Multi-sources - CQRS"    chapter-url="/chapitres/stockage/multi-sources/chapitre-54-stockage-multi-sources-cqrs/"  >}}    {{< chapter-option     letter="B"     color="yellow"     title="Je veux explorer les autres types de stockage"     subtitle="Vous voulez voir les alternatives √† Multi-sources"    criteria="Comparaison n√©cessaire,Choix de stockage,Architecture √† d√©finir,Performance √† optimiser"    time="30-40 minutes"    chapter="10"    chapter-title="Choix du Type de Stockage"    chapter-url="/chapitres/fondamentaux/chapitre-10-choix-type-stockage/"  >}}    {{< chapter-option     letter="C"     color="blue"     title="Je veux voir des exemples concrets"     subtitle="Vous voulez comprendre les impl√©mentations pratiques"    criteria="D√©veloppeur exp√©riment√©,Besoin d'exemples pratiques,Impl√©mentation √† faire,Code √† √©crire"    time="Variable"    chapter="0"    chapter-title="Exemples et Impl√©mentations"    chapter-url="/examples/"  >}}    {{< chapter-option     letter="D"     color="purple"     title="Je veux revenir aux fondamentaux"     subtitle="Vous voulez comprendre les concepts de base"    criteria="D√©veloppeur d√©butant,Besoin de comprendre les concepts,Projet √† structurer,√âquipe √† former"    time="45-60 minutes"    chapter="1"    chapter-title="Introduction au Domain-Driven Design et Event Storming"    chapter-url="/chapitres/fondamentaux/chapitre-01-introduction-event-storming-ddd/"  >}}{{< /chapter-nav >}}---*CQS avec Multi-sources offre un √©quilibre optimal entre performance et flexibilit√©, parfaitement adapt√© aux besoins complexes de Gyroscops.*