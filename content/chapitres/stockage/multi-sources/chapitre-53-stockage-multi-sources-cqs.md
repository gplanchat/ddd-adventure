---
title: "Stockage Multi-sources - CQS"
description: "Implémentation Command Query Separation avec Multi-sources pour optimiser les performances"
date: 2024-12-19
draft: true
type: "docs"
weight: 53
---
## 🎯 **Contexte et Objectifs**### **Pourquoi CQS avec Multi-sources ?**La combinaison CQS avec Multi-sources offre une architecture optimisée qui sépare clairement les responsabilités tout en exploitant les avantages de différents types de stockage. Cette approche permet d'optimiser chaque côté (commandes et requêtes) avec les sources les plus appropriées.#### **Avantages de CQS avec Multi-sources**- **Performance optimisée** : Séparation claire entre écriture et lecture- **Flexibilité maximale** : Choix du meilleur stockage pour chaque opération- **Scalabilité** : Possibilité de scaler indépendamment chaque côté- **Résilience** : Redondance et failover entre sources- **Maintenabilité** : Code plus clair et organisé### **Contexte Gyroscops**Dans notre écosystème **User → Organization → Workflow → Cloud Resources → Billing**, CQS avec Multi-sources est particulièrement pertinent pour :- **Workflows de commande** : Orchestration des processus de modification avec sources optimisées- **Workflows de requête** : Optimisation des lectures avec sources spécialisées- **Processus de facturation** : Séparation des écritures et lectures de facturation- **Intégrations complexes** : Orchestration des intégrations avec sources multiples## 🏗️ **Architecture CQS avec Multi-sources**### **Séparation des Responsabilités**#### **Côté Commande (Write) avec Multi-sources**- **Command Workflows** : Orchestration des processus de modification- **Command Activities** : Exécution des activités de modification- **Event Handlers** : Gestion des événements de domaine- **Command Bus** : Orchestration des commandes- **Write Sources** : Sources optimisées pour les écritures- **Command Models** : Modèles optimisés pour les écritures#### **Côté Requête (Read) avec Multi-sources**- **Query Workflows** : Orchestration des processus de lecture- **Query Activities** : Exécution des activités de lecture- **Search Services** : Services de recherche spécialisés- **Query Bus** : Orchestration des requêtes- **Read Sources** : Sources optimisées pour les lectures- **Query Models** : Modèles optimisés pour les lectures### **Flux de Données**```mermaidgraph TD    A[Command] --> B[Command Bus]    B --> C[Command Workflow]    C --> D[Command Activities]    D --> E[Write Sources]    E --> F[SQL Database]    E --> G[Redis Cache]    E --> H[File System]        I[Query] --> J[Query Bus]    J --> K[Query Workflow]    K --> L[Query Activities]    L --> M[Read Sources]    M --> N[ElasticSearch]    M --> O[Redis Cache]    M --> P[SQL Database]        Q[Event] --> R[Event Handler]    R --> C        S[Projection] --> T[Read Model Update]    T --> M```## 💻 **Implémentation Pratique**### **1. Command Side avec Multi-sources**#### **Command Bus avec Multi-sources**```php<?phpnamespace App\Application\CommandBus\MultiSource;use App\Domain\Command\CommandInterface;use App\Domain\Command\CommandHandlerInterface;use App\Infrastructure\MultiSource\SourceRouter;use Psr\Log\LoggerInterface;class MultiSourceCommandBus{    private array $handlers = [];    private array $middleware = [];    private SourceRouter $sourceRouter;    private LoggerInterface $logger;    public function __construct(        SourceRouter $sourceRouter,        LoggerInterface $logger    ) {        $this->sourceRouter = $sourceRouter;        $this->logger = $logger;    }    public function registerHandler(string $commandClass, CommandHandlerInterface $handler): void    {        $this->handlers[$commandClass] = $handler;    }    public function addMiddleware(callable $middleware): void    {        $this->middleware[] = $middleware;    }    public function handle(CommandInterface $command): void    {        $commandClass = get_class($command);                if (!isset($this->handlers[$commandClass])) {            throw new \InvalidArgumentException("No handler registered for command: $commandClass");        }        $handler = $this->handlers[$commandClass];                // Exécuter les middleware        $this->executeMiddleware($command, function() use ($handler, $command) {            $this->logger->info('Executing command via Multi-source CQS', [                'command' => get_class($command),                'data' => $command->toArray()            ]);                        $handler->handle($command);        });    }    private function executeMiddleware(CommandInterface $command, callable $next): void    {        $middleware = array_reverse($this->middleware);                foreach ($middleware as $mw) {            $next = function() use ($mw, $command, $next) {                return $mw($command, $next);            };        }                $next();    }}```#### **Command Workflow avec Multi-sources**```php<?phpnamespace App\Workflow\Command\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Infrastructure\MultiSource\SourceRouter;#[WorkflowInterface]interface PaymentMultiSourceCommandWorkflowInterface{    #[WorkflowMethod]    public function processPaymentCommandWithMultiSource(PaymentCommandRequest $request): PaymentCommandResult;        #[WorkflowMethod]    public function updatePaymentCommandWithMultiSource(PaymentUpdateCommandRequest $request): PaymentCommandResult;        #[WorkflowMethod]    public function deletePaymentCommandWithMultiSource(PaymentDeleteCommandRequest $request): PaymentCommandResult;}#[ActivityInterface]interface PaymentMultiSourceCommandActivityInterface{    #[ActivityMethod]    public function validatePaymentCommand(PaymentCommandRequest $request): ValidationResult;        #[ActivityMethod]    public function executePaymentCommand(PaymentCommandRequest $request): CommandExecutionResult;        #[ActivityMethod]    public function persistToWriteSources(Payment $payment, array $sources): void;        #[ActivityMethod]    public function updateCommandModels(Payment $payment): void;}class PaymentMultiSourceCommandWorkflow implements PaymentMultiSourceCommandWorkflowInterface{    private PaymentMultiSourceCommandActivityInterface $commandActivity;    private SourceRouter $sourceRouter;    public function __construct()    {        $this->commandActivity = Workflow::newActivityStub(PaymentMultiSourceCommandActivityInterface::class);        $this->sourceRouter = Workflow::newActivityStub(SourceRouter::class);    }    public function processPaymentCommandWithMultiSource(PaymentCommandRequest $request): PaymentCommandResult    {        try {            // Validation de la commande            $validation = yield $this->commandActivity->validatePaymentCommand($request);                        if (!$validation->isValid()) {                return new PaymentCommandResult(false, $validation->getError());            }                        // Exécution de la commande            $execution = yield $this->commandActivity->executePaymentCommand($request);                        if (!$execution->isSuccess()) {                return new PaymentCommandResult(false, $execution->getError());            }                        // Déterminer les sources d'écriture optimales            $writeSources = yield $this->sourceRouter->routeWrite('save', $execution->getPayment());                        // Persister dans les sources d'écriture            yield $this->commandActivity->persistToWriteSources($execution->getPayment(), $writeSources);                        // Mettre à jour les modèles de commande            yield $this->commandActivity->updateCommandModels($execution->getPayment());                        return new PaymentCommandResult(true, 'Payment command processed with Multi-source CQS');                    } catch (\Exception $e) {            return new PaymentCommandResult(false, $e->getMessage());        }    }    public function updatePaymentCommandWithMultiSource(PaymentUpdateCommandRequest $request): PaymentCommandResult    {        try {            // Validation de la commande de mise à jour            $validation = yield $this->commandActivity->validatePaymentCommand($request);                        if (!$validation->isValid()) {                return new PaymentCommandResult(false, $validation->getError());            }                        // Exécution de la mise à jour            $execution = yield $this->commandActivity->executePaymentCommand($request);                        if (!$execution->isSuccess()) {                return new PaymentCommandResult(false, $execution->getError());            }                        // Déterminer les sources d'écriture optimales            $writeSources = yield $this->sourceRouter->routeWrite('update', $execution->getPayment());                        // Persister dans les sources d'écriture            yield $this->commandActivity->persistToWriteSources($execution->getPayment(), $writeSources);                        // Mettre à jour les modèles de commande            yield $this->commandActivity->updateCommandModels($execution->getPayment());                        return new PaymentCommandResult(true, 'Payment update command processed with Multi-source CQS');                    } catch (\Exception $e) {            return new PaymentCommandResult(false, $e->getMessage());        }    }    public function deletePaymentCommandWithMultiSource(PaymentDeleteCommandRequest $request): PaymentCommandResult    {        try {            // Validation de la commande de suppression            $validation = yield $this->commandActivity->validatePaymentCommand($request);                        if (!$validation->isValid()) {                return new PaymentCommandResult(false, $validation->getError());            }                        // Exécution de la suppression            $execution = yield $this->commandActivity->executePaymentCommand($request);                        if (!$execution->isSuccess()) {                return new PaymentCommandResult(false, $execution->getError());            }                        // Déterminer les sources d'écriture optimales            $writeSources = yield $this->sourceRouter->routeWrite('delete', $execution->getPayment());                        // Persister dans les sources d'écriture            yield $this->commandActivity->persistToWriteSources($execution->getPayment(), $writeSources);                        // Mettre à jour les modèles de commande            yield $this->commandActivity->updateCommandModels($execution->getPayment());                        return new PaymentCommandResult(true, 'Payment delete command processed with Multi-source CQS');                    } catch (\Exception $e) {            return new PaymentCommandResult(false, $e->getMessage());        }    }}```### **2. Query Side avec Multi-sources**#### **Query Bus avec Cache et Multi-sources**```php<?phpnamespace App\Application\QueryBus\MultiSource;use App\Domain\Query\QueryInterface;use App\Domain\Query\QueryHandlerInterface;use App\Infrastructure\MultiSource\SourceRouter;use App\Infrastructure\MultiSource\MultiSourceCacheManager;use Psr\Log\LoggerInterface;class MultiSourceQueryBus{    private array $handlers = [];    private SourceRouter $sourceRouter;    private MultiSourceCacheManager $cacheManager;    private LoggerInterface $logger;    public function __construct(        SourceRouter $sourceRouter,        MultiSourceCacheManager $cacheManager,        LoggerInterface $logger    ) {        $this->sourceRouter = $sourceRouter;        $this->cacheManager = $cacheManager;        $this->logger = $logger;    }    public function registerHandler(string $queryClass, QueryHandlerInterface $handler): void    {        $this->handlers[$queryClass] = $handler;    }    public function handle(QueryInterface $query): mixed    {        $queryClass = get_class($query);                if (!isset($this->handlers[$queryClass])) {            throw new \InvalidArgumentException("No handler registered for query: $queryClass");        }        // Vérifier le cache        $cacheKey = $this->generateCacheKey($query);        $cachedResult = $this->cacheManager->get($cacheKey);                if ($cachedResult !== null) {            $this->logger->debug('Query result served from cache', [                'query' => $queryClass,                'cacheKey' => $cacheKey            ]);                        return $cachedResult;        }        // Déterminer la source de lecture optimale        $readSource = $this->sourceRouter->routeRead($queryClass, $query->toArray());                // Exécuter la requête via la source optimale        $handler = $this->handlers[$queryClass];        $result = $handler->handle($query, $readSource);                // Mettre en cache        $this->cacheManager->set($cacheKey, $result, 300);                $this->logger->info('Query executed and cached via Multi-source CQS', [            'query' => $queryClass,            'source' => $readSource,            'cacheKey' => $cacheKey        ]);                return $result;    }    private function generateCacheKey(QueryInterface $query): string    {        return 'multi_source_query_' . md5(serialize($query));    }}```#### **Query Workflow avec Multi-sources**```php<?phpnamespace App\Workflow\Query\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Infrastructure\MultiSource\SourceRouter;#[WorkflowInterface]interface PaymentMultiSourceQueryWorkflowInterface{    #[WorkflowMethod]    public function searchPaymentsWithMultiSource(PaymentSearchQuery $query): PaymentSearchResult;        #[WorkflowMethod]    public function getPaymentByIdWithMultiSource(PaymentByIdQuery $query): ?Payment;        #[WorkflowMethod]    public function getPaymentStatisticsWithMultiSource(PaymentStatisticsQuery $query): array;        #[WorkflowMethod]    public function getPaymentAnalyticsWithMultiSource(PaymentAnalyticsQuery $query): array;}#[ActivityInterface]interface PaymentMultiSourceQueryActivityInterface{    #[ActivityMethod]    public function searchPaymentsInSource(PaymentSearchQuery $query, string $source): array;        #[ActivityMethod]    public function getPaymentFromSource(string $paymentId, string $source): ?Payment;        #[ActivityMethod]    public function calculatePaymentStatisticsInSource(PaymentStatisticsQuery $query, string $source): array;        #[ActivityMethod]    public function generatePaymentAnalyticsInSource(PaymentAnalyticsQuery $query, string $source): array;}class PaymentMultiSourceQueryWorkflow implements PaymentMultiSourceQueryWorkflowInterface{    private PaymentMultiSourceQueryActivityInterface $queryActivity;    private SourceRouter $sourceRouter;    public function __construct()    {        $this->queryActivity = Workflow::newActivityStub(PaymentMultiSourceQueryActivityInterface::class);        $this->sourceRouter = Workflow::newActivityStub(SourceRouter::class);    }    public function searchPaymentsWithMultiSource(PaymentSearchQuery $query): PaymentSearchResult    {        try {            // Déterminer la source de lecture optimale            $readSource = yield $this->sourceRouter->routeRead('search', $query->toArray());                        // Recherche dans la source optimale            $payments = yield $this->queryActivity->searchPaymentsInSource($query, $readSource);                        // Filtrage et tri            $filteredPayments = $this->filterPayments($payments, $query);            $sortedPayments = $this->sortPayments($filteredPayments, $query);                        // Pagination            $paginatedPayments = $this->paginatePayments($sortedPayments, $query);                        return new PaymentSearchResult(                $paginatedPayments,                count($filteredPayments),                $query->getPage(),                $query->getSize()            );                    } catch (\Exception $e) {            return new PaymentSearchResult([], 0, $query->getPage(), $query->getSize());        }    }    public function getPaymentByIdWithMultiSource(PaymentByIdQuery $query): ?Payment    {        try {            // Déterminer la source de lecture optimale            $readSource = yield $this->sourceRouter->routeRead('findById', ['id' => $query->getPaymentId()]);                        return yield $this->queryActivity->getPaymentFromSource($query->getPaymentId(), $readSource);        } catch (\Exception $e) {            return null;        }    }    public function getPaymentStatisticsWithMultiSource(PaymentStatisticsQuery $query): array    {        try {            // Déterminer la source de lecture optimale            $readSource = yield $this->sourceRouter->routeRead('statistics', $query->toArray());                        return yield $this->queryActivity->calculatePaymentStatisticsInSource($query, $readSource);        } catch (\Exception $e) {            return [];        }    }    public function getPaymentAnalyticsWithMultiSource(PaymentAnalyticsQuery $query): array    {        try {            // Déterminer la source de lecture optimale            $readSource = yield $this->sourceRouter->routeRead('analytics', $query->toArray());                        return yield $this->queryActivity->generatePaymentAnalyticsInSource($query, $readSource);        } catch (\Exception $e) {            return [];        }    }    private function filterPayments(array $payments, PaymentSearchQuery $query): array    {        return array_filter($payments, function($payment) use ($query) {            if ($query->getOrganizationId() && $payment->getOrganizationId() !== $query->getOrganizationId()) {                return false;            }                        if ($query->getStatus() && $payment->getStatus() !== $query->getStatus()) {                return false;            }                        if ($query->getMinAmount() && $payment->getAmount() < $query->getMinAmount()) {                return false;            }                        if ($query->getMaxAmount() && $payment->getAmount() > $query->getMaxAmount()) {                return false;            }                        return true;        });    }    private function sortPayments(array $payments, PaymentSearchQuery $query): array    {        $sortField = $query->getSortField() ?? 'createdAt';        $sortDirection = $query->getSortDirection() ?? 'desc';                usort($payments, function($a, $b) use ($sortField, $sortDirection) {            $valueA = $this->getFieldValue($a, $sortField);            $valueB = $this->getFieldValue($b, $sortField);                        if ($sortDirection === 'asc') {                return $valueA <=> $valueB;            } else {                return $valueB <=> $valueA;            }        });                return $payments;    }    private function paginatePayments(array $payments, PaymentSearchQuery $query): array    {        $page = $query->getPage() ?? 1;        $size = $query->getSize() ?? 10;        $offset = ($page - 1) * $size;                return array_slice($payments, $offset, $size);    }    private function getFieldValue(Payment $payment, string $field): mixed    {        switch ($field) {            case 'amount':                return $payment->getAmount();            case 'createdAt':                return $payment->getCreatedAt();            case 'status':                return $payment->getStatus();            default:                return $payment->getCreatedAt();        }    }}```### **3. Service de Synchronisation Multi-Sources**#### **Service de Synchronisation CQS**```php<?phpnamespace App\Application\Service\MultiSource;use App\Domain\Event\DomainEvent;use App\Infrastructure\MultiSource\SourceRouter;use App\Infrastructure\MultiSource\MultiSourceCacheManager;use Psr\Log\LoggerInterface;class MultiSourceCqsSynchronizationService{    private SourceRouter $sourceRouter;    private MultiSourceCacheManager $cacheManager;    private LoggerInterface $logger;    public function __construct(        SourceRouter $sourceRouter,        MultiSourceCacheManager $cacheManager,        LoggerInterface $logger    ) {        $this->sourceRouter = $sourceRouter;        $this->cacheManager = $cacheManager;        $this->logger = $logger;    }    public function handleEvent(DomainEvent $event): void    {        try {            $this->logger->info('Handling event via Multi-source CQS', [                'eventType' => $event->getEventType(),                'eventId' => $event->getId()            ]);            // Déterminer les sources affectées            $affectedSources = $this->determineAffectedSources($event);                        // Mettre à jour chaque source            foreach ($affectedSources as $source) {                $this->updateSource($source, $event);            }                        // Invalider le cache si nécessaire            if ($this->shouldInvalidateCache($event)) {                $this->invalidateCache($event);            }                    } catch (\Exception $e) {            $this->logger->error('Failed to handle event via Multi-source CQS', [                'eventType' => $event->getEventType(),                'error' => $e->getMessage()            ]);                        throw $e;        }    }    public function synchronizeSources(): void    {        try {            $this->logger->info('Synchronizing sources via Multi-source CQS');                        // Synchroniser les sources de lecture avec les sources d'écriture            $this->synchronizeReadSources();                        // Nettoyer les caches expirés            $this->cleanExpiredCaches();                        $this->logger->info('Sources synchronized successfully via Multi-source CQS');                    } catch (\Exception $e) {            $this->logger->error('Failed to synchronize sources via Multi-source CQS', [                'error' => $e->getMessage()            ]);                        throw $e;        }    }    private function determineAffectedSources(DomainEvent $event): array    {        $sources = [];                // Toujours affecter la base de données pour les événements critiques        if ($this->isCriticalEvent($event)) {            $sources[] = 'database';        }                // Affecter le cache pour les événements de lecture        if ($this->isReadEvent($event)) {            $sources[] = 'cache';        }                // Affecter ElasticSearch pour les événements de recherche        if ($this->isSearchEvent($event)) {            $sources[] = 'elasticsearch';        }                return $sources;    }    private function updateSource(string $source, DomainEvent $event): void    {        $this->logger->debug('Updating source', [            'source' => $source,            'eventType' => $event->getEventType()        ]);                // Implémentation spécifique à chaque source        switch ($source) {            case 'database':                $this->updateDatabase($event);                break;            case 'cache':                $this->updateCache($event);                break;            case 'elasticsearch':                $this->updateElasticSearch($event);                break;        }    }    private function shouldInvalidateCache(DomainEvent $event): bool    {        return in_array($event->getEventType(), [            'PaymentUpdated',            'PaymentDeleted',            'PaymentStatusChanged'        ]);    }    private function invalidateCache(DomainEvent $event): void    {        $this->logger->debug('Invalidating cache', [            'eventType' => $event->getEventType()        ]);                // Invalider les caches pertinents        if (isset($event->getData()['paymentId'])) {            $this->cacheManager->deletePayment($event->getData()['paymentId']);        }    }    private function isCriticalEvent(DomainEvent $event): bool    {        return in_array($event->getEventType(), [            'PaymentCreated',            'PaymentUpdated',            'PaymentDeleted'        ]);    }    private function isReadEvent(DomainEvent $event): bool    {        return in_array($event->getEventType(), [            'PaymentViewed',            'PaymentSearched'        ]);    }    private function isSearchEvent(DomainEvent $event): bool    {        return in_array($event->getEventType(), [            'PaymentCreated',            'PaymentUpdated',            'PaymentDeleted'        ]);    }    private function updateDatabase(DomainEvent $event): void    {        // Implémentation de la mise à jour de la base de données    }    private function updateCache(DomainEvent $event): void    {        // Implémentation de la mise à jour du cache    }    private function updateElasticSearch(DomainEvent $event): void    {        // Implémentation de la mise à jour d'ElasticSearch    }    private function synchronizeReadSources(): void    {        // Implémentation de la synchronisation des sources de lecture    }    private function cleanExpiredCaches(): void    {        // Implémentation du nettoyage des caches expirés    }}```## 🧪 **Tests et Validation**### **Tests d'Intégration CQS Multi-Sources**```php<?phpnamespace App\Tests\Integration\MultiSource;use App\Workflow\Command\Payment\PaymentCommandRequest;use App\Workflow\Query\Payment\PaymentSearchQuery;use App\Application\CommandBus\MultiSource\MultiSourceCommandBus;use App\Application\QueryBus\MultiSource\MultiSourceQueryBus;use App\Infrastructure\MultiSource\SourceRouter;class MultiSourceCqsTest extends TestCase{    private MultiSourceCommandBus $commandBus;    private MultiSourceQueryBus $queryBus;    private SourceRouter $sourceRouter;    protected function setUp(): void    {        $this->sourceRouter = $this->createMock(SourceRouter::class);        $this->commandBus = new MultiSourceCommandBus(            $this->sourceRouter,            $this->createMock(LoggerInterface::class)        );        $this->queryBus = new MultiSourceQueryBus(            $this->sourceRouter,            $this->createMock(MultiSourceCacheManager::class),            $this->createMock(LoggerInterface::class)        );    }    public function testCqsSeparationWithMultiSource(): void    {        // Exécuter une commande avec Multi-source CQS        $command = new PaymentCommandRequest(            'CREATE',            'payment-123',            'org-456',            'user-789',            100.00,            'EUR',            'Test payment'        );                $this->commandBus->handle($command);                // Vérifier avec une requête        $query = new PaymentSearchQuery('org-456', 0, 10);        $result = $this->queryBus->handle($query);                $this->assertGreaterThan(0, $result->getTotal());    }    public function testQueryCachingWithMultiSource(): void    {        $query = new PaymentSearchQuery('org-456', 0, 10);                // Première recherche        $result1 = $this->queryBus->handle($query);                // Deuxième recherche (devrait utiliser le cache)        $result2 = $this->queryBus->handle($query);                $this->assertEquals($result1->getTotal(), $result2->getTotal());    }}```## 📊 **Performance et Optimisation**### **Stratégies d'Optimisation CQS Multi-Sources**#### **1. Cache Stratégique Multi-Sources**```phppublic function searchPaymentsWithCache(PaymentSearchQuery $query): PaymentSearchResult{    $cacheKey = 'multi_source_payment_search_' . md5(serialize($query));        if ($cached = $this->cacheManager->get($cacheKey)) {        return $cached;    }        $result = $this->searchPaymentsWithMultiSource($query);    $this->cacheManager->set($cacheKey, $result, 300);        return $result;}```#### **2. Load Balancing Multi-Sources**```phppublic function getOptimalSourceForOperation(string $operation, array $criteria = []): string{    $sourceLoads = $this->getSourceLoads();    $optimalSource = array_keys($sourceLoads, min($sourceLoads))[0];        $this->logger->debug('Selected optimal source for operation', [        'operation' => $operation,        'source' => $optimalSource,        'loads' => $sourceLoads    ]);        return $optimalSource;}```#### **3. Monitoring des Sources Multi-Sources**```phppublic function getMultiSourceMetrics(): array{    return [        'commandSources' => $this->getCommandSourceMetrics(),        'querySources' => $this->getQuerySourceMetrics(),        'cacheHitRate' => $this->getCacheHitRate(),        'sourceHealth' => $this->getSourceHealth(),        'averageExecutionTime' => $this->getAverageExecutionTime()    ];}```## 🎯 **Critères d'Adoption**### **Quand Utiliser CQS avec Multi-sources**#### **✅ Avantages**- **Performance optimisée** : Séparation claire entre écriture et lecture- **Flexibilité maximale** : Choix du meilleur stockage pour chaque opération- **Scalabilité** : Possibilité de scaler indépendamment chaque côté- **Résilience** : Redondance et failover entre sources- **Maintenabilité** : Code plus clair et organisé#### **❌ Inconvénients**- **Complexité élevée** : Gestion de plusieurs sources de données- **Cohérence** : Risque d'incohérence entre sources- **Maintenance** : Plus de sources à maintenir- **Expertise** : Équipe expérimentée requise#### **🎯 Critères d'Adoption**- **Système complexe** : Besoins de performance différents par type d'opération- **Données hétérogènes** : Types de données différents nécessitant différents stockages- **Performance critique** : Besoins de performance optimale- **Séparation des responsabilités** : Besoin de séparer clairement les commandes et requêtes- **Équipe expérimentée** : Maîtrise de plusieurs technologies de stockage et CQS- **Budget suffisant** : Investissement en infrastructure multiple- **Temps de développement** : Suffisant pour implémenter cette complexité## 🚀 **Votre Prochaine Étape**{{< chapter-nav >}}  {{< chapter-option     letter="A"     color="green"     title="Je veux voir l'approche CQRS avec Multi-sources"     subtitle="Vous voulez comprendre la séparation complète des responsabilités"    criteria="Architecture complexe,Équipe très expérimentée,Performance critique,Scalabilité maximale"    time="45-60 minutes"    chapter="54"    chapter-title="Stockage Multi-sources - CQRS"    chapter-url="/chapitres/stockage/multi-sources/chapitre-54-stockage-multi-sources-cqrs/"  >}}    {{< chapter-option     letter="B"     color="yellow"     title="Je veux explorer les autres types de stockage"     subtitle="Vous voulez voir les alternatives à Multi-sources"    criteria="Comparaison nécessaire,Choix de stockage,Architecture à définir,Performance à optimiser"    time="30-40 minutes"    chapter="10"    chapter-title="Choix du Type de Stockage"    chapter-url="/chapitres/fondamentaux/chapitre-10-choix-type-stockage/"  >}}    {{< chapter-option     letter="C"     color="blue"     title="Je veux voir des exemples concrets"     subtitle="Vous voulez comprendre les implémentations pratiques"    criteria="Développeur expérimenté,Besoin d'exemples pratiques,Implémentation à faire,Code à écrire"    time="Variable"    chapter="0"    chapter-title="Exemples et Implémentations"    chapter-url="/examples/"  >}}    {{< chapter-option     letter="D"     color="purple"     title="Je veux revenir aux fondamentaux"     subtitle="Vous voulez comprendre les concepts de base"    criteria="Développeur débutant,Besoin de comprendre les concepts,Projet à structurer,Équipe à former"    time="45-60 minutes"    chapter="1"    chapter-title="Introduction au Domain-Driven Design et Event Storming"    chapter-url="/chapitres/fondamentaux/chapitre-01-introduction-event-storming-ddd/"  >}}{{< /chapter-nav >}}---*CQS avec Multi-sources offre un équilibre optimal entre performance et flexibilité, parfaitement adapté aux besoins complexes de Gyroscops.*