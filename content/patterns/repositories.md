---
title: "Repositories - Patterns de Persistance"
description: "DÃ©couvrez les patterns Repository, la couche d'abstraction qui sÃ©pare la logique mÃ©tier de la persistance"
date: 2024-12-19
draft: false
weight: 3
type: "docs"
---
## ğŸŒŸ **Qu'est-ce qu'un Repository ?**Un **Repository** est un pattern qui encapsule la logique d'accÃ¨s aux donnÃ©es, fournissant une interface orientÃ©e objet pour accÃ©der Ã  la couche de persistance.### **Le Principe Fondamental**> **"Un Repository reprÃ©sente une collection d'objets en mÃ©moire"** - Eric EvansLe Repository :- **Abstrait** la persistance des donnÃ©es- **Encapsule** la logique d'accÃ¨s aux donnÃ©es- **Fournit** une interface mÃ©tier claire- **Cache** la complexitÃ© de la persistance## ğŸ—ï¸ **Repositories dans Gyroscops**### **Contexte MÃ©tier : Gestion des Utilisateurs**Dans Gyroscops, nous gÃ©rons des utilisateurs avec diffÃ©rents besoins d'accÃ¨s :#### **Interface Repository**```phpinterface UserRepository{    public function save(User $user): void;    public function findById(UserId $id): ?User;    public function findByEmail(Email $email): ?User;    public function findByOrganization(OrganizationId $organizationId): array;    public function delete(UserId $id): void;    public function exists(UserId $id): bool;}```#### **ImplÃ©mentation Doctrine**```phpclass DoctrineUserRepository implements UserRepository{    public function __construct(        private EntityManagerInterface $entityManager    ) {}        public function save(User $user): void    {        $this->entityManager->persist($user);        $this->entityManager->flush();    }        public function findById(UserId $id): ?User    {        return $this->entityManager            ->getRepository(User::class)            ->find($id->value());    }        public function findByEmail(Email $email): ?User    {        return $this->entityManager            ->getRepository(User::class)            ->findOneBy(['email' => $email->value()]);    }        public function findByOrganization(OrganizationId $organizationId): array    {        return $this->entityManager            ->getRepository(User::class)            ->findBy(['organizationId' => $organizationId->value()]);    }        public function delete(UserId $id): void    {        $user = $this->findById($id);        if ($user) {            $this->entityManager->remove($user);            $this->entityManager->flush();        }    }        public function exists(UserId $id): bool    {        return $this->entityManager            ->getRepository(User::class)            ->count(['id' => $id->value()]) > 0;    }}```## ğŸ¯ **Types de Repositories**### **1. Repository de Commande (Write)**```phpinterface PaymentCommandRepository{    public function save(Payment $payment): void;    public function findById(PaymentId $id): ?Payment;    public function delete(PaymentId $id): void;}class DoctrinePaymentCommandRepository implements PaymentCommandRepository{    public function save(Payment $payment): void    {        $this->entityManager->persist($payment);        $this->entityManager->flush();    }        public function findById(PaymentId $id): ?Payment    {        return $this->entityManager            ->getRepository(Payment::class)            ->find($id->value());    }}```### **2. Repository de RequÃªte (Read)**```phpinterface PaymentQueryRepository{    public function findPaymentDetails(PaymentId $id): ?PaymentDetailsView;    public function findPaymentsByCustomer(CustomerId $customerId): array;    public function findPaymentsByDateRange(DateRange $dateRange): array;    public function findPendingPayments(): array;}class DoctrinePaymentQueryRepository implements PaymentQueryRepository{    public function findPaymentDetails(PaymentId $id): ?PaymentDetailsView    {        $result = $this->entityManager            ->createQuery('                SELECT p.id, p.amount, p.status, p.createdAt,                       c.name as customerName, s.name as subscriptionName                FROM Payment p                JOIN p.customer c                JOIN p.subscription s                WHERE p.id = :id            ')            ->setParameter('id', $id->value())            ->getOneOrNullResult();                    return $result ? PaymentDetailsView::fromArray($result) : null;    }        public function findPaymentsByCustomer(CustomerId $customerId): array    {        return $this->entityManager            ->createQuery('                SELECT p.id, p.amount, p.status, p.createdAt                FROM Payment p                WHERE p.customerId = :customerId                ORDER BY p.createdAt DESC            ')            ->setParameter('customerId', $customerId->value())            ->getResult();    }}```### **3. Repository SpÃ©cialisÃ©**```phpinterface PaymentAnalyticsRepository{    public function getMonthlyRevenue(int $year, int $month): Amount;    public function getPaymentTrends(DateRange $dateRange): array;    public function getTopCustomers(int $limit): array;}class ElasticsearchPaymentAnalyticsRepository implements PaymentAnalyticsRepository{    public function getMonthlyRevenue(int $year, int $month): Amount    {        $query = [            'query' => [                'bool' => [                    'must' => [                        ['term' => ['status' => 'completed']],                        ['range' => ['createdAt' => [                            'gte' => "$year-$month-01",                            'lt' => "$year-" . ($month + 1) . "-01"                        ]]]                    ]                ]            ],            'aggs' => [                'total_revenue' => [                    'sum' => ['field' => 'amount']                ]            ]        ];                $result = $this->elasticsearch->search($query);        return new Amount($result['aggregations']['total_revenue']['value']);    }}```## ğŸ”§ **Patterns AvancÃ©s de Repository**### **1. Repository avec SpÃ©cifications**```phpinterface Specification{    public function isSatisfiedBy($entity): bool;    public function toQueryBuilder(QueryBuilder $qb): QueryBuilder;}class UserByOrganizationSpecification implements Specification{    public function __construct(        private OrganizationId $organizationId    ) {}        public function isSatisfiedBy($entity): bool    {        return $entity instanceof User &&                $entity->organizationId()->equals($this->organizationId);    }        public function toQueryBuilder(QueryBuilder $qb): QueryBuilder    {        return $qb->andWhere('u.organizationId = :organizationId')                  ->setParameter('organizationId', $this->organizationId->value());    }}interface UserRepository{    public function findBySpecification(Specification $spec): array;    public function countBySpecification(Specification $spec): int;}class DoctrineUserRepository implements UserRepository{    public function findBySpecification(Specification $spec): array    {        $qb = $this->entityManager->createQueryBuilder()            ->select('u')            ->from(User::class, 'u');                    return $spec->toQueryBuilder($qb)->getQuery()->getResult();    }}```### **2. Repository avec Cache**```phpclass CachedUserRepository implements UserRepository{    public function __construct(        private UserRepository $decorated,        private CacheInterface $cache    ) {}        public function findById(UserId $id): ?User    {        $cacheKey = "user_{$id->value()}";                return $this->cache->get($cacheKey, function () use ($id) {            return $this->decorated->findById($id);        });    }        public function save(User $user): void    {        $this->decorated->save($user);                // Invalider le cache        $this->cache->delete("user_{$user->id()->value()}");    }}```### **3. Repository avec Event Sourcing**```phpinterface EventStore{    public function append(StreamId $streamId, array $events): void;    public function getEvents(StreamId $streamId): array;}class EventSourcedUserRepository implements UserRepository{    public function __construct(        private EventStore $eventStore    ) {}        public function save(User $user): void    {        $events = $user->getUncommittedEvents();        $streamId = StreamId::fromUserId($user->id());                $this->eventStore->append($streamId, $events);        $user->markEventsAsCommitted();    }        public function findById(UserId $id): ?User    {        $streamId = StreamId::fromUserId($id);        $events = $this->eventStore->getEvents($streamId);                if (empty($events)) {            return null;        }                return User::fromEvents($events);    }}```## ğŸš€ **Repositories Multi-Sources**### **Repository avec Fallback**```phpclass FallbackUserRepository implements UserRepository{    public function __construct(        private UserRepository $primary,        private UserRepository $fallback    ) {}        public function findById(UserId $id): ?User    {        try {            return $this->primary->findById($id);        } catch (Exception $e) {            $this->logger->warning('Primary repository failed, using fallback', [                'error' => $e->getMessage(),                'userId' => $id->value()            ]);                        return $this->fallback->findById($id);        }    }}```### **Repository avec Routing**```phpclass RoutedUserRepository implements UserRepository{    public function __construct(        private UserRepository $sqlRepository,        private UserRepository $mongoRepository    ) {}        public function findById(UserId $id): ?User    {        // Route basÃ©e sur l'ID        if ($this->shouldUseMongo($id)) {            return $this->mongoRepository->findById($id);        }                return $this->sqlRepository->findById($id);    }        private function shouldUseMongo(UserId $id): bool    {        // Logique de routing (ex: utilisateurs rÃ©cents en MongoDB)        return $id->value() > 1000000;    }}```## âš¡ **Performance et Optimisation**### **Optimisations de RequÃªte**```phpclass OptimizedUserRepository implements UserRepository{    public function findByOrganization(OrganizationId $organizationId): array    {        // Utiliser des requÃªtes optimisÃ©es        return $this->entityManager            ->createQuery('                SELECT u.id, u.email, u.firstName, u.lastName                FROM User u                WHERE u.organizationId = :organizationId                AND u.status = :status            ')            ->setParameter('organizationId', $organizationId->value())            ->setParameter('status', UserStatus::ACTIVE)            ->setMaxResults(100) // Limiter les rÃ©sultats            ->getResult();    }}```### **Optimisations de Cache**```phpclass SmartCachedUserRepository implements UserRepository{    public function findByOrganization(OrganizationId $organizationId): array    {        $cacheKey = "users_org_{$organizationId->value()}";                return $this->cache->get($cacheKey, function () use ($organizationId) {            $users = $this->decorated->findByOrganization($organizationId);                        // Cache individuel pour chaque utilisateur            foreach ($users as $user) {                $this->cache->set("user_{$user->id()->value()}", $user, 3600);            }                        return $users;        }, 1800); // TTL de 30 minutes    }}```## ğŸ¯ **Quand Utiliser les Repositories ?**### **âœ… Cas d'Usage AppropriÃ©s**- **Abstraction de persistance** : Changer de technologie de stockage- **Tests unitaires** : Mocker facilement l'accÃ¨s aux donnÃ©es- **Logique mÃ©tier complexe** : Encapsuler la logique d'accÃ¨s- **Performance** : Optimiser les requÃªtes### **âŒ Cas d'Usage InappropriÃ©s**- **Applications simples** : CRUD basique- **Over-engineering** : ComplexitÃ© inutile- **Performance critique** : Overhead des abstractions- **Prototypage** : DÃ©veloppement rapide## ğŸ”„ **Migration vers les Repositories**### **Ã‰tape 1 : Identifier les AccÃ¨s aux DonnÃ©es**- Lister tous les accÃ¨s aux donnÃ©es- Grouper par entitÃ© mÃ©tier### **Ã‰tape 2 : CrÃ©er les Interfaces**- DÃ©finir les contrats Repository- SpÃ©cifier les mÃ©thodes nÃ©cessaires### **Ã‰tape 3 : ImplÃ©menter les Repositories**- CrÃ©er les implÃ©mentations- Migrer progressivement### **Ã‰tape 4 : Optimiser**- Ajouter le cache si nÃ©cessaire- Optimiser les requÃªtes## ğŸ“Š **MÃ©triques et Monitoring**### **MÃ©triques Repository**- Temps de rÃ©ponse des requÃªtes- Taux de cache hit- Nombre de requÃªtes par seconde### **MÃ©triques de Performance**- Temps de traitement des requÃªtes complexes- Utilisation mÃ©moire- Charge des bases de donnÃ©es## ğŸ¯ **Prochaines Ã‰tapes**Maintenant que vous comprenez les Repositories, explorez :1. **[CQRS](/concept/cqrs/)** : SÃ©parer les commandes des requÃªtes2. **[Event Sourcing](/concept/event-sourcing/)** : Stocker les Ã©vÃ©nements comme source de vÃ©ritÃ©3. **[ImplÃ©mentation Repositories](/chapitres/fondamentaux/chapitre-09-repositories-persistance/)** : Guide d'implÃ©mentation complet---*Les Repositories sont la pierre angulaire d'une architecture propre. Dans Gyroscops, ils nous ont permis de sÃ©parer clairement la logique mÃ©tier de la persistance, rendant le code plus testable et Ã©volutif.*