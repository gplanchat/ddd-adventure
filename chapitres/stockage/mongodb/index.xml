<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Stockage MongoDB on DDD Adventure</title><link>http://localhost:1313/chapitres/stockage/mongodb/</link><description>Recent content in Stockage MongoDB on DDD Adventure</description><generator>Hugo</generator><language>fr-fr</language><lastBuildDate>Thu, 19 Dec 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/chapitres/stockage/mongodb/index.xml" rel="self" type="application/rss+xml"/><item><title>Chapitre 28 : Stockage MongoDB - Approche Classique</title><link>http://localhost:1313/chapitres/stockage/mongodb/chapitre-28-stockage-mongodb-classique/</link><pubDate>Mon, 15 Jan 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/mongodb/chapitre-28-stockage-mongodb-classique/</guid><description>&lt;h2 id="-objectif-du-chapitrece-chapitre-explore-lutilisation-de-mongodb-pour-la-persistance-avec-une-approche-classique-en-mettant-laccent-sur-les-patterns-de-base-et-les-bonnes-pratiques-pour-les-applications-nosql--prérequis--chapitre-9--repositories-et-persistance---comprendre-les-patterns-de-persistance--chapitre-15--choix-du-type-de-stockage---comprendre-les-options-disponibles--connaissance-mongodb--bases-de-mongodb-et-des-concepts-nosql--architecture-mongodb-classique-vue-densemblelapproche-classique-avec-mongodb-utilise---collections--équivalent-des-tables-en-sql--documents--structure-json-flexible--indexes--optimisation-des-requêtes--repository-pattern--abstraction-de-la-persistance-diagramme-darchitecturemermaidgraph-tb----subgraph-couche-application--------sservice--------rrepository----end--------subgraph-couche-infrastructure--------mrmongodb-repository--------mcmongodb-client----end--------subgraph-couche-persistance--------dbmongodb--------idxindexes----end--------s----r----r----mr----mr----mc----mc----db----db----idx--implémentation-technique-1-configuration-mongodbphpphpnamespace-appaccountinginfrastructureconfigurationuse-mongodbclientuse-mongodbdatabaseclass-mongodbconfiguration----private-client-client----private-database-database--------public-function-__constructstring-connectionstring-string-databasename------------this-client--new-clientconnectionstring--------this-database--this-client-selectdatabasedatabasename------------public-function-getclient-client------------return-this-client------------public-function-getdatabase-database------------return-this-database------------public-function-getcollectionstring-name-mongodbcollection------------return-this-database-selectcollectionname-----2-repository-mongodb-de-basephpphpnamespace-appaccountinginfrastructurerepositoryuse-appaccountingdomainaggregatepaymentuse-appaccountingdomainvalueobjectpaymentiduse-appaccountingdomainrepositorypaymentrepositoryinterfaceuse-appaccountinginfrastructureconfigurationmongodbconfigurationuse-appaccountinginfrastructuremapperpaymentmapperclass-mongodbpaymentrepository-implements-paymentrepositoryinterface----private-mongodbcollection-collection--------public-function-__construct--------private-mongodbconfiguration-mongoconfig--------private-paymentmapper-mapper-------------this-collection--mongoconfig-getcollectionpayments------------public-function-savepayment-payment-void------------document--this-mapper-todocumentpayment----------------this-collection-replaceone------------_id--payment-getid-getvalue------------document------------upsert--true--------------------public-function-findpaymentid-id-payment------------document--this-collection-findone_id--id-getvalue----------------if-document-------------return-null------------------------return-this-mapper-todomaindocument------------public-function-findall-array------------documents--this-collection-find----------------return-array_map------------fndoc--this-mapper-todomaindoc------------documents-toarray--------------------public-function-findbystatusstring-status-array------------documents--this-collection-findstatus--status----------------return-array_map------------fndoc--this-mapper-todomaindoc------------documents-toarray-------------3-mapper-pour-la-conversionphpphpnamespace-appaccountinginfrastructuremapperuse-appaccountingdomainaggregatepaymentuse-appaccountingdomainvalueobjectpaymentiduse-appaccountingdomainvalueobjectamountuse-appaccountingdomainvalueobjectcurrencyclass-paymentmapper----public-function-todocumentpayment-payment-array------------return-------------_id--payment-getid-getvalue------------amount--payment-getamount-getvalue------------currency--payment-getcurrency-getcode------------status--payment-getstatus-getvalue------------created_at--payment-getcreatedat-formaty-m-d-his------------updated_at--payment-getupdatedat-formaty-m-d-his------------metadata--payment-getmetadata-toarray--------------------public-function-todomainarray-document-payment------------return-paymentfromarray------------id--document_id------------amount--documentamount------------currency--documentcurrency------------status--documentstatus------------created_at--documentcreated_at------------updated_at--documentupdated_at------------metadata--documentmetadata----------------patterns-dimplémentation-1-repository-avec-requêtes-complexesphpphpnamespace-appaccountinginfrastructurerepositoryuse-appaccountingdomainvalueobjectpaymentiduse-appaccountingdomainvalueobjectamountuse-appaccountingdomainvalueobjectcurrencyuse-mongodbbsonobjectidclass-advancedmongodbpaymentrepository----private-mongodbcollection-collection--------public-function-__construct--------private-mongodbconfiguration-mongoconfig--------private-paymentmapper-mapper-------------this-collection--mongoconfig-getcollectionpayments------------public-function-findbyamountrangeamount-minamount-amount-maxamount-array------------documents--this-collection-find------------amount------------------gte--minamount-getvalue----------------lte--maxamount-getvalue------------------------------------return-array_map------------fndoc--this-mapper-todomaindoc------------documents-toarray--------------------public-function-findbycurrencycurrency-currency-array------------documents--this-collection-find------------currency--currency-getcode------------------------return-array_map------------fndoc--this-mapper-todomaindoc------------documents-toarray--------------------public-function-findrecentint-days--7-array------------startdate--new-datetimeimmutable-days-days----------------documents--this-collection-find------------created_at------------------gte--startdate-formaty-m-d-his------------------------------------return-array_map------------fndoc--this-mapper-todomaindoc------------documents-toarray--------------------public-function-aggregatebystatus-array------------pipeline------------------------------group----------------------_id--status--------------------count--sum--1--------------------total_amount--sum--amount--------------------------------------------------------sort--count---1------------------------------------result--this-collection-aggregatepipeline----------------return-result-toarray-----2-gestion-des-indexesphpphpnamespace-appaccountinginfrastructureindexuse-appaccountinginfrastructureconfigurationmongodbconfigurationclass-paymentindexmanager----private-mongodbcollection-collection--------public-function-__constructmongodbconfiguration-mongoconfig------------this-collection--mongoconfig-getcollectionpayments------------public-function-createindexes-void-------------index-simple-sur-le-statut--------this-collection-createindexstatus--1-----------------index-composé-sur-la-devise-et-le-montant--------this-collection-createindex------------currency--1------------amount--1-------------------------index-sur-la-date-de-création--------this-collection-createindexcreated_at--1-----------------index-de-texte-pour-la-recherche--------this-collection-createindex------------metadatadescription--text------------metadatanotes--text-------------------------index-ttl-pour-lexpiration-automatique--------this-collection-createindex------------expires_at--1------------expireafterseconds--0--------------------public-function-getindexes-array------------return-this-collection-listindexes-toarray-----3-gestion-des-transactionsphpphpnamespace-appaccountinginfrastructuretransactionuse-appaccountingdomainaggregatepaymentuse-appaccountingdomainaggregatesubscriptionuse-appaccountinginfrastructureconfigurationmongodbconfigurationclass-mongodbtransactionmanager----private-mongodbdatabase-database--------public-function-__constructmongodbconfiguration-mongoconfig------------this-database--mongoconfig-getdatabase------------public-function-executeintransactioncallable-callback-mixed------------session--this-database-getclient-startsession----------------try-------------session-starttransaction------------------------result--callbacksession------------------------session-committransaction------------------------return-result---------catch-exception-e-------------session-aborttransaction------------throw-e---------finally-------------session-endsession--------------------public-function-processpaymentwithsubscription--------payment-payment--------subscription-subscription-----void---------this-executeintransactionfunction-session-use-payment-subscription--------------sauvegarder-le-paiement------------paymentcollection--this-database-selectcollectionpayments------------paymentcollection-replaceone----------------_id--payment-getid-getvalue----------------this-paymentmapper-todocumentpayment----------------upsert--true-session--session-------------------------------------mettre-à-jour-labonnement------------subscriptioncollection--this-database-selectcollectionsubscriptions------------subscriptioncollection-replaceone----------------_id--subscription-getid-getvalue----------------this-subscriptionmapper-todocumentsubscription----------------upsert--true-session--session--------------------------gestion-des-erreurs-et-résilience-1-gestion-des-erreurs-mongodbphpphpnamespace-appaccountinginfrastructureerroruse-mongodbexceptionexceptioninterfaceuse-mongodbexceptionwriteexceptionuse-mongodbexceptionconnectionexceptionuse-psrlogloggerinterfaceclass-mongodberrorhandler----public-function-__construct--------private-loggerinterface-logger-------------public-function-handleexceptionexceptioninterface-e-void------------if-e-instanceof-writeexception-------------this-handlewriteexceptione---------elseif-e-instanceof-connectionexception-------------this-handleconnectionexceptione---------else-------------this-handlegenericexceptione--------------------private-function-handlewriteexceptionwriteexception-e-void------------this-logger-errormongodb-write-error-------------error--e-getmessage------------code--e-getcode------------write_errors--e-getwriteresult-getwriteerrors-------------------------logique-de-retry-ou-de-fallback--------throw-new-runtimeexceptionfailed-to-write-to-mongodb-0-e------------private-function-handleconnectionexceptionconnectionexception-e-void------------this-logger-errormongodb-connection-error-------------error--e-getmessage------------code--e-getcode-------------------------logique-de-reconnexion--------throw-new-runtimeexceptionmongodb-connection-failed-0-e-----2-retry-patternphpphpnamespace-appaccountinginfrastructureretryuse-mongodbexceptionexceptioninterfaceuse-mongodbexceptionwriteexceptionclass-mongodbretryhandler----private-int-maxretries----private-int-basedelay--------public-function-__constructint-maxretries--3-int-basedelay--1000------------this-maxretries--maxretries--------this-basedelay--basedelay------------public-function-executewithretrycallable-operation-mixed------------attempt--0--------lastexception--null----------------while-attempt--this-maxretries-------------try-----------------return-operation-------------catch-writeexception-e-----------------lastexception--e--------------------------------if-this-shouldretrye---------------------attempt--------------------delay--this-calculatedelayattempt--------------------usleepdelay--1000-----------------else---------------------throw-e-----------------------------catch-exceptioninterface-e-----------------throw-e------------------------------------throw-lastexception------------private-function-shouldretrywriteexception-e-bool------------writeerrors--e-getwriteresult-getwriteerrors----------------foreach-writeerrors-as-error--------------retry-sur-les-erreurs-temporaires------------if-in_arrayerrorcode-11000-11001-112-----------------return-true------------------------------------return-false------------private-function-calculatedelayint-attempt-int------------return-this-basedelay--pow2-attempt---1------monitoring-et-observabilité-1-métriques-mongodbphpphpnamespace-appaccountinginfrastructuremonitoringuse-appaccountinginfrastructureconfigurationmongodbconfigurationuse-appaccountinginfrastructuremetricsprometheusmetricsclass-mongodbmetricscollector----public-function-__construct--------private-mongodbconfiguration-mongoconfig--------private-prometheusmetrics-metrics-------------public-function-collectmetrics-void------------stats--this-mongoconfig-getdatabase-commanddbstats--1-toarray0-----------------métriques-de-base--------this-metrics-setgaugemongodb_database_size_bytes-statsdatasize--------this-metrics-setgaugemongodb_index_size_bytes-statsindexsize--------this-metrics-setgaugemongodb_collections_total-statscollections--------this-metrics-setgaugemongodb_indexes_total-statsindexes-----------------métriques-de-performance--------this-metrics-setgaugemongodb_operations_total-statsopcountersinsert--statsopcountersquery--------this-metrics-setgaugemongodb_connections_current-statsconnectionscurrent------------public-function-recordoperationstring-operation-float-duration-bool-success-void------------this-metrics-incrementcountermongodb_operations_total-------------operation--operation------------status--success--success--error------------------------this-metrics-recordhistogrammongodb_operation_duration-duration-------------operation--operation-------------2-health-checkphpphpnamespace-appaccountinginfrastructurehealthuse-appaccountinginfrastructureconfigurationmongodbconfigurationclass-mongodbhealthcheck----public-function-__construct--------private-mongodbconfiguration-mongoconfig-------------public-function-check-array------------try--------------test-de-connexion------------this-mongoconfig-getdatabase-commandping--1-------------------------test-de-lecture------------this-mongoconfig-getcollectionpayments-findone------------------------return-----------------status--healthy----------------database--connected----------------read--working----------------write--working---------------------catch-exception-e-------------return-----------------status--unhealthy----------------error--e-getmessage----------------database--disconnected--------------------------avantages-de-lapproche-1-flexibilité-du-schéma--documents-flexibles--structure-json-adaptable--évolution-facile--pas-de-migrations-de-schéma--données-hétérogènes--support-des-données-variées-2-performance--indexes-optimisés--requêtes-rapides--sharding--distribution-horizontale--cache-intégré--performance-mémoire-3-développement--api-simple--interface-intuitive--requêtes-puissantes--aggregation-pipeline--intégration-facile--drivers-multiples--inconvénients-et-considérations-1-consistance--acid-limité--pas-de-transactions-complexes--consistance-éventuelle--dans-les-clusters--pas-de-contraintes--validation-applicative-2-requêtes--pas-de-joins--relations-manuelles--requêtes-complexes--aggregation-pipeline--performance--indexes-critiques-3-maintenance--monitoring--outils-spécialisés--backup--stratégies-spécifiques--scaling--configuration-complexe--configuration-et-déploiement-1-configuration-des-servicesyaml-configpackagesmongodbyamlmongodb--connections----default------uri-envmongodb_uri------database-envmongodb_database------options--------connecttimeoutms-30000--------sockettimeoutms-30000--------serverselectiontimeoutms-30000--------maxpoolsize-10--------minpoolsize-1-2-déploiement-avec-dockeryaml-docker-composeymlversion-38services--mongodb----image-mongo60----container_name-gyroscops-cloud-mongodb----restart-unless-stopped----ports--------2701727017----environment------mongo_initdb_root_username-admin------mongo_initdb_root_password-password------mongo_initdb_database-hive_accounting----volumes--------mongodb_datadatadb--------mongodbinitdocker-entrypoint-initdbd----networks--------gyroscops-cloud-networkvolumes--mongodb_datanetworks--gyroscops-cloud-network----driver-bridge--exemples-concrets-du-projet-gyroscops-cloud-1-repository-de-paiementsphpphpnamespace-appaccountinginfrastructurerepositoryuse-appaccountingdomainaggregatepaymentuse-appaccountingdomainvalueobjectpaymentiduse-appaccountinginfrastructureconfigurationmongodbconfigurationclass-hivepaymentrepository----private-mongodbcollection-collection--------public-function-__constructmongodbconfiguration-mongoconfig------------this-collection--mongoconfig-getcollectionpayments------------public-function-savepayment-payment-void------------document--------------_id--payment-getid-getvalue------------amount--payment-getamount-getvalue------------currency--payment-getcurrency-getcode------------status--payment-getstatus-getvalue------------workspace_id--payment-getworkspaceid-getvalue------------organization_id--payment-getorganizationid-getvalue------------created_at--payment-getcreatedat-formaty-m-d-his------------updated_at--payment-getupdatedat-formaty-m-d-his------------metadata--payment-getmetadata-toarray------------------------this-collection-replaceone------------_id--payment-getid-getvalue------------document------------upsert--true--------------------public-function-findbyworkspacestring-workspaceid-array------------documents--this-collection-find------------workspace_id--workspaceid------------------------return-array_map------------fndoc--this-maptopaymentdoc------------documents-toarray-------------2-aggregation-pour-les-rapportsphpphpnamespace-appaccountinginfrastructurereportuse-appaccountinginfrastructureconfigurationmongodbconfigurationclass-paymentreportgenerator----private-mongodbcollection-collection--------public-function-__constructmongodbconfiguration-mongoconfig------------this-collection--mongoconfig-getcollectionpayments------------public-function-generatemonthlyreportstring-workspaceid-int-year-int-month-array------------startdate--new-datetimeimmutableyear-month-01--------enddate--startdate-modify1-month----------------pipeline------------------------------match----------------------workspace_id--workspaceid--------------------created_at--------------------------gte--startdate-formaty-m-d-his------------------------lt--enddate-formaty-m-d-his----------------------------------------------------------------------------group----------------------_id--------------------------status--status------------------------currency--currency----------------------------------------count--sum--1--------------------total_amount--sum--amount--------------------avg_amount--avg--amount--------------------------------------------------------sort--total_amount---1------------------------------------return-this-collection-aggregatepipeline-toarray------critères-dadoption--adoptez-cette-approche-si---données-non-relationnelles-avec-structure-flexible--performance-de-lecture-importante--évolutivité-horizontale-requise--équipe-expérimentée-avec-nosql--requêtes-complexes-avec-aggregation--flexibilité-du-schéma-nécessaire--évitez-cette-approche-si---données-relationnelles-strictes--transactions-acid-critiques--équipe-junior-sans-expérience-nosql--requêtes-simples-avec-joins--contraintes-de-schéma-importantes--métriques-de-succès-1-performance--temps-de-réponse-des-requêtes--50ms--throughput-des-opérations--10000min--disponibilité--999-2-qualité--couverture-de-tests--90--taux-d--01--temps-de-récupération--2-minutes-3-business--satisfaction-utilisateur--455--temps-de-développement-des-nouvelles-fonctionnalités--coût-de-maintenance-acceptable--votre-prochaine-étapemaintenant-que-vous-comprenez-lapproche-classique-avec-mongodb-quel-est-votre-contexte-hahahugoshortcode51s0hbhb"&gt;🎯 Objectif du ChapitreCe chapitre explore l&amp;rsquo;utilisation de MongoDB pour la persistance avec une approche classique, en mettant l&amp;rsquo;accent sur les patterns de base et les bonnes pratiques pour les applications NoSQL.## 📋 Prérequis- &lt;strong&gt;Chapitre 9&lt;/strong&gt; : Repositories et Persistance - Comprendre les patterns de persistance- &lt;strong&gt;Chapitre 15&lt;/strong&gt; : Choix du Type de Stockage - Comprendre les options disponibles- &lt;strong&gt;Connaissance MongoDB&lt;/strong&gt; : Bases de MongoDB et des concepts NoSQL## 🏗️ Architecture MongoDB Classique### Vue d&amp;rsquo;EnsembleL&amp;rsquo;approche classique avec MongoDB utilise :- &lt;strong&gt;Collections&lt;/strong&gt; : Équivalent des tables en SQL- &lt;strong&gt;Documents&lt;/strong&gt; : Structure JSON flexible- &lt;strong&gt;Indexes&lt;/strong&gt; : Optimisation des requêtes- &lt;strong&gt;Repository Pattern&lt;/strong&gt; : Abstraction de la persistance### Diagramme d&amp;rsquo;Architecture&lt;code&gt;mermaidgraph TB subgraph &amp;quot;Couche Application&amp;quot; S[Service] R[Repository] end subgraph &amp;quot;Couche Infrastructure&amp;quot; MR[MongoDB Repository] MC[MongoDB Client] end subgraph &amp;quot;Couche Persistance&amp;quot; DB[(MongoDB)] IDX[(Indexes)] end S --&amp;gt; R R --&amp;gt; MR MR --&amp;gt; MC MC --&amp;gt; DB DB --&amp;gt; IDX&lt;/code&gt;## 🔧 Implémentation Technique### 1. Configuration MongoDB&lt;code&gt;php&amp;lt;?phpnamespace App\Accounting\Infrastructure\Configuration;use MongoDB\Client;use MongoDB\Database;class MongoDBConfiguration{ private Client $client; private Database $database; public function __construct(string $connectionString, string $databaseName) { $this-&amp;gt;client = new Client($connectionString); $this-&amp;gt;database = $this-&amp;gt;client-&amp;gt;selectDatabase($databaseName); } public function getClient(): Client { return $this-&amp;gt;client; } public function getDatabase(): Database { return $this-&amp;gt;database; } public function getCollection(string $name): \MongoDB\Collection { return $this-&amp;gt;database-&amp;gt;selectCollection($name); }}&lt;/code&gt;### 2. Repository MongoDB de Base&lt;code&gt;php&amp;lt;?phpnamespace App\Accounting\Infrastructure\Repository;use App\Accounting\Domain\Aggregate\Payment;use App\Accounting\Domain\ValueObject\PaymentId;use App\Accounting\Domain\Repository\PaymentRepositoryInterface;use App\Accounting\Infrastructure\Configuration\MongoDBConfiguration;use App\Accounting\Infrastructure\Mapper\PaymentMapper;class MongoDBPaymentRepository implements PaymentRepositoryInterface{ private \MongoDB\Collection $collection; public function __construct( private MongoDBConfiguration $mongoConfig, private PaymentMapper $mapper ) { $this-&amp;gt;collection = $mongoConfig-&amp;gt;getCollection('payments'); } public function save(Payment $payment): void { $document = $this-&amp;gt;mapper-&amp;gt;toDocument($payment); $this-&amp;gt;collection-&amp;gt;replaceOne( ['_id' =&amp;gt; $payment-&amp;gt;getId()-&amp;gt;getValue()], $document, ['upsert' =&amp;gt; true] ); } public function find(PaymentId $id): ?Payment { $document = $this-&amp;gt;collection-&amp;gt;findOne(['_id' =&amp;gt; $id-&amp;gt;getValue()]); if (!$document) { return null; } return $this-&amp;gt;mapper-&amp;gt;toDomain($document); } public function findAll(): array { $documents = $this-&amp;gt;collection-&amp;gt;find(); return array_map( fn($doc) =&amp;gt; $this-&amp;gt;mapper-&amp;gt;toDomain($doc), $documents-&amp;gt;toArray() ); } public function findByStatus(string $status): array { $documents = $this-&amp;gt;collection-&amp;gt;find(['status' =&amp;gt; $status]); return array_map( fn($doc) =&amp;gt; $this-&amp;gt;mapper-&amp;gt;toDomain($doc), $documents-&amp;gt;toArray() ); }}&lt;/code&gt;### 3. Mapper pour la Conversion&lt;code&gt;php&amp;lt;?phpnamespace App\Accounting\Infrastructure\Mapper;use App\Accounting\Domain\Aggregate\Payment;use App\Accounting\Domain\ValueObject\PaymentId;use App\Accounting\Domain\ValueObject\Amount;use App\Accounting\Domain\ValueObject\Currency;class PaymentMapper{ public function toDocument(Payment $payment): array { return [ '_id' =&amp;gt; $payment-&amp;gt;getId()-&amp;gt;getValue(), 'amount' =&amp;gt; $payment-&amp;gt;getAmount()-&amp;gt;getValue(), 'currency' =&amp;gt; $payment-&amp;gt;getCurrency()-&amp;gt;getCode(), 'status' =&amp;gt; $payment-&amp;gt;getStatus()-&amp;gt;getValue(), 'created_at' =&amp;gt; $payment-&amp;gt;getCreatedAt()-&amp;gt;format('Y-m-d H:i:s'), 'updated_at' =&amp;gt; $payment-&amp;gt;getUpdatedAt()-&amp;gt;format('Y-m-d H:i:s'), 'metadata' =&amp;gt; $payment-&amp;gt;getMetadata()-&amp;gt;toArray() ]; } public function toDomain(array $document): Payment { return Payment::fromArray([ 'id' =&amp;gt; $document['_id'], 'amount' =&amp;gt; $document['amount'], 'currency' =&amp;gt; $document['currency'], 'status' =&amp;gt; $document['status'], 'created_at' =&amp;gt; $document['created_at'], 'updated_at' =&amp;gt; $document['updated_at'], 'metadata' =&amp;gt; $document['metadata'] ?? [] ]); }}&lt;/code&gt;## 🎨 Patterns d&amp;rsquo;Implémentation### 1. Repository avec Requêtes Complexes&lt;code&gt;php&amp;lt;?phpnamespace App\Accounting\Infrastructure\Repository;use App\Accounting\Domain\ValueObject\PaymentId;use App\Accounting\Domain\ValueObject\Amount;use App\Accounting\Domain\ValueObject\Currency;use MongoDB\BSON\ObjectId;class AdvancedMongoDBPaymentRepository{ private \MongoDB\Collection $collection; public function __construct( private MongoDBConfiguration $mongoConfig, private PaymentMapper $mapper ) { $this-&amp;gt;collection = $mongoConfig-&amp;gt;getCollection('payments'); } public function findByAmountRange(Amount $minAmount, Amount $maxAmount): array { $documents = $this-&amp;gt;collection-&amp;gt;find([ 'amount' =&amp;gt; [ '$gte' =&amp;gt; $minAmount-&amp;gt;getValue(), '$lte' =&amp;gt; $maxAmount-&amp;gt;getValue() ] ]); return array_map( fn($doc) =&amp;gt; $this-&amp;gt;mapper-&amp;gt;toDomain($doc), $documents-&amp;gt;toArray() ); } public function findByCurrency(Currency $currency): array { $documents = $this-&amp;gt;collection-&amp;gt;find([ 'currency' =&amp;gt; $currency-&amp;gt;getCode() ]); return array_map( fn($doc) =&amp;gt; $this-&amp;gt;mapper-&amp;gt;toDomain($doc), $documents-&amp;gt;toArray() ); } public function findRecent(int $days = 7): array { $startDate = new \DateTimeImmutable(&amp;quot;-{$days} days&amp;quot;); $documents = $this-&amp;gt;collection-&amp;gt;find([ 'created_at' =&amp;gt; [ '$gte' =&amp;gt; $startDate-&amp;gt;format('Y-m-d H:i:s') ] ]); return array_map( fn($doc) =&amp;gt; $this-&amp;gt;mapper-&amp;gt;toDomain($doc), $documents-&amp;gt;toArray() ); } public function aggregateByStatus(): array { $pipeline = [ [ '$group' =&amp;gt; [ '_id' =&amp;gt; '$status', 'count' =&amp;gt; ['$sum' =&amp;gt; 1], 'total_amount' =&amp;gt; ['$sum' =&amp;gt; '$amount'] ] ], [ '$sort' =&amp;gt; ['count' =&amp;gt; -1] ] ]; $result = $this-&amp;gt;collection-&amp;gt;aggregate($pipeline); return $result-&amp;gt;toArray(); }}&lt;/code&gt;### 2. Gestion des Indexes&lt;code&gt;php&amp;lt;?phpnamespace App\Accounting\Infrastructure\Index;use App\Accounting\Infrastructure\Configuration\MongoDBConfiguration;class PaymentIndexManager{ private \MongoDB\Collection $collection; public function __construct(MongoDBConfiguration $mongoConfig) { $this-&amp;gt;collection = $mongoConfig-&amp;gt;getCollection('payments'); } public function createIndexes(): void { // Index simple sur le statut $this-&amp;gt;collection-&amp;gt;createIndex(['status' =&amp;gt; 1]); // Index composé sur la devise et le montant $this-&amp;gt;collection-&amp;gt;createIndex([ 'currency' =&amp;gt; 1, 'amount' =&amp;gt; 1 ]); // Index sur la date de création $this-&amp;gt;collection-&amp;gt;createIndex(['created_at' =&amp;gt; 1]); // Index de texte pour la recherche $this-&amp;gt;collection-&amp;gt;createIndex([ 'metadata.description' =&amp;gt; 'text', 'metadata.notes' =&amp;gt; 'text' ]); // Index TTL pour l'expiration automatique $this-&amp;gt;collection-&amp;gt;createIndex( ['expires_at' =&amp;gt; 1], ['expireAfterSeconds' =&amp;gt; 0] ); } public function getIndexes(): array { return $this-&amp;gt;collection-&amp;gt;listIndexes()-&amp;gt;toArray(); }}&lt;/code&gt;### 3. Gestion des Transactions&lt;code&gt;php&amp;lt;?phpnamespace App\Accounting\Infrastructure\Transaction;use App\Accounting\Domain\Aggregate\Payment;use App\Accounting\Domain\Aggregate\Subscription;use App\Accounting\Infrastructure\Configuration\MongoDBConfiguration;class MongoDBTransactionManager{ private \MongoDB\Database $database; public function __construct(MongoDBConfiguration $mongoConfig) { $this-&amp;gt;database = $mongoConfig-&amp;gt;getDatabase(); } public function executeInTransaction(callable $callback): mixed { $session = $this-&amp;gt;database-&amp;gt;getClient()-&amp;gt;startSession(); try { $session-&amp;gt;startTransaction(); $result = $callback($session); $session-&amp;gt;commitTransaction(); return $result; } catch (\Exception $e) { $session-&amp;gt;abortTransaction(); throw $e; } finally { $session-&amp;gt;endSession(); } } public function processPaymentWithSubscription( Payment $payment, Subscription $subscription ): void { $this-&amp;gt;executeInTransaction(function ($session) use ($payment, $subscription) { // Sauvegarder le paiement $paymentCollection = $this-&amp;gt;database-&amp;gt;selectCollection('payments'); $paymentCollection-&amp;gt;replaceOne( ['_id' =&amp;gt; $payment-&amp;gt;getId()-&amp;gt;getValue()], $this-&amp;gt;paymentMapper-&amp;gt;toDocument($payment), ['upsert' =&amp;gt; true, 'session' =&amp;gt; $session] ); // Mettre à jour l'abonnement $subscriptionCollection = $this-&amp;gt;database-&amp;gt;selectCollection('subscriptions'); $subscriptionCollection-&amp;gt;replaceOne( ['_id' =&amp;gt; $subscription-&amp;gt;getId()-&amp;gt;getValue()], $this-&amp;gt;subscriptionMapper-&amp;gt;toDocument($subscription), ['upsert' =&amp;gt; true, 'session' =&amp;gt; $session] ); }); }}&lt;/code&gt;## 🔄 Gestion des Erreurs et Résilience### 1. Gestion des Erreurs MongoDB&lt;code&gt;php&amp;lt;?phpnamespace App\Accounting\Infrastructure\Error;use MongoDB\Exception\ExceptionInterface;use MongoDB\Exception\WriteException;use MongoDB\Exception\ConnectionException;use Psr\Log\LoggerInterface;class MongoDBErrorHandler{ public function __construct( private LoggerInterface $logger ) {} public function handleException(ExceptionInterface $e): void { if ($e instanceof WriteException) { $this-&amp;gt;handleWriteException($e); } elseif ($e instanceof ConnectionException) { $this-&amp;gt;handleConnectionException($e); } else { $this-&amp;gt;handleGenericException($e); } } private function handleWriteException(WriteException $e): void { $this-&amp;gt;logger-&amp;gt;error('MongoDB Write Error', [ 'error' =&amp;gt; $e-&amp;gt;getMessage(), 'code' =&amp;gt; $e-&amp;gt;getCode(), 'write_errors' =&amp;gt; $e-&amp;gt;getWriteResult()-&amp;gt;getWriteErrors() ]); // Logique de retry ou de fallback throw new \RuntimeException('Failed to write to MongoDB', 0, $e); } private function handleConnectionException(ConnectionException $e): void { $this-&amp;gt;logger-&amp;gt;error('MongoDB Connection Error', [ 'error' =&amp;gt; $e-&amp;gt;getMessage(), 'code' =&amp;gt; $e-&amp;gt;getCode() ]); // Logique de reconnexion throw new \RuntimeException('MongoDB connection failed', 0, $e); }}&lt;/code&gt;### 2. Retry Pattern&lt;code&gt;php&amp;lt;?phpnamespace App\Accounting\Infrastructure\Retry;use MongoDB\Exception\ExceptionInterface;use MongoDB\Exception\WriteException;class MongoDBRetryHandler{ private int $maxRetries; private int $baseDelay; public function __construct(int $maxRetries = 3, int $baseDelay = 1000) { $this-&amp;gt;maxRetries = $maxRetries; $this-&amp;gt;baseDelay = $baseDelay; } public function executeWithRetry(callable $operation): mixed { $attempt = 0; $lastException = null; while ($attempt &amp;lt; $this-&amp;gt;maxRetries) { try { return $operation(); } catch (WriteException $e) { $lastException = $e; if ($this-&amp;gt;shouldRetry($e)) { $attempt++; $delay = $this-&amp;gt;calculateDelay($attempt); usleep($delay * 1000); } else { throw $e; } } catch (ExceptionInterface $e) { throw $e; } } throw $lastException; } private function shouldRetry(WriteException $e): bool { $writeErrors = $e-&amp;gt;getWriteResult()-&amp;gt;getWriteErrors(); foreach ($writeErrors as $error) { // Retry sur les erreurs temporaires if (in_array($error['code'], [11000, 11001, 112])) { return true; } } return false; } private function calculateDelay(int $attempt): int { return $this-&amp;gt;baseDelay * pow(2, $attempt - 1); }}&lt;/code&gt;## 📊 Monitoring et Observabilité### 1. Métriques MongoDB&lt;code&gt;php&amp;lt;?phpnamespace App\Accounting\Infrastructure\Monitoring;use App\Accounting\Infrastructure\Configuration\MongoDBConfiguration;use App\Accounting\Infrastructure\Metrics\PrometheusMetrics;class MongoDBMetricsCollector{ public function __construct( private MongoDBConfiguration $mongoConfig, private PrometheusMetrics $metrics ) {} public function collectMetrics(): void { $stats = $this-&amp;gt;mongoConfig-&amp;gt;getDatabase()-&amp;gt;command(['dbStats' =&amp;gt; 1])-&amp;gt;toArray()[0]; // Métriques de base $this-&amp;gt;metrics-&amp;gt;setGauge('mongodb_database_size_bytes', $stats['dataSize']); $this-&amp;gt;metrics-&amp;gt;setGauge('mongodb_index_size_bytes', $stats['indexSize']); $this-&amp;gt;metrics-&amp;gt;setGauge('mongodb_collections_total', $stats['collections']); $this-&amp;gt;metrics-&amp;gt;setGauge('mongodb_indexes_total', $stats['indexes']); // Métriques de performance $this-&amp;gt;metrics-&amp;gt;setGauge('mongodb_operations_total', $stats['opcounters']['insert'] + $stats['opcounters']['query']); $this-&amp;gt;metrics-&amp;gt;setGauge('mongodb_connections_current', $stats['connections']['current']); } public function recordOperation(string $operation, float $duration, bool $success): void { $this-&amp;gt;metrics-&amp;gt;incrementCounter('mongodb_operations_total', [ 'operation' =&amp;gt; $operation, 'status' =&amp;gt; $success ? 'success' : 'error' ]); $this-&amp;gt;metrics-&amp;gt;recordHistogram('mongodb_operation_duration', $duration, [ 'operation' =&amp;gt; $operation ]); }}&lt;/code&gt;### 2. Health Check&lt;code&gt;php&amp;lt;?phpnamespace App\Accounting\Infrastructure\Health;use App\Accounting\Infrastructure\Configuration\MongoDBConfiguration;class MongoDBHealthCheck{ public function __construct( private MongoDBConfiguration $mongoConfig ) {} public function check(): array { try { // Test de connexion $this-&amp;gt;mongoConfig-&amp;gt;getDatabase()-&amp;gt;command(['ping' =&amp;gt; 1]); // Test de lecture $this-&amp;gt;mongoConfig-&amp;gt;getCollection('payments')-&amp;gt;findOne(); return [ 'status' =&amp;gt; 'healthy', 'database' =&amp;gt; 'connected', 'read' =&amp;gt; 'working', 'write' =&amp;gt; 'working' ]; } catch (\Exception $e) { return [ 'status' =&amp;gt; 'unhealthy', 'error' =&amp;gt; $e-&amp;gt;getMessage(), 'database' =&amp;gt; 'disconnected' ]; } }}&lt;/code&gt;## 🎯 Avantages de l&amp;rsquo;Approche### 1. Flexibilité du Schéma- &lt;strong&gt;Documents flexibles&lt;/strong&gt; : Structure JSON adaptable- &lt;strong&gt;Évolution facile&lt;/strong&gt; : Pas de migrations de schéma- &lt;strong&gt;Données hétérogènes&lt;/strong&gt; : Support des données variées### 2. Performance- &lt;strong&gt;Indexes optimisés&lt;/strong&gt; : Requêtes rapides- &lt;strong&gt;Sharding&lt;/strong&gt; : Distribution horizontale- &lt;strong&gt;Cache intégré&lt;/strong&gt; : Performance mémoire### 3. Développement- &lt;strong&gt;API simple&lt;/strong&gt; : Interface intuitive- &lt;strong&gt;Requêtes puissantes&lt;/strong&gt; : Aggregation pipeline- &lt;strong&gt;Intégration facile&lt;/strong&gt; : Drivers multiples## ⚠️ Inconvénients et Considérations### 1. Consistance- &lt;strong&gt;ACID limité&lt;/strong&gt; : Pas de transactions complexes- &lt;strong&gt;Consistance éventuelle&lt;/strong&gt; : Dans les clusters- &lt;strong&gt;Pas de contraintes&lt;/strong&gt; : Validation applicative### 2. Requêtes- &lt;strong&gt;Pas de JOINs&lt;/strong&gt; : Relations manuelles- &lt;strong&gt;Requêtes complexes&lt;/strong&gt; : Aggregation pipeline- &lt;strong&gt;Performance&lt;/strong&gt; : Indexes critiques### 3. Maintenance- &lt;strong&gt;Monitoring&lt;/strong&gt; : Outils spécialisés- &lt;strong&gt;Backup&lt;/strong&gt; : Stratégies spécifiques- &lt;strong&gt;Scaling&lt;/strong&gt; : Configuration complexe## 🔧 Configuration et Déploiement### 1. Configuration des Services&lt;code&gt;yaml# config/packages/mongodb.yamlmongodb: connections: default: uri: '%env(MONGODB_URI)%' database: '%env(MONGODB_DATABASE)%' options: connectTimeoutMS: 30000 socketTimeoutMS: 30000 serverSelectionTimeoutMS: 30000 maxPoolSize: 10 minPoolSize: 1&lt;/code&gt;### 2. Déploiement avec Docker&lt;code&gt;yaml# docker-compose.ymlversion: '3.8'services: mongodb: image: mongo:6.0 container_name: Gyroscops Cloud-mongodb restart: unless-stopped ports: - &amp;quot;27017:27017&amp;quot; environment: MONGO_INITDB_ROOT_USERNAME: admin MONGO_INITDB_ROOT_PASSWORD: password MONGO_INITDB_DATABASE: hive_accounting volumes: - mongodb_data:/data/db - ./mongodb/init:/docker-entrypoint-initdb.d networks: - Gyroscops Cloud-networkvolumes: mongodb_data:networks: Gyroscops Cloud-network: driver: bridge&lt;/code&gt;## 📚 Exemples Concrets du projet Gyroscops Cloud### 1. Repository de Paiements&lt;code&gt;php&amp;lt;?phpnamespace App\Accounting\Infrastructure\Repository;use App\Accounting\Domain\Aggregate\Payment;use App\Accounting\Domain\ValueObject\PaymentId;use App\Accounting\Infrastructure\Configuration\MongoDBConfiguration;class HivePaymentRepository{ private \MongoDB\Collection $collection; public function __construct(MongoDBConfiguration $mongoConfig) { $this-&amp;gt;collection = $mongoConfig-&amp;gt;getCollection('payments'); } public function save(Payment $payment): void { $document = [ '_id' =&amp;gt; $payment-&amp;gt;getId()-&amp;gt;getValue(), 'amount' =&amp;gt; $payment-&amp;gt;getAmount()-&amp;gt;getValue(), 'currency' =&amp;gt; $payment-&amp;gt;getCurrency()-&amp;gt;getCode(), 'status' =&amp;gt; $payment-&amp;gt;getStatus()-&amp;gt;getValue(), 'workspace_id' =&amp;gt; $payment-&amp;gt;getWorkspaceId()-&amp;gt;getValue(), 'organization_id' =&amp;gt; $payment-&amp;gt;getOrganizationId()-&amp;gt;getValue(), 'created_at' =&amp;gt; $payment-&amp;gt;getCreatedAt()-&amp;gt;format('Y-m-d H:i:s'), 'updated_at' =&amp;gt; $payment-&amp;gt;getUpdatedAt()-&amp;gt;format('Y-m-d H:i:s'), 'metadata' =&amp;gt; $payment-&amp;gt;getMetadata()-&amp;gt;toArray() ]; $this-&amp;gt;collection-&amp;gt;replaceOne( ['_id' =&amp;gt; $payment-&amp;gt;getId()-&amp;gt;getValue()], $document, ['upsert' =&amp;gt; true] ); } public function findByWorkspace(string $workspaceId): array { $documents = $this-&amp;gt;collection-&amp;gt;find([ 'workspace_id' =&amp;gt; $workspaceId ]); return array_map( fn($doc) =&amp;gt; $this-&amp;gt;mapToPayment($doc), $documents-&amp;gt;toArray() ); }}&lt;/code&gt;### 2. Aggregation pour les Rapports&lt;code&gt;php&amp;lt;?phpnamespace App\Accounting\Infrastructure\Report;use App\Accounting\Infrastructure\Configuration\MongoDBConfiguration;class PaymentReportGenerator{ private \MongoDB\Collection $collection; public function __construct(MongoDBConfiguration $mongoConfig) { $this-&amp;gt;collection = $mongoConfig-&amp;gt;getCollection('payments'); } public function generateMonthlyReport(string $workspaceId, int $year, int $month): array { $startDate = new \DateTimeImmutable(&amp;quot;{$year}-{$month}-01&amp;quot;); $endDate = $startDate-&amp;gt;modify('+1 month'); $pipeline = [ [ '$match' =&amp;gt; [ 'workspace_id' =&amp;gt; $workspaceId, 'created_at' =&amp;gt; [ '$gte' =&amp;gt; $startDate-&amp;gt;format('Y-m-d H:i:s'), '$lt' =&amp;gt; $endDate-&amp;gt;format('Y-m-d H:i:s') ] ] ], [ '$group' =&amp;gt; [ '_id' =&amp;gt; [ 'status' =&amp;gt; '$status', 'currency' =&amp;gt; '$currency' ], 'count' =&amp;gt; ['$sum' =&amp;gt; 1], 'total_amount' =&amp;gt; ['$sum' =&amp;gt; '$amount'], 'avg_amount' =&amp;gt; ['$avg' =&amp;gt; '$amount'] ] ], [ '$sort' =&amp;gt; ['total_amount' =&amp;gt; -1] ] ]; return $this-&amp;gt;collection-&amp;gt;aggregate($pipeline)-&amp;gt;toArray(); }}&lt;/code&gt;## 🎯 Critères d&amp;rsquo;Adoption### ✅ Adoptez cette approche si :- &lt;strong&gt;Données non relationnelles&lt;/strong&gt; avec structure flexible- &lt;strong&gt;Performance de lecture&lt;/strong&gt; importante- &lt;strong&gt;Évolutivité horizontale&lt;/strong&gt; requise- &lt;strong&gt;Équipe expérimentée&lt;/strong&gt; avec NoSQL- &lt;strong&gt;Requêtes complexes&lt;/strong&gt; avec aggregation- &lt;strong&gt;Flexibilité du schéma&lt;/strong&gt; nécessaire### ❌ Évitez cette approche si :- &lt;strong&gt;Données relationnelles&lt;/strong&gt; strictes- &lt;strong&gt;Transactions ACID&lt;/strong&gt; critiques- &lt;strong&gt;Équipe junior&lt;/strong&gt; sans expérience NoSQL- &lt;strong&gt;Requêtes simples&lt;/strong&gt; avec JOINs- &lt;strong&gt;Contraintes de schéma&lt;/strong&gt; importantes## 📈 Métriques de Succès### 1. Performance- &lt;strong&gt;Temps de réponse&lt;/strong&gt; des requêtes &amp;lt; 50ms- &lt;strong&gt;Throughput&lt;/strong&gt; des opérations &amp;gt; 10000/min- &lt;strong&gt;Disponibilité&lt;/strong&gt; &amp;gt; 99.9%### 2. Qualité- &lt;strong&gt;Couverture de tests&lt;/strong&gt; &amp;gt; 90%- &lt;strong&gt;Taux d&amp;rsquo;erreur&lt;/strong&gt; &amp;lt; 0.1%- &lt;strong&gt;Temps de récupération&lt;/strong&gt; &amp;lt; 2 minutes### 3. Business- &lt;strong&gt;Satisfaction utilisateur&lt;/strong&gt; &amp;gt; 4.5/5- &lt;strong&gt;Temps de développement&lt;/strong&gt; des nouvelles fonctionnalités- &lt;strong&gt;Coût de maintenance&lt;/strong&gt; acceptable&amp;mdash;## 🎯 Votre Prochaine ÉtapeMaintenant que vous comprenez l&amp;rsquo;approche classique avec MongoDB, quel est votre contexte ?

&lt;div class="chapter-navigation"&gt;
 &lt;h2 class="chapter-nav-title"&gt;🎯 Votre Prochaine Étape&lt;/h2&gt;
 &lt;p class="chapter-nav-subtitle"&gt;Maintenant que vous comprenez les concepts de base et que j'ai partagé mon expérience avec Gyroscops, quel est votre contexte ?&lt;/p&gt;</description></item><item><title>Chapitre 29 : Stockage MongoDB - Approche CQS</title><link>http://localhost:1313/chapitres/stockage/mongodb/chapitre-29-stockage-mongodb-cqs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/mongodb/chapitre-29-stockage-mongodb-cqs/</guid><description>&lt;h2 id="-objectif-de-ce-chapitredans-ce-chapitre-vous-allez-découvrir-comment-implémenter-le-pattern-cqs-command-query-separation-avec-mongodb-en-séparant-clairement-les-opérations-de-lecture-et-décriture-pour-optimiser-les-performances-et-la-maintenabilité--mon-expérience-avec-gyroscopsavec-gyroscops-nous-avions-un-défi-particulier--nos-utilisateurs-consultaient-massivement-les-données-de-facturation-lectures-mais-les-mises-à-jour-étaient-rares-écritures-mongodb-nous-permettait-de-créer-des-collections-optimisées-pour-chaque-type-dopération-le-problème-initialnotre-collection-billing_documents-était-devenue-un-goulot-détranglement---les-requêtes-de-lecture-représentaient-95-du-trafic--les-écritures-bloquaient-les-lectures--les-index-étaient-optimisés-pour-les-écritures-pas-les-lectures-la-découverte-cqs-avec-mongodbjai-découvert-que-mongodb-permettait-de-créer-des-collections-spécialisées---collection-de-commandes--optimisée-pour-les-écritures--collection-de-requêtes--optimisée-pour-les-lectures--synchronisation--via-des-projections-en-temps-réel--architecture-cqs-avec-mongodb-séparation-des-collectionsjavascript-collection-de-commandes-écrituresdbbilling_commandsinsertone--_id-objectid--type-invoice_created--data-----invoiceid-inv_123----amount-150000----currency-eur----customerid-cust_456----timestamp-new-date--version-1-collection-de-requêtes-lecturesdbbilling_queriesinsertone--_id-inv_123--invoicenumber-inv-2024-001--amount-150000--currency-eur--customer-----id-cust_456----name-acme-corp----email-billingacmecom----status-paid--createdat-new-date--updatedat-new-date-index-optimisés-par-collectionjavascript-index-pour-les-commandes-écrituresdbbilling_commandscreateindex-timestamp-1-dbbilling_commandscreateindex-type-1-timestamp-1--index-pour-les-requêtes-lecturesdbbilling_queriescreateindex-customerid-1-status-1-dbbilling_queriescreateindex-amount-1-currency-1-dbbilling_queriescreateindex-createdat--1---synchronisation-des-collections-projection-en-temps-réeljavascript-change-stream-pour-synchroniser-les-collectionsconst-changestream--dbbilling_commandswatch---match--operationtype-insert--changestreamonchange-change----const-command--changefulldocument-----transformer-la-commande-en-requête--const-query--transformcommandtoquerycommand-----insérer-dans-la-collection-de-requêtes--dbbilling_queriesreplaceone-----_id-query_id-----query-----upsert-true----transformation-des-donnéesjavascriptfunction-transformcommandtoquerycommand---switch-commandtype-----case-invoice_created------return---------_id-commanddatainvoiceid--------invoicenumber-generateinvoicenumbercommanddata--------amount-commanddataamount--------currency-commanddatacurrency--------customer-enrichcustomerdatacommanddatacustomerid--------status-pending--------createdat-commandtimestamp--------updatedat-commandtimestamp--------------case-invoice_paid------return---------_id-commanddatainvoiceid--------status-paid--------paidat-commandtimestamp--------updatedat-commandtimestamp--------------default------throw-new-errorunknown-command-type-commandtype----avantages-de-cqs-avec-mongodb-performance-optimiséejavascript-lecture-ultra-rapide-collection-optimiséeconst-invoices--await-dbbilling_queriesfind--customerid-cust_456--status-paidsort-createdat--1-limit10-écriture-atomique-collection-de-commandesconst-result--await-dbbilling_commandsinsertone--type-invoice_created--data-invoicedata--timestamp-new-date--version-1-scalabilité-horizontalejavascript-sharding-par-type-dopérationshshardcollectiongyroscopsbilling_commands--type-1-shshardcollectiongyroscopsbilling_queries--customerid-1---défis-et-solutions-cohérence-éventuellejavascript-vérification-de-cohérenceasync-function-checkconsistencyinvoiceid---const-command--await-dbbilling_commandsfindone----datainvoiceid-invoiceid------const-query--await-dbbilling_queriesfindone----_id-invoiceid------if-command--query-----throw-new-errorinconsistency-detected-for-invoice-invoiceid------return--command-query--gestion-des-erreursjavascript-retry-automatique-en-cas-déchecasync-function-syncwithretrycommand-maxretries--3---for-let-i--0-i--maxretries-i-----try-------await-synccommandtoquerycommand------return-----catch-error-------if-i--maxretries---1-throw-error------await-new-promiseresolve--settimeoutresolve-1000--mathpow2-i--------critères-d-quand-utiliser-cqs-avec-mongodb---lecturesécritures-très-différentes--8020-ou-plus---performance-critique--latence--100ms-requise---équipe-expérimentée--connaissance-de-mongodb-avancée---évolutivité-importante--croissance-prévue--10x-quand-éviter-cqs-avec-mongodb---application-simple--peu-de-trafic-équipe-junior---cohérence-forte-requise--données-financières-critiques---développement-rapide--mvp-prototypage---budget-limité--complexité-supplémentaire-non-justifiée--métriques-de-succès-performancejavascript-métriques-de-performanceconst-metrics----readlatency--50ms--writelatency--100ms--throughput--10k-opssec--consistency-999-monitoringjavascript-dashboard-de-monitoringconst-dashboard----commandspersecond-monitorcommands--queriespersecond-monitorqueries--synclag-monitorsynclag--errorrate-monitorerrors--migration-depuis-l-étape-1--créer-les-collections-cqsjavascript-créer-les-nouvelles-collectionsdbcreatecollectionbilling_commandsdbcreatecollectionbilling_queries-créer-les-index-optimiséscreateoptimizedindexes-étape-2--migrer-les-données-existantesjavascript-migration-des-données-existantesasync-function-migratetocqs---const-existingdata--await-dbbilling_documentsfind----for-const-doc-of-existingdata------créer-la-commande----await-dbbilling_commandsinsertone------type-migration------data-doc------timestamp-new-date------version-1-------------créer-la-requête----await-dbbilling_queriesinsertonetransformtoquerydoc---étape-3--basculer-progressivementjavascript-feature-flag-pour-basculer-progressivementconst-usecqs--await-getfeatureflagmongodb_cqs_enabledif-usecqs----utiliser-les-collections-cqs--return-await-queryfromcqscollection-else----utiliser-lancienne-collection--return-await-queryfromlegacycollection--conseils-pratiques-design-des-collections1-commandes--structure-simple-optimisée-pour-lécriture2-requêtes--structure-riche-optimisée-pour-la-lecture3-index--différents-pour-chaque-collection4-sharding--stratégies-différentes-selon-lusage-monitoring-et-alertes1-lag-de-synchronisation---1-seconde2-taux-d---013-performance--latence--100ms4-cohérence--vérification-quotidienne--votre-prochaine-étapemaintenant-que-vous-comprenez-lapproche-cqs-avec-mongodb-quelle-est-votre-situation-hahahugoshortcode52s0hbhb-conseil--si-vous-nêtes-pas-sûr-commencez-par-lapproche-classique-option-c-pour-bien-comprendre-mongodb-puis-revenez-à-cqs-quand-vous-serez-prêt-alternative--si-vous-voulez-tout-voir-dans-lordre-continuez-avec-lapproche-cqrs-option-a"&gt;🎯 &lt;strong&gt;Objectif de ce Chapitre&lt;/strong&gt;Dans ce chapitre, vous allez découvrir comment implémenter le pattern CQS (Command Query Separation) avec MongoDB, en séparant clairement les opérations de lecture et d&amp;rsquo;écriture pour optimiser les performances et la maintenabilité.## 📖 &lt;strong&gt;Mon Expérience avec Gyroscops&lt;/strong&gt;Avec Gyroscops, nous avions un défi particulier : nos utilisateurs consultaient massivement les données de facturation (lectures) mais les mises à jour étaient rares (écritures). MongoDB nous permettait de créer des collections optimisées pour chaque type d&amp;rsquo;opération.### &lt;strong&gt;Le Problème Initial&lt;/strong&gt;Notre collection &lt;code&gt;billing_documents&lt;/code&gt; était devenue un goulot d&amp;rsquo;étranglement :- Les requêtes de lecture représentaient 95% du trafic- Les écritures bloquaient les lectures- Les index étaient optimisés pour les écritures, pas les lectures### &lt;strong&gt;La Découverte CQS avec MongoDB&lt;/strong&gt;J&amp;rsquo;ai découvert que MongoDB permettait de créer des collections spécialisées :- &lt;strong&gt;Collection de commandes&lt;/strong&gt; : Optimisée pour les écritures- &lt;strong&gt;Collection de requêtes&lt;/strong&gt; : Optimisée pour les lectures- &lt;strong&gt;Synchronisation&lt;/strong&gt; : Via des projections en temps réel## 🏗️ &lt;strong&gt;Architecture CQS avec MongoDB&lt;/strong&gt;### &lt;strong&gt;Séparation des Collections&lt;/strong&gt;&lt;code&gt;javascript// Collection de commandes (écritures)db.billing_commands.insertOne({ _id: ObjectId(), type: &amp;quot;invoice_created&amp;quot;, data: { invoiceId: &amp;quot;inv_123&amp;quot;, amount: 1500.00, currency: &amp;quot;EUR&amp;quot;, customerId: &amp;quot;cust_456&amp;quot; }, timestamp: new Date(), version: 1});// Collection de requêtes (lectures)db.billing_queries.insertOne({ _id: &amp;quot;inv_123&amp;quot;, invoiceNumber: &amp;quot;INV-2024-001&amp;quot;, amount: 1500.00, currency: &amp;quot;EUR&amp;quot;, customer: { id: &amp;quot;cust_456&amp;quot;, name: &amp;quot;Acme Corp&amp;quot;, email: &amp;quot;billing@acme.com&amp;quot; }, status: &amp;quot;paid&amp;quot;, createdAt: new Date(), updatedAt: new Date()});&lt;/code&gt;### &lt;strong&gt;Index Optimisés par Collection&lt;/strong&gt;&lt;code&gt;javascript// Index pour les commandes (écritures)db.billing_commands.createIndex({ &amp;quot;timestamp&amp;quot;: 1 });db.billing_commands.createIndex({ &amp;quot;type&amp;quot;: 1, &amp;quot;timestamp&amp;quot;: 1 });// Index pour les requêtes (lectures)db.billing_queries.createIndex({ &amp;quot;customer.id&amp;quot;: 1, &amp;quot;status&amp;quot;: 1 });db.billing_queries.createIndex({ &amp;quot;amount&amp;quot;: 1, &amp;quot;currency&amp;quot;: 1 });db.billing_queries.createIndex({ &amp;quot;createdAt&amp;quot;: -1 });&lt;/code&gt;## 🔄 &lt;strong&gt;Synchronisation des Collections&lt;/strong&gt;### &lt;strong&gt;Projection en Temps Réel&lt;/strong&gt;&lt;code&gt;javascript// Change Stream pour synchroniser les collectionsconst changeStream = db.billing_commands.watch([ { $match: { &amp;quot;operationType&amp;quot;: &amp;quot;insert&amp;quot; } }]);changeStream.on('change', (change) =&amp;gt; { const command = change.fullDocument; // Transformer la commande en requête const query = transformCommandToQuery(command); // Insérer dans la collection de requêtes db.billing_queries.replaceOne( { _id: query._id }, query, { upsert: true } );});&lt;/code&gt;### &lt;strong&gt;Transformation des Données&lt;/strong&gt;&lt;code&gt;javascriptfunction transformCommandToQuery(command) { switch (command.type) { case &amp;quot;invoice_created&amp;quot;: return { _id: command.data.invoiceId, invoiceNumber: generateInvoiceNumber(command.data), amount: command.data.amount, currency: command.data.currency, customer: enrichCustomerData(command.data.customerId), status: &amp;quot;pending&amp;quot;, createdAt: command.timestamp, updatedAt: command.timestamp }; case &amp;quot;invoice_paid&amp;quot;: return { _id: command.data.invoiceId, status: &amp;quot;paid&amp;quot;, paidAt: command.timestamp, updatedAt: command.timestamp }; default: throw new Error(`Unknown command type: ${command.type}`); }}&lt;/code&gt;## 📊 &lt;strong&gt;Avantages de CQS avec MongoDB&lt;/strong&gt;### &lt;strong&gt;Performance Optimisée&lt;/strong&gt;&lt;code&gt;javascript// Lecture ultra-rapide (collection optimisée)const invoices = await db.billing_queries.find({ &amp;quot;customer.id&amp;quot;: &amp;quot;cust_456&amp;quot;, &amp;quot;status&amp;quot;: &amp;quot;paid&amp;quot;}).sort({ &amp;quot;createdAt&amp;quot;: -1 }).limit(10);// Écriture atomique (collection de commandes)const result = await db.billing_commands.insertOne({ type: &amp;quot;invoice_created&amp;quot;, data: invoiceData, timestamp: new Date(), version: 1});&lt;/code&gt;### &lt;strong&gt;Scalabilité Horizontale&lt;/strong&gt;&lt;code&gt;javascript// Sharding par type d'opérationsh.shardCollection(&amp;quot;gyroscops.billing_commands&amp;quot;, { &amp;quot;type&amp;quot;: 1 });sh.shardCollection(&amp;quot;gyroscops.billing_queries&amp;quot;, { &amp;quot;customer.id&amp;quot;: 1 });&lt;/code&gt;## ⚠️ &lt;strong&gt;Défis et Solutions&lt;/strong&gt;### &lt;strong&gt;Cohérence Éventuelle&lt;/strong&gt;&lt;code&gt;javascript// Vérification de cohérenceasync function checkConsistency(invoiceId) { const command = await db.billing_commands.findOne({ &amp;quot;data.invoiceId&amp;quot;: invoiceId }); const query = await db.billing_queries.findOne({ _id: invoiceId }); if (!command || !query) { throw new Error(`Inconsistency detected for invoice ${invoiceId}`); } return { command, query };}&lt;/code&gt;### &lt;strong&gt;Gestion des Erreurs&lt;/strong&gt;&lt;code&gt;javascript// Retry automatique en cas d'échecasync function syncWithRetry(command, maxRetries = 3) { for (let i = 0; i &amp;lt; maxRetries; i++) { try { await syncCommandToQuery(command); return; } catch (error) { if (i === maxRetries - 1) throw error; await new Promise(resolve =&amp;gt; setTimeout(resolve, 1000 * Math.pow(2, i))); } }}&lt;/code&gt;## 🎯 &lt;strong&gt;Critères d&amp;rsquo;Adoption&lt;/strong&gt;### &lt;strong&gt;Quand Utiliser CQS avec MongoDB&lt;/strong&gt;- ✅ &lt;strong&gt;Lectures/écritures très différentes&lt;/strong&gt; : 80/20 ou plus- ✅ &lt;strong&gt;Performance critique&lt;/strong&gt; : Latence &amp;lt; 100ms requise- ✅ &lt;strong&gt;Équipe expérimentée&lt;/strong&gt; : Connaissance de MongoDB avancée- ✅ &lt;strong&gt;Évolutivité importante&lt;/strong&gt; : Croissance prévue &amp;gt; 10x### &lt;strong&gt;Quand Éviter CQS avec MongoDB&lt;/strong&gt;- ❌ &lt;strong&gt;Application simple&lt;/strong&gt; : Peu de trafic, équipe junior- ❌ &lt;strong&gt;Cohérence forte requise&lt;/strong&gt; : Données financières critiques- ❌ &lt;strong&gt;Développement rapide&lt;/strong&gt; : MVP, prototypage- ❌ &lt;strong&gt;Budget limité&lt;/strong&gt; : Complexité supplémentaire non justifiée## 📈 &lt;strong&gt;Métriques de Succès&lt;/strong&gt;### &lt;strong&gt;Performance&lt;/strong&gt;&lt;code&gt;javascript// Métriques de performanceconst metrics = { readLatency: &amp;quot;&amp;lt; 50ms&amp;quot;, writeLatency: &amp;quot;&amp;lt; 100ms&amp;quot;, throughput: &amp;quot;&amp;gt; 10k ops/sec&amp;quot;, consistency: &amp;quot;99.9%&amp;quot;};&lt;/code&gt;### &lt;strong&gt;Monitoring&lt;/strong&gt;&lt;code&gt;javascript// Dashboard de monitoringconst dashboard = { commandsPerSecond: monitorCommands(), queriesPerSecond: monitorQueries(), syncLag: monitorSyncLag(), errorRate: monitorErrors()};&lt;/code&gt;## 🔄 &lt;strong&gt;Migration depuis l&amp;rsquo;Approche Classique&lt;/strong&gt;### &lt;strong&gt;Étape 1 : Créer les Collections CQS&lt;/strong&gt;&lt;code&gt;javascript// Créer les nouvelles collectionsdb.createCollection(&amp;quot;billing_commands&amp;quot;);db.createCollection(&amp;quot;billing_queries&amp;quot;);// Créer les index optimiséscreateOptimizedIndexes();&lt;/code&gt;### &lt;strong&gt;Étape 2 : Migrer les Données Existantes&lt;/strong&gt;&lt;code&gt;javascript// Migration des données existantesasync function migrateToCQS() { const existingData = await db.billing_documents.find({}); for (const doc of existingData) { // Créer la commande await db.billing_commands.insertOne({ type: &amp;quot;migration&amp;quot;, data: doc, timestamp: new Date(), version: 1 }); // Créer la requête await db.billing_queries.insertOne(transformToQuery(doc)); }}&lt;/code&gt;### &lt;strong&gt;Étape 3 : Basculer Progressivement&lt;/strong&gt;&lt;code&gt;javascript// Feature flag pour basculer progressivementconst useCQS = await getFeatureFlag(&amp;quot;mongodb_cqs_enabled&amp;quot;);if (useCQS) { // Utiliser les collections CQS return await queryFromCQSCollection();} else { // Utiliser l'ancienne collection return await queryFromLegacyCollection();}&lt;/code&gt;## 💡 &lt;strong&gt;Conseils Pratiques&lt;/strong&gt;### &lt;strong&gt;Design des Collections&lt;/strong&gt;1. &lt;strong&gt;Commandes&lt;/strong&gt; : Structure simple, optimisée pour l&amp;rsquo;écriture2. &lt;strong&gt;Requêtes&lt;/strong&gt; : Structure riche, optimisée pour la lecture3. &lt;strong&gt;Index&lt;/strong&gt; : Différents pour chaque collection4. &lt;strong&gt;Sharding&lt;/strong&gt; : Stratégies différentes selon l&amp;rsquo;usage### &lt;strong&gt;Monitoring et Alertes&lt;/strong&gt;1. &lt;strong&gt;Lag de synchronisation&lt;/strong&gt; : &amp;lt; 1 seconde2. &lt;strong&gt;Taux d&amp;rsquo;erreur&lt;/strong&gt; : &amp;lt; 0.1%3. &lt;strong&gt;Performance&lt;/strong&gt; : Latence &amp;lt; 100ms4. &lt;strong&gt;Cohérence&lt;/strong&gt; : Vérification quotidienne## 🎯 &lt;strong&gt;Votre Prochaine Étape&lt;/strong&gt;Maintenant que vous comprenez l&amp;rsquo;approche CQS avec MongoDB, quelle est votre situation ?

&lt;div class="chapter-navigation"&gt;
 &lt;h2 class="chapter-nav-title"&gt;🎯 Votre Prochaine Étape&lt;/h2&gt;
 &lt;p class="chapter-nav-subtitle"&gt;Maintenant que vous comprenez les concepts de base et que j'ai partagé mon expérience avec Gyroscops, quel est votre contexte ?&lt;/p&gt;</description></item><item><title>Chapitre 30 : Stockage MongoDB - Approche CQRS</title><link>http://localhost:1313/chapitres/stockage/mongodb/chapitre-30-stockage-mongodb-cqrs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/mongodb/chapitre-30-stockage-mongodb-cqrs/</guid><description>&lt;h2 id="-objectif-de-ce-chapitredans-ce-chapitre-vous-allez-découvrir-comment-implémenter-cqrs-command-query-responsibility-segregation-avec-mongodb-en-séparant-complètement-les-modèles-de-lecture-et-décriture-pour-une-architecture-distribuée-et-évolutive--mon-expérience-avec-gyroscopsavec-gyroscops-nous-avions-atteint-les-limites-de-lapproche-cqs-classique-nos-équipes-de-développement-et-danalytics-avaient-des-besoins-complètement-différents-et-nous-avions-besoin-dune-séparation-plus-radicale-le-problème-avec-cqsnotre-collection-billing_queries-était-devenue-un-monstre---structure-complexe-pour-satisfaire-tous-les-cas-dusage--index-contradictoires-entre-les-équipes--performance-dégradée-par-la-polyvalence-la-révolution-cqrsjai-découvert-que-cqrs-permettait-de-créer-des-modèles-complètement-différents---modèle-de-commande--optimisé-pour-les-écritures--modèles-de-requête--spécialisés-par-cas-dusage--découplage-total--équipes-indépendantes--architecture-cqrs-avec-mongodb-séparation-complète-des-modèlesjavascript-modèle-de-commande-écritureconst-invoicecommand----_id-objectid--type-createinvoice--aggregateid-invoice_123--data-----customerid-cust_456----amount-150000----currency-eur----items--------description-cloud-resources-amount-120000--------description-support-amount-30000---------timestamp-new-date--version-1--metadata-----userid-user_789----correlationid-corr_abc---modèle-de-requête---vue-facturationconst-invoicebillingview----_id-invoice_123--invoicenumber-inv-2024-001--customer-----id-cust_456----name-acme-corp----billingaddress-123-main-st-paris----totalamount-150000--currency-eur--status-pending--duedate-new-date2024-02-15--createdat-new-date-modèle-de-requête---vue-analyticsconst-invoiceanalyticsview----_id-invoice_123--customersegment-enterprise--revenue-150000--currency-eur--month-2024-01--region-europe--productcategory-cloud--createdat-new-date-collections-spécialiséesjavascript-collection-de-commandesdbinvoice_commandscreateindex-aggregateid-1-version-1-dbinvoice_commandscreateindex-timestamp-1-dbinvoice_commandscreateindex-type-1--collection-de-vues-facturationdbinvoice_billing_viewscreateindex-customerid-1-status-1-dbinvoice_billing_viewscreateindex-duedate-1-dbinvoice_billing_viewscreateindex-createdat--1--collection-de-vues-analyticsdbinvoice_analytics_viewscreateindex-customersegment-1-month-1-dbinvoice_analytics_viewscreateindex-region-1-productcategory-1-dbinvoice_analytics_viewscreateindex-revenue--1---projection-des-vues-projection-en-temps-réeljavascript-change-stream-pour-les-commandesconst-changestream--dbinvoice_commandswatch---match--operationtype-insert--changestreamonchange-async-change----const-command--changefulldocument----try------projeter-vers-la-vue-facturation----await-projecttobillingviewcommand---------projeter-vers-la-vue-analytics----await-projecttoanalyticsviewcommand--------consolelogcommand-command_id-projected-successfully---catch-error-----consoleerrorprojection-failed-for-command-command_id-error-----gérer-lerreur-retry-dead-letter-queue-etc---projection-vers-la-vue-facturationjavascriptasync-function-projecttobillingviewcommand---const-invoicedata--commanddata-----enrichir-les-données-client--const-customer--await-dbcustomersfindone-_id-invoicedatacustomerid------créer-la-vue-facturation--const-billingview------_id-commandaggregateid----invoicenumber-generateinvoicenumbercommand----customer-------id-customer_id------name-customername------billingaddress-customerbillingaddress--------totalamount-invoicedataamount----currency-invoicedatacurrency----status-pending----duedate-calculateduedatecommandtimestamp----createdat-commandtimestamp------await-dbinvoice_billing_viewsreplaceone-----_id-commandaggregateid-----billingview-----upsert-true----projection-vers-la-vue-analyticsjavascriptasync-function-projecttoanalyticsviewcommand---const-invoicedata--commanddata-----enrichir-les-données-analytics--const-customer--await-dbcustomersfindone-_id-invoicedatacustomerid---const-customersegment--determinecustomersegmentcustomer-----créer-la-vue-analytics--const-analyticsview------_id-commandaggregateid----customersegment-customersegment----revenue-invoicedataamount----currency-invoicedatacurrency----month-formatmonthcommandtimestamp----region-customerregion----productcategory-determineproductcategoryinvoicedataitems----createdat-commandtimestamp------await-dbinvoice_analytics_viewsreplaceone-----_id-commandaggregateid-----analyticsview-----upsert-true-----avantages-de-cqrs-avec-mongodb-performance-optimisée-par-cas-djavascript-requête-facturation-ultra-rapideconst-pendinginvoices--await-dbinvoice_billing_viewsfind--customerid-cust_456--status-pendingsort-duedate-1--requête-analytics-complexeconst-monthlyrevenue--await-dbinvoice_analytics_viewsaggregate---match--month-2024-01-region-europe-----group--_id-customersegment-totalrevenue--sum-revenue------sort--totalrevenue--1---évolutivité-horizontalejavascript-sharding-par-domaine-métiershshardcollectiongyroscopsinvoice_commands--type-1-shshardcollectiongyroscopsinvoice_billing_views--customerid-1-shshardcollectiongyroscopsinvoice_analytics_views--month-1--découplage-des-équipesjavascript-équipe-facturation---modèle-simpleconst-billingservice----async-getpendinginvoicescustomerid-----return-await-dbinvoice_billing_viewsfind------customerid-customerid------status-pending-------équipe-analytics---modèle-complexeconst-analyticsservice----async-getrevenuebysegmentmonth-region-----return-await-dbinvoice_analytics_viewsaggregate-------match--month-region---------group--_id-customersegment-revenue--sum-revenue-----------défis-et-solutions-cohérence-éventuellejavascript-vérification-de-cohérence-entre-vuesasync-function-checkviewconsistencyaggregateid---const-command--await-dbinvoice_commandsfindone-aggregateid---const-billingview--await-dbinvoice_billing_viewsfindone-_id-aggregateid---const-analyticsview--await-dbinvoice_analytics_viewsfindone-_id-aggregateid-----if-command--billingview--analyticsview-----throw-new-errorinconsistent-views-for-aggregate-aggregateid------return--command-billingview-analyticsview--gestion-des-erreurs-de-projectionjavascript-dead-letter-queue-pour-les-échecs-de-projectionasync-function-handleprojectionfailurecommand-error---await-dbprojection_failuresinsertone----commandid-command_id----aggregateid-commandaggregateid----error-errormessage----timestamp-new-date----retrycount-0-------notifier-léquipe-de-monitoring--await-notifymonitoringteamcommand-error-replay-des-projectionsjavascript-replay-des-projections-en-cas-derreurasync-function-replayprojectionsfromtimestamp---const-commands--await-dbinvoice_commandsfind----timestamp--gte-fromtimestamp---sort-timestamp-1-----for-const-command-of-commands-----try-------await-projecttobillingviewcommand------await-projecttoanalyticsviewcommand-----catch-error-------consoleerrorreplay-failed-for-command-command_id-error--------critères-d-quand-utiliser-cqrs-avec-mongodb---équipes-multiples--développement-analytics-facturation---cas-d--lectures-complexes-vs-écritures-simples---performance-critique--latence--50ms-requise---évolutivité-maximale--croissance--100x-prévue-quand-éviter-cqrs-avec-mongodb---équipe-unique--pas-de-séparation-des-responsabilités---application-simple--cas-dusage-uniformes---cohérence-forte-requise--données-financières-critiques---budget-limité--complexité-non-justifiée--métriques-de-succès-performance-par-vuejavascriptconst-performancemetrics----billingview-----readlatency--30ms----writelatency--100ms----throughput--20k-opssec----analyticsview-----readlatency--100ms----writelatency--200ms----throughput--5k-opssec---monitoring-des-projectionsjavascriptconst-projectionmetrics----successrate--999--averagelag--1-second--errorrate--01--replaytime--5-minutes--migration-depuis-cqs-étape-1--créer-les-nouvelles-collectionsjavascript-créer-les-collections-cqrsdbcreatecollectioninvoice_commandsdbcreatecollectioninvoice_billing_viewsdbcreatecollectioninvoice_analytics_views-étape-2--migrer-les-données-existantesjavascript-migration-des-données-cqs-vers-cqrsasync-function-migratefromcqs---const-existingqueries--await-dbbilling_queriesfind----for-const-query-of-existingqueries------créer-la-commande----await-dbinvoice_commandsinsertone------type-migration------aggregateid-query_id------data-query------timestamp-new-date------version-1-------------projeter-vers-les-vues----await-projecttobillingview-aggregateid-query_id-data-query-----await-projecttoanalyticsview-aggregateid-query_id-data-query----étape-3--basculer-progressivementjavascript-feature-flag-pour-basculer-vers-cqrsconst-usecqrs--await-getfeatureflagmongodb_cqrs_enabledif-usecqrs----utiliser-les-vues-cqrs--return-await-queryfromcqrsviews-else----utiliser-lancienne-collection-cqs--return-await-queryfromcqscollection--conseils-pratiques-design-des-vues1-vue-facturation--structure-simple-optimisée-pour-les-requêtes-métier2-vue-analytics--structure-complexe-optimisée-pour-les-agrégations3-index-spécialisés--différents-pour-chaque-vue4-sharding--stratégies-différentes-selon-lusage-monitoring-et-alertes1-lag-de-projection---1-seconde2-taux-d---013-performance--latence--50ms4-cohérence--vérification-quotidienne--votre-prochaine-étapemaintenant-que-vous-comprenez-lapproche-cqrs-avec-mongodb-quelle-est-votre-situation-hahahugoshortcode53s0hbhb-conseil--si-vous-nêtes-pas-sûr-commencez-par-lapproche-cqs-option-c-pour-bien-comprendre-la-séparation-des-responsabilités-puis-revenez-à-cqrs-quand-vous-serez-prêt-alternative--si-vous-voulez-tout-voir-dans-lordre-continuez-avec-lapproche-event-sourcing-option-a"&gt;🎯 &lt;strong&gt;Objectif de ce Chapitre&lt;/strong&gt;Dans ce chapitre, vous allez découvrir comment implémenter CQRS (Command Query Responsibility Segregation) avec MongoDB, en séparant complètement les modèles de lecture et d&amp;rsquo;écriture pour une architecture distribuée et évolutive.## 📖 &lt;strong&gt;Mon Expérience avec Gyroscops&lt;/strong&gt;Avec Gyroscops, nous avions atteint les limites de l&amp;rsquo;approche CQS classique. Nos équipes de développement et d&amp;rsquo;analytics avaient des besoins complètement différents, et nous avions besoin d&amp;rsquo;une séparation plus radicale.### &lt;strong&gt;Le Problème avec CQS&lt;/strong&gt;Notre collection &lt;code&gt;billing_queries&lt;/code&gt; était devenue un monstre :- Structure complexe pour satisfaire tous les cas d&amp;rsquo;usage- Index contradictoires entre les équipes- Performance dégradée par la polyvalence### &lt;strong&gt;La Révolution CQRS&lt;/strong&gt;J&amp;rsquo;ai découvert que CQRS permettait de créer des modèles complètement différents :- &lt;strong&gt;Modèle de commande&lt;/strong&gt; : Optimisé pour les écritures- &lt;strong&gt;Modèles de requête&lt;/strong&gt; : Spécialisés par cas d&amp;rsquo;usage- &lt;strong&gt;Découplage total&lt;/strong&gt; : Équipes indépendantes## 🏗️ &lt;strong&gt;Architecture CQRS avec MongoDB&lt;/strong&gt;### &lt;strong&gt;Séparation Complète des Modèles&lt;/strong&gt;&lt;code&gt;javascript// Modèle de commande (écriture)const InvoiceCommand = { _id: ObjectId(), type: &amp;quot;CreateInvoice&amp;quot;, aggregateId: &amp;quot;invoice_123&amp;quot;, data: { customerId: &amp;quot;cust_456&amp;quot;, amount: 1500.00, currency: &amp;quot;EUR&amp;quot;, items: [ { description: &amp;quot;Cloud Resources&amp;quot;, amount: 1200.00 }, { description: &amp;quot;Support&amp;quot;, amount: 300.00 } ] }, timestamp: new Date(), version: 1, metadata: { userId: &amp;quot;user_789&amp;quot;, correlationId: &amp;quot;corr_abc&amp;quot; }};// Modèle de requête - Vue facturationconst InvoiceBillingView = { _id: &amp;quot;invoice_123&amp;quot;, invoiceNumber: &amp;quot;INV-2024-001&amp;quot;, customer: { id: &amp;quot;cust_456&amp;quot;, name: &amp;quot;Acme Corp&amp;quot;, billingAddress: &amp;quot;123 Main St, Paris&amp;quot; }, totalAmount: 1500.00, currency: &amp;quot;EUR&amp;quot;, status: &amp;quot;pending&amp;quot;, dueDate: new Date(&amp;quot;2024-02-15&amp;quot;), createdAt: new Date()};// Modèle de requête - Vue analyticsconst InvoiceAnalyticsView = { _id: &amp;quot;invoice_123&amp;quot;, customerSegment: &amp;quot;enterprise&amp;quot;, revenue: 1500.00, currency: &amp;quot;EUR&amp;quot;, month: &amp;quot;2024-01&amp;quot;, region: &amp;quot;europe&amp;quot;, productCategory: &amp;quot;cloud&amp;quot;, createdAt: new Date()};&lt;/code&gt;### &lt;strong&gt;Collections Spécialisées&lt;/strong&gt;&lt;code&gt;javascript// Collection de commandesdb.invoice_commands.createIndex({ &amp;quot;aggregateId&amp;quot;: 1, &amp;quot;version&amp;quot;: 1 });db.invoice_commands.createIndex({ &amp;quot;timestamp&amp;quot;: 1 });db.invoice_commands.createIndex({ &amp;quot;type&amp;quot;: 1 });// Collection de vues facturationdb.invoice_billing_views.createIndex({ &amp;quot;customer.id&amp;quot;: 1, &amp;quot;status&amp;quot;: 1 });db.invoice_billing_views.createIndex({ &amp;quot;dueDate&amp;quot;: 1 });db.invoice_billing_views.createIndex({ &amp;quot;createdAt&amp;quot;: -1 });// Collection de vues analyticsdb.invoice_analytics_views.createIndex({ &amp;quot;customerSegment&amp;quot;: 1, &amp;quot;month&amp;quot;: 1 });db.invoice_analytics_views.createIndex({ &amp;quot;region&amp;quot;: 1, &amp;quot;productCategory&amp;quot;: 1 });db.invoice_analytics_views.createIndex({ &amp;quot;revenue&amp;quot;: -1 });&lt;/code&gt;## 🔄 &lt;strong&gt;Projection des Vues&lt;/strong&gt;### &lt;strong&gt;Projection en Temps Réel&lt;/strong&gt;&lt;code&gt;javascript// Change Stream pour les commandesconst changeStream = db.invoice_commands.watch([ { $match: { &amp;quot;operationType&amp;quot;: &amp;quot;insert&amp;quot; } }]);changeStream.on('change', async (change) =&amp;gt; { const command = change.fullDocument; try { // Projeter vers la vue facturation await projectToBillingView(command); // Projeter vers la vue analytics await projectToAnalyticsView(command); console.log(`Command ${command._id} projected successfully`); } catch (error) { console.error(`Projection failed for command ${command._id}:`, error); // Gérer l'erreur (retry, dead letter queue, etc.) }});&lt;/code&gt;### &lt;strong&gt;Projection vers la Vue Facturation&lt;/strong&gt;&lt;code&gt;javascriptasync function projectToBillingView(command) { const invoiceData = command.data; // Enrichir les données client const customer = await db.customers.findOne({ _id: invoiceData.customerId }); // Créer la vue facturation const billingView = { _id: command.aggregateId, invoiceNumber: generateInvoiceNumber(command), customer: { id: customer._id, name: customer.name, billingAddress: customer.billingAddress }, totalAmount: invoiceData.amount, currency: invoiceData.currency, status: &amp;quot;pending&amp;quot;, dueDate: calculateDueDate(command.timestamp), createdAt: command.timestamp }; await db.invoice_billing_views.replaceOne( { _id: command.aggregateId }, billingView, { upsert: true } );}&lt;/code&gt;### &lt;strong&gt;Projection vers la Vue Analytics&lt;/strong&gt;&lt;code&gt;javascriptasync function projectToAnalyticsView(command) { const invoiceData = command.data; // Enrichir les données analytics const customer = await db.customers.findOne({ _id: invoiceData.customerId }); const customerSegment = determineCustomerSegment(customer); // Créer la vue analytics const analyticsView = { _id: command.aggregateId, customerSegment: customerSegment, revenue: invoiceData.amount, currency: invoiceData.currency, month: formatMonth(command.timestamp), region: customer.region, productCategory: determineProductCategory(invoiceData.items), createdAt: command.timestamp }; await db.invoice_analytics_views.replaceOne( { _id: command.aggregateId }, analyticsView, { upsert: true } );}&lt;/code&gt;## 📊 &lt;strong&gt;Avantages de CQRS avec MongoDB&lt;/strong&gt;### &lt;strong&gt;Performance Optimisée par Cas d&amp;rsquo;Usage&lt;/strong&gt;&lt;code&gt;javascript// Requête facturation ultra-rapideconst pendingInvoices = await db.invoice_billing_views.find({ &amp;quot;customer.id&amp;quot;: &amp;quot;cust_456&amp;quot;, &amp;quot;status&amp;quot;: &amp;quot;pending&amp;quot;}).sort({ &amp;quot;dueDate&amp;quot;: 1 });// Requête analytics complexeconst monthlyRevenue = await db.invoice_analytics_views.aggregate([ { $match: { &amp;quot;month&amp;quot;: &amp;quot;2024-01&amp;quot;, &amp;quot;region&amp;quot;: &amp;quot;europe&amp;quot; } }, { $group: { _id: &amp;quot;$customerSegment&amp;quot;, totalRevenue: { $sum: &amp;quot;$revenue&amp;quot; } } }, { $sort: { totalRevenue: -1 } }]);&lt;/code&gt;### &lt;strong&gt;Évolutivité Horizontale&lt;/strong&gt;&lt;code&gt;javascript// Sharding par domaine métiersh.shardCollection(&amp;quot;gyroscops.invoice_commands&amp;quot;, { &amp;quot;type&amp;quot;: 1 });sh.shardCollection(&amp;quot;gyroscops.invoice_billing_views&amp;quot;, { &amp;quot;customer.id&amp;quot;: 1 });sh.shardCollection(&amp;quot;gyroscops.invoice_analytics_views&amp;quot;, { &amp;quot;month&amp;quot;: 1 });&lt;/code&gt;### &lt;strong&gt;Découplage des Équipes&lt;/strong&gt;&lt;code&gt;javascript// Équipe facturation - Modèle simpleconst BillingService = { async getPendingInvoices(customerId) { return await db.invoice_billing_views.find({ &amp;quot;customer.id&amp;quot;: customerId, &amp;quot;status&amp;quot;: &amp;quot;pending&amp;quot; }); }};// Équipe analytics - Modèle complexeconst AnalyticsService = { async getRevenueBySegment(month, region) { return await db.invoice_analytics_views.aggregate([ { $match: { month, region } }, { $group: { _id: &amp;quot;$customerSegment&amp;quot;, revenue: { $sum: &amp;quot;$revenue&amp;quot; } } } ]); }};&lt;/code&gt;## ⚠️ &lt;strong&gt;Défis et Solutions&lt;/strong&gt;### &lt;strong&gt;Cohérence Éventuelle&lt;/strong&gt;&lt;code&gt;javascript// Vérification de cohérence entre vuesasync function checkViewConsistency(aggregateId) { const command = await db.invoice_commands.findOne({ aggregateId }); const billingView = await db.invoice_billing_views.findOne({ _id: aggregateId }); const analyticsView = await db.invoice_analytics_views.findOne({ _id: aggregateId }); if (!command || !billingView || !analyticsView) { throw new Error(`Inconsistent views for aggregate ${aggregateId}`); } return { command, billingView, analyticsView };}&lt;/code&gt;### &lt;strong&gt;Gestion des Erreurs de Projection&lt;/strong&gt;&lt;code&gt;javascript// Dead Letter Queue pour les échecs de projectionasync function handleProjectionFailure(command, error) { await db.projection_failures.insertOne({ commandId: command._id, aggregateId: command.aggregateId, error: error.message, timestamp: new Date(), retryCount: 0 }); // Notifier l'équipe de monitoring await notifyMonitoringTeam(command, error);}&lt;/code&gt;### &lt;strong&gt;Replay des Projections&lt;/strong&gt;&lt;code&gt;javascript// Replay des projections en cas d'erreurasync function replayProjections(fromTimestamp) { const commands = await db.invoice_commands.find({ timestamp: { $gte: fromTimestamp } }).sort({ timestamp: 1 }); for (const command of commands) { try { await projectToBillingView(command); await projectToAnalyticsView(command); } catch (error) { console.error(`Replay failed for command ${command._id}:`, error); } }}&lt;/code&gt;## 🎯 &lt;strong&gt;Critères d&amp;rsquo;Adoption&lt;/strong&gt;### &lt;strong&gt;Quand Utiliser CQRS avec MongoDB&lt;/strong&gt;- ✅ &lt;strong&gt;Équipes multiples&lt;/strong&gt; : Développement, analytics, facturation- ✅ &lt;strong&gt;Cas d&amp;rsquo;usage très différents&lt;/strong&gt; : Lectures complexes vs écritures simples- ✅ &lt;strong&gt;Performance critique&lt;/strong&gt; : Latence &amp;lt; 50ms requise- ✅ &lt;strong&gt;Évolutivité maximale&lt;/strong&gt; : Croissance &amp;gt; 100x prévue### &lt;strong&gt;Quand Éviter CQRS avec MongoDB&lt;/strong&gt;- ❌ &lt;strong&gt;Équipe unique&lt;/strong&gt; : Pas de séparation des responsabilités- ❌ &lt;strong&gt;Application simple&lt;/strong&gt; : Cas d&amp;rsquo;usage uniformes- ❌ &lt;strong&gt;Cohérence forte requise&lt;/strong&gt; : Données financières critiques- ❌ &lt;strong&gt;Budget limité&lt;/strong&gt; : Complexité non justifiée## 📈 &lt;strong&gt;Métriques de Succès&lt;/strong&gt;### &lt;strong&gt;Performance par Vue&lt;/strong&gt;&lt;code&gt;javascriptconst performanceMetrics = { billingView: { readLatency: &amp;quot;&amp;lt; 30ms&amp;quot;, writeLatency: &amp;quot;&amp;lt; 100ms&amp;quot;, throughput: &amp;quot;&amp;gt; 20k ops/sec&amp;quot; }, analyticsView: { readLatency: &amp;quot;&amp;lt; 100ms&amp;quot;, writeLatency: &amp;quot;&amp;lt; 200ms&amp;quot;, throughput: &amp;quot;&amp;gt; 5k ops/sec&amp;quot; }};&lt;/code&gt;### &lt;strong&gt;Monitoring des Projections&lt;/strong&gt;&lt;code&gt;javascriptconst projectionMetrics = { successRate: &amp;quot;&amp;gt; 99.9%&amp;quot;, averageLag: &amp;quot;&amp;lt; 1 second&amp;quot;, errorRate: &amp;quot;&amp;lt; 0.1%&amp;quot;, replayTime: &amp;quot;&amp;lt; 5 minutes&amp;quot;};&lt;/code&gt;## 🔄 &lt;strong&gt;Migration depuis CQS&lt;/strong&gt;### &lt;strong&gt;Étape 1 : Créer les Nouvelles Collections&lt;/strong&gt;&lt;code&gt;javascript// Créer les collections CQRSdb.createCollection(&amp;quot;invoice_commands&amp;quot;);db.createCollection(&amp;quot;invoice_billing_views&amp;quot;);db.createCollection(&amp;quot;invoice_analytics_views&amp;quot;);&lt;/code&gt;### &lt;strong&gt;Étape 2 : Migrer les Données Existantes&lt;/strong&gt;&lt;code&gt;javascript// Migration des données CQS vers CQRSasync function migrateFromCQS() { const existingQueries = await db.billing_queries.find({}); for (const query of existingQueries) { // Créer la commande await db.invoice_commands.insertOne({ type: &amp;quot;migration&amp;quot;, aggregateId: query._id, data: query, timestamp: new Date(), version: 1 }); // Projeter vers les vues await projectToBillingView({ aggregateId: query._id, data: query }); await projectToAnalyticsView({ aggregateId: query._id, data: query }); }}&lt;/code&gt;### &lt;strong&gt;Étape 3 : Basculer Progressivement&lt;/strong&gt;&lt;code&gt;javascript// Feature flag pour basculer vers CQRSconst useCQRS = await getFeatureFlag(&amp;quot;mongodb_cqrs_enabled&amp;quot;);if (useCQRS) { // Utiliser les vues CQRS return await queryFromCQRSViews();} else { // Utiliser l'ancienne collection CQS return await queryFromCQSCollection();}&lt;/code&gt;## 💡 &lt;strong&gt;Conseils Pratiques&lt;/strong&gt;### &lt;strong&gt;Design des Vues&lt;/strong&gt;1. &lt;strong&gt;Vue facturation&lt;/strong&gt; : Structure simple, optimisée pour les requêtes métier2. &lt;strong&gt;Vue analytics&lt;/strong&gt; : Structure complexe, optimisée pour les agrégations3. &lt;strong&gt;Index spécialisés&lt;/strong&gt; : Différents pour chaque vue4. &lt;strong&gt;Sharding&lt;/strong&gt; : Stratégies différentes selon l&amp;rsquo;usage### &lt;strong&gt;Monitoring et Alertes&lt;/strong&gt;1. &lt;strong&gt;Lag de projection&lt;/strong&gt; : &amp;lt; 1 seconde2. &lt;strong&gt;Taux d&amp;rsquo;erreur&lt;/strong&gt; : &amp;lt; 0.1%3. &lt;strong&gt;Performance&lt;/strong&gt; : Latence &amp;lt; 50ms4. &lt;strong&gt;Cohérence&lt;/strong&gt; : Vérification quotidienne## 🎯 &lt;strong&gt;Votre Prochaine Étape&lt;/strong&gt;Maintenant que vous comprenez l&amp;rsquo;approche CQRS avec MongoDB, quelle est votre situation ?

&lt;div class="chapter-navigation"&gt;
 &lt;h2 class="chapter-nav-title"&gt;🎯 Votre Prochaine Étape&lt;/h2&gt;
 &lt;p class="chapter-nav-subtitle"&gt;Maintenant que vous comprenez les concepts de base et que j'ai partagé mon expérience avec Gyroscops, quel est votre contexte ?&lt;/p&gt;</description></item><item><title>Chapitre 31 : Stockage MongoDB - Event Sourcing</title><link>http://localhost:1313/chapitres/stockage/mongodb/chapitre-31-stockage-mongodb-event-sourcing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/mongodb/chapitre-31-stockage-mongodb-event-sourcing/</guid><description>&lt;h2 id="-objectif-de-ce-chapitredans-ce-chapitre-vous-allez-découvrir-comment-implémenter-event-sourcing-avec-mongodb-en-stockant-les-événements-comme-source-de-vérité-et-en-reconstruisant-létat-à-partir-de-ces-événements--mon-expérience-avec-gyroscopsavec-gyroscops-nous-avions-un-besoin-critique-daudit-trail-pour-nos-données-financières-les-régulateurs-exigeaient-de-pouvoir-tracer-chaque-modification-et-nous-avions-besoin-de-comprendre-lhistorique-complet-des-transactions-le-problème-avec-lnotre-collection-billing_documents-ne-gardait-que-létat-final---impossible-de-savoir-qui-avait-modifié-quoi-et-quand--pas-de-possibilité-de-rejouer-lhistorique--audit-trail-incomplet-pour-la-conformité-la-révolution-event-sourcingjai-découvert-quevent-sourcing-permettait-de-stocker-lhistorique-complet---événements-immutables--chaque-changement-est-un-événement--audit-trail-complet--traçabilité-totale--replay-possible--reconstruction-de-létat-à-tout-moment--architecture-event-sourcing-avec-mongodb-stockage-des-événementsjavascript-événement-de-création-de-factureconst-invoicecreatedevent----_id-objectid--aggregateid-invoice_123--aggregatetype-invoice--eventtype-invoicecreated--eventversion-1--eventdata-----invoicenumber-inv-2024-001----customerid-cust_456----amount-150000----currency-eur----items--------description-cloud-resources-amount-120000--------description-support-amount-30000---------metadata-----userid-user_789----correlationid-corr_abc----causationid-cause_def----timestamp-new-date--sequencenumber-1-événement-de-paiementconst-invoicepaidevent----_id-objectid--aggregateid-invoice_123--aggregatetype-invoice--eventtype-invoicepaid--eventversion-1--eventdata-----paymentid-pay_789----paymentmethod-credit_card----paidamount-150000----paidat-new-date----metadata-----userid-user_789----correlationid-corr_abc----causationid-cause_ghi----timestamp-new-date--sequencenumber-2-index-optimisés-pour-event-sourcingjavascript-index-pour-les-requêtes-par-agrégatdbeventscreateindex-aggregateid-1-sequencenumber-1-dbeventscreateindex-aggregateid-1-eventtype-1--index-pour-les-requêtes-temporellesdbeventscreateindex-timestamp-1-dbeventscreateindex-eventtype-1-timestamp-1--index-pour-les-requêtes-de-corrélationdbeventscreateindex-metadatacorrelationid-1-dbeventscreateindex-metadatauserid-1---reconstruction-de-l-reconstruction-complètejavascript-reconstruire-létat-complet-dun-agrégatasync-function-reconstructaggregateaggregateid---const-events--await-dbeventsfind----aggregateid-aggregateid--sort-sequencenumber-1-----let-aggregate------id-aggregateid----version-0----state-------for-const-event-of-events-----aggregate--applyeventaggregate-event------return-aggregate-appliquer-un-événement-à-lagrégatfunction-applyeventaggregate-event---switch-eventeventtype-----case-invoicecreated------return---------aggregate--------version-eventsequencenumber--------state-----------aggregatestate----------invoicenumber-eventeventdatainvoicenumber----------customerid-eventeventdatacustomerid----------amount-eventeventdataamount----------currency-eventeventdatacurrency----------items-eventeventdataitems----------status-pending----------createdat-eventtimestamp----------------------case-invoicepaid------return---------aggregate--------version-eventsequencenumber--------state-----------aggregatestate----------status-paid----------paymentid-eventeventdatapaymentid----------paymentmethod-eventeventdatapaymentmethod----------paidat-eventeventdatapaidat----------------------default------return-aggregate---reconstruction-incrémentalejavascript-reconstruire-à-partir-dune-version-spécifiqueasync-function-reconstructfromversionaggregateid-fromversion---const-events--await-dbeventsfind----aggregateid-aggregateid----sequencenumber--gt-fromversion---sort-sequencenumber-1-----let-aggregate--await-getsnapshotaggregateid-fromversion----for-const-event-of-events-----aggregate--applyeventaggregate-event------return-aggregate--snapshots-pour-performance-création-de-snapshotsjavascript-créer-un-snapshot-de-lagrégatasync-function-createsnapshotaggregateid-version---const-aggregate--await-reconstructaggregateaggregateid----const-snapshot------_id-aggregateid_version----aggregateid-aggregateid----version-version----state-aggregatestate----timestamp-new-date------await-dbsnapshotsreplaceone-----_id-snapshot_id-----snapshot-----upsert-true-------return-snapshot-récupérer-un-snapshotasync-function-getsnapshotaggregateid-version---const-snapshot--await-dbsnapshotsfindone----aggregateid-aggregateid----version--lte-version---sort-version--1-----if-snapshot-----return-------id-aggregateid------version-snapshotversion------state-snapshotstate----------return-----id-aggregateid----version-0----state----stratégie-de-snapshotjavascript-créer-des-snapshots-tous-les-n-événementsconst-snapshot_frequency--100async-function-shouldcreatesnapshotaggregateid---const-eventcount--await-dbeventscountdocuments----aggregateid-aggregateid------return-eventcount--snapshot_frequency--0--requêtes-sur-les-événements-requêtes-temporellesjavascript-tous-les-événements-dun-type-sur-une-périodeasync-function-geteventsbytypeeventtype-startdate-enddate---return-await-dbeventsfind----eventtype-eventtype----timestamp-------gte-startdate------lte-enddate------sort-timestamp-1--événements-par-utilisateurasync-function-geteventsbyuseruserid-limit--100---return-await-dbeventsfind----metadatauserid-userid--sort-timestamp--1-limitlimit-requêtes-de-corrélationjavascript-tous-les-événements-dune-corrélationasync-function-geteventsbycorrelationcorrelationid---return-await-dbeventsfind----metadatacorrelationid-correlationid--sort-timestamp-1--tracer-le-flux-dune-commandeasync-function-tracecommandflowcorrelationid---const-events--await-geteventsbycorrelationcorrelationid----const-flow--eventsmapevent------timestamp-eventtimestamp----aggregateid-eventaggregateid----eventtype-eventeventtype----userid-eventmetadatauserid------return-flow--défis-et-solutions-gestion-des-conflitsjavascript-vérifier-la-version-avant-dajouter-un-événementasync-function-appendeventaggregateid-eventtype-eventdata-expectedversion---const-session--await-clientstartsession----try-----await-sessionwithtransactionasync----------vérifier-la-version-actuelle------const-currentversion--await-dbeventsfindone---------aggregateid-aggregateid----------sort--sequencenumber--1--------------------if-currentversion--currentversionsequencenumber--expectedversion---------throw-new-errorversion-conflict-expected-expectedversion-got-currentversionsequencenumber-------------------ajouter-lévénement------const-event----------_id-objectid--------aggregateid-aggregateid--------aggregatetype-invoice--------eventtype-eventtype--------eventversion-1--------eventdata-eventdata--------timestamp-new-date--------sequencenumber-currentversionsequencenumber--0--1------------------await-dbeventsinsertoneevent-------finally-----await-sessionendsession---gestion-des-erreursjavascript-retry-automatique-en-cas-déchecasync-function-appendeventwithretryaggregateid-eventtype-eventdata-expectedversion-maxretries--3---for-let-i--0-i--maxretries-i-----try-------await-appendeventaggregateid-eventtype-eventdata-expectedversion------return-----catch-error-------if-i--maxretries---1-throw-error-------------attendre-avant-de-retry------await-new-promiseresolve--settimeoutresolve-1000--mathpow2-i-------nettoyage-des-anciens-événementsjavascript-archiver-les-anciens-événementsasync-function-archiveoldeventsolderthandays--365---const-cutoffdate--new-date--cutoffdatesetdatecutoffdategetdate---olderthandays----const-oldevents--await-dbeventsfind----timestamp--lt-cutoffdate---toarray-----archiver-vers-une-collection-séparée--if-oldeventslength--0-----await-dbevents_archiveinsertmanyoldevents----await-dbeventsdeletemany------_id--in-oldeventsmape--e_id---------critères-d-quand-utiliser-event-sourcing-avec-mongodb---audit-trail-critique--conformité-réglementaire-requise---debugging-complexe--besoin-de-comprendre-lhistorique---équipe-très-expérimentée--connaissance-devent-sourcing---budget-important--complexité-justifiée-par-les-besoins-quand-éviter-event-sourcing-avec-mongodb---application-simple--pas-de-besoin-daudit-trail---équipe-junior--complexité-trop-élevée---performance-critique--latence--10ms-requise---budget-limité--complexité-non-justifiée--métriques-de-succès-performancejavascriptconst-performancemetrics----eventappendlatency--50ms--aggregatereconstruction--200ms--snapshotcreation--1s--eventquerylatency--100ms-monitoringjavascriptconst-monitoringmetrics----eventspersecond--1k--averageaggregatesize--100-events--snapshotfrequency-every-100-events--archivefrequency-daily--migration-vers-event-sourcing-étape-1--créer-les-collectionsjavascript-créer-les-collections-event-sourcingdbcreatecollectioneventsdbcreatecollectionsnapshotsdbcreatecollectionevents_archive-étape-2--migrer-les-données-existantesjavascript-migration-des-données-existantes-vers-event-sourcingasync-function-migratetoeventsourcing---const-existingdocuments--await-dbbilling_documentsfind----for-const-doc-of-existingdocuments------créer-lévénement-de-migration----await-dbeventsinsertone------_id-objectid------aggregateid-doc_id------aggregatetype-invoice------eventtype-invoicemigrated------eventversion-1------eventdata-doc------timestamp-new-date------sequencenumber-1-------étape-3--basculer-progressivementjavascript-feature-flag-pour-basculer-vers-event-sourcingconst-useeventsourcing--await-getfeatureflagmongodb_event_sourcing_enabledif-useeventsourcing----utiliser-event-sourcing--return-await-reconstructaggregateaggregateid-else----utiliser-lancienne-collection--return-await-dbbilling_documentsfindone-_id-aggregateid---conseils-pratiques-design-des-événements1-immutables--jamais-de-modification-après-création2-versionnés--support-des-évolutions-de-schéma3-métadonnées--correlationid-causationid-userid4-granularité--un-événement-par-action-métier-monitoring-et-alertes1-lag-de-reconstruction---200ms2-taux-d---013-performance--latence--50ms4-cohérence--vérification-quotidienne--votre-prochaine-étapemaintenant-que-vous-comprenez-lapproche-event-sourcing-avec-mongodb-quelle-est-votre-situation-hahahugoshortcode54s0hbhb-conseil--si-vous-nêtes-pas-sûr-commencez-par-lapproche-cqs-option-c-pour-bien-comprendre-la-séparation-des-responsabilités-puis-revenez-à-event-sourcing-quand-vous-serez-prêt-alternative--si-vous-voulez-tout-voir-dans-lordre-continuez-avec-lapproche-cqrs--event-sourcing-option-a"&gt;🎯 &lt;strong&gt;Objectif de ce Chapitre&lt;/strong&gt;Dans ce chapitre, vous allez découvrir comment implémenter Event Sourcing avec MongoDB, en stockant les événements comme source de vérité et en reconstruisant l&amp;rsquo;état à partir de ces événements.## 📖 &lt;strong&gt;Mon Expérience avec Gyroscops&lt;/strong&gt;Avec Gyroscops, nous avions un besoin critique d&amp;rsquo;audit trail pour nos données financières. Les régulateurs exigeaient de pouvoir tracer chaque modification, et nous avions besoin de comprendre l&amp;rsquo;historique complet des transactions.### &lt;strong&gt;Le Problème avec l&amp;rsquo;État Actuel&lt;/strong&gt;Notre collection &lt;code&gt;billing_documents&lt;/code&gt; ne gardait que l&amp;rsquo;état final :- Impossible de savoir qui avait modifié quoi et quand- Pas de possibilité de &amp;ldquo;rejouer&amp;rdquo; l&amp;rsquo;historique- Audit trail incomplet pour la conformité### &lt;strong&gt;La Révolution Event Sourcing&lt;/strong&gt;J&amp;rsquo;ai découvert qu&amp;rsquo;Event Sourcing permettait de stocker l&amp;rsquo;historique complet :- &lt;strong&gt;Événements immutables&lt;/strong&gt; : Chaque changement est un événement- &lt;strong&gt;Audit trail complet&lt;/strong&gt; : Traçabilité totale- &lt;strong&gt;Replay possible&lt;/strong&gt; : Reconstruction de l&amp;rsquo;état à tout moment## 🏗️ &lt;strong&gt;Architecture Event Sourcing avec MongoDB&lt;/strong&gt;### &lt;strong&gt;Stockage des Événements&lt;/strong&gt;&lt;code&gt;javascript// Événement de création de factureconst InvoiceCreatedEvent = { _id: ObjectId(), aggregateId: &amp;quot;invoice_123&amp;quot;, aggregateType: &amp;quot;Invoice&amp;quot;, eventType: &amp;quot;InvoiceCreated&amp;quot;, eventVersion: 1, eventData: { invoiceNumber: &amp;quot;INV-2024-001&amp;quot;, customerId: &amp;quot;cust_456&amp;quot;, amount: 1500.00, currency: &amp;quot;EUR&amp;quot;, items: [ { description: &amp;quot;Cloud Resources&amp;quot;, amount: 1200.00 }, { description: &amp;quot;Support&amp;quot;, amount: 300.00 } ] }, metadata: { userId: &amp;quot;user_789&amp;quot;, correlationId: &amp;quot;corr_abc&amp;quot;, causationId: &amp;quot;cause_def&amp;quot; }, timestamp: new Date(), sequenceNumber: 1};// Événement de paiementconst InvoicePaidEvent = { _id: ObjectId(), aggregateId: &amp;quot;invoice_123&amp;quot;, aggregateType: &amp;quot;Invoice&amp;quot;, eventType: &amp;quot;InvoicePaid&amp;quot;, eventVersion: 1, eventData: { paymentId: &amp;quot;pay_789&amp;quot;, paymentMethod: &amp;quot;credit_card&amp;quot;, paidAmount: 1500.00, paidAt: new Date() }, metadata: { userId: &amp;quot;user_789&amp;quot;, correlationId: &amp;quot;corr_abc&amp;quot;, causationId: &amp;quot;cause_ghi&amp;quot; }, timestamp: new Date(), sequenceNumber: 2};&lt;/code&gt;### &lt;strong&gt;Index Optimisés pour Event Sourcing&lt;/strong&gt;&lt;code&gt;javascript// Index pour les requêtes par agrégatdb.events.createIndex({ &amp;quot;aggregateId&amp;quot;: 1, &amp;quot;sequenceNumber&amp;quot;: 1 });db.events.createIndex({ &amp;quot;aggregateId&amp;quot;: 1, &amp;quot;eventType&amp;quot;: 1 });// Index pour les requêtes temporellesdb.events.createIndex({ &amp;quot;timestamp&amp;quot;: 1 });db.events.createIndex({ &amp;quot;eventType&amp;quot;: 1, &amp;quot;timestamp&amp;quot;: 1 });// Index pour les requêtes de corrélationdb.events.createIndex({ &amp;quot;metadata.correlationId&amp;quot;: 1 });db.events.createIndex({ &amp;quot;metadata.userId&amp;quot;: 1 });&lt;/code&gt;## 🔄 &lt;strong&gt;Reconstruction de l&amp;rsquo;État&lt;/strong&gt;### &lt;strong&gt;Reconstruction Complète&lt;/strong&gt;&lt;code&gt;javascript// Reconstruire l'état complet d'un agrégatasync function reconstructAggregate(aggregateId) { const events = await db.events.find({ aggregateId: aggregateId }).sort({ sequenceNumber: 1 }); let aggregate = { id: aggregateId, version: 0, state: {} }; for (const event of events) { aggregate = applyEvent(aggregate, event); } return aggregate;}// Appliquer un événement à l'agrégatfunction applyEvent(aggregate, event) { switch (event.eventType) { case &amp;quot;InvoiceCreated&amp;quot;: return { ...aggregate, version: event.sequenceNumber, state: { ...aggregate.state, invoiceNumber: event.eventData.invoiceNumber, customerId: event.eventData.customerId, amount: event.eventData.amount, currency: event.eventData.currency, items: event.eventData.items, status: &amp;quot;pending&amp;quot;, createdAt: event.timestamp } }; case &amp;quot;InvoicePaid&amp;quot;: return { ...aggregate, version: event.sequenceNumber, state: { ...aggregate.state, status: &amp;quot;paid&amp;quot;, paymentId: event.eventData.paymentId, paymentMethod: event.eventData.paymentMethod, paidAt: event.eventData.paidAt } }; default: return aggregate; }}&lt;/code&gt;### &lt;strong&gt;Reconstruction Incrémentale&lt;/strong&gt;&lt;code&gt;javascript// Reconstruire à partir d'une version spécifiqueasync function reconstructFromVersion(aggregateId, fromVersion) { const events = await db.events.find({ aggregateId: aggregateId, sequenceNumber: { $gt: fromVersion } }).sort({ sequenceNumber: 1 }); let aggregate = await getSnapshot(aggregateId, fromVersion); for (const event of events) { aggregate = applyEvent(aggregate, event); } return aggregate;}&lt;/code&gt;## 📊 &lt;strong&gt;Snapshots pour Performance&lt;/strong&gt;### &lt;strong&gt;Création de Snapshots&lt;/strong&gt;&lt;code&gt;javascript// Créer un snapshot de l'agrégatasync function createSnapshot(aggregateId, version) { const aggregate = await reconstructAggregate(aggregateId); const snapshot = { _id: `${aggregateId}_${version}`, aggregateId: aggregateId, version: version, state: aggregate.state, timestamp: new Date() }; await db.snapshots.replaceOne( { _id: snapshot._id }, snapshot, { upsert: true } ); return snapshot;}// Récupérer un snapshotasync function getSnapshot(aggregateId, version) { const snapshot = await db.snapshots.findOne({ aggregateId: aggregateId, version: { $lte: version } }).sort({ version: -1 }); if (snapshot) { return { id: aggregateId, version: snapshot.version, state: snapshot.state }; } return { id: aggregateId, version: 0, state: {} };}&lt;/code&gt;### &lt;strong&gt;Stratégie de Snapshot&lt;/strong&gt;&lt;code&gt;javascript// Créer des snapshots tous les N événementsconst SNAPSHOT_FREQUENCY = 100;async function shouldCreateSnapshot(aggregateId) { const eventCount = await db.events.countDocuments({ aggregateId: aggregateId }); return eventCount % SNAPSHOT_FREQUENCY === 0;}&lt;/code&gt;## 🔍 &lt;strong&gt;Requêtes sur les Événements&lt;/strong&gt;### &lt;strong&gt;Requêtes Temporelles&lt;/strong&gt;&lt;code&gt;javascript// Tous les événements d'un type sur une périodeasync function getEventsByType(eventType, startDate, endDate) { return await db.events.find({ eventType: eventType, timestamp: { $gte: startDate, $lte: endDate } }).sort({ timestamp: 1 });}// Événements par utilisateurasync function getEventsByUser(userId, limit = 100) { return await db.events.find({ &amp;quot;metadata.userId&amp;quot;: userId }).sort({ timestamp: -1 }).limit(limit);}&lt;/code&gt;### &lt;strong&gt;Requêtes de Corrélation&lt;/strong&gt;&lt;code&gt;javascript// Tous les événements d'une corrélationasync function getEventsByCorrelation(correlationId) { return await db.events.find({ &amp;quot;metadata.correlationId&amp;quot;: correlationId }).sort({ timestamp: 1 });}// Tracer le flux d'une commandeasync function traceCommandFlow(correlationId) { const events = await getEventsByCorrelation(correlationId); const flow = events.map(event =&amp;gt; ({ timestamp: event.timestamp, aggregateId: event.aggregateId, eventType: event.eventType, userId: event.metadata.userId })); return flow;}&lt;/code&gt;## ⚠️ &lt;strong&gt;Défis et Solutions&lt;/strong&gt;### &lt;strong&gt;Gestion des Conflits&lt;/strong&gt;&lt;code&gt;javascript// Vérifier la version avant d'ajouter un événementasync function appendEvent(aggregateId, eventType, eventData, expectedVersion) { const session = await client.startSession(); try { await session.withTransaction(async () =&amp;gt; { // Vérifier la version actuelle const currentVersion = await db.events.findOne( { aggregateId: aggregateId }, { sort: { sequenceNumber: -1 } } ); if (currentVersion &amp;amp;&amp;amp; currentVersion.sequenceNumber !== expectedVersion) { throw new Error(`Version conflict: expected ${expectedVersion}, got ${currentVersion.sequenceNumber}`); } // Ajouter l'événement const event = { _id: ObjectId(), aggregateId: aggregateId, aggregateType: &amp;quot;Invoice&amp;quot;, eventType: eventType, eventVersion: 1, eventData: eventData, timestamp: new Date(), sequenceNumber: (currentVersion?.sequenceNumber || 0) + 1 }; await db.events.insertOne(event); }); } finally { await session.endSession(); }}&lt;/code&gt;### &lt;strong&gt;Gestion des Erreurs&lt;/strong&gt;&lt;code&gt;javascript// Retry automatique en cas d'échecasync function appendEventWithRetry(aggregateId, eventType, eventData, expectedVersion, maxRetries = 3) { for (let i = 0; i &amp;lt; maxRetries; i++) { try { await appendEvent(aggregateId, eventType, eventData, expectedVersion); return; } catch (error) { if (i === maxRetries - 1) throw error; // Attendre avant de retry await new Promise(resolve =&amp;gt; setTimeout(resolve, 1000 * Math.pow(2, i))); } }}&lt;/code&gt;### &lt;strong&gt;Nettoyage des Anciens Événements&lt;/strong&gt;&lt;code&gt;javascript// Archiver les anciens événementsasync function archiveOldEvents(olderThanDays = 365) { const cutoffDate = new Date(); cutoffDate.setDate(cutoffDate.getDate() - olderThanDays); const oldEvents = await db.events.find({ timestamp: { $lt: cutoffDate } }).toArray(); // Archiver vers une collection séparée if (oldEvents.length &amp;gt; 0) { await db.events_archive.insertMany(oldEvents); await db.events.deleteMany({ _id: { $in: oldEvents.map(e =&amp;gt; e._id) } }); }}&lt;/code&gt;## 🎯 &lt;strong&gt;Critères d&amp;rsquo;Adoption&lt;/strong&gt;### &lt;strong&gt;Quand Utiliser Event Sourcing avec MongoDB&lt;/strong&gt;- ✅ &lt;strong&gt;Audit trail critique&lt;/strong&gt; : Conformité réglementaire requise- ✅ &lt;strong&gt;Debugging complexe&lt;/strong&gt; : Besoin de comprendre l&amp;rsquo;historique- ✅ &lt;strong&gt;Équipe très expérimentée&lt;/strong&gt; : Connaissance d&amp;rsquo;Event Sourcing- ✅ &lt;strong&gt;Budget important&lt;/strong&gt; : Complexité justifiée par les besoins### &lt;strong&gt;Quand Éviter Event Sourcing avec MongoDB&lt;/strong&gt;- ❌ &lt;strong&gt;Application simple&lt;/strong&gt; : Pas de besoin d&amp;rsquo;audit trail- ❌ &lt;strong&gt;Équipe junior&lt;/strong&gt; : Complexité trop élevée- ❌ &lt;strong&gt;Performance critique&lt;/strong&gt; : Latence &amp;lt; 10ms requise- ❌ &lt;strong&gt;Budget limité&lt;/strong&gt; : Complexité non justifiée## 📈 &lt;strong&gt;Métriques de Succès&lt;/strong&gt;### &lt;strong&gt;Performance&lt;/strong&gt;&lt;code&gt;javascriptconst performanceMetrics = { eventAppendLatency: &amp;quot;&amp;lt; 50ms&amp;quot;, aggregateReconstruction: &amp;quot;&amp;lt; 200ms&amp;quot;, snapshotCreation: &amp;quot;&amp;lt; 1s&amp;quot;, eventQueryLatency: &amp;quot;&amp;lt; 100ms&amp;quot;};&lt;/code&gt;### &lt;strong&gt;Monitoring&lt;/strong&gt;&lt;code&gt;javascriptconst monitoringMetrics = { eventsPerSecond: &amp;quot;&amp;gt; 1k&amp;quot;, averageAggregateSize: &amp;quot;&amp;lt; 100 events&amp;quot;, snapshotFrequency: &amp;quot;Every 100 events&amp;quot;, archiveFrequency: &amp;quot;Daily&amp;quot;};&lt;/code&gt;## 🔄 &lt;strong&gt;Migration vers Event Sourcing&lt;/strong&gt;### &lt;strong&gt;Étape 1 : Créer les Collections&lt;/strong&gt;&lt;code&gt;javascript// Créer les collections Event Sourcingdb.createCollection(&amp;quot;events&amp;quot;);db.createCollection(&amp;quot;snapshots&amp;quot;);db.createCollection(&amp;quot;events_archive&amp;quot;);&lt;/code&gt;### &lt;strong&gt;Étape 2 : Migrer les Données Existantes&lt;/strong&gt;&lt;code&gt;javascript// Migration des données existantes vers Event Sourcingasync function migrateToEventSourcing() { const existingDocuments = await db.billing_documents.find({}); for (const doc of existingDocuments) { // Créer l'événement de migration await db.events.insertOne({ _id: ObjectId(), aggregateId: doc._id, aggregateType: &amp;quot;Invoice&amp;quot;, eventType: &amp;quot;InvoiceMigrated&amp;quot;, eventVersion: 1, eventData: doc, timestamp: new Date(), sequenceNumber: 1 }); }}&lt;/code&gt;### &lt;strong&gt;Étape 3 : Basculer Progressivement&lt;/strong&gt;&lt;code&gt;javascript// Feature flag pour basculer vers Event Sourcingconst useEventSourcing = await getFeatureFlag(&amp;quot;mongodb_event_sourcing_enabled&amp;quot;);if (useEventSourcing) { // Utiliser Event Sourcing return await reconstructAggregate(aggregateId);} else { // Utiliser l'ancienne collection return await db.billing_documents.findOne({ _id: aggregateId });}&lt;/code&gt;## 💡 &lt;strong&gt;Conseils Pratiques&lt;/strong&gt;### &lt;strong&gt;Design des Événements&lt;/strong&gt;1. &lt;strong&gt;Immutables&lt;/strong&gt; : Jamais de modification après création2. &lt;strong&gt;Versionnés&lt;/strong&gt; : Support des évolutions de schéma3. &lt;strong&gt;Métadonnées&lt;/strong&gt; : CorrelationId, CausationId, UserId4. &lt;strong&gt;Granularité&lt;/strong&gt; : Un événement par action métier### &lt;strong&gt;Monitoring et Alertes&lt;/strong&gt;1. &lt;strong&gt;Lag de reconstruction&lt;/strong&gt; : &amp;lt; 200ms2. &lt;strong&gt;Taux d&amp;rsquo;erreur&lt;/strong&gt; : &amp;lt; 0.1%3. &lt;strong&gt;Performance&lt;/strong&gt; : Latence &amp;lt; 50ms4. &lt;strong&gt;Cohérence&lt;/strong&gt; : Vérification quotidienne## 🎯 &lt;strong&gt;Votre Prochaine Étape&lt;/strong&gt;Maintenant que vous comprenez l&amp;rsquo;approche Event Sourcing avec MongoDB, quelle est votre situation ?

&lt;div class="chapter-navigation"&gt;
 &lt;h2 class="chapter-nav-title"&gt;🎯 Votre Prochaine Étape&lt;/h2&gt;
 &lt;p class="chapter-nav-subtitle"&gt;Maintenant que vous comprenez les concepts de base et que j'ai partagé mon expérience avec Gyroscops, quel est votre contexte ?&lt;/p&gt;</description></item><item><title>Stockage MongoDB - Event Sourcing + CQS</title><link>http://localhost:1313/chapitres/stockage/mongodb/chapitre-32-stockage-mongodb-event-sourcing-cqs/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/mongodb/chapitre-32-stockage-mongodb-event-sourcing-cqs/</guid><description>&lt;h2 id="-contexte-et-objectifs-pourquoi-event-sourcing--cqs-avec-mongodb-après-avoir-exploré-levent-sourcing-pur-avec-mongodb-nous-allons-maintenant-combiner-cette-approche-avec-le-command-query-separation-cqs-pour-optimiser-les-performances-et-la-scalabilité-avantages-de-cette-combinaison--performance-optimisée--séparation-claire-entre-écriture-et-lecture--scalabilité--possibilité-de-scaler-indépendamment-les-commandes-et-requêtes--flexibilité--projections-multiples-pour-différents-besoins--audit-trail--historique-complet-des-événements-contexte-gyroscopsdans-notre-écosystème-user--organization--workflow--cloud-resources--billing-cette-approche-est-particulièrement-pertinente-pour---gestion-des-factures--audit-trail-complet-des-modifications--workflows-complexes--événements-de-progression-et-détat--ressources-cloud--historique-des-changements-dinfrastructure--architecture-event-sourcing--cqs-séparation-des-responsabilités-côté-commande-write--event-store--stockage-des-événements-dans-mongodb--command-handlers--traitement-des-commandes-métier--event-handlers--gestion-des-événements-générés--aggregates--logique-métier-et-invariants-côté-requête-read--projections--vues-optimisées-pour-la-lecture--query-handlers--traitement-des-requêtes--read-models--modèles-optimisés-pour-laffichage--caches--optimisation-des-performances-flux-de-donnéesmermaidgraph-td----acommand----bcommand-handler----b----caggregate----c----devents----d----eevent-store-mongodb----d----fevent-handlers----f----gprojections----g----hread-models----h----iquery-handler----i----jresponse--------kquery----i--implémentation-pratique-1-event-store-mongodb-structure-des-collectionsjavascript-collection-events--_id-objectid--aggregateid-payment-123--aggregatetype-payment--eventtype-paymentprocessed--eventdata-----amount-10000----currency-eur----status-completed----version-1--timestamp-isodate2024-12-19t100000z--metadata-----userid-user-456----organizationid-org-789---collection-snapshots--_id-objectid--aggregateid-payment-123--aggregatetype-payment--data-----amount-10000----currency-eur----status-completed----processedat-isodate2024-12-19t100000z----version-1--timestamp-isodate2024-12-19t100000z-index-mongodbjavascript-index-pour-les-événementsdbeventscreateindex-aggregateid-1-version-1-dbeventscreateindex-aggregatetype-1-timestamp-1-dbeventscreateindex-eventtype-1-timestamp-1--index-pour-les-snapshotsdbsnapshotscreateindex-aggregateid-1-dbsnapshotscreateindex-aggregatetype-1-timestamp-1--2-command-side-implementation-event-store-repositoryphpphpnamespace-appinfrastructureeventstoreuse-mongodbclientuse-mongodbcollectionuse-appdomaineventdomaineventuse-appdomaineventeventstoreinterfaceclass-mongoeventstore-implements-eventstoreinterface----private-collection-events----private-collection-snapshots----public-function-__constructclient-mongoclient------------this-events--mongoclient-selectcollectiongyroscops-cloud-events--------this-snapshots--mongoclient-selectcollectiongyroscops-cloud-snapshots--------public-function-appendeventsstring-aggregateid-array-events-int-expectedversion-void------------session--this-events-getdatabase-getclient-startsession----------------try-------------session-starttransaction-------------------------vérifier-la-version-attendue------------lastevent--this-events-findone----------------aggregateid--aggregateid----------------sort--version---1------------------------------------if-lastevent--lasteventversion--expectedversion-----------------throw-new-concurrencyexceptionversion-mismatch-------------------------------------insérer-les-nouveaux-événements------------documents--------------version--expectedversion--1------------------------foreach-events-as-event-----------------documents----------------------aggregateid--aggregateid--------------------aggregatetype--event-getaggregatetype--------------------eventtype--event-geteventtype--------------------eventdata--event-toarray--------------------version--version--------------------timestamp--new-mongodbbsonutcdatetime--------------------metadata--event-getmetadata----------------------------------------------------this-events-insertmanydocuments------------session-committransaction---------------------catch-exception-e-------------session-aborttransaction------------throw-e----------------public-function-geteventsstring-aggregateid-int-fromversion--0-array------------cursor--this-events-find----------------------------aggregateid--aggregateid----------------version--gte--fromversion------------------------sort--version--1------------------------events----------foreach-cursor-as-document-------------events--this-deserializeeventdocument------------------------return-events--------private-function-deserializeeventarray-document-domainevent------------eventclass--documenteventtype--------return-eventclassfromarraydocumenteventdata-----command-handlerphpphpnamespace-appapplicationcommandpaymentuse-appdomainpaymentpaymentaggregateuse-appdomaineventeventstoreinterfaceuse-appdomainpaymentpaymentrepositoryinterfaceclass-processpaymentcommandhandler----public-function-__construct--------private-eventstoreinterface-eventstore--------private-paymentrepositoryinterface-paymentrepository---------public-function-handleprocesspaymentcommand-command-void-------------charger-lagrégat--------events--this-eventstore-geteventscommand-getpaymentid--------payment--paymentaggregatefromeventsevents-----------------exécuter-la-commande--------payment-processpaymentcommand-getamount-command-getcurrency-----------------sauvegarder-les-événements--------this-eventstore-appendevents------------command-getpaymentid------------payment-getuncommittedevents------------payment-getversion-------------------------nettoyer-les-événements-non-commités--------payment-markeventsascommitted-----3-query-side-implementation-projection-handlerphpphpnamespace-appapplicationprojectionpaymentuse-appdomaineventdomaineventuse-appinfrastructurereadmodelpaymentreadmodeluse-mongodbclientclass-paymentprojectionhandler----private-mongodbcollection-readmodel----public-function-__constructclient-mongoclient------------this-readmodel--mongoclient-selectcollectiongyroscops-cloud-payment_read_models--------public-function-handledomainevent-event-void------------switch-event-geteventtype-------------case-paymentprocessed----------------this-handlepaymentprocessedevent----------------break------------case-paymentfailed----------------this-handlepaymentfailedevent----------------break----------------private-function-handlepaymentprocesseddomainevent-event-void------------this-readmodel-updateone------------paymentid--event-getaggregateid----------------------------set----------------------paymentid--event-getaggregateid--------------------amount--event-getdataamount--------------------currency--event-getdatacurrency--------------------status--completed--------------------processedat--event-gettimestamp--------------------updatedat--new-mongodbbsonutcdatetime----------------------------------------upsert--true----------------private-function-handlepaymentfaileddomainevent-event-void------------this-readmodel-updateone------------paymentid--event-getaggregateid----------------------------set----------------------status--failed--------------------error--event-getdataerror--------------------updatedat--new-mongodbbsonutcdatetime----------------------------------------upsert--true-------------query-handlerphpphpnamespace-appapplicationquerypaymentuse-appinfrastructurereadmodelpaymentreadmodeluse-mongodbclientclass-paymentqueryhandler----private-mongodbcollection-readmodel----public-function-__constructclient-mongoclient------------this-readmodel--mongoclient-selectcollectiongyroscops-cloud-payment_read_models--------public-function-getpaymentbyidstring-paymentid-paymentreadmodel------------document--this-readmodel-findonepaymentid--paymentid----------------if-document-------------return-null------------------------return-paymentreadmodelfromarraydocument--------public-function-getpaymentsbyorganizationstring-organizationid-int-limit--50-int-offset--0-array------------cursor--this-readmodel-find------------organizationid--organizationid----------------------------sort--processedat---1----------------limit--limit----------------skip--offset------------------------------------payments----------foreach-cursor-as-document-------------payments--paymentreadmodelfromarraydocument------------------------return-payments--------public-function-getpaymentstatisticsstring-organizationid-datetime-from-datetime-to-array------------pipeline------------------------------match----------------------organizationid--organizationid--------------------processedat--------------------------gte--new-mongodbbsonutcdatetimefrom------------------------lte--new-mongodbbsonutcdatetimeto----------------------------------------------------------------------------group----------------------_id--status--------------------count--sum--1--------------------totalamount--sum--amount----------------------------------------------------cursor--this-readmodel-aggregatepipeline----------------statistics----------foreach-cursor-as-document-------------statisticsdocument_id------------------count--documentcount----------------totalamount--documenttotalamount------------------------------------return-statistics------tests-et-validation-tests-unitairesphpphpnamespace-apptestsinfrastructureeventstoreuse-phpunitframeworktestcaseuse-appinfrastructureeventstoremongoeventstoreuse-appdomainpaymentpaymentprocessedeventclass-mongoeventstoretest-extends-testcase----private-mongoeventstore-eventstore----private-mongodbclient-mongoclient----protected-function-setup-void------------this-mongoclient--new-mongodbclientmongodblocalhost27017--------this-eventstore--new-mongoeventstorethis-mongoclient-----------------nettoyer-les-collections-de-test--------this-mongoclient-selectcollectiontest-events-drop--------this-mongoclient-selectcollectiontest-snapshots-drop--------public-function-testappendevents-void------------paymentid--payment-123--------event--new-paymentprocessedeventpaymentid-10000-eur----------------this-eventstore-appendeventspaymentid-event-0----------------events--this-eventstore-geteventspaymentid--------this-assertcount1-events--------this-assertinstanceofpaymentprocessedeventclass-events0--------public-function-testconcurrencycontrol-void------------paymentid--payment-123--------event1--new-paymentprocessedeventpaymentid-10000-eur--------event2--new-paymentprocessedeventpaymentid-20000-eur-----------------premier-append--------this-eventstore-appendeventspaymentid-event1-0-----------------tentative-de-concourrence--------this-expectexceptionconcurrencyexceptionclass--------this-eventstore-appendeventspaymentid-event2-0-----tests-dphpphpnamespace-apptestsintegrationpaymentuse-appapplicationcommandpaymentprocesspaymentcommanduse-appapplicationcommandpaymentprocesspaymentcommandhandleruse-appapplicationquerypaymentpaymentqueryhandleruse-appinfrastructureeventstoremongoeventstoreuse-mongodbclientclass-paymenteventsourcingcqstest-extends-testcase----public-function-testcompletepaymentflow-void------------mongoclient--new-clientmongodblocalhost27017--------eventstore--new-mongoeventstoremongoclient----------------commandhandler--new-processpaymentcommandhandlereventstore-this-createmockpaymentrepositoryinterfaceclass--------queryhandler--new-paymentqueryhandlermongoclient-----------------exécuter-la-commande--------command--new-processpaymentcommandpayment-123-10000-eur--------commandhandler-handlecommand-----------------vérifier-la-requête--------payment--queryhandler-getpaymentbyidpayment-123--------this-assertnotnullpayment--------this-assertequals10000-payment-getamount--------this-assertequalseur-payment-getcurrency--------this-assertequalscompleted-payment-getstatus------performance-et-optimisation-stratégies-d-1-index-mongodbjavascript-index-composés-pour-les-requêtes-fréquentesdbeventscreateindex-aggregatetype-1-timestamp--1-dbeventscreateindex-eventtype-1-aggregateid-1-dbpayment_read_modelscreateindex-organizationid-1-processedat--1-dbpayment_read_modelscreateindex-status-1-processedat--1--2-snapshotsphppublic-function-createsnapshotstring-aggregateid-int-version-void----events--this-geteventsaggregateid-0----aggregate--paymentaggregatefromeventsevents--------this-snapshots-replaceone--------aggregateid--aggregateid--------------------aggregateid--aggregateid------------aggregatetype--payment------------data--aggregate-tosnapshot------------version--version------------timestamp--new-mongodbbsonutcdatetime----------------upsert--true-----3-projections-asynchronesphppublic-function-handleeventasyncdomainevent-event-void-----mettre-en-queue-pour-traitement-asynchrone----this-messagebus-dispatchnew-processprojectioncommandevent--critères-d-quand-utiliser-event-sourcing--cqs-avec-mongodb--avantages--audit-trail-complet--historique-de-tous-les-changements--performance-optimisée--séparation-lectureécriture--scalabilité--possibilité-de-scaler-indépendamment--flexibilité--projections-multiples-pour-différents-besoins--debugging--possibilité-de-rejouer-les-événements--inconvénients--complexité--architecture-plus-complexe--latence--délai-entre-écriture-et-lecture--stockage--plus-despace-disque-nécessaire--expertise--équipe-expérimentée-requise--critères-d--audit-trail-critique--besoin-de-traçabilité-complète--performance-importante--lectures-et-écritures-très-différentes--équipe-expérimentée--maîtrise-des-patterns-avancés--budget-important--investissement-en-complexité-justifié--évolutivité--besoin-de-scaler-indépendamment--votre-prochaine-étapehahahugoshortcode55s0hbhbcette-approche-event-sourcing--cqs-avec-mongodb-offre-un-équilibre-optimal-entre-performance-scalabilité-et-audit-trail-parfaitement-adapté-aux-besoins-complexes-de-gyroscops"&gt;🎯 &lt;strong&gt;Contexte et Objectifs&lt;/strong&gt;### **Pourquoi Event Sourcing + CQS avec MongoDB ?**Après avoir exploré l&amp;rsquo;Event Sourcing pur avec MongoDB, nous allons maintenant combiner cette approche avec le &lt;strong&gt;Command Query Separation (CQS)&lt;/strong&gt; pour optimiser les performances et la scalabilité.#### &lt;strong&gt;Avantages de cette Combinaison&lt;/strong&gt;- &lt;strong&gt;Performance optimisée&lt;/strong&gt; : Séparation claire entre écriture et lecture- &lt;strong&gt;Scalabilité&lt;/strong&gt; : Possibilité de scaler indépendamment les commandes et requêtes- &lt;strong&gt;Flexibilité&lt;/strong&gt; : Projections multiples pour différents besoins- &lt;strong&gt;Audit trail&lt;/strong&gt; : Historique complet des événements### &lt;strong&gt;Contexte Gyroscops&lt;/strong&gt;Dans notre écosystème &lt;strong&gt;User → Organization → Workflow → Cloud Resources → Billing&lt;/strong&gt;, cette approche est particulièrement pertinente pour :- &lt;strong&gt;Gestion des factures&lt;/strong&gt; : Audit trail complet des modifications- &lt;strong&gt;Workflows complexes&lt;/strong&gt; : Événements de progression et d&amp;rsquo;état- &lt;strong&gt;Ressources cloud&lt;/strong&gt; : Historique des changements d&amp;rsquo;infrastructure## 🏗️ &lt;strong&gt;Architecture Event Sourcing + CQS&lt;/strong&gt;### &lt;strong&gt;Séparation des Responsabilités&lt;/strong&gt;#### &lt;strong&gt;Côté Commande (Write)&lt;/strong&gt;- &lt;strong&gt;Event Store&lt;/strong&gt; : Stockage des événements dans MongoDB- &lt;strong&gt;Command Handlers&lt;/strong&gt; : Traitement des commandes métier- &lt;strong&gt;Event Handlers&lt;/strong&gt; : Gestion des événements générés- &lt;strong&gt;Aggregates&lt;/strong&gt; : Logique métier et invariants#### &lt;strong&gt;Côté Requête (Read)&lt;/strong&gt;- &lt;strong&gt;Projections&lt;/strong&gt; : Vues optimisées pour la lecture- &lt;strong&gt;Query Handlers&lt;/strong&gt; : Traitement des requêtes- &lt;strong&gt;Read Models&lt;/strong&gt; : Modèles optimisés pour l&amp;rsquo;affichage- &lt;strong&gt;Caches&lt;/strong&gt; : Optimisation des performances### &lt;strong&gt;Flux de Données&lt;/strong&gt;&lt;code&gt;mermaidgraph TD A[Command] --&amp;gt; B[Command Handler] B --&amp;gt; C[Aggregate] C --&amp;gt; D[Events] D --&amp;gt; E[Event Store MongoDB] D --&amp;gt; F[Event Handlers] F --&amp;gt; G[Projections] G --&amp;gt; H[Read Models] H --&amp;gt; I[Query Handler] I --&amp;gt; J[Response] K[Query] --&amp;gt; I&lt;/code&gt;## 💻 &lt;strong&gt;Implémentation Pratique&lt;/strong&gt;### &lt;strong&gt;1. Event Store MongoDB&lt;/strong&gt;#### &lt;strong&gt;Structure des Collections&lt;/strong&gt;&lt;code&gt;javascript// Collection: events{ _id: ObjectId(&amp;quot;...&amp;quot;), aggregateId: &amp;quot;payment-123&amp;quot;, aggregateType: &amp;quot;Payment&amp;quot;, eventType: &amp;quot;PaymentProcessed&amp;quot;, eventData: { amount: 100.00, currency: &amp;quot;EUR&amp;quot;, status: &amp;quot;completed&amp;quot; }, version: 1, timestamp: ISODate(&amp;quot;2024-12-19T10:00:00Z&amp;quot;), metadata: { userId: &amp;quot;user-456&amp;quot;, organizationId: &amp;quot;org-789&amp;quot; }}// Collection: snapshots{ _id: ObjectId(&amp;quot;...&amp;quot;), aggregateId: &amp;quot;payment-123&amp;quot;, aggregateType: &amp;quot;Payment&amp;quot;, data: { amount: 100.00, currency: &amp;quot;EUR&amp;quot;, status: &amp;quot;completed&amp;quot;, processedAt: ISODate(&amp;quot;2024-12-19T10:00:00Z&amp;quot;) }, version: 1, timestamp: ISODate(&amp;quot;2024-12-19T10:00:00Z&amp;quot;)}&lt;/code&gt;#### &lt;strong&gt;Index MongoDB&lt;/strong&gt;&lt;code&gt;javascript// Index pour les événementsdb.events.createIndex({ aggregateId: 1, version: 1 })db.events.createIndex({ aggregateType: 1, timestamp: 1 })db.events.createIndex({ eventType: 1, timestamp: 1 })// Index pour les snapshotsdb.snapshots.createIndex({ aggregateId: 1 })db.snapshots.createIndex({ aggregateType: 1, timestamp: 1 })&lt;/code&gt;### &lt;strong&gt;2. Command Side Implementation&lt;/strong&gt;#### &lt;strong&gt;Event Store Repository&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Infrastructure\EventStore;use MongoDB\Client;use MongoDB\Collection;use App\Domain\Event\DomainEvent;use App\Domain\Event\EventStoreInterface;class MongoEventStore implements EventStoreInterface{ private Collection $events; private Collection $snapshots; public function __construct(Client $mongoClient) { $this-&amp;gt;events = $mongoClient-&amp;gt;selectCollection('Gyroscops Cloud', 'events'); $this-&amp;gt;snapshots = $mongoClient-&amp;gt;selectCollection('Gyroscops Cloud', 'snapshots'); } public function appendEvents(string $aggregateId, array $events, int $expectedVersion): void { $session = $this-&amp;gt;events-&amp;gt;getDatabase()-&amp;gt;getClient()-&amp;gt;startSession(); try { $session-&amp;gt;startTransaction(); // Vérifier la version attendue $lastEvent = $this-&amp;gt;events-&amp;gt;findOne( ['aggregateId' =&amp;gt; $aggregateId], ['sort' =&amp;gt; ['version' =&amp;gt; -1]] ); if ($lastEvent &amp;amp;&amp;amp; $lastEvent['version'] !== $expectedVersion) { throw new ConcurrencyException('Version mismatch'); } // Insérer les nouveaux événements $documents = []; $version = $expectedVersion + 1; foreach ($events as $event) { $documents[] = [ 'aggregateId' =&amp;gt; $aggregateId, 'aggregateType' =&amp;gt; $event-&amp;gt;getAggregateType(), 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'eventData' =&amp;gt; $event-&amp;gt;toArray(), 'version' =&amp;gt; $version++, 'timestamp' =&amp;gt; new \MongoDB\BSON\UTCDateTime(), 'metadata' =&amp;gt; $event-&amp;gt;getMetadata() ]; } $this-&amp;gt;events-&amp;gt;insertMany($documents); $session-&amp;gt;commitTransaction(); } catch (\Exception $e) { $session-&amp;gt;abortTransaction(); throw $e; } } public function getEvents(string $aggregateId, int $fromVersion = 0): array { $cursor = $this-&amp;gt;events-&amp;gt;find( [ 'aggregateId' =&amp;gt; $aggregateId, 'version' =&amp;gt; ['$gte' =&amp;gt; $fromVersion] ], ['sort' =&amp;gt; ['version' =&amp;gt; 1]] ); $events = []; foreach ($cursor as $document) { $events[] = $this-&amp;gt;deserializeEvent($document); } return $events; } private function deserializeEvent(array $document): DomainEvent { $eventClass = $document['eventType']; return $eventClass::fromArray($document['eventData']); }}&lt;/code&gt;#### &lt;strong&gt;Command Handler&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Command\Payment;use App\Domain\Payment\PaymentAggregate;use App\Domain\Event\EventStoreInterface;use App\Domain\Payment\PaymentRepositoryInterface;class ProcessPaymentCommandHandler{ public function __construct( private EventStoreInterface $eventStore, private PaymentRepositoryInterface $paymentRepository ) {} public function handle(ProcessPaymentCommand $command): void { // Charger l'agrégat $events = $this-&amp;gt;eventStore-&amp;gt;getEvents($command-&amp;gt;getPaymentId()); $payment = PaymentAggregate::fromEvents($events); // Exécuter la commande $payment-&amp;gt;processPayment($command-&amp;gt;getAmount(), $command-&amp;gt;getCurrency()); // Sauvegarder les événements $this-&amp;gt;eventStore-&amp;gt;appendEvents( $command-&amp;gt;getPaymentId(), $payment-&amp;gt;getUncommittedEvents(), $payment-&amp;gt;getVersion() ); // Nettoyer les événements non commités $payment-&amp;gt;markEventsAsCommitted(); }}&lt;/code&gt;### &lt;strong&gt;3. Query Side Implementation&lt;/strong&gt;#### &lt;strong&gt;Projection Handler&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Projection\Payment;use App\Domain\Event\DomainEvent;use App\Infrastructure\ReadModel\PaymentReadModel;use MongoDB\Client;class PaymentProjectionHandler{ private \MongoDB\Collection $readModel; public function __construct(Client $mongoClient) { $this-&amp;gt;readModel = $mongoClient-&amp;gt;selectCollection('Gyroscops Cloud', 'payment_read_models'); } public function handle(DomainEvent $event): void { switch ($event-&amp;gt;getEventType()) { case 'PaymentProcessed': $this-&amp;gt;handlePaymentProcessed($event); break; case 'PaymentFailed': $this-&amp;gt;handlePaymentFailed($event); break; } } private function handlePaymentProcessed(DomainEvent $event): void { $this-&amp;gt;readModel-&amp;gt;updateOne( ['paymentId' =&amp;gt; $event-&amp;gt;getAggregateId()], [ '$set' =&amp;gt; [ 'paymentId' =&amp;gt; $event-&amp;gt;getAggregateId(), 'amount' =&amp;gt; $event-&amp;gt;getData()['amount'], 'currency' =&amp;gt; $event-&amp;gt;getData()['currency'], 'status' =&amp;gt; 'completed', 'processedAt' =&amp;gt; $event-&amp;gt;getTimestamp(), 'updatedAt' =&amp;gt; new \MongoDB\BSON\UTCDateTime() ] ], ['upsert' =&amp;gt; true] ); } private function handlePaymentFailed(DomainEvent $event): void { $this-&amp;gt;readModel-&amp;gt;updateOne( ['paymentId' =&amp;gt; $event-&amp;gt;getAggregateId()], [ '$set' =&amp;gt; [ 'status' =&amp;gt; 'failed', 'error' =&amp;gt; $event-&amp;gt;getData()['error'], 'updatedAt' =&amp;gt; new \MongoDB\BSON\UTCDateTime() ] ], ['upsert' =&amp;gt; true] ); }}&lt;/code&gt;#### &lt;strong&gt;Query Handler&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Query\Payment;use App\Infrastructure\ReadModel\PaymentReadModel;use MongoDB\Client;class PaymentQueryHandler{ private \MongoDB\Collection $readModel; public function __construct(Client $mongoClient) { $this-&amp;gt;readModel = $mongoClient-&amp;gt;selectCollection('Gyroscops Cloud', 'payment_read_models'); } public function getPaymentById(string $paymentId): ?PaymentReadModel { $document = $this-&amp;gt;readModel-&amp;gt;findOne(['paymentId' =&amp;gt; $paymentId]); if (!$document) { return null; } return PaymentReadModel::fromArray($document); } public function getPaymentsByOrganization(string $organizationId, int $limit = 50, int $offset = 0): array { $cursor = $this-&amp;gt;readModel-&amp;gt;find( ['organizationId' =&amp;gt; $organizationId], [ 'sort' =&amp;gt; ['processedAt' =&amp;gt; -1], 'limit' =&amp;gt; $limit, 'skip' =&amp;gt; $offset ] ); $payments = []; foreach ($cursor as $document) { $payments[] = PaymentReadModel::fromArray($document); } return $payments; } public function getPaymentStatistics(string $organizationId, \DateTime $from, \DateTime $to): array { $pipeline = [ [ '$match' =&amp;gt; [ 'organizationId' =&amp;gt; $organizationId, 'processedAt' =&amp;gt; [ '$gte' =&amp;gt; new \MongoDB\BSON\UTCDateTime($from), '$lte' =&amp;gt; new \MongoDB\BSON\UTCDateTime($to) ] ] ], [ '$group' =&amp;gt; [ '_id' =&amp;gt; '$status', 'count' =&amp;gt; ['$sum' =&amp;gt; 1], 'totalAmount' =&amp;gt; ['$sum' =&amp;gt; '$amount'] ] ] ]; $cursor = $this-&amp;gt;readModel-&amp;gt;aggregate($pipeline); $statistics = []; foreach ($cursor as $document) { $statistics[$document['_id']] = [ 'count' =&amp;gt; $document['count'], 'totalAmount' =&amp;gt; $document['totalAmount'] ]; } return $statistics; }}&lt;/code&gt;## 🧪 &lt;strong&gt;Tests et Validation&lt;/strong&gt;### &lt;strong&gt;Tests Unitaires&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Tests\Infrastructure\EventStore;use PHPUnit\Framework\TestCase;use App\Infrastructure\EventStore\MongoEventStore;use App\Domain\Payment\PaymentProcessedEvent;class MongoEventStoreTest extends TestCase{ private MongoEventStore $eventStore; private \MongoDB\Client $mongoClient; protected function setUp(): void { $this-&amp;gt;mongoClient = new \MongoDB\Client('mongodb://localhost:27017'); $this-&amp;gt;eventStore = new MongoEventStore($this-&amp;gt;mongoClient); // Nettoyer les collections de test $this-&amp;gt;mongoClient-&amp;gt;selectCollection('test', 'events')-&amp;gt;drop(); $this-&amp;gt;mongoClient-&amp;gt;selectCollection('test', 'snapshots')-&amp;gt;drop(); } public function testAppendEvents(): void { $paymentId = 'payment-123'; $event = new PaymentProcessedEvent($paymentId, 100.00, 'EUR'); $this-&amp;gt;eventStore-&amp;gt;appendEvents($paymentId, [$event], 0); $events = $this-&amp;gt;eventStore-&amp;gt;getEvents($paymentId); $this-&amp;gt;assertCount(1, $events); $this-&amp;gt;assertInstanceOf(PaymentProcessedEvent::class, $events[0]); } public function testConcurrencyControl(): void { $paymentId = 'payment-123'; $event1 = new PaymentProcessedEvent($paymentId, 100.00, 'EUR'); $event2 = new PaymentProcessedEvent($paymentId, 200.00, 'EUR'); // Premier append $this-&amp;gt;eventStore-&amp;gt;appendEvents($paymentId, [$event1], 0); // Tentative de concourrence $this-&amp;gt;expectException(ConcurrencyException::class); $this-&amp;gt;eventStore-&amp;gt;appendEvents($paymentId, [$event2], 0); }}&lt;/code&gt;### &lt;strong&gt;Tests d&amp;rsquo;Intégration&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Tests\Integration\Payment;use App\Application\Command\Payment\ProcessPaymentCommand;use App\Application\Command\Payment\ProcessPaymentCommandHandler;use App\Application\Query\Payment\PaymentQueryHandler;use App\Infrastructure\EventStore\MongoEventStore;use MongoDB\Client;class PaymentEventSourcingCqsTest extends TestCase{ public function testCompletePaymentFlow(): void { $mongoClient = new Client('mongodb://localhost:27017'); $eventStore = new MongoEventStore($mongoClient); $commandHandler = new ProcessPaymentCommandHandler($eventStore, $this-&amp;gt;createMock(PaymentRepositoryInterface::class)); $queryHandler = new PaymentQueryHandler($mongoClient); // Exécuter la commande $command = new ProcessPaymentCommand('payment-123', 100.00, 'EUR'); $commandHandler-&amp;gt;handle($command); // Vérifier la requête $payment = $queryHandler-&amp;gt;getPaymentById('payment-123'); $this-&amp;gt;assertNotNull($payment); $this-&amp;gt;assertEquals(100.00, $payment-&amp;gt;getAmount()); $this-&amp;gt;assertEquals('EUR', $payment-&amp;gt;getCurrency()); $this-&amp;gt;assertEquals('completed', $payment-&amp;gt;getStatus()); }}&lt;/code&gt;## 📊 &lt;strong&gt;Performance et Optimisation&lt;/strong&gt;### &lt;strong&gt;Stratégies d&amp;rsquo;Optimisation&lt;/strong&gt;#### &lt;strong&gt;1. Index MongoDB&lt;/strong&gt;&lt;code&gt;javascript// Index composés pour les requêtes fréquentesdb.events.createIndex({ aggregateType: 1, timestamp: -1 })db.events.createIndex({ eventType: 1, aggregateId: 1 })db.payment_read_models.createIndex({ organizationId: 1, processedAt: -1 })db.payment_read_models.createIndex({ status: 1, processedAt: -1 })&lt;/code&gt;#### &lt;strong&gt;2. Snapshots&lt;/strong&gt;&lt;code&gt;phppublic function createSnapshot(string $aggregateId, int $version): void{ $events = $this-&amp;gt;getEvents($aggregateId, 0); $aggregate = PaymentAggregate::fromEvents($events); $this-&amp;gt;snapshots-&amp;gt;replaceOne( ['aggregateId' =&amp;gt; $aggregateId], [ 'aggregateId' =&amp;gt; $aggregateId, 'aggregateType' =&amp;gt; 'Payment', 'data' =&amp;gt; $aggregate-&amp;gt;toSnapshot(), 'version' =&amp;gt; $version, 'timestamp' =&amp;gt; new \MongoDB\BSON\UTCDateTime() ], ['upsert' =&amp;gt; true] );}&lt;/code&gt;#### &lt;strong&gt;3. Projections Asynchrones&lt;/strong&gt;&lt;code&gt;phppublic function handleEventAsync(DomainEvent $event): void{ // Mettre en queue pour traitement asynchrone $this-&amp;gt;messageBus-&amp;gt;dispatch(new ProcessProjectionCommand($event));}&lt;/code&gt;## 🎯 &lt;strong&gt;Critères d&amp;rsquo;Adoption&lt;/strong&gt;### &lt;strong&gt;Quand Utiliser Event Sourcing + CQS avec MongoDB&lt;/strong&gt;#### &lt;strong&gt;✅ Avantages&lt;/strong&gt;- &lt;strong&gt;Audit trail complet&lt;/strong&gt; : Historique de tous les changements- &lt;strong&gt;Performance optimisée&lt;/strong&gt; : Séparation lecture/écriture- &lt;strong&gt;Scalabilité&lt;/strong&gt; : Possibilité de scaler indépendamment- &lt;strong&gt;Flexibilité&lt;/strong&gt; : Projections multiples pour différents besoins- &lt;strong&gt;Debugging&lt;/strong&gt; : Possibilité de rejouer les événements#### &lt;strong&gt;❌ Inconvénients&lt;/strong&gt;- &lt;strong&gt;Complexité&lt;/strong&gt; : Architecture plus complexe- &lt;strong&gt;Latence&lt;/strong&gt; : Délai entre écriture et lecture- &lt;strong&gt;Stockage&lt;/strong&gt; : Plus d&amp;rsquo;espace disque nécessaire- &lt;strong&gt;Expertise&lt;/strong&gt; : Équipe expérimentée requise#### &lt;strong&gt;🎯 Critères d&amp;rsquo;Adoption&lt;/strong&gt;- &lt;strong&gt;Audit trail critique&lt;/strong&gt; : Besoin de traçabilité complète- &lt;strong&gt;Performance importante&lt;/strong&gt; : Lectures et écritures très différentes- &lt;strong&gt;Équipe expérimentée&lt;/strong&gt; : Maîtrise des patterns avancés- &lt;strong&gt;Budget important&lt;/strong&gt; : Investissement en complexité justifié- &lt;strong&gt;Évolutivité&lt;/strong&gt; : Besoin de scaler indépendamment## 🚀 &lt;strong&gt;Votre Prochaine Étape&lt;/strong&gt;

&lt;div class="chapter-navigation"&gt;
 &lt;h2 class="chapter-nav-title"&gt;🎯 Votre Prochaine Étape&lt;/h2&gt;
 &lt;p class="chapter-nav-subtitle"&gt;Maintenant que vous comprenez les concepts de base et que j'ai partagé mon expérience avec Gyroscops, quel est votre contexte ?&lt;/p&gt;</description></item><item><title>Stockage MongoDB - Event Sourcing + CQRS</title><link>http://localhost:1313/chapitres/stockage/mongodb/chapitre-33-stockage-mongodb-event-sourcing-cqrs/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/mongodb/chapitre-33-stockage-mongodb-event-sourcing-cqrs/</guid><description>&lt;h2 id="-contexte-et-objectifs-lnous-arrivons-maintenant-à-lapproche-la-plus-sophistiquée--event-sourcing--cqrs-avec-mongodb-cette-combinaison-offre-une-architecture-hautement-scalable-et-flexible-parfaite-pour-les-systèmes-complexes-pourquoi-cette-approche---séparation-totale--commandes-et-requêtes-complètement-découplées--scalabilité-maximale--possibilité-de-scaler-indépendamment-chaque-côté--flexibilité--projections-multiples-pour-différents-besoins--audit-trail-complet--historique-de-tous-les-changements--performance-optimale--chaque-côté-optimisé-pour-son-usage-contexte-gyroscopsdans-notre-écosystème-user--organization--workflow--cloud-resources--billing-cette-approche-est-idéale-pour---système-de-facturation--audit-trail-complet-et-projections-multiples--workflows-complexes--événements-de-progression-et-états--ressources-cloud--historique-des-changements-et-métriques--analytics--projections-spécialisées-pour-les-rapports--architecture-event-sourcing--cqrs-séparation-complète-des-responsabilités-command-side-write--event-store--stockage-des-événements-dans-mongodb--command-handlers--traitement-des-commandes-métier--aggregates--logique-métier-et-invariants--event-handlers--gestion-des-événements-générés--command-bus--orchestration-des-commandes-query-side-read--projections--vues-optimisées-pour-la-lecture--query-handlers--traitement-des-requêtes--read-models--modèles-optimisés-pour-laffichage--query-bus--orchestration-des-requêtes--caches--optimisation-des-performances-flux-de-données-completmermaidgraph-td----acommand----bcommand-bus----b----ccommand-handler----c----daggregate----d----eevents----e----fevent-store-mongodb----e----gevent-bus----g----hevent-handlers----h----iprojections----i----jread-models----j----kquery-bus----k----lquery-handler----l----mresponse--------nquery----k----ocache----l--implémentation-complète-1-event-store-avancé-structure-des-collections-optimiséejavascript-collection-events--_id-objectid--aggregateid-payment-123--aggregatetype-payment--eventtype-paymentprocessed--eventdata-----amount-10000----currency-eur----status-completed----metadata-------userid-user-456------organizationid-org-789--------version-1--timestamp-isodate2024-12-19t100000z--correlationid-corr-789--causationid-cmd-456-collection-snapshots--_id-objectid--aggregateid-payment-123--aggregatetype-payment--data-----amount-10000----currency-eur----status-completed----processedat-isodate2024-12-19t100000z----version-1--timestamp-isodate2024-12-19t100000z-collection-projections_metadata--_id-objectid--projectionname-paymentreadmodel--lastprocessedeventid-objectid--lastprocessedtimestamp-isodate2024-12-19t100000z--version-1-index-mongodb-optimisésjavascript-index-pour-les-événementsdbeventscreateindex-aggregateid-1-version-1-dbeventscreateindex-aggregatetype-1-timestamp-1-dbeventscreateindex-eventtype-1-timestamp-1-dbeventscreateindex-correlationid-1-dbeventscreateindex-timestamp-1---expireafterseconds-31536000---1-an-index-pour-les-snapshotsdbsnapshotscreateindex-aggregateid-1-dbsnapshotscreateindex-aggregatetype-1-timestamp-1--index-pour-les-projectionsdbpayment_read_modelscreateindex-organizationid-1-processedat--1-dbpayment_read_modelscreateindex-status-1-processedat--1-dbpayment_read_modelscreateindex-amount-1-processedat--1--2-command-side-implementation-event-store-avec-gestion-des-métadonnéesphpphpnamespace-appinfrastructureeventstoreuse-mongodbclientuse-mongodbcollectionuse-appdomaineventdomaineventuse-appdomaineventeventstoreinterfaceclass-mongoeventstore-implements-eventstoreinterface----private-collection-events----private-collection-snapshots----private-collection-projectionsmetadata----public-function-__constructclient-mongoclient------------this-events--mongoclient-selectcollectiongyroscops-cloud-events--------this-snapshots--mongoclient-selectcollectiongyroscops-cloud-snapshots--------this-projectionsmetadata--mongoclient-selectcollectiongyroscops-cloud-projections_metadata--------public-function-appendeventsstring-aggregateid-array-events-int-expectedversion-string-correlationid--null-void------------session--this-events-getdatabase-getclient-startsession----------------try-------------session-starttransaction-------------------------vérifier-la-version-attendue------------lastevent--this-events-findone----------------aggregateid--aggregateid----------------sort--version---1------------------------------------if-lastevent--lasteventversion--expectedversion-----------------throw-new-concurrencyexceptionversion-mismatch-------------------------------------insérer-les-nouveaux-événements------------documents--------------version--expectedversion--1------------causationid--correlationid------------------------foreach-events-as-event-----------------documents----------------------aggregateid--aggregateid--------------------aggregatetype--event-getaggregatetype--------------------eventtype--event-geteventtype--------------------eventdata--event-toarray--------------------version--version--------------------timestamp--new-mongodbbsonutcdatetime--------------------correlationid--correlationid--------------------causationid--causationid--------------------metadata--event-getmetadata----------------------------------------------------this-events-insertmanydocuments------------session-committransaction---------------------catch-exception-e-------------session-aborttransaction------------throw-e----------------public-function-geteventsstring-aggregateid-int-fromversion--0-array------------cursor--this-events-find----------------------------aggregateid--aggregateid----------------version--gte--fromversion------------------------sort--version--1------------------------events----------foreach-cursor-as-document-------------events--this-deserializeeventdocument------------------------return-events--------public-function-geteventsbycorrelationidstring-correlationid-array------------cursor--this-events-find------------correlationid--correlationid------------sort--timestamp--1------------------------events----------foreach-cursor-as-document-------------events--this-deserializeeventdocument------------------------return-events--------private-function-deserializeeventarray-document-domainevent------------eventclass--documenteventtype--------return-eventclassfromarraydocumenteventdata-----command-bus-avec-middlewarephpphpnamespace-appapplicationcommandbususe-appdomaincommandcommandinterfaceuse-appdomaincommandcommandhandlerinterfaceuse-psrlogloggerinterfaceclass-commandbus----private-array-handlers------private-array-middleware------private-loggerinterface-logger----public-function-__constructloggerinterface-logger------------this-logger--logger--------public-function-registerhandlerstring-commandclass-commandhandlerinterface-handler-void------------this-handlerscommandclass--handler--------public-function-addmiddlewarecallable-middleware-void------------this-middleware--middleware--------public-function-handlecommandinterface-command-void------------commandclass--get_classcommand----------------if-issetthis-handlerscommandclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-command-commandclass----------------handler--this-handlerscommandclass-----------------exécuter-les-middleware--------this-executemiddlewarecommand-function-use-handler-command-------------this-logger-infoexecuting-command-----------------command--get_classcommand----------------data--command-toarray------------------------------------handler-handlecommand----------------private-function-executemiddlewarecommandinterface-command-callable-next-void------------middleware--array_reversethis-middleware----------------foreach-middleware-as-mw-------------next--function-use-mw-command-next-----------------return-mwcommand-next------------------------------------next-----command-handler-avancéphpphpnamespace-appapplicationcommandpaymentuse-appdomainpaymentpaymentaggregateuse-appdomaineventeventstoreinterfaceuse-appdomaineventeventbusinterfaceuse-appdomainpaymentpaymentrepositoryinterfaceuse-psrlogloggerinterfaceclass-processpaymentcommandhandler-implements-commandhandlerinterface----public-function-__construct--------private-eventstoreinterface-eventstore--------private-eventbusinterface-eventbus--------private-paymentrepositoryinterface-paymentrepository--------private-loggerinterface-logger---------public-function-handleprocesspaymentcommand-command-void------------try--------------charger-lagrégat------------events--this-eventstore-geteventscommand-getpaymentid------------payment--paymentaggregatefromeventsevents-------------------------exécuter-la-commande------------payment-processpaymentcommand-getamount-command-getcurrency-------------------------sauvegarder-les-événements------------this-eventstore-appendevents----------------command-getpaymentid----------------payment-getuncommittedevents----------------payment-getversion----------------command-getcorrelationid-------------------------------------publier-les-événements------------foreach-payment-getuncommittedevents-as-event-----------------this-eventbus-publishevent-------------------------------------nettoyer-les-événements-non-commités------------payment-markeventsascommitted------------------------this-logger-infopayment-processed-successfully-----------------paymentid--command-getpaymentid----------------amount--command-getamount----------------currency--command-getcurrency---------------------------------catch-exception-e-------------this-logger-errorpayment-processing-failed-----------------paymentid--command-getpaymentid----------------error--e-getmessage----------------trace--e-gettraceasstring------------------------------------throw-e-------------3-query-side-implementation-query-bus-avec-cachephpphpnamespace-appapplicationquerybususe-appdomainqueryqueryinterfaceuse-appdomainqueryqueryhandlerinterfaceuse-psrcachecacheitempoolinterfaceuse-psrlogloggerinterfaceclass-querybus----private-array-handlers------private-cacheitempoolinterface-cache----private-loggerinterface-logger----public-function-__constructcacheitempoolinterface-cache-loggerinterface-logger------------this-cache--cache--------this-logger--logger--------public-function-registerhandlerstring-queryclass-queryhandlerinterface-handler-void------------this-handlersqueryclass--handler--------public-function-handlequeryinterface-query-mixed------------queryclass--get_classquery----------------if-issetthis-handlersqueryclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-query-queryclass-----------------vérifier-le-cache--------cachekey--this-generatecachekeyquery--------cacheditem--this-cache-getitemcachekey----------------if-cacheditem-ishit-------------this-logger-debugquery-result-served-from-cache-----------------query--queryclass----------------cachekey--cachekey------------------------------------return-cacheditem-get-----------------exécuter-la-requête--------handler--this-handlersqueryclass--------result--handler-handlequery-----------------mettre-en-cache--------cacheditem-setresult--------cacheditem-expiresafter300--5-minutes--------this-cache-savecacheditem----------------this-logger-infoquery-executed-and-cached-------------query--queryclass------------cachekey--cachekey------------------------return-result--------private-function-generatecachekeyqueryinterface-query-string------------return-query_--md5serializequery-----projection-handler-avec-gestion-des-métadonnéesphpphpnamespace-appapplicationprojectionpaymentuse-appdomaineventdomaineventuse-appinfrastructurereadmodelpaymentreadmodeluse-mongodbclientuse-psrlogloggerinterfaceclass-paymentprojectionhandler----private-mongodbcollection-readmodel----private-mongodbcollection-projectionsmetadata----private-loggerinterface-logger----public-function-__constructclient-mongoclient-loggerinterface-logger------------this-readmodel--mongoclient-selectcollectiongyroscops-cloud-payment_read_models--------this-projectionsmetadata--mongoclient-selectcollectiongyroscops-cloud-projections_metadata--------this-logger--logger--------public-function-handledomainevent-event-void------------try-------------switch-event-geteventtype-----------------case-paymentprocessed--------------------this-handlepaymentprocessedevent--------------------break----------------case-paymentfailed--------------------this-handlepaymentfailedevent--------------------break----------------case-paymentrefunded--------------------this-handlepaymentrefundedevent--------------------break-------------------------------------mettre-à-jour-les-métadonnées-de-projection------------this-updateprojectionmetadataevent---------------------catch-exception-e-------------this-logger-errorprojection-handling-failed-----------------event--event-geteventtype----------------aggregateid--event-getaggregateid----------------error--e-getmessage------------------------------------throw-e----------------private-function-handlepaymentprocesseddomainevent-event-void------------this-readmodel-updateone------------paymentid--event-getaggregateid----------------------------set----------------------paymentid--event-getaggregateid--------------------amount--event-getdataamount--------------------currency--event-getdatacurrency--------------------status--completed--------------------processedat--event-gettimestamp--------------------organizationid--event-getmetadataorganizationid--------------------userid--event-getmetadatauserid--------------------updatedat--new-mongodbbsonutcdatetime----------------------------------------upsert--true----------------private-function-handlepaymentfaileddomainevent-event-void------------this-readmodel-updateone------------paymentid--event-getaggregateid----------------------------set----------------------status--failed--------------------error--event-getdataerror--------------------failedat--event-gettimestamp--------------------updatedat--new-mongodbbsonutcdatetime----------------------------------------upsert--true----------------private-function-handlepaymentrefundeddomainevent-event-void------------this-readmodel-updateone------------paymentid--event-getaggregateid----------------------------set----------------------status--refunded--------------------refundamount--event-getdatarefundamount--------------------refundedat--event-gettimestamp--------------------updatedat--new-mongodbbsonutcdatetime----------------------------------------upsert--true----------------private-function-updateprojectionmetadatadomainevent-event-void------------this-projectionsmetadata-updateone------------projectionname--paymentreadmodel----------------------------set----------------------projectionname--paymentreadmodel--------------------lastprocessedeventid--event-getid--------------------lastprocessedtimestamp--event-gettimestamp--------------------version--event-getversion--------------------updatedat--new-mongodbbsonutcdatetime----------------------------------------upsert--true-------------query-handler-avancé-avec-analyticsphpphpnamespace-appapplicationquerypaymentuse-appinfrastructurereadmodelpaymentreadmodeluse-mongodbclientuse-psrlogloggerinterfaceclass-paymentqueryhandler-implements-queryhandlerinterface----private-mongodbcollection-readmodel----private-loggerinterface-logger----public-function-__constructclient-mongoclient-loggerinterface-logger------------this-readmodel--mongoclient-selectcollectiongyroscops-cloud-payment_read_models--------this-logger--logger--------public-function-handlegetpaymentbyidquery-query-paymentreadmodel------------document--this-readmodel-findonepaymentid--query-getpaymentid----------------if-document-------------return-null------------------------return-paymentreadmodelfromarraydocument--------public-function-handlegetpaymentsbyorganizationquery-query-array------------cursor--this-readmodel-find------------organizationid--query-getorganizationid----------------------------sort--processedat---1----------------limit--query-getlimit----------------skip--query-getoffset------------------------------------payments----------foreach-cursor-as-document-------------payments--paymentreadmodelfromarraydocument------------------------return-payments--------public-function-handlegetpaymentstatisticsquery-query-array------------pipeline------------------------------match----------------------organizationid--query-getorganizationid--------------------processedat--------------------------gte--new-mongodbbsonutcdatetimequery-getfrom------------------------lte--new-mongodbbsonutcdatetimequery-getto----------------------------------------------------------------------------group----------------------_id--------------------------status--status------------------------currency--currency----------------------------------------count--sum--1--------------------totalamount--sum--amount--------------------averageamount--avg--amount--------------------------------------------------------sort--_idstatus--1-_idcurrency--1------------------------------------cursor--this-readmodel-aggregatepipeline----------------statistics----------foreach-cursor-as-document-------------status--document_idstatus------------currency--document_idcurrency------------------------if-issetstatisticsstatus-----------------statisticsstatus--------------------------------------statisticsstatuscurrency------------------count--documentcount----------------totalamount--documenttotalamount----------------averageamount--documentaverageamount------------------------------------return-statistics--------public-function-handlegetpaymenttrendsquery-query-array------------pipeline------------------------------match----------------------organizationid--query-getorganizationid--------------------processedat--------------------------gte--new-mongodbbsonutcdatetimequery-getfrom------------------------lte--new-mongodbbsonutcdatetimequery-getto----------------------------------------------------------------------------group----------------------_id--------------------------year--year--processedat------------------------month--month--processedat------------------------day--dayofmonth--processedat----------------------------------------count--sum--1--------------------totalamount--sum--amount--------------------------------------------------------sort--_idyear--1-_idmonth--1-_idday--1------------------------------------cursor--this-readmodel-aggregatepipeline----------------trends----------foreach-cursor-as-document-------------date--sprintf04d-02d-02d-----------------document_idyear----------------document_idmonth----------------document_idday------------------------------------trendsdate------------------count--documentcount----------------totalamount--documenttotalamount------------------------------------return-trends------tests-et-validation-tests-dphpphpnamespace-apptestsintegrationpaymentuse-appapplicationcommandpaymentprocesspaymentcommanduse-appapplicationcommandpaymentprocesspaymentcommandhandleruse-appapplicationquerypaymentgetpaymentbyidqueryuse-appapplicationquerypaymentgetpaymentstatisticsqueryuse-appapplicationquerypaymentpaymentqueryhandleruse-appinfrastructureeventstoremongoeventstoreuse-appinfrastructureeventbuseventbususe-mongodbclientclass-paymenteventsourcingcqrstest-extends-testcase----public-function-testcompleteeventsourcingcqrsflow-void------------mongoclient--new-clientmongodblocalhost27017--------eventstore--new-mongoeventstoremongoclient--------eventbus--new-eventbus----------------commandhandler--new-processpaymentcommandhandler------------eventstore-------------eventbus-------------this-createmockpaymentrepositoryinterfaceclass------------this-createmockloggerinterfaceclass------------------------queryhandler--new-paymentqueryhandlermongoclient-this-createmockloggerinterfaceclass-----------------exécuter-la-commande--------command--new-processpaymentcommandpayment-123-10000-eur-org-456--------commandhandler-handlecommand-----------------vérifier-la-requête--------query--new-getpaymentbyidquerypayment-123--------payment--queryhandler-handlequery----------------this-assertnotnullpayment--------this-assertequals10000-payment-getamount--------this-assertequalseur-payment-getcurrency--------this-assertequalscompleted-payment-getstatus--------public-function-testpaymentstatistics-void------------mongoclient--new-clientmongodblocalhost27017--------queryhandler--new-paymentqueryhandlermongoclient-this-createmockloggerinterfaceclass----------------query--new-getpaymentstatisticsquery------------org-456------------new-datetime2024-01-01------------new-datetime2024-12-31------------------------statistics--queryhandler-handlequery----------------this-assertisarraystatistics--------this-assertarrayhaskeycompleted-statistics--------this-assertarrayhaskeyeur-statisticscompleted------performance-et-optimisation-stratégies-d-1-index-mongodb-optimisésjavascript-index-composés-pour-les-requêtes-complexesdbeventscreateindex-aggregatetype-1-timestamp--1-eventtype-1-dbeventscreateindex-correlationid-1-timestamp-1-dbpayment_read_modelscreateindex-organizationid-1-status-1-processedat--1-dbpayment_read_modelscreateindex-amount-1-processedat--1-dbpayment_read_modelscreateindex-currency-1-status-1--index-partiels-pour-les-requêtes-fréquentesdbpayment_read_modelscreateindex-----organizationid-1-processedat--1------partialfilterexpression--status-completed---2-projections-asynchronesphppublic-function-handleeventasyncdomainevent-event-void-----mettre-en-queue-pour-traitement-asynchrone----this-messagebus-dispatchnew-processprojectioncommandevent-3-cache-multi-niveauxphppublic-function-handlegetpaymentbyidquery-query-paymentreadmodel-----cache-l1-mémoire----if-issetthis-memorycachequery-getpaymentid---------return-this-memorycachequery-getpaymentid-------------cache-l2-redis----cached--this-redis-getpaymentquery-getpaymentid----if-cached---------payment--paymentreadmodelfromarrayjson_decodecached-true--------this-memorycachequery-getpaymentid--payment--------return-payment-------------base-de-données----payment--this-getfromdatabasequery-getpaymentid----if-payment---------this-memorycachequery-getpaymentid--payment--------this-redis-setexpaymentquery-getpaymentid-300-json_encodepayment-toarray------------return-payment--critères-d-quand-utiliser-event-sourcing--cqrs-avec-mongodb--avantages--scalabilité-maximale--possibilité-de-scaler-indépendamment--performance-optimale--chaque-côté-optimisé-pour-son-usage--flexibilité--projections-multiples-pour-différents-besoins--audit-trail-complet--historique-de-tous-les-changements--debugging-avancé--possibilité-de-rejouer-les-événements--analytics--projections-spécialisées-pour-les-rapports--inconvénients--complexité-maximale--architecture-très-complexe--latence--délai-entre-écriture-et-lecture--stockage--beaucoup-despace-disque-nécessaire--expertise--équipe-très-expérimentée-requise--coût--investissement-important-en-complexité--critères-d--système-très-complexe--besoins-de-scalabilité-maximale--équipe-très-expérimentée--maîtrise-des-patterns-avancés--budget-important--investissement-en-complexité-justifié--performance-critique--besoins-de-performance-maximale--analytics-avancées--besoins-de-rapports-complexes--audit-trail-complet--traçabilité-absolue-requise--votre-prochaine-étapehahahugoshortcode56s0hbhbcette-approche-event-sourcing--cqrs-avec-mongodb-représente-l"&gt;🎯 &lt;strong&gt;Contexte et Objectifs&lt;/strong&gt;### &lt;strong&gt;L&amp;rsquo;Approche la Plus Avancée&lt;/strong&gt;Nous arrivons maintenant à l&amp;rsquo;approche la plus sophistiquée : &lt;strong&gt;Event Sourcing + CQRS avec MongoDB&lt;/strong&gt;. Cette combinaison offre une architecture hautement scalable et flexible, parfaite pour les systèmes complexes.#### &lt;strong&gt;Pourquoi cette Approche ?&lt;/strong&gt;- &lt;strong&gt;Séparation totale&lt;/strong&gt; : Commandes et requêtes complètement découplées- &lt;strong&gt;Scalabilité maximale&lt;/strong&gt; : Possibilité de scaler indépendamment chaque côté- &lt;strong&gt;Flexibilité&lt;/strong&gt; : Projections multiples pour différents besoins- &lt;strong&gt;Audit trail complet&lt;/strong&gt; : Historique de tous les changements- &lt;strong&gt;Performance optimale&lt;/strong&gt; : Chaque côté optimisé pour son usage### &lt;strong&gt;Contexte Gyroscops&lt;/strong&gt;Dans notre écosystème &lt;strong&gt;User → Organization → Workflow → Cloud Resources → Billing&lt;/strong&gt;, cette approche est idéale pour :- &lt;strong&gt;Système de facturation&lt;/strong&gt; : Audit trail complet et projections multiples- &lt;strong&gt;Workflows complexes&lt;/strong&gt; : Événements de progression et états- &lt;strong&gt;Ressources cloud&lt;/strong&gt; : Historique des changements et métriques- &lt;strong&gt;Analytics&lt;/strong&gt; : Projections spécialisées pour les rapports## 🏗️ &lt;strong&gt;Architecture Event Sourcing + CQRS&lt;/strong&gt;### &lt;strong&gt;Séparation Complète des Responsabilités&lt;/strong&gt;#### &lt;strong&gt;Command Side (Write)&lt;/strong&gt;- &lt;strong&gt;Event Store&lt;/strong&gt; : Stockage des événements dans MongoDB- &lt;strong&gt;Command Handlers&lt;/strong&gt; : Traitement des commandes métier- &lt;strong&gt;Aggregates&lt;/strong&gt; : Logique métier et invariants- &lt;strong&gt;Event Handlers&lt;/strong&gt; : Gestion des événements générés- &lt;strong&gt;Command Bus&lt;/strong&gt; : Orchestration des commandes#### &lt;strong&gt;Query Side (Read)&lt;/strong&gt;- &lt;strong&gt;Projections&lt;/strong&gt; : Vues optimisées pour la lecture- &lt;strong&gt;Query Handlers&lt;/strong&gt; : Traitement des requêtes- &lt;strong&gt;Read Models&lt;/strong&gt; : Modèles optimisés pour l&amp;rsquo;affichage- &lt;strong&gt;Query Bus&lt;/strong&gt; : Orchestration des requêtes- &lt;strong&gt;Caches&lt;/strong&gt; : Optimisation des performances### &lt;strong&gt;Flux de Données Complet&lt;/strong&gt;&lt;code&gt;mermaidgraph TD A[Command] --&amp;gt; B[Command Bus] B --&amp;gt; C[Command Handler] C --&amp;gt; D[Aggregate] D --&amp;gt; E[Events] E --&amp;gt; F[Event Store MongoDB] E --&amp;gt; G[Event Bus] G --&amp;gt; H[Event Handlers] H --&amp;gt; I[Projections] I --&amp;gt; J[Read Models] J --&amp;gt; K[Query Bus] K --&amp;gt; L[Query Handler] L --&amp;gt; M[Response] N[Query] --&amp;gt; K O[Cache] --&amp;gt; L&lt;/code&gt;## 💻 &lt;strong&gt;Implémentation Complète&lt;/strong&gt;### &lt;strong&gt;1. Event Store Avancé&lt;/strong&gt;#### &lt;strong&gt;Structure des Collections Optimisée&lt;/strong&gt;&lt;code&gt;javascript// Collection: events{ _id: ObjectId(&amp;quot;...&amp;quot;), aggregateId: &amp;quot;payment-123&amp;quot;, aggregateType: &amp;quot;Payment&amp;quot;, eventType: &amp;quot;PaymentProcessed&amp;quot;, eventData: { amount: 100.00, currency: &amp;quot;EUR&amp;quot;, status: &amp;quot;completed&amp;quot;, metadata: { userId: &amp;quot;user-456&amp;quot;, organizationId: &amp;quot;org-789&amp;quot; } }, version: 1, timestamp: ISODate(&amp;quot;2024-12-19T10:00:00Z&amp;quot;), correlationId: &amp;quot;corr-789&amp;quot;, causationId: &amp;quot;cmd-456&amp;quot;}// Collection: snapshots{ _id: ObjectId(&amp;quot;...&amp;quot;), aggregateId: &amp;quot;payment-123&amp;quot;, aggregateType: &amp;quot;Payment&amp;quot;, data: { amount: 100.00, currency: &amp;quot;EUR&amp;quot;, status: &amp;quot;completed&amp;quot;, processedAt: ISODate(&amp;quot;2024-12-19T10:00:00Z&amp;quot;) }, version: 1, timestamp: ISODate(&amp;quot;2024-12-19T10:00:00Z&amp;quot;)}// Collection: projections_metadata{ _id: ObjectId(&amp;quot;...&amp;quot;), projectionName: &amp;quot;PaymentReadModel&amp;quot;, lastProcessedEventId: ObjectId(&amp;quot;...&amp;quot;), lastProcessedTimestamp: ISODate(&amp;quot;2024-12-19T10:00:00Z&amp;quot;), version: 1}&lt;/code&gt;#### &lt;strong&gt;Index MongoDB Optimisés&lt;/strong&gt;&lt;code&gt;javascript// Index pour les événementsdb.events.createIndex({ aggregateId: 1, version: 1 })db.events.createIndex({ aggregateType: 1, timestamp: 1 })db.events.createIndex({ eventType: 1, timestamp: 1 })db.events.createIndex({ correlationId: 1 })db.events.createIndex({ timestamp: 1 }, { expireAfterSeconds: 31536000 }) // 1 an// Index pour les snapshotsdb.snapshots.createIndex({ aggregateId: 1 })db.snapshots.createIndex({ aggregateType: 1, timestamp: 1 })// Index pour les projectionsdb.payment_read_models.createIndex({ organizationId: 1, processedAt: -1 })db.payment_read_models.createIndex({ status: 1, processedAt: -1 })db.payment_read_models.createIndex({ amount: 1, processedAt: -1 })&lt;/code&gt;### &lt;strong&gt;2. Command Side Implementation&lt;/strong&gt;#### &lt;strong&gt;Event Store avec Gestion des Métadonnées&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Infrastructure\EventStore;use MongoDB\Client;use MongoDB\Collection;use App\Domain\Event\DomainEvent;use App\Domain\Event\EventStoreInterface;class MongoEventStore implements EventStoreInterface{ private Collection $events; private Collection $snapshots; private Collection $projectionsMetadata; public function __construct(Client $mongoClient) { $this-&amp;gt;events = $mongoClient-&amp;gt;selectCollection('Gyroscops Cloud', 'events'); $this-&amp;gt;snapshots = $mongoClient-&amp;gt;selectCollection('Gyroscops Cloud', 'snapshots'); $this-&amp;gt;projectionsMetadata = $mongoClient-&amp;gt;selectCollection('Gyroscops Cloud', 'projections_metadata'); } public function appendEvents(string $aggregateId, array $events, int $expectedVersion, string $correlationId = null): void { $session = $this-&amp;gt;events-&amp;gt;getDatabase()-&amp;gt;getClient()-&amp;gt;startSession(); try { $session-&amp;gt;startTransaction(); // Vérifier la version attendue $lastEvent = $this-&amp;gt;events-&amp;gt;findOne( ['aggregateId' =&amp;gt; $aggregateId], ['sort' =&amp;gt; ['version' =&amp;gt; -1]] ); if ($lastEvent &amp;amp;&amp;amp; $lastEvent['version'] !== $expectedVersion) { throw new ConcurrencyException('Version mismatch'); } // Insérer les nouveaux événements $documents = []; $version = $expectedVersion + 1; $causationId = $correlationId; foreach ($events as $event) { $documents[] = [ 'aggregateId' =&amp;gt; $aggregateId, 'aggregateType' =&amp;gt; $event-&amp;gt;getAggregateType(), 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'eventData' =&amp;gt; $event-&amp;gt;toArray(), 'version' =&amp;gt; $version++, 'timestamp' =&amp;gt; new \MongoDB\BSON\UTCDateTime(), 'correlationId' =&amp;gt; $correlationId, 'causationId' =&amp;gt; $causationId, 'metadata' =&amp;gt; $event-&amp;gt;getMetadata() ]; } $this-&amp;gt;events-&amp;gt;insertMany($documents); $session-&amp;gt;commitTransaction(); } catch (\Exception $e) { $session-&amp;gt;abortTransaction(); throw $e; } } public function getEvents(string $aggregateId, int $fromVersion = 0): array { $cursor = $this-&amp;gt;events-&amp;gt;find( [ 'aggregateId' =&amp;gt; $aggregateId, 'version' =&amp;gt; ['$gte' =&amp;gt; $fromVersion] ], ['sort' =&amp;gt; ['version' =&amp;gt; 1]] ); $events = []; foreach ($cursor as $document) { $events[] = $this-&amp;gt;deserializeEvent($document); } return $events; } public function getEventsByCorrelationId(string $correlationId): array { $cursor = $this-&amp;gt;events-&amp;gt;find( ['correlationId' =&amp;gt; $correlationId], ['sort' =&amp;gt; ['timestamp' =&amp;gt; 1]] ); $events = []; foreach ($cursor as $document) { $events[] = $this-&amp;gt;deserializeEvent($document); } return $events; } private function deserializeEvent(array $document): DomainEvent { $eventClass = $document['eventType']; return $eventClass::fromArray($document['eventData']); }}&lt;/code&gt;#### &lt;strong&gt;Command Bus avec Middleware&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\CommandBus;use App\Domain\Command\CommandInterface;use App\Domain\Command\CommandHandlerInterface;use Psr\Log\LoggerInterface;class CommandBus{ private array $handlers = []; private array $middleware = []; private LoggerInterface $logger; public function __construct(LoggerInterface $logger) { $this-&amp;gt;logger = $logger; } public function registerHandler(string $commandClass, CommandHandlerInterface $handler): void { $this-&amp;gt;handlers[$commandClass] = $handler; } public function addMiddleware(callable $middleware): void { $this-&amp;gt;middleware[] = $middleware; } public function handle(CommandInterface $command): void { $commandClass = get_class($command); if (!isset($this-&amp;gt;handlers[$commandClass])) { throw new \InvalidArgumentException(&amp;quot;No handler registered for command: $commandClass&amp;quot;); } $handler = $this-&amp;gt;handlers[$commandClass]; // Exécuter les middleware $this-&amp;gt;executeMiddleware($command, function() use ($handler, $command) { $this-&amp;gt;logger-&amp;gt;info('Executing command', [ 'command' =&amp;gt; get_class($command), 'data' =&amp;gt; $command-&amp;gt;toArray() ]); $handler-&amp;gt;handle($command); }); } private function executeMiddleware(CommandInterface $command, callable $next): void { $middleware = array_reverse($this-&amp;gt;middleware); foreach ($middleware as $mw) { $next = function() use ($mw, $command, $next) { return $mw($command, $next); }; } $next(); }}&lt;/code&gt;#### &lt;strong&gt;Command Handler Avancé&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Command\Payment;use App\Domain\Payment\PaymentAggregate;use App\Domain\Event\EventStoreInterface;use App\Domain\Event\EventBusInterface;use App\Domain\Payment\PaymentRepositoryInterface;use Psr\Log\LoggerInterface;class ProcessPaymentCommandHandler implements CommandHandlerInterface{ public function __construct( private EventStoreInterface $eventStore, private EventBusInterface $eventBus, private PaymentRepositoryInterface $paymentRepository, private LoggerInterface $logger ) {} public function handle(ProcessPaymentCommand $command): void { try { // Charger l'agrégat $events = $this-&amp;gt;eventStore-&amp;gt;getEvents($command-&amp;gt;getPaymentId()); $payment = PaymentAggregate::fromEvents($events); // Exécuter la commande $payment-&amp;gt;processPayment($command-&amp;gt;getAmount(), $command-&amp;gt;getCurrency()); // Sauvegarder les événements $this-&amp;gt;eventStore-&amp;gt;appendEvents( $command-&amp;gt;getPaymentId(), $payment-&amp;gt;getUncommittedEvents(), $payment-&amp;gt;getVersion(), $command-&amp;gt;getCorrelationId() ); // Publier les événements foreach ($payment-&amp;gt;getUncommittedEvents() as $event) { $this-&amp;gt;eventBus-&amp;gt;publish($event); } // Nettoyer les événements non commités $payment-&amp;gt;markEventsAsCommitted(); $this-&amp;gt;logger-&amp;gt;info('Payment processed successfully', [ 'paymentId' =&amp;gt; $command-&amp;gt;getPaymentId(), 'amount' =&amp;gt; $command-&amp;gt;getAmount(), 'currency' =&amp;gt; $command-&amp;gt;getCurrency() ]); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Payment processing failed', [ 'paymentId' =&amp;gt; $command-&amp;gt;getPaymentId(), 'error' =&amp;gt; $e-&amp;gt;getMessage(), 'trace' =&amp;gt; $e-&amp;gt;getTraceAsString() ]); throw $e; } }}&lt;/code&gt;### &lt;strong&gt;3. Query Side Implementation&lt;/strong&gt;#### &lt;strong&gt;Query Bus avec Cache&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\QueryBus;use App\Domain\Query\QueryInterface;use App\Domain\Query\QueryHandlerInterface;use Psr\Cache\CacheItemPoolInterface;use Psr\Log\LoggerInterface;class QueryBus{ private array $handlers = []; private CacheItemPoolInterface $cache; private LoggerInterface $logger; public function __construct(CacheItemPoolInterface $cache, LoggerInterface $logger) { $this-&amp;gt;cache = $cache; $this-&amp;gt;logger = $logger; } public function registerHandler(string $queryClass, QueryHandlerInterface $handler): void { $this-&amp;gt;handlers[$queryClass] = $handler; } public function handle(QueryInterface $query): mixed { $queryClass = get_class($query); if (!isset($this-&amp;gt;handlers[$queryClass])) { throw new \InvalidArgumentException(&amp;quot;No handler registered for query: $queryClass&amp;quot;); } // Vérifier le cache $cacheKey = $this-&amp;gt;generateCacheKey($query); $cachedItem = $this-&amp;gt;cache-&amp;gt;getItem($cacheKey); if ($cachedItem-&amp;gt;isHit()) { $this-&amp;gt;logger-&amp;gt;debug('Query result served from cache', [ 'query' =&amp;gt; $queryClass, 'cacheKey' =&amp;gt; $cacheKey ]); return $cachedItem-&amp;gt;get(); } // Exécuter la requête $handler = $this-&amp;gt;handlers[$queryClass]; $result = $handler-&amp;gt;handle($query); // Mettre en cache $cachedItem-&amp;gt;set($result); $cachedItem-&amp;gt;expiresAfter(300); // 5 minutes $this-&amp;gt;cache-&amp;gt;save($cachedItem); $this-&amp;gt;logger-&amp;gt;info('Query executed and cached', [ 'query' =&amp;gt; $queryClass, 'cacheKey' =&amp;gt; $cacheKey ]); return $result; } private function generateCacheKey(QueryInterface $query): string { return 'query_' . md5(serialize($query)); }}&lt;/code&gt;#### &lt;strong&gt;Projection Handler avec Gestion des Métadonnées&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Projection\Payment;use App\Domain\Event\DomainEvent;use App\Infrastructure\ReadModel\PaymentReadModel;use MongoDB\Client;use Psr\Log\LoggerInterface;class PaymentProjectionHandler{ private \MongoDB\Collection $readModel; private \MongoDB\Collection $projectionsMetadata; private LoggerInterface $logger; public function __construct(Client $mongoClient, LoggerInterface $logger) { $this-&amp;gt;readModel = $mongoClient-&amp;gt;selectCollection('Gyroscops Cloud', 'payment_read_models'); $this-&amp;gt;projectionsMetadata = $mongoClient-&amp;gt;selectCollection('Gyroscops Cloud', 'projections_metadata'); $this-&amp;gt;logger = $logger; } public function handle(DomainEvent $event): void { try { switch ($event-&amp;gt;getEventType()) { case 'PaymentProcessed': $this-&amp;gt;handlePaymentProcessed($event); break; case 'PaymentFailed': $this-&amp;gt;handlePaymentFailed($event); break; case 'PaymentRefunded': $this-&amp;gt;handlePaymentRefunded($event); break; } // Mettre à jour les métadonnées de projection $this-&amp;gt;updateProjectionMetadata($event); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Projection handling failed', [ 'event' =&amp;gt; $event-&amp;gt;getEventType(), 'aggregateId' =&amp;gt; $event-&amp;gt;getAggregateId(), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } private function handlePaymentProcessed(DomainEvent $event): void { $this-&amp;gt;readModel-&amp;gt;updateOne( ['paymentId' =&amp;gt; $event-&amp;gt;getAggregateId()], [ '$set' =&amp;gt; [ 'paymentId' =&amp;gt; $event-&amp;gt;getAggregateId(), 'amount' =&amp;gt; $event-&amp;gt;getData()['amount'], 'currency' =&amp;gt; $event-&amp;gt;getData()['currency'], 'status' =&amp;gt; 'completed', 'processedAt' =&amp;gt; $event-&amp;gt;getTimestamp(), 'organizationId' =&amp;gt; $event-&amp;gt;getMetadata()['organizationId'], 'userId' =&amp;gt; $event-&amp;gt;getMetadata()['userId'], 'updatedAt' =&amp;gt; new \MongoDB\BSON\UTCDateTime() ] ], ['upsert' =&amp;gt; true] ); } private function handlePaymentFailed(DomainEvent $event): void { $this-&amp;gt;readModel-&amp;gt;updateOne( ['paymentId' =&amp;gt; $event-&amp;gt;getAggregateId()], [ '$set' =&amp;gt; [ 'status' =&amp;gt; 'failed', 'error' =&amp;gt; $event-&amp;gt;getData()['error'], 'failedAt' =&amp;gt; $event-&amp;gt;getTimestamp(), 'updatedAt' =&amp;gt; new \MongoDB\BSON\UTCDateTime() ] ], ['upsert' =&amp;gt; true] ); } private function handlePaymentRefunded(DomainEvent $event): void { $this-&amp;gt;readModel-&amp;gt;updateOne( ['paymentId' =&amp;gt; $event-&amp;gt;getAggregateId()], [ '$set' =&amp;gt; [ 'status' =&amp;gt; 'refunded', 'refundAmount' =&amp;gt; $event-&amp;gt;getData()['refundAmount'], 'refundedAt' =&amp;gt; $event-&amp;gt;getTimestamp(), 'updatedAt' =&amp;gt; new \MongoDB\BSON\UTCDateTime() ] ], ['upsert' =&amp;gt; true] ); } private function updateProjectionMetadata(DomainEvent $event): void { $this-&amp;gt;projectionsMetadata-&amp;gt;updateOne( ['projectionName' =&amp;gt; 'PaymentReadModel'], [ '$set' =&amp;gt; [ 'projectionName' =&amp;gt; 'PaymentReadModel', 'lastProcessedEventId' =&amp;gt; $event-&amp;gt;getId(), 'lastProcessedTimestamp' =&amp;gt; $event-&amp;gt;getTimestamp(), 'version' =&amp;gt; $event-&amp;gt;getVersion(), 'updatedAt' =&amp;gt; new \MongoDB\BSON\UTCDateTime() ] ], ['upsert' =&amp;gt; true] ); }}&lt;/code&gt;#### &lt;strong&gt;Query Handler Avancé avec Analytics&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Query\Payment;use App\Infrastructure\ReadModel\PaymentReadModel;use MongoDB\Client;use Psr\Log\LoggerInterface;class PaymentQueryHandler implements QueryHandlerInterface{ private \MongoDB\Collection $readModel; private LoggerInterface $logger; public function __construct(Client $mongoClient, LoggerInterface $logger) { $this-&amp;gt;readModel = $mongoClient-&amp;gt;selectCollection('Gyroscops Cloud', 'payment_read_models'); $this-&amp;gt;logger = $logger; } public function handle(GetPaymentByIdQuery $query): ?PaymentReadModel { $document = $this-&amp;gt;readModel-&amp;gt;findOne(['paymentId' =&amp;gt; $query-&amp;gt;getPaymentId()]); if (!$document) { return null; } return PaymentReadModel::fromArray($document); } public function handle(GetPaymentsByOrganizationQuery $query): array { $cursor = $this-&amp;gt;readModel-&amp;gt;find( ['organizationId' =&amp;gt; $query-&amp;gt;getOrganizationId()], [ 'sort' =&amp;gt; ['processedAt' =&amp;gt; -1], 'limit' =&amp;gt; $query-&amp;gt;getLimit(), 'skip' =&amp;gt; $query-&amp;gt;getOffset() ] ); $payments = []; foreach ($cursor as $document) { $payments[] = PaymentReadModel::fromArray($document); } return $payments; } public function handle(GetPaymentStatisticsQuery $query): array { $pipeline = [ [ '$match' =&amp;gt; [ 'organizationId' =&amp;gt; $query-&amp;gt;getOrganizationId(), 'processedAt' =&amp;gt; [ '$gte' =&amp;gt; new \MongoDB\BSON\UTCDateTime($query-&amp;gt;getFrom()), '$lte' =&amp;gt; new \MongoDB\BSON\UTCDateTime($query-&amp;gt;getTo()) ] ] ], [ '$group' =&amp;gt; [ '_id' =&amp;gt; [ 'status' =&amp;gt; '$status', 'currency' =&amp;gt; '$currency' ], 'count' =&amp;gt; ['$sum' =&amp;gt; 1], 'totalAmount' =&amp;gt; ['$sum' =&amp;gt; '$amount'], 'averageAmount' =&amp;gt; ['$avg' =&amp;gt; '$amount'] ] ], [ '$sort' =&amp;gt; ['_id.status' =&amp;gt; 1, '_id.currency' =&amp;gt; 1] ] ]; $cursor = $this-&amp;gt;readModel-&amp;gt;aggregate($pipeline); $statistics = []; foreach ($cursor as $document) { $status = $document['_id']['status']; $currency = $document['_id']['currency']; if (!isset($statistics[$status])) { $statistics[$status] = []; } $statistics[$status][$currency] = [ 'count' =&amp;gt; $document['count'], 'totalAmount' =&amp;gt; $document['totalAmount'], 'averageAmount' =&amp;gt; $document['averageAmount'] ]; } return $statistics; } public function handle(GetPaymentTrendsQuery $query): array { $pipeline = [ [ '$match' =&amp;gt; [ 'organizationId' =&amp;gt; $query-&amp;gt;getOrganizationId(), 'processedAt' =&amp;gt; [ '$gte' =&amp;gt; new \MongoDB\BSON\UTCDateTime($query-&amp;gt;getFrom()), '$lte' =&amp;gt; new \MongoDB\BSON\UTCDateTime($query-&amp;gt;getTo()) ] ] ], [ '$group' =&amp;gt; [ '_id' =&amp;gt; [ 'year' =&amp;gt; ['$year' =&amp;gt; '$processedAt'], 'month' =&amp;gt; ['$month' =&amp;gt; '$processedAt'], 'day' =&amp;gt; ['$dayOfMonth' =&amp;gt; '$processedAt'] ], 'count' =&amp;gt; ['$sum' =&amp;gt; 1], 'totalAmount' =&amp;gt; ['$sum' =&amp;gt; '$amount'] ] ], [ '$sort' =&amp;gt; ['_id.year' =&amp;gt; 1, '_id.month' =&amp;gt; 1, '_id.day' =&amp;gt; 1] ] ]; $cursor = $this-&amp;gt;readModel-&amp;gt;aggregate($pipeline); $trends = []; foreach ($cursor as $document) { $date = sprintf('%04d-%02d-%02d', $document['_id']['year'], $document['_id']['month'], $document['_id']['day'] ); $trends[$date] = [ 'count' =&amp;gt; $document['count'], 'totalAmount' =&amp;gt; $document['totalAmount'] ]; } return $trends; }}&lt;/code&gt;## 🧪 &lt;strong&gt;Tests et Validation&lt;/strong&gt;### &lt;strong&gt;Tests d&amp;rsquo;Intégration Complets&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Tests\Integration\Payment;use App\Application\Command\Payment\ProcessPaymentCommand;use App\Application\Command\Payment\ProcessPaymentCommandHandler;use App\Application\Query\Payment\GetPaymentByIdQuery;use App\Application\Query\Payment\GetPaymentStatisticsQuery;use App\Application\Query\Payment\PaymentQueryHandler;use App\Infrastructure\EventStore\MongoEventStore;use App\Infrastructure\EventBus\EventBus;use MongoDB\Client;class PaymentEventSourcingCqrsTest extends TestCase{ public function testCompleteEventSourcingCqrsFlow(): void { $mongoClient = new Client('mongodb://localhost:27017'); $eventStore = new MongoEventStore($mongoClient); $eventBus = new EventBus(); $commandHandler = new ProcessPaymentCommandHandler( $eventStore, $eventBus, $this-&amp;gt;createMock(PaymentRepositoryInterface::class), $this-&amp;gt;createMock(LoggerInterface::class) ); $queryHandler = new PaymentQueryHandler($mongoClient, $this-&amp;gt;createMock(LoggerInterface::class)); // Exécuter la commande $command = new ProcessPaymentCommand('payment-123', 100.00, 'EUR', 'org-456'); $commandHandler-&amp;gt;handle($command); // Vérifier la requête $query = new GetPaymentByIdQuery('payment-123'); $payment = $queryHandler-&amp;gt;handle($query); $this-&amp;gt;assertNotNull($payment); $this-&amp;gt;assertEquals(100.00, $payment-&amp;gt;getAmount()); $this-&amp;gt;assertEquals('EUR', $payment-&amp;gt;getCurrency()); $this-&amp;gt;assertEquals('completed', $payment-&amp;gt;getStatus()); } public function testPaymentStatistics(): void { $mongoClient = new Client('mongodb://localhost:27017'); $queryHandler = new PaymentQueryHandler($mongoClient, $this-&amp;gt;createMock(LoggerInterface::class)); $query = new GetPaymentStatisticsQuery( 'org-456', new \DateTime('2024-01-01'), new \DateTime('2024-12-31') ); $statistics = $queryHandler-&amp;gt;handle($query); $this-&amp;gt;assertIsArray($statistics); $this-&amp;gt;assertArrayHasKey('completed', $statistics); $this-&amp;gt;assertArrayHasKey('EUR', $statistics['completed']); }}&lt;/code&gt;## 📊 &lt;strong&gt;Performance et Optimisation&lt;/strong&gt;### &lt;strong&gt;Stratégies d&amp;rsquo;Optimisation Avancées&lt;/strong&gt;#### &lt;strong&gt;1. Index MongoDB Optimisés&lt;/strong&gt;&lt;code&gt;javascript// Index composés pour les requêtes complexesdb.events.createIndex({ aggregateType: 1, timestamp: -1, eventType: 1 })db.events.createIndex({ correlationId: 1, timestamp: 1 })db.payment_read_models.createIndex({ organizationId: 1, status: 1, processedAt: -1 })db.payment_read_models.createIndex({ amount: 1, processedAt: -1 })db.payment_read_models.createIndex({ currency: 1, status: 1 })// Index partiels pour les requêtes fréquentesdb.payment_read_models.createIndex( { organizationId: 1, processedAt: -1 }, { partialFilterExpression: { status: 'completed' } })&lt;/code&gt;#### &lt;strong&gt;2. Projections Asynchrones&lt;/strong&gt;&lt;code&gt;phppublic function handleEventAsync(DomainEvent $event): void{ // Mettre en queue pour traitement asynchrone $this-&amp;gt;messageBus-&amp;gt;dispatch(new ProcessProjectionCommand($event));}&lt;/code&gt;#### &lt;strong&gt;3. Cache Multi-Niveaux&lt;/strong&gt;&lt;code&gt;phppublic function handle(GetPaymentByIdQuery $query): ?PaymentReadModel{ // Cache L1: Mémoire if (isset($this-&amp;gt;memoryCache[$query-&amp;gt;getPaymentId()])) { return $this-&amp;gt;memoryCache[$query-&amp;gt;getPaymentId()]; } // Cache L2: Redis $cached = $this-&amp;gt;redis-&amp;gt;get(&amp;quot;payment:{$query-&amp;gt;getPaymentId()}&amp;quot;); if ($cached) { $payment = PaymentReadModel::fromArray(json_decode($cached, true)); $this-&amp;gt;memoryCache[$query-&amp;gt;getPaymentId()] = $payment; return $payment; } // Base de données $payment = $this-&amp;gt;getFromDatabase($query-&amp;gt;getPaymentId()); if ($payment) { $this-&amp;gt;memoryCache[$query-&amp;gt;getPaymentId()] = $payment; $this-&amp;gt;redis-&amp;gt;setex(&amp;quot;payment:{$query-&amp;gt;getPaymentId()}&amp;quot;, 300, json_encode($payment-&amp;gt;toArray())); } return $payment;}&lt;/code&gt;## 🎯 &lt;strong&gt;Critères d&amp;rsquo;Adoption&lt;/strong&gt;### &lt;strong&gt;Quand Utiliser Event Sourcing + CQRS avec MongoDB&lt;/strong&gt;#### &lt;strong&gt;✅ Avantages&lt;/strong&gt;- &lt;strong&gt;Scalabilité maximale&lt;/strong&gt; : Possibilité de scaler indépendamment- &lt;strong&gt;Performance optimale&lt;/strong&gt; : Chaque côté optimisé pour son usage- &lt;strong&gt;Flexibilité&lt;/strong&gt; : Projections multiples pour différents besoins- &lt;strong&gt;Audit trail complet&lt;/strong&gt; : Historique de tous les changements- &lt;strong&gt;Debugging avancé&lt;/strong&gt; : Possibilité de rejouer les événements- &lt;strong&gt;Analytics&lt;/strong&gt; : Projections spécialisées pour les rapports#### &lt;strong&gt;❌ Inconvénients&lt;/strong&gt;- &lt;strong&gt;Complexité maximale&lt;/strong&gt; : Architecture très complexe- &lt;strong&gt;Latence&lt;/strong&gt; : Délai entre écriture et lecture- &lt;strong&gt;Stockage&lt;/strong&gt; : Beaucoup d&amp;rsquo;espace disque nécessaire- &lt;strong&gt;Expertise&lt;/strong&gt; : Équipe très expérimentée requise- &lt;strong&gt;Coût&lt;/strong&gt; : Investissement important en complexité#### &lt;strong&gt;🎯 Critères d&amp;rsquo;Adoption&lt;/strong&gt;- &lt;strong&gt;Système très complexe&lt;/strong&gt; : Besoins de scalabilité maximale- &lt;strong&gt;Équipe très expérimentée&lt;/strong&gt; : Maîtrise des patterns avancés- &lt;strong&gt;Budget important&lt;/strong&gt; : Investissement en complexité justifié- &lt;strong&gt;Performance critique&lt;/strong&gt; : Besoins de performance maximale- &lt;strong&gt;Analytics avancées&lt;/strong&gt; : Besoins de rapports complexes- &lt;strong&gt;Audit trail complet&lt;/strong&gt; : Traçabilité absolue requise## 🚀 &lt;strong&gt;Votre Prochaine Étape&lt;/strong&gt;

&lt;div class="chapter-navigation"&gt;
 &lt;h2 class="chapter-nav-title"&gt;🎯 Votre Prochaine Étape&lt;/h2&gt;
 &lt;p class="chapter-nav-subtitle"&gt;Maintenant que vous comprenez les concepts de base et que j'ai partagé mon expérience avec Gyroscops, quel est votre contexte ?&lt;/p&gt;</description></item></channel></rss>