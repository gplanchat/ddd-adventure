<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Stockage Multi-sources on DDD Adventure</title><link>http://localhost:1313/chapitres/stockage/multi-sources/</link><description>Recent content in Stockage Multi-sources on DDD Adventure</description><generator>Hugo</generator><language>fr-fr</language><lastBuildDate>Thu, 19 Dec 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/chapitres/stockage/multi-sources/index.xml" rel="self" type="application/rss+xml"/><item><title>Stockage Multi-sources - Approche Classique</title><link>http://localhost:1313/chapitres/stockage/multi-sources/chapitre-52-stockage-multi-sources-classique/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/multi-sources/chapitre-52-stockage-multi-sources-classique/</guid><description>&lt;h2 id="-contexte-et-objectifs-pourquoi-multi-sources-pour-le-stockage-le-stockage-multi-sources-offre-une-approche-hybride-qui-combine-diff√©rents-types-de-stockage-pour-optimiser-les-performances-et-r√©pondre-aux-besoins-sp√©cifiques-de-chaque-partie-du-syst√®me-cette-approche-est-particuli√®rement-adapt√©e-aux-syst√®mes-complexes-qui-n√©cessitent-diff√©rents-niveaux-de-performance-et-de-persistance-avantages-du-stockage-multi-sources--flexibilit√©--choix-du-meilleur-stockage-pour-chaque-cas-dusage--performance--optimisation-des-performances-par-type-dop√©ration--r√©silience--redondance-et-failover-entre-sources--scalabilit√©--possibilit√©-de-scaler-ind√©pendamment-chaque-source--co√ªt--optimisation-des-co√ªts-selon-les-besoins-contexte-gyroscopsdans-notre-√©cosyst√®me-user--organization--workflow--cloud-resources--billing-multi-sources-est-particuli√®rement-pertinent-pour---donn√©es-utilisateur--cache-redis--base-de-donn√©es-sql--donn√©es-de-facturation--base-de-donn√©es-sql--elasticsearch-pour-analytics--donn√©es-de-workflow--temporal--cache-in-memory--donn√©es-de-configuration--base-de-donn√©es--fichiers-de-configuration--architecture-multi-sources-classique-structure-des-sources-source-de-donn√©es-principale--base-de-donn√©es-sql--donn√©es-transactionnelles-critiques--cache-redis--donn√©es-fr√©quemment-acc√©d√©es--elasticsearch--donn√©es-de-recherche-et-analytics--fichiers--configuration-et-logs-flux-de-donn√©esmermaidgraph-td----aapplication----bmulti-source-manager----b----csource-router----c----dsql-database----c----eredis-cache----c----felasticsearch----c----gfile-system--------hread-operation----icache-check----i----jcache-hit----i----kcache-miss----k----lprimary-source----l----mupdate-cache--------nwrite-operation----oprimary-source----o----pupdate-cache----o----qupdate-search-index--impl√©mentation-pratique-1-multi-source-manager-gestionnaire-multi-sourcesphpphpnamespace-appinfrastructuremultisourceuse-appdomainpaymentpaymentuse-appdomainpaymentpaymentrepositoryinterfaceuse-appinfrastructurerepositorysqlpaymentrepositoryuse-appinfrastructurerepositoryredispaymentrepositoryuse-appinfrastructurerepositoryelasticsearchpaymentrepositoryuse-psrlogloggerinterfaceclass-multisourcepaymentrepository-implements-paymentrepositoryinterface----private-sqlpaymentrepository-sqlrepository----private-redispaymentrepository-redisrepository----private-elasticsearchpaymentrepository-elasticsearchrepository----private-loggerinterface-logger----private-array-sourceconfig----public-function-__construct--------sqlpaymentrepository-sqlrepository--------redispaymentrepository-redisrepository--------elasticsearchpaymentrepository-elasticsearchrepository--------loggerinterface-logger--------array-sourceconfig---------------this-sqlrepository--sqlrepository--------this-redisrepository--redisrepository--------this-elasticsearchrepository--elasticsearchrepository--------this-logger--logger--------this-sourceconfig--array_merge------------read_strategy--cache_first------------write_strategy--write_through------------cache_ttl--300------------fallback_enabled--true---------sourceconfig--------public-function-savepayment-payment-void------------try-------------this-logger-infosaving-payment-via-multi-source-----------------paymentid--payment-getid----------------strategy--this-sourceconfigwrite_strategy------------------------switch-this-sourceconfigwrite_strategy-----------------case-write_through--------------------this-writethroughpayment--------------------break----------------case-write_behind--------------------this-writebehindpayment--------------------break----------------case-write_around--------------------this-writearoundpayment--------------------break----------------default--------------------this-writethroughpayment------------------------this-logger-infopayment-saved-successfully-via-multi-source-----------------paymentid--payment-getid---------------------catch-exception-e-------------this-logger-errorfailed-to-save-payment-via-multi-source-----------------paymentid--payment-getid----------------error--e-getmessage------------------------throw-e----------------public-function-findbyidstring-id-payment------------try-------------this-logger-infofinding-payment-via-multi-source-----------------paymentid--id----------------strategy--this-sourceconfigread_strategy------------------------switch-this-sourceconfigread_strategy-----------------case-cache_first--------------------return-this-cachefirstid----------------case-database_first--------------------return-this-databasefirstid----------------case-parallel--------------------return-this-parallelreadid----------------default--------------------return-this-cachefirstid---------------------catch-exception-e-------------this-logger-errorfailed-to-find-payment-via-multi-source-----------------paymentid--id----------------error--e-getmessage------------------------return-null----------------public-function-findbyorganizationstring-organizationid-array------------try-------------this-logger-infofinding-payments-by-organization-via-multi-source-----------------organizationid--organizationid-------------------------pour-les-requ√™tes-complexes-utiliser-elasticsearch------------payments--this-elasticsearchrepository-findbyorganizationorganizationid------------this-logger-infopayments-found-by-organization-via-multi-source-----------------organizationid--organizationid----------------count--countpayments------------------------return-payments---------catch-exception-e-------------this-logger-errorfailed-to-find-payments-by-organization-via-multi-source-----------------organizationid--organizationid----------------error--e-getmessage-------------------------fallback-vers-la-base-de-donn√©es-sql------------if-this-sourceconfigfallback_enabled-----------------return-this-sqlrepository-findbyorganizationorganizationid------------------------return-----------------public-function-deletestring-id-void------------try-------------this-logger-infodeleting-payment-via-multi-source-----------------paymentid--id-------------------------supprimer-de-toutes-les-sources------------this-sqlrepository-deleteid------------this-redisrepository-deleteid------------this-elasticsearchrepository-deleteid------------this-logger-infopayment-deleted-successfully-via-multi-source-----------------paymentid--id---------------------catch-exception-e-------------this-logger-errorfailed-to-delete-payment-via-multi-source-----------------paymentid--id----------------error--e-getmessage------------------------throw-e----------------public-function-count-int------------try--------------utiliser-la-source-la-plus-fiable-pour-le-comptage------------return-this-sqlrepository-count---------catch-exception-e-------------this-logger-errorfailed-to-count-payments-via-multi-source-----------------error--e-getmessage------------------------return-0----------------private-function-writethroughpayment-payment-void-------------√©crire-dans-la-base-de-donn√©es-sql-dabord--------this-sqlrepository-savepayment-----------------puis-mettre-√†-jour-le-cache--------this-redisrepository-savepayment-----------------et-lindex-de-recherche--------this-elasticsearchrepository-savepayment--------private-function-writebehindpayment-payment-void-------------√©crire-dans-le-cache-dabord--------this-redisrepository-savepayment-----------------programmer-l√©criture-en-base-de-donn√©es--------this-scheduledatabasewritepayment--------private-function-writearoundpayment-payment-void-------------√©crire-directement-dans-la-base-de-donn√©es--------this-sqlrepository-savepayment-----------------invalider-le-cache--------this-redisrepository-deletepayment-getid--------private-function-cachefirststring-id-payment-------------v√©rifier-le-cache-dabord--------payment--this-redisrepository-findbyidid----------------if-payment-------------return-payment-------------------------si-pas-en-cache-chercher-en-base-de-donn√©es--------payment--this-sqlrepository-findbyidid----------------if-payment--------------mettre-en-cache------------this-redisrepository-savepayment------------------------return-payment--------private-function-databasefirststring-id-payment-------------chercher-en-base-de-donn√©es-dabord--------payment--this-sqlrepository-findbyidid----------------if-payment--------------mettre-en-cache------------this-redisrepository-savepayment------------------------return-payment--------private-function-parallelreadstring-id-payment-------------lancer-les-lectures-en-parall√®le--------cachepromise--this-redisrepository-findbyidasyncid--------databasepromise--this-sqlrepository-findbyidasyncid-----------------attendre-les-r√©sultats--------cacheresult--cachepromise-wait--------databaseresult--databasepromise-wait-----------------retourner-le-r√©sultat-le-plus-r√©cent--------if-cacheresult--databaseresult-------------return-cacheresult-getupdatedat--databaseresult-getupdatedat------------------cacheresult------------------databaseresult------------------------return-cacheresult--databaseresult--------private-function-scheduledatabasewritepayment-payment-void-------------impl√©mentation-de-l√©criture-diff√©r√©e---------ex-via-une-queue-de-messages--------this-messagequeue-pushnew-databasewritejobpayment-----2-source-router-routeur-de-sourcesphpphpnamespace-appinfrastructuremultisourceuse-appdomainpaymentpaymentuse-psrlogloggerinterfaceclass-sourcerouter----private-array-routingrules----private-loggerinterface-logger----public-function-__constructarray-routingrules---loggerinterface-logger------------this-routingrules--array_merge------------read------------------simple_queries--cache----------------complex_queries--elasticsearch----------------critical_data--database------------------------write------------------transactions--database----------------cache_updates--cache----------------search_index--elasticsearch---------------------routingrules--------this-logger--logger--------public-function-routereadstring-operation-array-criteria---string------------this-logger-debugrouting-read-operation-------------operation--operation------------criteria--criteria-----------------logique-de-routage-bas√©e-sur-lop√©ration--------if-this-issimplequeryoperation-criteria-------------return-cache----------------if-this-iscomplexqueryoperation-criteria-------------return-elasticsearch----------------if-this-iscriticaldataoperation-criteria-------------return-database-----------------par-d√©faut-utiliser-le-cache--------return-cache--------public-function-routewritestring-operation-payment-payment-array------------this-logger-debugrouting-write-operation-------------operation--operation------------paymentid--payment-getid----------------sources-----------toujours-√©crire-en-base-de-donn√©es-pour-les-transactions--------if-this-istransactionoperation-------------sources--database-----------------mettre-√†-jour-le-cache-pour-les-donn√©es-fr√©quemment-acc√©d√©es--------if-this-shouldupdatecachepayment-------------sources--cache-----------------mettre-√†-jour-lindex-de-recherche-pour-les-donn√©es-recherchables--------if-this-shouldupdatesearchindexpayment-------------sources--elasticsearch----------------return-sources--------private-function-issimplequerystring-operation-array-criteria-bool------------return-in_arrayoperation-findbyid-findbystatus-----------------countcriteria--2--------private-function-iscomplexquerystring-operation-array-criteria-bool------------return-in_arrayoperation-search-findbyorganization-findbydaterange----------------countcriteria--2--------private-function-iscriticaldatastring-operation-array-criteria-bool------------return-in_arrayoperation-findbyid-----------------issetcriteriacritical-----------------criteriacritical--true--------private-function-istransactionstring-operation-bool------------return-in_arrayoperation-save-update-delete--------private-function-shouldupdatecachepayment-payment-bool-------------mettre-√†-jour-le-cache-pour-les-paiements-r√©cents-ou-fr√©quemment-acc√©d√©s--------return-payment-getcreatedat--new-datetime-1-hour----------------payment-getstatus--processing--------private-function-shouldupdatesearchindexpayment-payment-bool-------------mettre-√†-jour-lindex-de-recherche-pour-les-paiements-avec-des-donn√©es-recherchables--------return-emptypayment-getdescription----------------payment-getamount--1000-----3-cache-manager-gestionnaire-de-cache-multi-sourcesphpphpnamespace-appinfrastructuremultisourceuse-appdomainpaymentpaymentuse-psrcachecacheitempoolinterfaceuse-psrlogloggerinterfaceclass-multisourcecachemanager----private-cacheitempoolinterface-cache----private-loggerinterface-logger----private-array-cacheconfig----public-function-__construct--------cacheitempoolinterface-cache--------loggerinterface-logger--------array-cacheconfig---------------this-cache--cache--------this-logger--logger--------this-cacheconfig--array_merge------------default_ttl--300------------payment_ttl--600------------search_ttl--1800------------enable_compression--true---------cacheconfig--------public-function-getstring-key-mixed------------try-------------cacheitem--this-cache-getitemkey------------------------if-cacheitem-ishit-----------------this-logger-debugcache-hit-key--key----------------return-this-unserializecacheitem-get------------------------------------this-logger-debugcache-miss-key--key------------return-null---------------------catch-exception-e-------------this-logger-errorcache-get-failed-----------------key--key----------------error--e-getmessage------------------------------------return-null----------------public-function-setstring-key-mixed-value-int-ttl--null-bool------------try-------------cacheitem--this-cache-getitemkey------------cacheitem-setthis-serializevalue------------cacheitem-expiresafterttl--this-cacheconfigdefault_ttl------------------------result--this-cache-savecacheitem------------------------this-logger-debugcache-set-----------------key--key----------------ttl--ttl--this-cacheconfigdefault_ttl----------------success--result------------------------------------return-result---------------------catch-exception-e-------------this-logger-errorcache-set-failed-----------------key--key----------------error--e-getmessage------------------------------------return-false----------------public-function-deletestring-key-bool------------try-------------result--this-cache-deleteitemkey------------------------this-logger-debugcache-delete-----------------key--key----------------success--result------------------------------------return-result---------------------catch-exception-e-------------this-logger-errorcache-delete-failed-----------------key--key----------------error--e-getmessage------------------------------------return-false----------------public-function-getpaymentstring-paymentid-payment------------key--this-generatepaymentkeypaymentid--------return-this-getkey--------public-function-setpaymentpayment-payment-int-ttl--null-bool------------key--this-generatepaymentkeypayment-getid--------ttl--ttl--this-cacheconfigpayment_ttl----------------return-this-setkey-payment-ttl--------public-function-deletepaymentstring-paymentid-bool------------key--this-generatepaymentkeypaymentid--------return-this-deletekey--------public-function-getsearchresultsstring-query-array-filters---array------------key--this-generatesearchkeyquery-filters--------return-this-getkey--------public-function-setsearchresultsstring-query-array-filters-array-results-int-ttl--null-bool------------key--this-generatesearchkeyquery-filters--------ttl--ttl--this-cacheconfigsearch_ttl----------------return-this-setkey-results-ttl--------private-function-generatepaymentkeystring-paymentid-string------------return-paymentpaymentid--------private-function-generatesearchkeystring-query-array-filters-string------------filterstring--md5serializefilters--------return-search--md5query--filterstring--------private-function-serializemixed-value-string------------if-this-cacheconfigenable_compression-------------return-gzcompressserializevalue------------------------return-serializevalue--------private-function-unserializestring-value-mixed------------if-this-cacheconfigenable_compression-------------return-unserializegzuncompressvalue------------------------return-unserializevalue------tests-et-validation-tests-dphpphpnamespace-apptestsintegrationmultisourceuse-appdomainpaymentpaymentuse-appinfrastructuremultisourcemultisourcepaymentrepositoryuse-appinfrastructurerepositorysqlpaymentrepositoryuse-appinfrastructurerepositoryredispaymentrepositoryuse-appinfrastructurerepositoryelasticsearchpaymentrepositoryclass-multisourcepaymentrepositorytest-extends-testcase----private-multisourcepaymentrepository-repository----private-sqlpaymentrepository-sqlrepository----private-redispaymentrepository-redisrepository----private-elasticsearchpaymentrepository-elasticsearchrepository----protected-function-setup-void------------this-sqlrepository--this-createmocksqlpaymentrepositoryclass--------this-redisrepository--this-createmockredispaymentrepositoryclass--------this-elasticsearchrepository--this-createmockelasticsearchpaymentrepositoryclass----------------this-repository--new-multisourcepaymentrepository------------this-sqlrepository------------this-redisrepository------------this-elasticsearchrepository------------this-createmockloggerinterfaceclass------------read_strategy--cache_first-write_strategy--write_through----------------public-function-testsavewithwritethrough-void------------payment--new-payment------------payment-123------------org-456------------user-789------------10000------------eur------------processing------------test-payment------------new-datetime------------------------this-sqlrepository-expectsthis-once-methodsave-withpayment--------this-redisrepository-expectsthis-once-methodsave-withpayment--------this-elasticsearchrepository-expectsthis-once-methodsave-withpayment----------------this-repository-savepayment--------public-function-testfindbyidwithcachefirst-void------------payment--new-payment------------payment-123------------org-456------------user-789------------10000------------eur------------processing------------test-payment------------new-datetime------------------------this-redisrepository-expectsthis-once-------------methodfindbyid-------------withpayment-123-------------willreturnpayment----------------result--this-repository-findbyidpayment-123----------------this-assertequalspayment-result--------public-function-testfindbyidwithcachemiss-void------------payment--new-payment------------payment-123------------org-456------------user-789------------10000------------eur------------processing------------test-payment------------new-datetime------------------------this-redisrepository-expectsthis-once-------------methodfindbyid-------------withpayment-123-------------willreturnnull----------------this-sqlrepository-expectsthis-once-------------methodfindbyid-------------withpayment-123-------------willreturnpayment----------------this-redisrepository-expectsthis-once-------------methodsave-------------withpayment----------------result--this-repository-findbyidpayment-123----------------this-assertequalspayment-result------performance-et-optimisation-strat√©gies-d-1-cache-warmingphppublic-function-warmcache-void----this-logger-infowarming-cache-for-frequently-accessed-data---------charger-les-paiements-r√©cents----recentpayments--this-sqlrepository-findrecent100----foreach-recentpayments-as-payment---------this-redisrepository-savepayment-------------charger-les-statistiques----stats--this-sqlrepository-getstatistics----this-redisrepository-setpaymentstats-stats-3600-2-load-balancingphppublic-function-getoptimalsourcestring-operation-string----sourceloads--this-getsourceloads----optimalsource--array_keyssourceloads-minsourceloads0--------this-logger-debugselected-optimal-source---------operation--operation--------source--optimalsource--------loads--sourceloads------------return-optimalsource-3-monitoring-des-sourcesphppublic-function-getsourcemetrics-array----return---------sql--this-getsqlmetrics--------redis--this-getredismetrics--------elasticsearch--this-getelasticsearchmetrics--------overall_health--this-getoverallhealth------crit√®res-d-quand-utiliser-multi-sources-classique--avantages--flexibilit√©--choix-du-meilleur-stockage-pour-chaque-cas-dusage--performance--optimisation-des-performances-par-type-dop√©ration--r√©silience--redondance-et-failover-entre-sources--scalabilit√©--possibilit√©-de-scaler-ind√©pendamment-chaque-source--co√ªt--optimisation-des-co√ªts-selon-les-besoins--inconv√©nients--complexit√©--gestion-de-plusieurs-sources-de-donn√©es--coh√©rence--risque-dincoh√©rence-entre-sources--maintenance--plus-de-sources-√†-maintenir--expertise--√©quipe-exp√©riment√©e-requise--crit√®res-d--syst√®me-complexe--besoins-de-performance-diff√©rents-par-type-dop√©ration--donn√©es-h√©t√©rog√®nes--types-de-donn√©es-diff√©rents-n√©cessitant-diff√©rents-stockages--performance-critique--besoins-de-performance-optimale--r√©silience-importante--besoin-de-redondance-et-failover--√©quipe-exp√©riment√©e--ma√Ætrise-de-plusieurs-technologies-de-stockage--budget-suffisant--investissement-en-infrastructure-multiple--temps-de-d√©veloppement--suffisant-pour-impl√©menter-cette-complexit√©--votre-prochaine-√©tapehahahugoshortcode58s0hbhbmulti-sources-classique-offre-une-approche-flexible-pour-combiner-diff√©rents-types-de-stockage-parfaitement-adapt√©e-aux-besoins-complexes-de-gyroscops"&gt;üéØ &lt;strong&gt;Contexte et Objectifs&lt;/strong&gt;### **Pourquoi Multi-sources pour le Stockage ?**Le stockage multi-sources offre une approche hybride qui combine diff√©rents types de stockage pour optimiser les performances et r√©pondre aux besoins sp√©cifiques de chaque partie du syst√®me. Cette approche est particuli√®rement adapt√©e aux syst√®mes complexes qui n√©cessitent diff√©rents niveaux de performance et de persistance.#### &lt;strong&gt;Avantages du Stockage Multi-sources&lt;/strong&gt;- &lt;strong&gt;Flexibilit√©&lt;/strong&gt; : Choix du meilleur stockage pour chaque cas d&amp;rsquo;usage- &lt;strong&gt;Performance&lt;/strong&gt; : Optimisation des performances par type d&amp;rsquo;op√©ration- &lt;strong&gt;R√©silience&lt;/strong&gt; : Redondance et failover entre sources- &lt;strong&gt;Scalabilit√©&lt;/strong&gt; : Possibilit√© de scaler ind√©pendamment chaque source- &lt;strong&gt;Co√ªt&lt;/strong&gt; : Optimisation des co√ªts selon les besoins### &lt;strong&gt;Contexte Gyroscops&lt;/strong&gt;Dans notre √©cosyst√®me &lt;strong&gt;User ‚Üí Organization ‚Üí Workflow ‚Üí Cloud Resources ‚Üí Billing&lt;/strong&gt;, Multi-sources est particuli√®rement pertinent pour :- &lt;strong&gt;Donn√©es utilisateur&lt;/strong&gt; : Cache Redis + Base de donn√©es SQL- &lt;strong&gt;Donn√©es de facturation&lt;/strong&gt; : Base de donn√©es SQL + ElasticSearch pour analytics- &lt;strong&gt;Donn√©es de workflow&lt;/strong&gt; : Temporal + Cache In-Memory- &lt;strong&gt;Donn√©es de configuration&lt;/strong&gt; : Base de donn√©es + Fichiers de configuration## üèóÔ∏è &lt;strong&gt;Architecture Multi-sources Classique&lt;/strong&gt;### &lt;strong&gt;Structure des Sources&lt;/strong&gt;#### &lt;strong&gt;Source de Donn√©es Principale&lt;/strong&gt;- &lt;strong&gt;Base de donn√©es SQL&lt;/strong&gt; : Donn√©es transactionnelles critiques- &lt;strong&gt;Cache Redis&lt;/strong&gt; : Donn√©es fr√©quemment acc√©d√©es- &lt;strong&gt;ElasticSearch&lt;/strong&gt; : Donn√©es de recherche et analytics- &lt;strong&gt;Fichiers&lt;/strong&gt; : Configuration et logs#### &lt;strong&gt;Flux de Donn√©es&lt;/strong&gt;&lt;code&gt;mermaidgraph TD A[Application] --&amp;gt; B[Multi-Source Manager] B --&amp;gt; C[Source Router] C --&amp;gt; D[SQL Database] C --&amp;gt; E[Redis Cache] C --&amp;gt; F[ElasticSearch] C --&amp;gt; G[File System] H[Read Operation] --&amp;gt; I[Cache Check] I --&amp;gt; J[Cache Hit] I --&amp;gt; K[Cache Miss] K --&amp;gt; L[Primary Source] L --&amp;gt; M[Update Cache] N[Write Operation] --&amp;gt; O[Primary Source] O --&amp;gt; P[Update Cache] O --&amp;gt; Q[Update Search Index]&lt;/code&gt;## üíª &lt;strong&gt;Impl√©mentation Pratique&lt;/strong&gt;### &lt;strong&gt;1. Multi-Source Manager&lt;/strong&gt;#### &lt;strong&gt;Gestionnaire Multi-Sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Infrastructure\MultiSource;use App\Domain\Payment\Payment;use App\Domain\Payment\PaymentRepositoryInterface;use App\Infrastructure\Repository\SqlPaymentRepository;use App\Infrastructure\Repository\RedisPaymentRepository;use App\Infrastructure\Repository\ElasticSearchPaymentRepository;use Psr\Log\LoggerInterface;class MultiSourcePaymentRepository implements PaymentRepositoryInterface{ private SqlPaymentRepository $sqlRepository; private RedisPaymentRepository $redisRepository; private ElasticSearchPaymentRepository $elasticSearchRepository; private LoggerInterface $logger; private array $sourceConfig; public function __construct( SqlPaymentRepository $sqlRepository, RedisPaymentRepository $redisRepository, ElasticSearchPaymentRepository $elasticSearchRepository, LoggerInterface $logger, array $sourceConfig = [] ) { $this-&amp;gt;sqlRepository = $sqlRepository; $this-&amp;gt;redisRepository = $redisRepository; $this-&amp;gt;elasticSearchRepository = $elasticSearchRepository; $this-&amp;gt;logger = $logger; $this-&amp;gt;sourceConfig = array_merge([ 'read_strategy' =&amp;gt; 'cache_first', 'write_strategy' =&amp;gt; 'write_through', 'cache_ttl' =&amp;gt; 300, 'fallback_enabled' =&amp;gt; true ], $sourceConfig); } public function save(Payment $payment): void { try { $this-&amp;gt;logger-&amp;gt;info('Saving payment via multi-source', [ 'paymentId' =&amp;gt; $payment-&amp;gt;getId(), 'strategy' =&amp;gt; $this-&amp;gt;sourceConfig['write_strategy'] ]); switch ($this-&amp;gt;sourceConfig['write_strategy']) { case 'write_through': $this-&amp;gt;writeThrough($payment); break; case 'write_behind': $this-&amp;gt;writeBehind($payment); break; case 'write_around': $this-&amp;gt;writeAround($payment); break; default: $this-&amp;gt;writeThrough($payment); } $this-&amp;gt;logger-&amp;gt;info('Payment saved successfully via multi-source', [ 'paymentId' =&amp;gt; $payment-&amp;gt;getId() ]); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to save payment via multi-source', [ 'paymentId' =&amp;gt; $payment-&amp;gt;getId(), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } public function findById(string $id): ?Payment { try { $this-&amp;gt;logger-&amp;gt;info('Finding payment via multi-source', [ 'paymentId' =&amp;gt; $id, 'strategy' =&amp;gt; $this-&amp;gt;sourceConfig['read_strategy'] ]); switch ($this-&amp;gt;sourceConfig['read_strategy']) { case 'cache_first': return $this-&amp;gt;cacheFirst($id); case 'database_first': return $this-&amp;gt;databaseFirst($id); case 'parallel': return $this-&amp;gt;parallelRead($id); default: return $this-&amp;gt;cacheFirst($id); } } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to find payment via multi-source', [ 'paymentId' =&amp;gt; $id, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); return null; } } public function findByOrganization(string $organizationId): array { try { $this-&amp;gt;logger-&amp;gt;info('Finding payments by organization via multi-source', [ 'organizationId' =&amp;gt; $organizationId ]); // Pour les requ√™tes complexes, utiliser ElasticSearch $payments = $this-&amp;gt;elasticSearchRepository-&amp;gt;findByOrganization($organizationId); $this-&amp;gt;logger-&amp;gt;info('Payments found by organization via multi-source', [ 'organizationId' =&amp;gt; $organizationId, 'count' =&amp;gt; count($payments) ]); return $payments; } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to find payments by organization via multi-source', [ 'organizationId' =&amp;gt; $organizationId, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); // Fallback vers la base de donn√©es SQL if ($this-&amp;gt;sourceConfig['fallback_enabled']) { return $this-&amp;gt;sqlRepository-&amp;gt;findByOrganization($organizationId); } return []; } } public function delete(string $id): void { try { $this-&amp;gt;logger-&amp;gt;info('Deleting payment via multi-source', [ 'paymentId' =&amp;gt; $id ]); // Supprimer de toutes les sources $this-&amp;gt;sqlRepository-&amp;gt;delete($id); $this-&amp;gt;redisRepository-&amp;gt;delete($id); $this-&amp;gt;elasticSearchRepository-&amp;gt;delete($id); $this-&amp;gt;logger-&amp;gt;info('Payment deleted successfully via multi-source', [ 'paymentId' =&amp;gt; $id ]); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to delete payment via multi-source', [ 'paymentId' =&amp;gt; $id, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } public function count(): int { try { // Utiliser la source la plus fiable pour le comptage return $this-&amp;gt;sqlRepository-&amp;gt;count(); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to count payments via multi-source', [ 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); return 0; } } private function writeThrough(Payment $payment): void { // √âcrire dans la base de donn√©es SQL d'abord $this-&amp;gt;sqlRepository-&amp;gt;save($payment); // Puis mettre √† jour le cache $this-&amp;gt;redisRepository-&amp;gt;save($payment); // Et l'index de recherche $this-&amp;gt;elasticSearchRepository-&amp;gt;save($payment); } private function writeBehind(Payment $payment): void { // √âcrire dans le cache d'abord $this-&amp;gt;redisRepository-&amp;gt;save($payment); // Programmer l'√©criture en base de donn√©es $this-&amp;gt;scheduleDatabaseWrite($payment); } private function writeAround(Payment $payment): void { // √âcrire directement dans la base de donn√©es $this-&amp;gt;sqlRepository-&amp;gt;save($payment); // Invalider le cache $this-&amp;gt;redisRepository-&amp;gt;delete($payment-&amp;gt;getId()); } private function cacheFirst(string $id): ?Payment { // V√©rifier le cache d'abord $payment = $this-&amp;gt;redisRepository-&amp;gt;findById($id); if ($payment) { return $payment; } // Si pas en cache, chercher en base de donn√©es $payment = $this-&amp;gt;sqlRepository-&amp;gt;findById($id); if ($payment) { // Mettre en cache $this-&amp;gt;redisRepository-&amp;gt;save($payment); } return $payment; } private function databaseFirst(string $id): ?Payment { // Chercher en base de donn√©es d'abord $payment = $this-&amp;gt;sqlRepository-&amp;gt;findById($id); if ($payment) { // Mettre en cache $this-&amp;gt;redisRepository-&amp;gt;save($payment); } return $payment; } private function parallelRead(string $id): ?Payment { // Lancer les lectures en parall√®le $cachePromise = $this-&amp;gt;redisRepository-&amp;gt;findByIdAsync($id); $databasePromise = $this-&amp;gt;sqlRepository-&amp;gt;findByIdAsync($id); // Attendre les r√©sultats $cacheResult = $cachePromise-&amp;gt;wait(); $databaseResult = $databasePromise-&amp;gt;wait(); // Retourner le r√©sultat le plus r√©cent if ($cacheResult &amp;amp;&amp;amp; $databaseResult) { return $cacheResult-&amp;gt;getUpdatedAt() &amp;gt; $databaseResult-&amp;gt;getUpdatedAt() ? $cacheResult : $databaseResult; } return $cacheResult ?: $databaseResult; } private function scheduleDatabaseWrite(Payment $payment): void { // Impl√©mentation de l'√©criture diff√©r√©e // Ex: via une queue de messages $this-&amp;gt;messageQueue-&amp;gt;push(new DatabaseWriteJob($payment)); }}&lt;/code&gt;### &lt;strong&gt;2. Source Router&lt;/strong&gt;#### &lt;strong&gt;Routeur de Sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Infrastructure\MultiSource;use App\Domain\Payment\Payment;use Psr\Log\LoggerInterface;class SourceRouter{ private array $routingRules; private LoggerInterface $logger; public function __construct(array $routingRules = [], LoggerInterface $logger) { $this-&amp;gt;routingRules = array_merge([ 'read' =&amp;gt; [ 'simple_queries' =&amp;gt; 'cache', 'complex_queries' =&amp;gt; 'elasticsearch', 'critical_data' =&amp;gt; 'database' ], 'write' =&amp;gt; [ 'transactions' =&amp;gt; 'database', 'cache_updates' =&amp;gt; 'cache', 'search_index' =&amp;gt; 'elasticsearch' ] ], $routingRules); $this-&amp;gt;logger = $logger; } public function routeRead(string $operation, array $criteria = []): string { $this-&amp;gt;logger-&amp;gt;debug('Routing read operation', [ 'operation' =&amp;gt; $operation, 'criteria' =&amp;gt; $criteria ]); // Logique de routage bas√©e sur l'op√©ration if ($this-&amp;gt;isSimpleQuery($operation, $criteria)) { return 'cache'; } if ($this-&amp;gt;isComplexQuery($operation, $criteria)) { return 'elasticsearch'; } if ($this-&amp;gt;isCriticalData($operation, $criteria)) { return 'database'; } // Par d√©faut, utiliser le cache return 'cache'; } public function routeWrite(string $operation, Payment $payment): array { $this-&amp;gt;logger-&amp;gt;debug('Routing write operation', [ 'operation' =&amp;gt; $operation, 'paymentId' =&amp;gt; $payment-&amp;gt;getId() ]); $sources = []; // Toujours √©crire en base de donn√©es pour les transactions if ($this-&amp;gt;isTransaction($operation)) { $sources[] = 'database'; } // Mettre √† jour le cache pour les donn√©es fr√©quemment acc√©d√©es if ($this-&amp;gt;shouldUpdateCache($payment)) { $sources[] = 'cache'; } // Mettre √† jour l'index de recherche pour les donn√©es recherchables if ($this-&amp;gt;shouldUpdateSearchIndex($payment)) { $sources[] = 'elasticsearch'; } return $sources; } private function isSimpleQuery(string $operation, array $criteria): bool { return in_array($operation, ['findById', 'findByStatus']) &amp;amp;&amp;amp; count($criteria) &amp;lt;= 2; } private function isComplexQuery(string $operation, array $criteria): bool { return in_array($operation, ['search', 'findByOrganization', 'findByDateRange']) || count($criteria) &amp;gt; 2; } private function isCriticalData(string $operation, array $criteria): bool { return in_array($operation, ['findById']) &amp;amp;&amp;amp; isset($criteria['critical']) &amp;amp;&amp;amp; $criteria['critical'] === true; } private function isTransaction(string $operation): bool { return in_array($operation, ['save', 'update', 'delete']); } private function shouldUpdateCache(Payment $payment): bool { // Mettre √† jour le cache pour les paiements r√©cents ou fr√©quemment acc√©d√©s return $payment-&amp;gt;getCreatedAt() &amp;gt; new \DateTime('-1 hour') || $payment-&amp;gt;getStatus() === 'processing'; } private function shouldUpdateSearchIndex(Payment $payment): bool { // Mettre √† jour l'index de recherche pour les paiements avec des donn√©es recherchables return !empty($payment-&amp;gt;getDescription()) || $payment-&amp;gt;getAmount() &amp;gt; 1000; }}&lt;/code&gt;### &lt;strong&gt;3. Cache Manager&lt;/strong&gt;#### &lt;strong&gt;Gestionnaire de Cache Multi-Sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Infrastructure\MultiSource;use App\Domain\Payment\Payment;use Psr\Cache\CacheItemPoolInterface;use Psr\Log\LoggerInterface;class MultiSourceCacheManager{ private CacheItemPoolInterface $cache; private LoggerInterface $logger; private array $cacheConfig; public function __construct( CacheItemPoolInterface $cache, LoggerInterface $logger, array $cacheConfig = [] ) { $this-&amp;gt;cache = $cache; $this-&amp;gt;logger = $logger; $this-&amp;gt;cacheConfig = array_merge([ 'default_ttl' =&amp;gt; 300, 'payment_ttl' =&amp;gt; 600, 'search_ttl' =&amp;gt; 1800, 'enable_compression' =&amp;gt; true ], $cacheConfig); } public function get(string $key): mixed { try { $cacheItem = $this-&amp;gt;cache-&amp;gt;getItem($key); if ($cacheItem-&amp;gt;isHit()) { $this-&amp;gt;logger-&amp;gt;debug('Cache hit', ['key' =&amp;gt; $key]); return $this-&amp;gt;unserialize($cacheItem-&amp;gt;get()); } $this-&amp;gt;logger-&amp;gt;debug('Cache miss', ['key' =&amp;gt; $key]); return null; } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Cache get failed', [ 'key' =&amp;gt; $key, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); return null; } } public function set(string $key, mixed $value, int $ttl = null): bool { try { $cacheItem = $this-&amp;gt;cache-&amp;gt;getItem($key); $cacheItem-&amp;gt;set($this-&amp;gt;serialize($value)); $cacheItem-&amp;gt;expiresAfter($ttl ?? $this-&amp;gt;cacheConfig['default_ttl']); $result = $this-&amp;gt;cache-&amp;gt;save($cacheItem); $this-&amp;gt;logger-&amp;gt;debug('Cache set', [ 'key' =&amp;gt; $key, 'ttl' =&amp;gt; $ttl ?? $this-&amp;gt;cacheConfig['default_ttl'], 'success' =&amp;gt; $result ]); return $result; } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Cache set failed', [ 'key' =&amp;gt; $key, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); return false; } } public function delete(string $key): bool { try { $result = $this-&amp;gt;cache-&amp;gt;deleteItem($key); $this-&amp;gt;logger-&amp;gt;debug('Cache delete', [ 'key' =&amp;gt; $key, 'success' =&amp;gt; $result ]); return $result; } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Cache delete failed', [ 'key' =&amp;gt; $key, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); return false; } } public function getPayment(string $paymentId): ?Payment { $key = $this-&amp;gt;generatePaymentKey($paymentId); return $this-&amp;gt;get($key); } public function setPayment(Payment $payment, int $ttl = null): bool { $key = $this-&amp;gt;generatePaymentKey($payment-&amp;gt;getId()); $ttl = $ttl ?? $this-&amp;gt;cacheConfig['payment_ttl']; return $this-&amp;gt;set($key, $payment, $ttl); } public function deletePayment(string $paymentId): bool { $key = $this-&amp;gt;generatePaymentKey($paymentId); return $this-&amp;gt;delete($key); } public function getSearchResults(string $query, array $filters = []): ?array { $key = $this-&amp;gt;generateSearchKey($query, $filters); return $this-&amp;gt;get($key); } public function setSearchResults(string $query, array $filters, array $results, int $ttl = null): bool { $key = $this-&amp;gt;generateSearchKey($query, $filters); $ttl = $ttl ?? $this-&amp;gt;cacheConfig['search_ttl']; return $this-&amp;gt;set($key, $results, $ttl); } private function generatePaymentKey(string $paymentId): string { return &amp;quot;payment:{$paymentId}&amp;quot;; } private function generateSearchKey(string $query, array $filters): string { $filterString = md5(serialize($filters)); return &amp;quot;search:&amp;quot; . md5($query) . &amp;quot;:{$filterString}&amp;quot;; } private function serialize(mixed $value): string { if ($this-&amp;gt;cacheConfig['enable_compression']) { return gzcompress(serialize($value)); } return serialize($value); } private function unserialize(string $value): mixed { if ($this-&amp;gt;cacheConfig['enable_compression']) { return unserialize(gzuncompress($value)); } return unserialize($value); }}&lt;/code&gt;## üß™ &lt;strong&gt;Tests et Validation&lt;/strong&gt;### &lt;strong&gt;Tests d&amp;rsquo;Int√©gration Multi-Sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Tests\Integration\MultiSource;use App\Domain\Payment\Payment;use App\Infrastructure\MultiSource\MultiSourcePaymentRepository;use App\Infrastructure\Repository\SqlPaymentRepository;use App\Infrastructure\Repository\RedisPaymentRepository;use App\Infrastructure\Repository\ElasticSearchPaymentRepository;class MultiSourcePaymentRepositoryTest extends TestCase{ private MultiSourcePaymentRepository $repository; private SqlPaymentRepository $sqlRepository; private RedisPaymentRepository $redisRepository; private ElasticSearchPaymentRepository $elasticSearchRepository; protected function setUp(): void { $this-&amp;gt;sqlRepository = $this-&amp;gt;createMock(SqlPaymentRepository::class); $this-&amp;gt;redisRepository = $this-&amp;gt;createMock(RedisPaymentRepository::class); $this-&amp;gt;elasticSearchRepository = $this-&amp;gt;createMock(ElasticSearchPaymentRepository::class); $this-&amp;gt;repository = new MultiSourcePaymentRepository( $this-&amp;gt;sqlRepository, $this-&amp;gt;redisRepository, $this-&amp;gt;elasticSearchRepository, $this-&amp;gt;createMock(LoggerInterface::class), ['read_strategy' =&amp;gt; 'cache_first', 'write_strategy' =&amp;gt; 'write_through'] ); } public function testSaveWithWriteThrough(): void { $payment = new Payment( 'payment-123', 'org-456', 'user-789', 100.00, 'EUR', 'processing', 'Test payment', new \DateTime() ); $this-&amp;gt;sqlRepository-&amp;gt;expects($this-&amp;gt;once())-&amp;gt;method('save')-&amp;gt;with($payment); $this-&amp;gt;redisRepository-&amp;gt;expects($this-&amp;gt;once())-&amp;gt;method('save')-&amp;gt;with($payment); $this-&amp;gt;elasticSearchRepository-&amp;gt;expects($this-&amp;gt;once())-&amp;gt;method('save')-&amp;gt;with($payment); $this-&amp;gt;repository-&amp;gt;save($payment); } public function testFindByIdWithCacheFirst(): void { $payment = new Payment( 'payment-123', 'org-456', 'user-789', 100.00, 'EUR', 'processing', 'Test payment', new \DateTime() ); $this-&amp;gt;redisRepository-&amp;gt;expects($this-&amp;gt;once()) -&amp;gt;method('findById') -&amp;gt;with('payment-123') -&amp;gt;willReturn($payment); $result = $this-&amp;gt;repository-&amp;gt;findById('payment-123'); $this-&amp;gt;assertEquals($payment, $result); } public function testFindByIdWithCacheMiss(): void { $payment = new Payment( 'payment-123', 'org-456', 'user-789', 100.00, 'EUR', 'processing', 'Test payment', new \DateTime() ); $this-&amp;gt;redisRepository-&amp;gt;expects($this-&amp;gt;once()) -&amp;gt;method('findById') -&amp;gt;with('payment-123') -&amp;gt;willReturn(null); $this-&amp;gt;sqlRepository-&amp;gt;expects($this-&amp;gt;once()) -&amp;gt;method('findById') -&amp;gt;with('payment-123') -&amp;gt;willReturn($payment); $this-&amp;gt;redisRepository-&amp;gt;expects($this-&amp;gt;once()) -&amp;gt;method('save') -&amp;gt;with($payment); $result = $this-&amp;gt;repository-&amp;gt;findById('payment-123'); $this-&amp;gt;assertEquals($payment, $result); }}&lt;/code&gt;## üìä &lt;strong&gt;Performance et Optimisation&lt;/strong&gt;### &lt;strong&gt;Strat√©gies d&amp;rsquo;Optimisation Multi-Sources&lt;/strong&gt;#### &lt;strong&gt;1. Cache Warming&lt;/strong&gt;&lt;code&gt;phppublic function warmCache(): void{ $this-&amp;gt;logger-&amp;gt;info('Warming cache for frequently accessed data'); // Charger les paiements r√©cents $recentPayments = $this-&amp;gt;sqlRepository-&amp;gt;findRecent(100); foreach ($recentPayments as $payment) { $this-&amp;gt;redisRepository-&amp;gt;save($payment); } // Charger les statistiques $stats = $this-&amp;gt;sqlRepository-&amp;gt;getStatistics(); $this-&amp;gt;redisRepository-&amp;gt;set('payment:stats', $stats, 3600);}&lt;/code&gt;#### &lt;strong&gt;2. Load Balancing&lt;/strong&gt;&lt;code&gt;phppublic function getOptimalSource(string $operation): string{ $sourceLoads = $this-&amp;gt;getSourceLoads(); $optimalSource = array_keys($sourceLoads, min($sourceLoads))[0]; $this-&amp;gt;logger-&amp;gt;debug('Selected optimal source', [ 'operation' =&amp;gt; $operation, 'source' =&amp;gt; $optimalSource, 'loads' =&amp;gt; $sourceLoads ]); return $optimalSource;}&lt;/code&gt;#### &lt;strong&gt;3. Monitoring des Sources&lt;/strong&gt;&lt;code&gt;phppublic function getSourceMetrics(): array{ return [ 'sql' =&amp;gt; $this-&amp;gt;getSqlMetrics(), 'redis' =&amp;gt; $this-&amp;gt;getRedisMetrics(), 'elasticsearch' =&amp;gt; $this-&amp;gt;getElasticSearchMetrics(), 'overall_health' =&amp;gt; $this-&amp;gt;getOverallHealth() ];}&lt;/code&gt;## üéØ &lt;strong&gt;Crit√®res d&amp;rsquo;Adoption&lt;/strong&gt;### &lt;strong&gt;Quand Utiliser Multi-sources Classique&lt;/strong&gt;#### &lt;strong&gt;‚úÖ Avantages&lt;/strong&gt;- &lt;strong&gt;Flexibilit√©&lt;/strong&gt; : Choix du meilleur stockage pour chaque cas d&amp;rsquo;usage- &lt;strong&gt;Performance&lt;/strong&gt; : Optimisation des performances par type d&amp;rsquo;op√©ration- &lt;strong&gt;R√©silience&lt;/strong&gt; : Redondance et failover entre sources- &lt;strong&gt;Scalabilit√©&lt;/strong&gt; : Possibilit√© de scaler ind√©pendamment chaque source- &lt;strong&gt;Co√ªt&lt;/strong&gt; : Optimisation des co√ªts selon les besoins#### &lt;strong&gt;‚ùå Inconv√©nients&lt;/strong&gt;- &lt;strong&gt;Complexit√©&lt;/strong&gt; : Gestion de plusieurs sources de donn√©es- &lt;strong&gt;Coh√©rence&lt;/strong&gt; : Risque d&amp;rsquo;incoh√©rence entre sources- &lt;strong&gt;Maintenance&lt;/strong&gt; : Plus de sources √† maintenir- &lt;strong&gt;Expertise&lt;/strong&gt; : √âquipe exp√©riment√©e requise#### &lt;strong&gt;üéØ Crit√®res d&amp;rsquo;Adoption&lt;/strong&gt;- &lt;strong&gt;Syst√®me complexe&lt;/strong&gt; : Besoins de performance diff√©rents par type d&amp;rsquo;op√©ration- &lt;strong&gt;Donn√©es h√©t√©rog√®nes&lt;/strong&gt; : Types de donn√©es diff√©rents n√©cessitant diff√©rents stockages- &lt;strong&gt;Performance critique&lt;/strong&gt; : Besoins de performance optimale- &lt;strong&gt;R√©silience importante&lt;/strong&gt; : Besoin de redondance et failover- &lt;strong&gt;√âquipe exp√©riment√©e&lt;/strong&gt; : Ma√Ætrise de plusieurs technologies de stockage- &lt;strong&gt;Budget suffisant&lt;/strong&gt; : Investissement en infrastructure multiple- &lt;strong&gt;Temps de d√©veloppement&lt;/strong&gt; : Suffisant pour impl√©menter cette complexit√©## üöÄ &lt;strong&gt;Votre Prochaine √âtape&lt;/strong&gt;

&lt;div class="chapter-navigation"&gt;
 &lt;h2 class="chapter-nav-title"&gt;üéØ Votre Prochaine √âtape&lt;/h2&gt;
 &lt;p class="chapter-nav-subtitle"&gt;Maintenant que vous comprenez les concepts de base et que j'ai partag√© mon exp√©rience avec Gyroscops, quel est votre contexte ?&lt;/p&gt;</description></item><item><title>Stockage Multi-sources - CQS</title><link>http://localhost:1313/chapitres/stockage/multi-sources/chapitre-53-stockage-multi-sources-cqs/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/multi-sources/chapitre-53-stockage-multi-sources-cqs/</guid><description>&lt;h2 id="-contexte-et-objectifs-pourquoi-cqs-avec-multi-sources-la-combinaison-cqs-avec-multi-sources-offre-une-architecture-optimis√©e-qui-s√©pare-clairement-les-responsabilit√©s-tout-en-exploitant-les-avantages-de-diff√©rents-types-de-stockage-cette-approche-permet-doptimiser-chaque-c√¥t√©-commandes-et-requ√™tes-avec-les-sources-les-plus-appropri√©es-avantages-de-cqs-avec-multi-sources--performance-optimis√©e--s√©paration-claire-entre-√©criture-et-lecture--flexibilit√©-maximale--choix-du-meilleur-stockage-pour-chaque-op√©ration--scalabilit√©--possibilit√©-de-scaler-ind√©pendamment-chaque-c√¥t√©--r√©silience--redondance-et-failover-entre-sources--maintenabilit√©--code-plus-clair-et-organis√©-contexte-gyroscopsdans-notre-√©cosyst√®me-user--organization--workflow--cloud-resources--billing-cqs-avec-multi-sources-est-particuli√®rement-pertinent-pour---workflows-de-commande--orchestration-des-processus-de-modification-avec-sources-optimis√©es--workflows-de-requ√™te--optimisation-des-lectures-avec-sources-sp√©cialis√©es--processus-de-facturation--s√©paration-des-√©critures-et-lectures-de-facturation--int√©grations-complexes--orchestration-des-int√©grations-avec-sources-multiples--architecture-cqs-avec-multi-sources-s√©paration-des-responsabilit√©s-c√¥t√©-commande-write-avec-multi-sources--command-workflows--orchestration-des-processus-de-modification--command-activities--ex√©cution-des-activit√©s-de-modification--event-handlers--gestion-des-√©v√©nements-de-domaine--command-bus--orchestration-des-commandes--write-sources--sources-optimis√©es-pour-les-√©critures--command-models--mod√®les-optimis√©s-pour-les-√©critures-c√¥t√©-requ√™te-read-avec-multi-sources--query-workflows--orchestration-des-processus-de-lecture--query-activities--ex√©cution-des-activit√©s-de-lecture--search-services--services-de-recherche-sp√©cialis√©s--query-bus--orchestration-des-requ√™tes--read-sources--sources-optimis√©es-pour-les-lectures--query-models--mod√®les-optimis√©s-pour-les-lectures-flux-de-donn√©esmermaidgraph-td----acommand----bcommand-bus----b----ccommand-workflow----c----dcommand-activities----d----ewrite-sources----e----fsql-database----e----gredis-cache----e----hfile-system--------iquery----jquery-bus----j----kquery-workflow----k----lquery-activities----l----mread-sources----m----nelasticsearch----m----oredis-cache----m----psql-database--------qevent----revent-handler----r----c--------sprojection----tread-model-update----t----m--impl√©mentation-pratique-1-command-side-avec-multi-sources-command-bus-avec-multi-sourcesphpphpnamespace-appapplicationcommandbusmultisourceuse-appdomaincommandcommandinterfaceuse-appdomaincommandcommandhandlerinterfaceuse-appinfrastructuremultisourcesourcerouteruse-psrlogloggerinterfaceclass-multisourcecommandbus----private-array-handlers------private-array-middleware------private-sourcerouter-sourcerouter----private-loggerinterface-logger----public-function-__construct--------sourcerouter-sourcerouter--------loggerinterface-logger-------------this-sourcerouter--sourcerouter--------this-logger--logger--------public-function-registerhandlerstring-commandclass-commandhandlerinterface-handler-void------------this-handlerscommandclass--handler--------public-function-addmiddlewarecallable-middleware-void------------this-middleware--middleware--------public-function-handlecommandinterface-command-void------------commandclass--get_classcommand----------------if-issetthis-handlerscommandclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-command-commandclass----------------handler--this-handlerscommandclass-----------------ex√©cuter-les-middleware--------this-executemiddlewarecommand-function-use-handler-command-------------this-logger-infoexecuting-command-via-multi-source-cqs-----------------command--get_classcommand----------------data--command-toarray------------------------------------handler-handlecommand----------------private-function-executemiddlewarecommandinterface-command-callable-next-void------------middleware--array_reversethis-middleware----------------foreach-middleware-as-mw-------------next--function-use-mw-command-next-----------------return-mwcommand-next------------------------------------next-----command-workflow-avec-multi-sourcesphpphpnamespace-appworkflowcommandpaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowuse-appinfrastructuremultisourcesourcerouterworkflowinterfaceinterface-paymentmultisourcecommandworkflowinterface----workflowmethod----public-function-processpaymentcommandwithmultisourcepaymentcommandrequest-request-paymentcommandresult--------workflowmethod----public-function-updatepaymentcommandwithmultisourcepaymentupdatecommandrequest-request-paymentcommandresult--------workflowmethod----public-function-deletepaymentcommandwithmultisourcepaymentdeletecommandrequest-request-paymentcommandresultactivityinterfaceinterface-paymentmultisourcecommandactivityinterface----activitymethod----public-function-validatepaymentcommandpaymentcommandrequest-request-validationresult--------activitymethod----public-function-executepaymentcommandpaymentcommandrequest-request-commandexecutionresult--------activitymethod----public-function-persisttowritesourcespayment-payment-array-sources-void--------activitymethod----public-function-updatecommandmodelspayment-payment-voidclass-paymentmultisourcecommandworkflow-implements-paymentmultisourcecommandworkflowinterface----private-paymentmultisourcecommandactivityinterface-commandactivity----private-sourcerouter-sourcerouter----public-function-__construct------------this-commandactivity--workflownewactivitystubpaymentmultisourcecommandactivityinterfaceclass--------this-sourcerouter--workflownewactivitystubsourcerouterclass--------public-function-processpaymentcommandwithmultisourcepaymentcommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------ex√©cution-de-la-commande------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------d√©terminer-les-sources-d√©criture-optimales------------writesources--yield-this-sourcerouter-routewritesave-execution-getpayment-------------------------persister-dans-les-sources-d√©criture------------yield-this-commandactivity-persisttowritesourcesexecution-getpayment-writesources-------------------------mettre-√†-jour-les-mod√®les-de-commande------------yield-this-commandactivity-updatecommandmodelsexecution-getpayment------------------------return-new-paymentcommandresulttrue-payment-command-processed-with-multi-source-cqs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage----------------public-function-updatepaymentcommandwithmultisourcepaymentupdatecommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande-de-mise-√†-jour------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------ex√©cution-de-la-mise-√†-jour------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------d√©terminer-les-sources-d√©criture-optimales------------writesources--yield-this-sourcerouter-routewriteupdate-execution-getpayment-------------------------persister-dans-les-sources-d√©criture------------yield-this-commandactivity-persisttowritesourcesexecution-getpayment-writesources-------------------------mettre-√†-jour-les-mod√®les-de-commande------------yield-this-commandactivity-updatecommandmodelsexecution-getpayment------------------------return-new-paymentcommandresulttrue-payment-update-command-processed-with-multi-source-cqs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage----------------public-function-deletepaymentcommandwithmultisourcepaymentdeletecommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande-de-suppression------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------ex√©cution-de-la-suppression------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------d√©terminer-les-sources-d√©criture-optimales------------writesources--yield-this-sourcerouter-routewritedelete-execution-getpayment-------------------------persister-dans-les-sources-d√©criture------------yield-this-commandactivity-persisttowritesourcesexecution-getpayment-writesources-------------------------mettre-√†-jour-les-mod√®les-de-commande------------yield-this-commandactivity-updatecommandmodelsexecution-getpayment------------------------return-new-paymentcommandresulttrue-payment-delete-command-processed-with-multi-source-cqs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage-------------2-query-side-avec-multi-sources-query-bus-avec-cache-et-multi-sourcesphpphpnamespace-appapplicationquerybusmultisourceuse-appdomainqueryqueryinterfaceuse-appdomainqueryqueryhandlerinterfaceuse-appinfrastructuremultisourcesourcerouteruse-appinfrastructuremultisourcemultisourcecachemanageruse-psrlogloggerinterfaceclass-multisourcequerybus----private-array-handlers------private-sourcerouter-sourcerouter----private-multisourcecachemanager-cachemanager----private-loggerinterface-logger----public-function-__construct--------sourcerouter-sourcerouter--------multisourcecachemanager-cachemanager--------loggerinterface-logger-------------this-sourcerouter--sourcerouter--------this-cachemanager--cachemanager--------this-logger--logger--------public-function-registerhandlerstring-queryclass-queryhandlerinterface-handler-void------------this-handlersqueryclass--handler--------public-function-handlequeryinterface-query-mixed------------queryclass--get_classquery----------------if-issetthis-handlersqueryclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-query-queryclass-----------------v√©rifier-le-cache--------cachekey--this-generatecachekeyquery--------cachedresult--this-cachemanager-getcachekey----------------if-cachedresult--null-------------this-logger-debugquery-result-served-from-cache-----------------query--queryclass----------------cachekey--cachekey------------------------------------return-cachedresult-----------------d√©terminer-la-source-de-lecture-optimale--------readsource--this-sourcerouter-routereadqueryclass-query-toarray-----------------ex√©cuter-la-requ√™te-via-la-source-optimale--------handler--this-handlersqueryclass--------result--handler-handlequery-readsource-----------------mettre-en-cache--------this-cachemanager-setcachekey-result-300----------------this-logger-infoquery-executed-and-cached-via-multi-source-cqs-------------query--queryclass------------source--readsource------------cachekey--cachekey------------------------return-result--------private-function-generatecachekeyqueryinterface-query-string------------return-multi_source_query_--md5serializequery-----query-workflow-avec-multi-sourcesphpphpnamespace-appworkflowquerypaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowuse-appinfrastructuremultisourcesourcerouterworkflowinterfaceinterface-paymentmultisourcequeryworkflowinterface----workflowmethod----public-function-searchpaymentswithmultisourcepaymentsearchquery-query-paymentsearchresult--------workflowmethod----public-function-getpaymentbyidwithmultisourcepaymentbyidquery-query-payment--------workflowmethod----public-function-getpaymentstatisticswithmultisourcepaymentstatisticsquery-query-array--------workflowmethod----public-function-getpaymentanalyticswithmultisourcepaymentanalyticsquery-query-arrayactivityinterfaceinterface-paymentmultisourcequeryactivityinterface----activitymethod----public-function-searchpaymentsinsourcepaymentsearchquery-query-string-source-array--------activitymethod----public-function-getpaymentfromsourcestring-paymentid-string-source-payment--------activitymethod----public-function-calculatepaymentstatisticsinsourcepaymentstatisticsquery-query-string-source-array--------activitymethod----public-function-generatepaymentanalyticsinsourcepaymentanalyticsquery-query-string-source-arrayclass-paymentmultisourcequeryworkflow-implements-paymentmultisourcequeryworkflowinterface----private-paymentmultisourcequeryactivityinterface-queryactivity----private-sourcerouter-sourcerouter----public-function-__construct------------this-queryactivity--workflownewactivitystubpaymentmultisourcequeryactivityinterfaceclass--------this-sourcerouter--workflownewactivitystubsourcerouterclass--------public-function-searchpaymentswithmultisourcepaymentsearchquery-query-paymentsearchresult------------try--------------d√©terminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadsearch-query-toarray-------------------------recherche-dans-la-source-optimale------------payments--yield-this-queryactivity-searchpaymentsinsourcequery-readsource-------------------------filtrage-et-tri------------filteredpayments--this-filterpaymentspayments-query------------sortedpayments--this-sortpaymentsfilteredpayments-query-------------------------pagination------------paginatedpayments--this-paginatepaymentssortedpayments-query------------------------return-new-paymentsearchresult----------------paginatedpayments----------------countfilteredpayments----------------query-getpage----------------query-getsize---------------------------------catch-exception-e-------------return-new-paymentsearchresult-0-query-getpage-query-getsize----------------public-function-getpaymentbyidwithmultisourcepaymentbyidquery-query-payment------------try--------------d√©terminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadfindbyid-id--query-getpaymentid------------------------return-yield-this-queryactivity-getpaymentfromsourcequery-getpaymentid-readsource---------catch-exception-e-------------return-null----------------public-function-getpaymentstatisticswithmultisourcepaymentstatisticsquery-query-array------------try--------------d√©terminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadstatistics-query-toarray------------------------return-yield-this-queryactivity-calculatepaymentstatisticsinsourcequery-readsource---------catch-exception-e-------------return-----------------public-function-getpaymentanalyticswithmultisourcepaymentanalyticsquery-query-array------------try--------------d√©terminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadanalytics-query-toarray------------------------return-yield-this-queryactivity-generatepaymentanalyticsinsourcequery-readsource---------catch-exception-e-------------return-----------------private-function-filterpaymentsarray-payments-paymentsearchquery-query-array------------return-array_filterpayments-functionpayment-use-query-------------if-query-getorganizationid--payment-getorganizationid--query-getorganizationid-----------------return-false------------------------------------if-query-getstatus--payment-getstatus--query-getstatus-----------------return-false------------------------------------if-query-getminamount--payment-getamount--query-getminamount-----------------return-false------------------------------------if-query-getmaxamount--payment-getamount--query-getmaxamount-----------------return-false------------------------------------return-true----------------private-function-sortpaymentsarray-payments-paymentsearchquery-query-array------------sortfield--query-getsortfield--createdat--------sortdirection--query-getsortdirection--desc----------------usortpayments-functiona-b-use-sortfield-sortdirection-------------valuea--this-getfieldvaluea-sortfield------------valueb--this-getfieldvalueb-sortfield------------------------if-sortdirection--asc-----------------return-valuea--valueb-------------else-----------------return-valueb--valuea------------------------------------return-payments--------private-function-paginatepaymentsarray-payments-paymentsearchquery-query-array------------page--query-getpage--1--------size--query-getsize--10--------offset--page---1--size----------------return-array_slicepayments-offset-size--------private-function-getfieldvaluepayment-payment-string-field-mixed------------switch-field-------------case-amount----------------return-payment-getamount------------case-createdat----------------return-payment-getcreatedat------------case-status----------------return-payment-getstatus------------default----------------return-payment-getcreatedat-------------3-service-de-synchronisation-multi-sources-service-de-synchronisation-cqsphpphpnamespace-appapplicationservicemultisourceuse-appdomaineventdomaineventuse-appinfrastructuremultisourcesourcerouteruse-appinfrastructuremultisourcemultisourcecachemanageruse-psrlogloggerinterfaceclass-multisourcecqssynchronizationservice----private-sourcerouter-sourcerouter----private-multisourcecachemanager-cachemanager----private-loggerinterface-logger----public-function-__construct--------sourcerouter-sourcerouter--------multisourcecachemanager-cachemanager--------loggerinterface-logger-------------this-sourcerouter--sourcerouter--------this-cachemanager--cachemanager--------this-logger--logger--------public-function-handleeventdomainevent-event-void------------try-------------this-logger-infohandling-event-via-multi-source-cqs-----------------eventtype--event-geteventtype----------------eventid--event-getid-------------------------d√©terminer-les-sources-affect√©es------------affectedsources--this-determineaffectedsourcesevent-------------------------mettre-√†-jour-chaque-source------------foreach-affectedsources-as-source-----------------this-updatesourcesource-event-------------------------------------invalider-le-cache-si-n√©cessaire------------if-this-shouldinvalidatecacheevent-----------------this-invalidatecacheevent---------------------------------catch-exception-e-------------this-logger-errorfailed-to-handle-event-via-multi-source-cqs-----------------eventtype--event-geteventtype----------------error--e-getmessage------------------------------------throw-e----------------public-function-synchronizesources-void------------try-------------this-logger-infosynchronizing-sources-via-multi-source-cqs-------------------------synchroniser-les-sources-de-lecture-avec-les-sources-d√©criture------------this-synchronizereadsources-------------------------nettoyer-les-caches-expir√©s------------this-cleanexpiredcaches------------------------this-logger-infosources-synchronized-successfully-via-multi-source-cqs---------------------catch-exception-e-------------this-logger-errorfailed-to-synchronize-sources-via-multi-source-cqs-----------------error--e-getmessage------------------------------------throw-e----------------private-function-determineaffectedsourcesdomainevent-event-array------------sources-------------------toujours-affecter-la-base-de-donn√©es-pour-les-√©v√©nements-critiques--------if-this-iscriticaleventevent-------------sources--database-------------------------affecter-le-cache-pour-les-√©v√©nements-de-lecture--------if-this-isreadeventevent-------------sources--cache-------------------------affecter-elasticsearch-pour-les-√©v√©nements-de-recherche--------if-this-issearcheventevent-------------sources--elasticsearch------------------------return-sources--------private-function-updatesourcestring-source-domainevent-event-void------------this-logger-debugupdating-source-------------source--source------------eventtype--event-geteventtype-------------------------impl√©mentation-sp√©cifique-√†-chaque-source--------switch-source-------------case-database----------------this-updatedatabaseevent----------------break------------case-cache----------------this-updatecacheevent----------------break------------case-elasticsearch----------------this-updateelasticsearchevent----------------break----------------private-function-shouldinvalidatecachedomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentupdated------------paymentdeleted------------paymentstatuschanged----------------private-function-invalidatecachedomainevent-event-void------------this-logger-debuginvalidating-cache-------------eventtype--event-geteventtype-------------------------invalider-les-caches-pertinents--------if-issetevent-getdatapaymentid-------------this-cachemanager-deletepaymentevent-getdatapaymentid----------------private-function-iscriticaleventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentcreated------------paymentupdated------------paymentdeleted----------------private-function-isreadeventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentviewed------------paymentsearched----------------private-function-issearcheventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentcreated------------paymentupdated------------paymentdeleted----------------private-function-updatedatabasedomainevent-event-void-------------impl√©mentation-de-la-mise-√†-jour-de-la-base-de-donn√©es--------private-function-updatecachedomainevent-event-void-------------impl√©mentation-de-la-mise-√†-jour-du-cache--------private-function-updateelasticsearchdomainevent-event-void-------------impl√©mentation-de-la-mise-√†-jour-delasticsearch--------private-function-synchronizereadsources-void-------------impl√©mentation-de-la-synchronisation-des-sources-de-lecture--------private-function-cleanexpiredcaches-void-------------impl√©mentation-du-nettoyage-des-caches-expir√©s------tests-et-validation-tests-dphpphpnamespace-apptestsintegrationmultisourceuse-appworkflowcommandpaymentpaymentcommandrequestuse-appworkflowquerypaymentpaymentsearchqueryuse-appapplicationcommandbusmultisourcemultisourcecommandbususe-appapplicationquerybusmultisourcemultisourcequerybususe-appinfrastructuremultisourcesourcerouterclass-multisourcecqstest-extends-testcase----private-multisourcecommandbus-commandbus----private-multisourcequerybus-querybus----private-sourcerouter-sourcerouter----protected-function-setup-void------------this-sourcerouter--this-createmocksourcerouterclass--------this-commandbus--new-multisourcecommandbus------------this-sourcerouter------------this-createmockloggerinterfaceclass----------------this-querybus--new-multisourcequerybus------------this-sourcerouter------------this-createmockmultisourcecachemanagerclass------------this-createmockloggerinterfaceclass----------------public-function-testcqsseparationwithmultisource-void-------------ex√©cuter-une-commande-avec-multi-source-cqs--------command--new-paymentcommandrequest------------create------------payment-123------------org-456------------user-789------------10000------------eur------------test-payment------------------------this-commandbus-handlecommand-----------------v√©rifier-avec-une-requ√™te--------query--new-paymentsearchqueryorg-456-0-10--------result--this-querybus-handlequery----------------this-assertgreaterthan0-result-gettotal--------public-function-testquerycachingwithmultisource-void------------query--new-paymentsearchqueryorg-456-0-10-----------------premi√®re-recherche--------result1--this-querybus-handlequery-----------------deuxi√®me-recherche-devrait-utiliser-le-cache--------result2--this-querybus-handlequery----------------this-assertequalsresult1-gettotal-result2-gettotal------performance-et-optimisation-strat√©gies-d-1-cache-strat√©gique-multi-sourcesphppublic-function-searchpaymentswithcachepaymentsearchquery-query-paymentsearchresult----cachekey--multi_source_payment_search_--md5serializequery--------if-cached--this-cachemanager-getcachekey---------return-cached------------result--this-searchpaymentswithmultisourcequery----this-cachemanager-setcachekey-result-300--------return-result-2-load-balancing-multi-sourcesphppublic-function-getoptimalsourceforoperationstring-operation-array-criteria---string----sourceloads--this-getsourceloads----optimalsource--array_keyssourceloads-minsourceloads0--------this-logger-debugselected-optimal-source-for-operation---------operation--operation--------source--optimalsource--------loads--sourceloads------------return-optimalsource-3-monitoring-des-sources-multi-sourcesphppublic-function-getmultisourcemetrics-array----return---------commandsources--this-getcommandsourcemetrics--------querysources--this-getquerysourcemetrics--------cachehitrate--this-getcachehitrate--------sourcehealth--this-getsourcehealth--------averageexecutiontime--this-getaverageexecutiontime------crit√®res-d-quand-utiliser-cqs-avec-multi-sources--avantages--performance-optimis√©e--s√©paration-claire-entre-√©criture-et-lecture--flexibilit√©-maximale--choix-du-meilleur-stockage-pour-chaque-op√©ration--scalabilit√©--possibilit√©-de-scaler-ind√©pendamment-chaque-c√¥t√©--r√©silience--redondance-et-failover-entre-sources--maintenabilit√©--code-plus-clair-et-organis√©--inconv√©nients--complexit√©-√©lev√©e--gestion-de-plusieurs-sources-de-donn√©es--coh√©rence--risque-dincoh√©rence-entre-sources--maintenance--plus-de-sources-√†-maintenir--expertise--√©quipe-exp√©riment√©e-requise--crit√®res-d--syst√®me-complexe--besoins-de-performance-diff√©rents-par-type-dop√©ration--donn√©es-h√©t√©rog√®nes--types-de-donn√©es-diff√©rents-n√©cessitant-diff√©rents-stockages--performance-critique--besoins-de-performance-optimale--s√©paration-des-responsabilit√©s--besoin-de-s√©parer-clairement-les-commandes-et-requ√™tes--√©quipe-exp√©riment√©e--ma√Ætrise-de-plusieurs-technologies-de-stockage-et-cqs--budget-suffisant--investissement-en-infrastructure-multiple--temps-de-d√©veloppement--suffisant-pour-impl√©menter-cette-complexit√©--votre-prochaine-√©tapehahahugoshortcode59s0hbhbcqs-avec-multi-sources-offre-un-√©quilibre-optimal-entre-performance-et-flexibilit√©-parfaitement-adapt√©-aux-besoins-complexes-de-gyroscops"&gt;üéØ &lt;strong&gt;Contexte et Objectifs&lt;/strong&gt;### **Pourquoi CQS avec Multi-sources ?**La combinaison CQS avec Multi-sources offre une architecture optimis√©e qui s√©pare clairement les responsabilit√©s tout en exploitant les avantages de diff√©rents types de stockage. Cette approche permet d&amp;rsquo;optimiser chaque c√¥t√© (commandes et requ√™tes) avec les sources les plus appropri√©es.#### &lt;strong&gt;Avantages de CQS avec Multi-sources&lt;/strong&gt;- &lt;strong&gt;Performance optimis√©e&lt;/strong&gt; : S√©paration claire entre √©criture et lecture- &lt;strong&gt;Flexibilit√© maximale&lt;/strong&gt; : Choix du meilleur stockage pour chaque op√©ration- &lt;strong&gt;Scalabilit√©&lt;/strong&gt; : Possibilit√© de scaler ind√©pendamment chaque c√¥t√©- &lt;strong&gt;R√©silience&lt;/strong&gt; : Redondance et failover entre sources- &lt;strong&gt;Maintenabilit√©&lt;/strong&gt; : Code plus clair et organis√©### &lt;strong&gt;Contexte Gyroscops&lt;/strong&gt;Dans notre √©cosyst√®me &lt;strong&gt;User ‚Üí Organization ‚Üí Workflow ‚Üí Cloud Resources ‚Üí Billing&lt;/strong&gt;, CQS avec Multi-sources est particuli√®rement pertinent pour :- &lt;strong&gt;Workflows de commande&lt;/strong&gt; : Orchestration des processus de modification avec sources optimis√©es- &lt;strong&gt;Workflows de requ√™te&lt;/strong&gt; : Optimisation des lectures avec sources sp√©cialis√©es- &lt;strong&gt;Processus de facturation&lt;/strong&gt; : S√©paration des √©critures et lectures de facturation- &lt;strong&gt;Int√©grations complexes&lt;/strong&gt; : Orchestration des int√©grations avec sources multiples## üèóÔ∏è &lt;strong&gt;Architecture CQS avec Multi-sources&lt;/strong&gt;### &lt;strong&gt;S√©paration des Responsabilit√©s&lt;/strong&gt;#### &lt;strong&gt;C√¥t√© Commande (Write) avec Multi-sources&lt;/strong&gt;- &lt;strong&gt;Command Workflows&lt;/strong&gt; : Orchestration des processus de modification- &lt;strong&gt;Command Activities&lt;/strong&gt; : Ex√©cution des activit√©s de modification- &lt;strong&gt;Event Handlers&lt;/strong&gt; : Gestion des √©v√©nements de domaine- &lt;strong&gt;Command Bus&lt;/strong&gt; : Orchestration des commandes- &lt;strong&gt;Write Sources&lt;/strong&gt; : Sources optimis√©es pour les √©critures- &lt;strong&gt;Command Models&lt;/strong&gt; : Mod√®les optimis√©s pour les √©critures#### &lt;strong&gt;C√¥t√© Requ√™te (Read) avec Multi-sources&lt;/strong&gt;- &lt;strong&gt;Query Workflows&lt;/strong&gt; : Orchestration des processus de lecture- &lt;strong&gt;Query Activities&lt;/strong&gt; : Ex√©cution des activit√©s de lecture- &lt;strong&gt;Search Services&lt;/strong&gt; : Services de recherche sp√©cialis√©s- &lt;strong&gt;Query Bus&lt;/strong&gt; : Orchestration des requ√™tes- &lt;strong&gt;Read Sources&lt;/strong&gt; : Sources optimis√©es pour les lectures- &lt;strong&gt;Query Models&lt;/strong&gt; : Mod√®les optimis√©s pour les lectures### &lt;strong&gt;Flux de Donn√©es&lt;/strong&gt;&lt;code&gt;mermaidgraph TD A[Command] --&amp;gt; B[Command Bus] B --&amp;gt; C[Command Workflow] C --&amp;gt; D[Command Activities] D --&amp;gt; E[Write Sources] E --&amp;gt; F[SQL Database] E --&amp;gt; G[Redis Cache] E --&amp;gt; H[File System] I[Query] --&amp;gt; J[Query Bus] J --&amp;gt; K[Query Workflow] K --&amp;gt; L[Query Activities] L --&amp;gt; M[Read Sources] M --&amp;gt; N[ElasticSearch] M --&amp;gt; O[Redis Cache] M --&amp;gt; P[SQL Database] Q[Event] --&amp;gt; R[Event Handler] R --&amp;gt; C S[Projection] --&amp;gt; T[Read Model Update] T --&amp;gt; M&lt;/code&gt;## üíª &lt;strong&gt;Impl√©mentation Pratique&lt;/strong&gt;### &lt;strong&gt;1. Command Side avec Multi-sources&lt;/strong&gt;#### &lt;strong&gt;Command Bus avec Multi-sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\CommandBus\MultiSource;use App\Domain\Command\CommandInterface;use App\Domain\Command\CommandHandlerInterface;use App\Infrastructure\MultiSource\SourceRouter;use Psr\Log\LoggerInterface;class MultiSourceCommandBus{ private array $handlers = []; private array $middleware = []; private SourceRouter $sourceRouter; private LoggerInterface $logger; public function __construct( SourceRouter $sourceRouter, LoggerInterface $logger ) { $this-&amp;gt;sourceRouter = $sourceRouter; $this-&amp;gt;logger = $logger; } public function registerHandler(string $commandClass, CommandHandlerInterface $handler): void { $this-&amp;gt;handlers[$commandClass] = $handler; } public function addMiddleware(callable $middleware): void { $this-&amp;gt;middleware[] = $middleware; } public function handle(CommandInterface $command): void { $commandClass = get_class($command); if (!isset($this-&amp;gt;handlers[$commandClass])) { throw new \InvalidArgumentException(&amp;quot;No handler registered for command: $commandClass&amp;quot;); } $handler = $this-&amp;gt;handlers[$commandClass]; // Ex√©cuter les middleware $this-&amp;gt;executeMiddleware($command, function() use ($handler, $command) { $this-&amp;gt;logger-&amp;gt;info('Executing command via Multi-source CQS', [ 'command' =&amp;gt; get_class($command), 'data' =&amp;gt; $command-&amp;gt;toArray() ]); $handler-&amp;gt;handle($command); }); } private function executeMiddleware(CommandInterface $command, callable $next): void { $middleware = array_reverse($this-&amp;gt;middleware); foreach ($middleware as $mw) { $next = function() use ($mw, $command, $next) { return $mw($command, $next); }; } $next(); }}&lt;/code&gt;#### &lt;strong&gt;Command Workflow avec Multi-sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Workflow\Command\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Infrastructure\MultiSource\SourceRouter;#[WorkflowInterface]interface PaymentMultiSourceCommandWorkflowInterface{ #[WorkflowMethod] public function processPaymentCommandWithMultiSource(PaymentCommandRequest $request): PaymentCommandResult; #[WorkflowMethod] public function updatePaymentCommandWithMultiSource(PaymentUpdateCommandRequest $request): PaymentCommandResult; #[WorkflowMethod] public function deletePaymentCommandWithMultiSource(PaymentDeleteCommandRequest $request): PaymentCommandResult;}#[ActivityInterface]interface PaymentMultiSourceCommandActivityInterface{ #[ActivityMethod] public function validatePaymentCommand(PaymentCommandRequest $request): ValidationResult; #[ActivityMethod] public function executePaymentCommand(PaymentCommandRequest $request): CommandExecutionResult; #[ActivityMethod] public function persistToWriteSources(Payment $payment, array $sources): void; #[ActivityMethod] public function updateCommandModels(Payment $payment): void;}class PaymentMultiSourceCommandWorkflow implements PaymentMultiSourceCommandWorkflowInterface{ private PaymentMultiSourceCommandActivityInterface $commandActivity; private SourceRouter $sourceRouter; public function __construct() { $this-&amp;gt;commandActivity = Workflow::newActivityStub(PaymentMultiSourceCommandActivityInterface::class); $this-&amp;gt;sourceRouter = Workflow::newActivityStub(SourceRouter::class); } public function processPaymentCommandWithMultiSource(PaymentCommandRequest $request): PaymentCommandResult { try { // Validation de la commande $validation = yield $this-&amp;gt;commandActivity-&amp;gt;validatePaymentCommand($request); if (!$validation-&amp;gt;isValid()) { return new PaymentCommandResult(false, $validation-&amp;gt;getError()); } // Ex√©cution de la commande $execution = yield $this-&amp;gt;commandActivity-&amp;gt;executePaymentCommand($request); if (!$execution-&amp;gt;isSuccess()) { return new PaymentCommandResult(false, $execution-&amp;gt;getError()); } // D√©terminer les sources d'√©criture optimales $writeSources = yield $this-&amp;gt;sourceRouter-&amp;gt;routeWrite('save', $execution-&amp;gt;getPayment()); // Persister dans les sources d'√©criture yield $this-&amp;gt;commandActivity-&amp;gt;persistToWriteSources($execution-&amp;gt;getPayment(), $writeSources); // Mettre √† jour les mod√®les de commande yield $this-&amp;gt;commandActivity-&amp;gt;updateCommandModels($execution-&amp;gt;getPayment()); return new PaymentCommandResult(true, 'Payment command processed with Multi-source CQS'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e-&amp;gt;getMessage()); } } public function updatePaymentCommandWithMultiSource(PaymentUpdateCommandRequest $request): PaymentCommandResult { try { // Validation de la commande de mise √† jour $validation = yield $this-&amp;gt;commandActivity-&amp;gt;validatePaymentCommand($request); if (!$validation-&amp;gt;isValid()) { return new PaymentCommandResult(false, $validation-&amp;gt;getError()); } // Ex√©cution de la mise √† jour $execution = yield $this-&amp;gt;commandActivity-&amp;gt;executePaymentCommand($request); if (!$execution-&amp;gt;isSuccess()) { return new PaymentCommandResult(false, $execution-&amp;gt;getError()); } // D√©terminer les sources d'√©criture optimales $writeSources = yield $this-&amp;gt;sourceRouter-&amp;gt;routeWrite('update', $execution-&amp;gt;getPayment()); // Persister dans les sources d'√©criture yield $this-&amp;gt;commandActivity-&amp;gt;persistToWriteSources($execution-&amp;gt;getPayment(), $writeSources); // Mettre √† jour les mod√®les de commande yield $this-&amp;gt;commandActivity-&amp;gt;updateCommandModels($execution-&amp;gt;getPayment()); return new PaymentCommandResult(true, 'Payment update command processed with Multi-source CQS'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e-&amp;gt;getMessage()); } } public function deletePaymentCommandWithMultiSource(PaymentDeleteCommandRequest $request): PaymentCommandResult { try { // Validation de la commande de suppression $validation = yield $this-&amp;gt;commandActivity-&amp;gt;validatePaymentCommand($request); if (!$validation-&amp;gt;isValid()) { return new PaymentCommandResult(false, $validation-&amp;gt;getError()); } // Ex√©cution de la suppression $execution = yield $this-&amp;gt;commandActivity-&amp;gt;executePaymentCommand($request); if (!$execution-&amp;gt;isSuccess()) { return new PaymentCommandResult(false, $execution-&amp;gt;getError()); } // D√©terminer les sources d'√©criture optimales $writeSources = yield $this-&amp;gt;sourceRouter-&amp;gt;routeWrite('delete', $execution-&amp;gt;getPayment()); // Persister dans les sources d'√©criture yield $this-&amp;gt;commandActivity-&amp;gt;persistToWriteSources($execution-&amp;gt;getPayment(), $writeSources); // Mettre √† jour les mod√®les de commande yield $this-&amp;gt;commandActivity-&amp;gt;updateCommandModels($execution-&amp;gt;getPayment()); return new PaymentCommandResult(true, 'Payment delete command processed with Multi-source CQS'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e-&amp;gt;getMessage()); } }}&lt;/code&gt;### &lt;strong&gt;2. Query Side avec Multi-sources&lt;/strong&gt;#### &lt;strong&gt;Query Bus avec Cache et Multi-sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\QueryBus\MultiSource;use App\Domain\Query\QueryInterface;use App\Domain\Query\QueryHandlerInterface;use App\Infrastructure\MultiSource\SourceRouter;use App\Infrastructure\MultiSource\MultiSourceCacheManager;use Psr\Log\LoggerInterface;class MultiSourceQueryBus{ private array $handlers = []; private SourceRouter $sourceRouter; private MultiSourceCacheManager $cacheManager; private LoggerInterface $logger; public function __construct( SourceRouter $sourceRouter, MultiSourceCacheManager $cacheManager, LoggerInterface $logger ) { $this-&amp;gt;sourceRouter = $sourceRouter; $this-&amp;gt;cacheManager = $cacheManager; $this-&amp;gt;logger = $logger; } public function registerHandler(string $queryClass, QueryHandlerInterface $handler): void { $this-&amp;gt;handlers[$queryClass] = $handler; } public function handle(QueryInterface $query): mixed { $queryClass = get_class($query); if (!isset($this-&amp;gt;handlers[$queryClass])) { throw new \InvalidArgumentException(&amp;quot;No handler registered for query: $queryClass&amp;quot;); } // V√©rifier le cache $cacheKey = $this-&amp;gt;generateCacheKey($query); $cachedResult = $this-&amp;gt;cacheManager-&amp;gt;get($cacheKey); if ($cachedResult !== null) { $this-&amp;gt;logger-&amp;gt;debug('Query result served from cache', [ 'query' =&amp;gt; $queryClass, 'cacheKey' =&amp;gt; $cacheKey ]); return $cachedResult; } // D√©terminer la source de lecture optimale $readSource = $this-&amp;gt;sourceRouter-&amp;gt;routeRead($queryClass, $query-&amp;gt;toArray()); // Ex√©cuter la requ√™te via la source optimale $handler = $this-&amp;gt;handlers[$queryClass]; $result = $handler-&amp;gt;handle($query, $readSource); // Mettre en cache $this-&amp;gt;cacheManager-&amp;gt;set($cacheKey, $result, 300); $this-&amp;gt;logger-&amp;gt;info('Query executed and cached via Multi-source CQS', [ 'query' =&amp;gt; $queryClass, 'source' =&amp;gt; $readSource, 'cacheKey' =&amp;gt; $cacheKey ]); return $result; } private function generateCacheKey(QueryInterface $query): string { return 'multi_source_query_' . md5(serialize($query)); }}&lt;/code&gt;#### &lt;strong&gt;Query Workflow avec Multi-sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Workflow\Query\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Infrastructure\MultiSource\SourceRouter;#[WorkflowInterface]interface PaymentMultiSourceQueryWorkflowInterface{ #[WorkflowMethod] public function searchPaymentsWithMultiSource(PaymentSearchQuery $query): PaymentSearchResult; #[WorkflowMethod] public function getPaymentByIdWithMultiSource(PaymentByIdQuery $query): ?Payment; #[WorkflowMethod] public function getPaymentStatisticsWithMultiSource(PaymentStatisticsQuery $query): array; #[WorkflowMethod] public function getPaymentAnalyticsWithMultiSource(PaymentAnalyticsQuery $query): array;}#[ActivityInterface]interface PaymentMultiSourceQueryActivityInterface{ #[ActivityMethod] public function searchPaymentsInSource(PaymentSearchQuery $query, string $source): array; #[ActivityMethod] public function getPaymentFromSource(string $paymentId, string $source): ?Payment; #[ActivityMethod] public function calculatePaymentStatisticsInSource(PaymentStatisticsQuery $query, string $source): array; #[ActivityMethod] public function generatePaymentAnalyticsInSource(PaymentAnalyticsQuery $query, string $source): array;}class PaymentMultiSourceQueryWorkflow implements PaymentMultiSourceQueryWorkflowInterface{ private PaymentMultiSourceQueryActivityInterface $queryActivity; private SourceRouter $sourceRouter; public function __construct() { $this-&amp;gt;queryActivity = Workflow::newActivityStub(PaymentMultiSourceQueryActivityInterface::class); $this-&amp;gt;sourceRouter = Workflow::newActivityStub(SourceRouter::class); } public function searchPaymentsWithMultiSource(PaymentSearchQuery $query): PaymentSearchResult { try { // D√©terminer la source de lecture optimale $readSource = yield $this-&amp;gt;sourceRouter-&amp;gt;routeRead('search', $query-&amp;gt;toArray()); // Recherche dans la source optimale $payments = yield $this-&amp;gt;queryActivity-&amp;gt;searchPaymentsInSource($query, $readSource); // Filtrage et tri $filteredPayments = $this-&amp;gt;filterPayments($payments, $query); $sortedPayments = $this-&amp;gt;sortPayments($filteredPayments, $query); // Pagination $paginatedPayments = $this-&amp;gt;paginatePayments($sortedPayments, $query); return new PaymentSearchResult( $paginatedPayments, count($filteredPayments), $query-&amp;gt;getPage(), $query-&amp;gt;getSize() ); } catch (\Exception $e) { return new PaymentSearchResult([], 0, $query-&amp;gt;getPage(), $query-&amp;gt;getSize()); } } public function getPaymentByIdWithMultiSource(PaymentByIdQuery $query): ?Payment { try { // D√©terminer la source de lecture optimale $readSource = yield $this-&amp;gt;sourceRouter-&amp;gt;routeRead('findById', ['id' =&amp;gt; $query-&amp;gt;getPaymentId()]); return yield $this-&amp;gt;queryActivity-&amp;gt;getPaymentFromSource($query-&amp;gt;getPaymentId(), $readSource); } catch (\Exception $e) { return null; } } public function getPaymentStatisticsWithMultiSource(PaymentStatisticsQuery $query): array { try { // D√©terminer la source de lecture optimale $readSource = yield $this-&amp;gt;sourceRouter-&amp;gt;routeRead('statistics', $query-&amp;gt;toArray()); return yield $this-&amp;gt;queryActivity-&amp;gt;calculatePaymentStatisticsInSource($query, $readSource); } catch (\Exception $e) { return []; } } public function getPaymentAnalyticsWithMultiSource(PaymentAnalyticsQuery $query): array { try { // D√©terminer la source de lecture optimale $readSource = yield $this-&amp;gt;sourceRouter-&amp;gt;routeRead('analytics', $query-&amp;gt;toArray()); return yield $this-&amp;gt;queryActivity-&amp;gt;generatePaymentAnalyticsInSource($query, $readSource); } catch (\Exception $e) { return []; } } private function filterPayments(array $payments, PaymentSearchQuery $query): array { return array_filter($payments, function($payment) use ($query) { if ($query-&amp;gt;getOrganizationId() &amp;amp;&amp;amp; $payment-&amp;gt;getOrganizationId() !== $query-&amp;gt;getOrganizationId()) { return false; } if ($query-&amp;gt;getStatus() &amp;amp;&amp;amp; $payment-&amp;gt;getStatus() !== $query-&amp;gt;getStatus()) { return false; } if ($query-&amp;gt;getMinAmount() &amp;amp;&amp;amp; $payment-&amp;gt;getAmount() &amp;lt; $query-&amp;gt;getMinAmount()) { return false; } if ($query-&amp;gt;getMaxAmount() &amp;amp;&amp;amp; $payment-&amp;gt;getAmount() &amp;gt; $query-&amp;gt;getMaxAmount()) { return false; } return true; }); } private function sortPayments(array $payments, PaymentSearchQuery $query): array { $sortField = $query-&amp;gt;getSortField() ?? 'createdAt'; $sortDirection = $query-&amp;gt;getSortDirection() ?? 'desc'; usort($payments, function($a, $b) use ($sortField, $sortDirection) { $valueA = $this-&amp;gt;getFieldValue($a, $sortField); $valueB = $this-&amp;gt;getFieldValue($b, $sortField); if ($sortDirection === 'asc') { return $valueA &amp;lt;=&amp;gt; $valueB; } else { return $valueB &amp;lt;=&amp;gt; $valueA; } }); return $payments; } private function paginatePayments(array $payments, PaymentSearchQuery $query): array { $page = $query-&amp;gt;getPage() ?? 1; $size = $query-&amp;gt;getSize() ?? 10; $offset = ($page - 1) * $size; return array_slice($payments, $offset, $size); } private function getFieldValue(Payment $payment, string $field): mixed { switch ($field) { case 'amount': return $payment-&amp;gt;getAmount(); case 'createdAt': return $payment-&amp;gt;getCreatedAt(); case 'status': return $payment-&amp;gt;getStatus(); default: return $payment-&amp;gt;getCreatedAt(); } }}&lt;/code&gt;### &lt;strong&gt;3. Service de Synchronisation Multi-Sources&lt;/strong&gt;#### &lt;strong&gt;Service de Synchronisation CQS&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Service\MultiSource;use App\Domain\Event\DomainEvent;use App\Infrastructure\MultiSource\SourceRouter;use App\Infrastructure\MultiSource\MultiSourceCacheManager;use Psr\Log\LoggerInterface;class MultiSourceCqsSynchronizationService{ private SourceRouter $sourceRouter; private MultiSourceCacheManager $cacheManager; private LoggerInterface $logger; public function __construct( SourceRouter $sourceRouter, MultiSourceCacheManager $cacheManager, LoggerInterface $logger ) { $this-&amp;gt;sourceRouter = $sourceRouter; $this-&amp;gt;cacheManager = $cacheManager; $this-&amp;gt;logger = $logger; } public function handleEvent(DomainEvent $event): void { try { $this-&amp;gt;logger-&amp;gt;info('Handling event via Multi-source CQS', [ 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'eventId' =&amp;gt; $event-&amp;gt;getId() ]); // D√©terminer les sources affect√©es $affectedSources = $this-&amp;gt;determineAffectedSources($event); // Mettre √† jour chaque source foreach ($affectedSources as $source) { $this-&amp;gt;updateSource($source, $event); } // Invalider le cache si n√©cessaire if ($this-&amp;gt;shouldInvalidateCache($event)) { $this-&amp;gt;invalidateCache($event); } } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to handle event via Multi-source CQS', [ 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } public function synchronizeSources(): void { try { $this-&amp;gt;logger-&amp;gt;info('Synchronizing sources via Multi-source CQS'); // Synchroniser les sources de lecture avec les sources d'√©criture $this-&amp;gt;synchronizeReadSources(); // Nettoyer les caches expir√©s $this-&amp;gt;cleanExpiredCaches(); $this-&amp;gt;logger-&amp;gt;info('Sources synchronized successfully via Multi-source CQS'); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to synchronize sources via Multi-source CQS', [ 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } private function determineAffectedSources(DomainEvent $event): array { $sources = []; // Toujours affecter la base de donn√©es pour les √©v√©nements critiques if ($this-&amp;gt;isCriticalEvent($event)) { $sources[] = 'database'; } // Affecter le cache pour les √©v√©nements de lecture if ($this-&amp;gt;isReadEvent($event)) { $sources[] = 'cache'; } // Affecter ElasticSearch pour les √©v√©nements de recherche if ($this-&amp;gt;isSearchEvent($event)) { $sources[] = 'elasticsearch'; } return $sources; } private function updateSource(string $source, DomainEvent $event): void { $this-&amp;gt;logger-&amp;gt;debug('Updating source', [ 'source' =&amp;gt; $source, 'eventType' =&amp;gt; $event-&amp;gt;getEventType() ]); // Impl√©mentation sp√©cifique √† chaque source switch ($source) { case 'database': $this-&amp;gt;updateDatabase($event); break; case 'cache': $this-&amp;gt;updateCache($event); break; case 'elasticsearch': $this-&amp;gt;updateElasticSearch($event); break; } } private function shouldInvalidateCache(DomainEvent $event): bool { return in_array($event-&amp;gt;getEventType(), [ 'PaymentUpdated', 'PaymentDeleted', 'PaymentStatusChanged' ]); } private function invalidateCache(DomainEvent $event): void { $this-&amp;gt;logger-&amp;gt;debug('Invalidating cache', [ 'eventType' =&amp;gt; $event-&amp;gt;getEventType() ]); // Invalider les caches pertinents if (isset($event-&amp;gt;getData()['paymentId'])) { $this-&amp;gt;cacheManager-&amp;gt;deletePayment($event-&amp;gt;getData()['paymentId']); } } private function isCriticalEvent(DomainEvent $event): bool { return in_array($event-&amp;gt;getEventType(), [ 'PaymentCreated', 'PaymentUpdated', 'PaymentDeleted' ]); } private function isReadEvent(DomainEvent $event): bool { return in_array($event-&amp;gt;getEventType(), [ 'PaymentViewed', 'PaymentSearched' ]); } private function isSearchEvent(DomainEvent $event): bool { return in_array($event-&amp;gt;getEventType(), [ 'PaymentCreated', 'PaymentUpdated', 'PaymentDeleted' ]); } private function updateDatabase(DomainEvent $event): void { // Impl√©mentation de la mise √† jour de la base de donn√©es } private function updateCache(DomainEvent $event): void { // Impl√©mentation de la mise √† jour du cache } private function updateElasticSearch(DomainEvent $event): void { // Impl√©mentation de la mise √† jour d'ElasticSearch } private function synchronizeReadSources(): void { // Impl√©mentation de la synchronisation des sources de lecture } private function cleanExpiredCaches(): void { // Impl√©mentation du nettoyage des caches expir√©s }}&lt;/code&gt;## üß™ &lt;strong&gt;Tests et Validation&lt;/strong&gt;### &lt;strong&gt;Tests d&amp;rsquo;Int√©gration CQS Multi-Sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Tests\Integration\MultiSource;use App\Workflow\Command\Payment\PaymentCommandRequest;use App\Workflow\Query\Payment\PaymentSearchQuery;use App\Application\CommandBus\MultiSource\MultiSourceCommandBus;use App\Application\QueryBus\MultiSource\MultiSourceQueryBus;use App\Infrastructure\MultiSource\SourceRouter;class MultiSourceCqsTest extends TestCase{ private MultiSourceCommandBus $commandBus; private MultiSourceQueryBus $queryBus; private SourceRouter $sourceRouter; protected function setUp(): void { $this-&amp;gt;sourceRouter = $this-&amp;gt;createMock(SourceRouter::class); $this-&amp;gt;commandBus = new MultiSourceCommandBus( $this-&amp;gt;sourceRouter, $this-&amp;gt;createMock(LoggerInterface::class) ); $this-&amp;gt;queryBus = new MultiSourceQueryBus( $this-&amp;gt;sourceRouter, $this-&amp;gt;createMock(MultiSourceCacheManager::class), $this-&amp;gt;createMock(LoggerInterface::class) ); } public function testCqsSeparationWithMultiSource(): void { // Ex√©cuter une commande avec Multi-source CQS $command = new PaymentCommandRequest( 'CREATE', 'payment-123', 'org-456', 'user-789', 100.00, 'EUR', 'Test payment' ); $this-&amp;gt;commandBus-&amp;gt;handle($command); // V√©rifier avec une requ√™te $query = new PaymentSearchQuery('org-456', 0, 10); $result = $this-&amp;gt;queryBus-&amp;gt;handle($query); $this-&amp;gt;assertGreaterThan(0, $result-&amp;gt;getTotal()); } public function testQueryCachingWithMultiSource(): void { $query = new PaymentSearchQuery('org-456', 0, 10); // Premi√®re recherche $result1 = $this-&amp;gt;queryBus-&amp;gt;handle($query); // Deuxi√®me recherche (devrait utiliser le cache) $result2 = $this-&amp;gt;queryBus-&amp;gt;handle($query); $this-&amp;gt;assertEquals($result1-&amp;gt;getTotal(), $result2-&amp;gt;getTotal()); }}&lt;/code&gt;## üìä &lt;strong&gt;Performance et Optimisation&lt;/strong&gt;### &lt;strong&gt;Strat√©gies d&amp;rsquo;Optimisation CQS Multi-Sources&lt;/strong&gt;#### &lt;strong&gt;1. Cache Strat√©gique Multi-Sources&lt;/strong&gt;&lt;code&gt;phppublic function searchPaymentsWithCache(PaymentSearchQuery $query): PaymentSearchResult{ $cacheKey = 'multi_source_payment_search_' . md5(serialize($query)); if ($cached = $this-&amp;gt;cacheManager-&amp;gt;get($cacheKey)) { return $cached; } $result = $this-&amp;gt;searchPaymentsWithMultiSource($query); $this-&amp;gt;cacheManager-&amp;gt;set($cacheKey, $result, 300); return $result;}&lt;/code&gt;#### &lt;strong&gt;2. Load Balancing Multi-Sources&lt;/strong&gt;&lt;code&gt;phppublic function getOptimalSourceForOperation(string $operation, array $criteria = []): string{ $sourceLoads = $this-&amp;gt;getSourceLoads(); $optimalSource = array_keys($sourceLoads, min($sourceLoads))[0]; $this-&amp;gt;logger-&amp;gt;debug('Selected optimal source for operation', [ 'operation' =&amp;gt; $operation, 'source' =&amp;gt; $optimalSource, 'loads' =&amp;gt; $sourceLoads ]); return $optimalSource;}&lt;/code&gt;#### &lt;strong&gt;3. Monitoring des Sources Multi-Sources&lt;/strong&gt;&lt;code&gt;phppublic function getMultiSourceMetrics(): array{ return [ 'commandSources' =&amp;gt; $this-&amp;gt;getCommandSourceMetrics(), 'querySources' =&amp;gt; $this-&amp;gt;getQuerySourceMetrics(), 'cacheHitRate' =&amp;gt; $this-&amp;gt;getCacheHitRate(), 'sourceHealth' =&amp;gt; $this-&amp;gt;getSourceHealth(), 'averageExecutionTime' =&amp;gt; $this-&amp;gt;getAverageExecutionTime() ];}&lt;/code&gt;## üéØ &lt;strong&gt;Crit√®res d&amp;rsquo;Adoption&lt;/strong&gt;### &lt;strong&gt;Quand Utiliser CQS avec Multi-sources&lt;/strong&gt;#### &lt;strong&gt;‚úÖ Avantages&lt;/strong&gt;- &lt;strong&gt;Performance optimis√©e&lt;/strong&gt; : S√©paration claire entre √©criture et lecture- &lt;strong&gt;Flexibilit√© maximale&lt;/strong&gt; : Choix du meilleur stockage pour chaque op√©ration- &lt;strong&gt;Scalabilit√©&lt;/strong&gt; : Possibilit√© de scaler ind√©pendamment chaque c√¥t√©- &lt;strong&gt;R√©silience&lt;/strong&gt; : Redondance et failover entre sources- &lt;strong&gt;Maintenabilit√©&lt;/strong&gt; : Code plus clair et organis√©#### &lt;strong&gt;‚ùå Inconv√©nients&lt;/strong&gt;- &lt;strong&gt;Complexit√© √©lev√©e&lt;/strong&gt; : Gestion de plusieurs sources de donn√©es- &lt;strong&gt;Coh√©rence&lt;/strong&gt; : Risque d&amp;rsquo;incoh√©rence entre sources- &lt;strong&gt;Maintenance&lt;/strong&gt; : Plus de sources √† maintenir- &lt;strong&gt;Expertise&lt;/strong&gt; : √âquipe exp√©riment√©e requise#### &lt;strong&gt;üéØ Crit√®res d&amp;rsquo;Adoption&lt;/strong&gt;- &lt;strong&gt;Syst√®me complexe&lt;/strong&gt; : Besoins de performance diff√©rents par type d&amp;rsquo;op√©ration- &lt;strong&gt;Donn√©es h√©t√©rog√®nes&lt;/strong&gt; : Types de donn√©es diff√©rents n√©cessitant diff√©rents stockages- &lt;strong&gt;Performance critique&lt;/strong&gt; : Besoins de performance optimale- &lt;strong&gt;S√©paration des responsabilit√©s&lt;/strong&gt; : Besoin de s√©parer clairement les commandes et requ√™tes- &lt;strong&gt;√âquipe exp√©riment√©e&lt;/strong&gt; : Ma√Ætrise de plusieurs technologies de stockage et CQS- &lt;strong&gt;Budget suffisant&lt;/strong&gt; : Investissement en infrastructure multiple- &lt;strong&gt;Temps de d√©veloppement&lt;/strong&gt; : Suffisant pour impl√©menter cette complexit√©## üöÄ &lt;strong&gt;Votre Prochaine √âtape&lt;/strong&gt;

&lt;div class="chapter-navigation"&gt;
 &lt;h2 class="chapter-nav-title"&gt;üéØ Votre Prochaine √âtape&lt;/h2&gt;
 &lt;p class="chapter-nav-subtitle"&gt;Maintenant que vous comprenez les concepts de base et que j'ai partag√© mon exp√©rience avec Gyroscops, quel est votre contexte ?&lt;/p&gt;</description></item><item><title>Stockage Multi-sources - CQRS</title><link>http://localhost:1313/chapitres/stockage/multi-sources/chapitre-54-stockage-multi-sources-cqrs/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/multi-sources/chapitre-54-stockage-multi-sources-cqrs/</guid><description>&lt;h2 id="-contexte-et-objectifs-lnous-arrivons-maintenant-√†-lapproche-la-plus-sophistiqu√©e-pour-multi-sources--cqrs-complet-cette-combinaison-offre-une-architecture-hautement-scalable-et-flexible-parfaite-pour-les-syst√®mes-n√©cessitant-s√©paration-maximale-des-responsabilit√©s-et-optimisation-des-performances-pourquoi-cqrs-avec-multi-sources---s√©paration-totale--commandes-et-requ√™tes-compl√®tement-d√©coupl√©es--flexibilit√©-maximale--choix-du-meilleur-stockage-pour-chaque-op√©ration--scalabilit√©-maximale--possibilit√©-de-scaler-ind√©pendamment-chaque-c√¥t√©--performance-optimale--chaque-c√¥t√©-optimis√©-pour-son-usage--r√©silience--redondance-et-failover-entre-sources--maintenabilit√©--code-plus-clair-et-organis√©-contexte-gyroscopsdans-notre-√©cosyst√®me-user--organization--workflow--cloud-resources--billing-cqrs-avec-multi-sources-est-la-solution-ultime-pour---workflows-de-commande--orchestration-des-processus-de-modification-avec-sources-optimis√©es--workflows-de-requ√™te--optimisation-des-lectures-avec-sources-sp√©cialis√©es--processus-de-facturation--s√©paration-compl√®te-des-√©critures-et-lectures-de-facturation--int√©grations-complexes--orchestration-des-int√©grations-avec-sources-multiples--architecture-cqrs-avec-multi-sources-s√©paration-compl√®te-des-responsabilit√©s-command-side-write-avec-multi-sources--command-workflows--orchestration-des-processus-de-modification--command-activities--ex√©cution-des-activit√©s-de-modification--event-handlers--gestion-des-√©v√©nements-de-domaine--command-bus--orchestration-des-commandes--write-sources--sources-optimis√©es-pour-les-√©critures--command-models--mod√®les-optimis√©s-pour-les-√©critures--projections--mise-√†-jour-des-vues-mat√©rialis√©es-query-side-read-avec-multi-sources--query-workflows--orchestration-des-processus-de-lecture--query-activities--ex√©cution-des-activit√©s-de-lecture--search-services--services-de-recherche-sp√©cialis√©s--query-bus--orchestration-des-requ√™tes--read-sources--sources-optimis√©es-pour-les-lectures--query-models--mod√®les-optimis√©s-pour-les-lectures--caches--optimisation-des-performances-flux-de-donn√©es-completmermaidgraph-td----acommand----bcommand-bus----b----ccommand-workflow----c----dcommand-activities----d----ewrite-sources----e----fsql-database----e----gredis-cache----e----hfile-system----e----ievent-store--------jquery----kquery-bus----k----lquery-workflow----l----mquery-activities----m----nread-sources----n----oelasticsearch----n----predis-cache----n----qsql-database----n----rread-models--------sevent----tevent-handler----t----c--------uprojection----vread-model-update----v----r--------wcommand-model----xwrite-optimization----x----e--------yquery-model----zread-optimization----z----n--impl√©mentation-compl√®te-1-command-side-avec-multi-sources-command-bus-avec-multi-sourcesphpphpnamespace-appapplicationcommandbusmultisourceuse-appdomaincommandcommandinterfaceuse-appdomaincommandcommandhandlerinterfaceuse-appinfrastructuremultisourcesourcerouteruse-psrlogloggerinterfaceclass-multisourcecqrscommandbus----private-array-handlers------private-array-middleware------private-sourcerouter-sourcerouter----private-loggerinterface-logger----public-function-__construct--------sourcerouter-sourcerouter--------loggerinterface-logger-------------this-sourcerouter--sourcerouter--------this-logger--logger--------public-function-registerhandlerstring-commandclass-commandhandlerinterface-handler-void------------this-handlerscommandclass--handler--------public-function-addmiddlewarecallable-middleware-void------------this-middleware--middleware--------public-function-handlecommandinterface-command-void------------commandclass--get_classcommand----------------if-issetthis-handlerscommandclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-command-commandclass----------------handler--this-handlerscommandclass-----------------ex√©cuter-les-middleware--------this-executemiddlewarecommand-function-use-handler-command-------------this-logger-infoexecuting-command-via-multi-source-cqrs-----------------command--get_classcommand----------------data--command-toarray------------------------------------handler-handlecommand----------------private-function-executemiddlewarecommandinterface-command-callable-next-void------------middleware--array_reversethis-middleware----------------foreach-middleware-as-mw-------------next--function-use-mw-command-next-----------------return-mwcommand-next------------------------------------next-----command-workflow-avec-multi-sourcesphpphpnamespace-appworkflowcommandpaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowuse-appinfrastructuremultisourcesourcerouterworkflowinterfaceinterface-paymentmultisourcecqrscommandworkflowinterface----workflowmethod----public-function-processpaymentcommandwithmultisourcecqrspaymentcommandrequest-request-paymentcommandresult--------workflowmethod----public-function-updatepaymentcommandwithmultisourcecqrspaymentupdatecommandrequest-request-paymentcommandresult--------workflowmethod----public-function-deletepaymentcommandwithmultisourcecqrspaymentdeletecommandrequest-request-paymentcommandresultactivityinterfaceinterface-paymentmultisourcecqrscommandactivityinterface----activitymethod----public-function-validatepaymentcommandpaymentcommandrequest-request-validationresult--------activitymethod----public-function-executepaymentcommandpaymentcommandrequest-request-commandexecutionresult--------activitymethod----public-function-persisttowritesourcespayment-payment-array-sources-void--------activitymethod----public-function-updateprojectionspayment-payment-void--------activitymethod----public-function-updatecommandmodelspayment-payment-voidclass-paymentmultisourcecqrscommandworkflow-implements-paymentmultisourcecqrscommandworkflowinterface----private-paymentmultisourcecqrscommandactivityinterface-commandactivity----private-sourcerouter-sourcerouter----public-function-__construct------------this-commandactivity--workflownewactivitystubpaymentmultisourcecqrscommandactivityinterfaceclass--------this-sourcerouter--workflownewactivitystubsourcerouterclass--------public-function-processpaymentcommandwithmultisourcecqrspaymentcommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------ex√©cution-de-la-commande------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------d√©terminer-les-sources-d√©criture-optimales------------writesources--yield-this-sourcerouter-routewritesave-execution-getpayment-------------------------persister-dans-les-sources-d√©criture------------yield-this-commandactivity-persisttowritesourcesexecution-getpayment-writesources-------------------------mettre-√†-jour-les-projections------------yield-this-commandactivity-updateprojectionsexecution-getpayment-------------------------mettre-√†-jour-les-mod√®les-de-commande------------yield-this-commandactivity-updatecommandmodelsexecution-getpayment------------------------return-new-paymentcommandresulttrue-payment-command-processed-with-multi-source-cqrs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage----------------public-function-updatepaymentcommandwithmultisourcecqrspaymentupdatecommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande-de-mise-√†-jour------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------ex√©cution-de-la-mise-√†-jour------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------d√©terminer-les-sources-d√©criture-optimales------------writesources--yield-this-sourcerouter-routewriteupdate-execution-getpayment-------------------------persister-dans-les-sources-d√©criture------------yield-this-commandactivity-persisttowritesourcesexecution-getpayment-writesources-------------------------mettre-√†-jour-les-projections------------yield-this-commandactivity-updateprojectionsexecution-getpayment-------------------------mettre-√†-jour-les-mod√®les-de-commande------------yield-this-commandactivity-updatecommandmodelsexecution-getpayment------------------------return-new-paymentcommandresulttrue-payment-update-command-processed-with-multi-source-cqrs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage----------------public-function-deletepaymentcommandwithmultisourcecqrspaymentdeletecommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande-de-suppression------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------ex√©cution-de-la-suppression------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------d√©terminer-les-sources-d√©criture-optimales------------writesources--yield-this-sourcerouter-routewritedelete-execution-getpayment-------------------------persister-dans-les-sources-d√©criture------------yield-this-commandactivity-persisttowritesourcesexecution-getpayment-writesources-------------------------mettre-√†-jour-les-projections------------yield-this-commandactivity-updateprojectionsexecution-getpayment-------------------------mettre-√†-jour-les-mod√®les-de-commande------------yield-this-commandactivity-updatecommandmodelsexecution-getpayment------------------------return-new-paymentcommandresulttrue-payment-delete-command-processed-with-multi-source-cqrs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage-------------2-query-side-avec-multi-sources-query-bus-avec-cache-et-multi-sourcesphpphpnamespace-appapplicationquerybusmultisourceuse-appdomainqueryqueryinterfaceuse-appdomainqueryqueryhandlerinterfaceuse-appinfrastructuremultisourcesourcerouteruse-appinfrastructuremultisourcemultisourcecachemanageruse-psrlogloggerinterfaceclass-multisourcecqrsquerybus----private-array-handlers------private-sourcerouter-sourcerouter----private-multisourcecachemanager-cachemanager----private-loggerinterface-logger----public-function-__construct--------sourcerouter-sourcerouter--------multisourcecachemanager-cachemanager--------loggerinterface-logger-------------this-sourcerouter--sourcerouter--------this-cachemanager--cachemanager--------this-logger--logger--------public-function-registerhandlerstring-queryclass-queryhandlerinterface-handler-void------------this-handlersqueryclass--handler--------public-function-handlequeryinterface-query-mixed------------queryclass--get_classquery----------------if-issetthis-handlersqueryclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-query-queryclass-----------------v√©rifier-le-cache--------cachekey--this-generatecachekeyquery--------cachedresult--this-cachemanager-getcachekey----------------if-cachedresult--null-------------this-logger-debugquery-result-served-from-cache-----------------query--queryclass----------------cachekey--cachekey------------------------------------return-cachedresult-----------------d√©terminer-la-source-de-lecture-optimale--------readsource--this-sourcerouter-routereadqueryclass-query-toarray-----------------ex√©cuter-la-requ√™te-via-la-source-optimale--------handler--this-handlersqueryclass--------result--handler-handlequery-readsource-----------------mettre-en-cache--------this-cachemanager-setcachekey-result-300----------------this-logger-infoquery-executed-and-cached-via-multi-source-cqrs-------------query--queryclass------------source--readsource------------cachekey--cachekey------------------------return-result--------private-function-generatecachekeyqueryinterface-query-string------------return-multi_source_cqrs_query_--md5serializequery-----query-workflow-avec-multi-sourcesphpphpnamespace-appworkflowquerypaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowuse-appinfrastructuremultisourcesourcerouterworkflowinterfaceinterface-paymentmultisourcecqrsqueryworkflowinterface----workflowmethod----public-function-searchpaymentswithmultisourcecqrspaymentsearchquery-query-paymentsearchresult--------workflowmethod----public-function-getpaymentbyidwithmultisourcecqrspaymentbyidquery-query-payment--------workflowmethod----public-function-getpaymentstatisticswithmultisourcecqrspaymentstatisticsquery-query-array--------workflowmethod----public-function-getpaymentanalyticswithmultisourcecqrspaymentanalyticsquery-query-array--------workflowmethod----public-function-getpaymenttimelinewithmultisourcecqrspaymenttimelinequery-query-arrayactivityinterfaceinterface-paymentmultisourcecqrsqueryactivityinterface----activitymethod----public-function-searchpaymentsinsourcepaymentsearchquery-query-string-source-array--------activitymethod----public-function-getpaymentfromsourcestring-paymentid-string-source-payment--------activitymethod----public-function-calculatepaymentstatisticsinsourcepaymentstatisticsquery-query-string-source-array--------activitymethod----public-function-generatepaymentanalyticsinsourcepaymentanalyticsquery-query-string-source-array--------activitymethod----public-function-geteventsbycorrelationidstring-correlationid-string-source-array--------activitymethod----public-function-updatequerymodelsarray-events-voidclass-paymentmultisourcecqrsqueryworkflow-implements-paymentmultisourcecqrsqueryworkflowinterface----private-paymentmultisourcecqrsqueryactivityinterface-queryactivity----private-sourcerouter-sourcerouter----public-function-__construct------------this-queryactivity--workflownewactivitystubpaymentmultisourcecqrsqueryactivityinterfaceclass--------this-sourcerouter--workflownewactivitystubsourcerouterclass--------public-function-searchpaymentswithmultisourcecqrspaymentsearchquery-query-paymentsearchresult------------try--------------d√©terminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadsearch-query-toarray-------------------------recherche-dans-la-source-optimale------------payments--yield-this-queryactivity-searchpaymentsinsourcequery-readsource-------------------------filtrage-et-tri------------filteredpayments--this-filterpaymentspayments-query------------sortedpayments--this-sortpaymentsfilteredpayments-query-------------------------pagination------------paginatedpayments--this-paginatepaymentssortedpayments-query------------------------return-new-paymentsearchresult----------------paginatedpayments----------------countfilteredpayments----------------query-getpage----------------query-getsize---------------------------------catch-exception-e-------------return-new-paymentsearchresult-0-query-getpage-query-getsize----------------public-function-getpaymentbyidwithmultisourcecqrspaymentbyidquery-query-payment------------try--------------d√©terminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadfindbyid-id--query-getpaymentid------------------------return-yield-this-queryactivity-getpaymentfromsourcequery-getpaymentid-readsource---------catch-exception-e-------------return-null----------------public-function-getpaymentstatisticswithmultisourcecqrspaymentstatisticsquery-query-array------------try--------------d√©terminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadstatistics-query-toarray------------------------return-yield-this-queryactivity-calculatepaymentstatisticsinsourcequery-readsource---------catch-exception-e-------------return-----------------public-function-getpaymentanalyticswithmultisourcecqrspaymentanalyticsquery-query-array------------try--------------d√©terminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadanalytics-query-toarray------------------------return-yield-this-queryactivity-generatepaymentanalyticsinsourcequery-readsource---------catch-exception-e-------------return-----------------public-function-getpaymenttimelinewithmultisourcecqrspaymenttimelinequery-query-array------------try--------------d√©terminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadtimeline-query-toarray------------------------events--yield-this-queryactivity-geteventsbycorrelationidquery-getcorrelationid-readsource------------------------timeline--------------foreach-events-as-event-----------------timeline----------------------eventid--event-getid--------------------aggregateid--event-getaggregateid--------------------eventtype--event-geteventtype--------------------timestamp--event-gettimestamp--------------------data--event-toarray--------------------metadata--event-getmetadata----------------------------------------------------return-timeline---------------------catch-exception-e-------------return-----------------private-function-filterpaymentsarray-payments-paymentsearchquery-query-array------------return-array_filterpayments-functionpayment-use-query-------------if-query-getorganizationid--payment-getorganizationid--query-getorganizationid-----------------return-false------------------------------------if-query-getstatus--payment-getstatus--query-getstatus-----------------return-false------------------------------------if-query-getminamount--payment-getamount--query-getminamount-----------------return-false------------------------------------if-query-getmaxamount--payment-getamount--query-getmaxamount-----------------return-false------------------------------------return-true----------------private-function-sortpaymentsarray-payments-paymentsearchquery-query-array------------sortfield--query-getsortfield--createdat--------sortdirection--query-getsortdirection--desc----------------usortpayments-functiona-b-use-sortfield-sortdirection-------------valuea--this-getfieldvaluea-sortfield------------valueb--this-getfieldvalueb-sortfield------------------------if-sortdirection--asc-----------------return-valuea--valueb-------------else-----------------return-valueb--valuea------------------------------------return-payments--------private-function-paginatepaymentsarray-payments-paymentsearchquery-query-array------------page--query-getpage--1--------size--query-getsize--10--------offset--page---1--size----------------return-array_slicepayments-offset-size--------private-function-getfieldvaluepayment-payment-string-field-mixed------------switch-field-------------case-amount----------------return-payment-getamount------------case-createdat----------------return-payment-getcreatedat------------case-status----------------return-payment-getstatus------------default----------------return-payment-getcreatedat-------------3-service-de-projection-avanc√©-avec-multi-sources-service-de-projection-avec-multi-sourcesphpphpnamespace-appapplicationservicemultisourceuse-appdomaineventdomaineventuse-appinfrastructuremultisourcesourcerouteruse-appinfrastructuremultisourcemultisourcecachemanageruse-psrlogloggerinterfaceclass-multisourcecqrsprojectionservice----private-sourcerouter-sourcerouter----private-multisourcecachemanager-cachemanager----private-loggerinterface-logger----public-function-__construct--------sourcerouter-sourcerouter--------multisourcecachemanager-cachemanager--------loggerinterface-logger-------------this-sourcerouter--sourcerouter--------this-cachemanager--cachemanager--------this-logger--logger--------public-function-handleeventdomainevent-event-void------------try-------------this-logger-infohandling-event-via-multi-source-cqrs-----------------eventtype--event-geteventtype----------------eventid--event-getid-------------------------d√©terminer-les-sources-affect√©es------------affectedsources--this-determineaffectedsourcesevent-------------------------mettre-√†-jour-chaque-source------------foreach-affectedsources-as-source-----------------this-updatesourcesource-event-------------------------------------invalider-le-cache-si-n√©cessaire------------if-this-shouldinvalidatecacheevent-----------------this-invalidatecacheevent---------------------------------catch-exception-e-------------this-logger-errorfailed-to-handle-event-via-multi-source-cqrs-----------------eventtype--event-geteventtype----------------error--e-getmessage------------------------------------throw-e----------------public-function-rebuildprojectionstring-projectiontype-void------------try-------------this-logger-inforebuilding-projection-via-multi-source-cqrs-----------------projectiontype--projectiontype-------------------------------------reconstruire-la-projection-dans-toutes-les-sources-pertinentes------------sources--this-getprojectionsourcesprojectiontype------------------------foreach-sources-as-source-----------------this-rebuildprojectioninsourceprojectiontype-source------------------------------------this-logger-infoprojection-rebuilt-successfully-via-multi-source-cqrs-----------------projectiontype--projectiontype---------------------------------catch-exception-e-------------this-logger-errorfailed-to-rebuild-projection-via-multi-source-cqrs-----------------projectiontype--projectiontype----------------error--e-getmessage------------------------------------throw-e----------------private-function-determineaffectedsourcesdomainevent-event-array------------sources-------------------toujours-affecter-la-base-de-donn√©es-pour-les-√©v√©nements-critiques--------if-this-iscriticaleventevent-------------sources--database-------------------------affecter-le-cache-pour-les-√©v√©nements-de-lecture--------if-this-isreadeventevent-------------sources--cache-------------------------affecter-elasticsearch-pour-les-√©v√©nements-de-recherche--------if-this-issearcheventevent-------------sources--elasticsearch-------------------------affecter-les-read-models-pour-les-projections--------if-this-isprojectioneventevent-------------sources--read_models------------------------return-sources--------private-function-updatesourcestring-source-domainevent-event-void------------this-logger-debugupdating-source-------------source--source------------eventtype--event-geteventtype-------------------------impl√©mentation-sp√©cifique-√†-chaque-source--------switch-source-------------case-database----------------this-updatedatabaseevent----------------break------------case-cache----------------this-updatecacheevent----------------break------------case-elasticsearch----------------this-updateelasticsearchevent----------------break------------case-read_models----------------this-updatereadmodelsevent----------------break----------------private-function-shouldinvalidatecachedomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentupdated------------paymentdeleted------------paymentstatuschanged----------------private-function-invalidatecachedomainevent-event-void------------this-logger-debuginvalidating-cache-------------eventtype--event-geteventtype-------------------------invalider-les-caches-pertinents--------if-issetevent-getdatapaymentid-------------this-cachemanager-deletepaymentevent-getdatapaymentid----------------private-function-iscriticaleventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentcreated------------paymentupdated------------paymentdeleted----------------private-function-isreadeventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentviewed------------paymentsearched----------------private-function-issearcheventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentcreated------------paymentupdated------------paymentdeleted----------------private-function-isprojectioneventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentcreated------------paymentupdated------------paymentdeleted------------paymentstatuschanged----------------private-function-getprojectionsourcesstring-projectiontype-array------------switch-projectiontype-------------case-payment_summary----------------return-database-cache-elasticsearch------------case-payment_analytics----------------return-elasticsearch-read_models------------case-payment_timeline----------------return-read_models-cache------------default----------------return-database----------------private-function-rebuildprojectioninsourcestring-projectiontype-string-source-void------------this-logger-debugrebuilding-projection-in-source-------------projectiontype--projectiontype------------source--source-------------------------impl√©mentation-sp√©cifique-√†-chaque-source--------switch-source-------------case-database----------------this-rebuilddatabaseprojectionprojectiontype----------------break------------case-cache----------------this-rebuildcacheprojectionprojectiontype----------------break------------case-elasticsearch----------------this-rebuildelasticsearchprojectionprojectiontype----------------break------------case-read_models----------------this-rebuildreadmodelsprojectionprojectiontype----------------break----------------private-function-updatedatabasedomainevent-event-void-------------impl√©mentation-de-la-mise-√†-jour-de-la-base-de-donn√©es--------private-function-updatecachedomainevent-event-void-------------impl√©mentation-de-la-mise-√†-jour-du-cache--------private-function-updateelasticsearchdomainevent-event-void-------------impl√©mentation-de-la-mise-√†-jour-delasticsearch--------private-function-updatereadmodelsdomainevent-event-void-------------impl√©mentation-de-la-mise-√†-jour-des-read-models--------private-function-rebuilddatabaseprojectionstring-projectiontype-void-------------impl√©mentation-de-la-reconstruction-de-la-projection-en-base-de-donn√©es--------private-function-rebuildcacheprojectionstring-projectiontype-void-------------impl√©mentation-de-la-reconstruction-de-la-projection-en-cache--------private-function-rebuildelasticsearchprojectionstring-projectiontype-void-------------impl√©mentation-de-la-reconstruction-de-la-projection-en-elasticsearch--------private-function-rebuildreadmodelsprojectionstring-projectiontype-void-------------impl√©mentation-de-la-reconstruction-de-la-projection-dans-les-read-models------tests-et-validation-tests-dphpphpnamespace-apptestsintegrationmultisourceuse-appworkflowcommandpaymentpaymentcommandrequestuse-appworkflowquerypaymentpaymentsearchqueryuse-appapplicationcommandbusmultisourcemultisourcecqrscommandbususe-appapplicationquerybusmultisourcemultisourcecqrsquerybususe-appinfrastructuremultisourcesourcerouterclass-multisourcecqrstest-extends-testcase----private-multisourcecqrscommandbus-commandbus----private-multisourcecqrsquerybus-querybus----private-sourcerouter-sourcerouter----protected-function-setup-void------------this-sourcerouter--this-createmocksourcerouterclass--------this-commandbus--new-multisourcecqrscommandbus------------this-sourcerouter------------this-createmockloggerinterfaceclass----------------this-querybus--new-multisourcecqrsquerybus------------this-sourcerouter------------this-createmockmultisourcecachemanagerclass------------this-createmockloggerinterfaceclass----------------public-function-testcqrsseparationwithmultisource-void-------------ex√©cuter-une-commande-avec-multi-source-cqrs--------command--new-paymentcommandrequest------------create------------payment-123------------org-456------------user-789------------10000------------eur------------test-payment------------------------this-commandbus-handlecommand-----------------v√©rifier-avec-une-requ√™te--------query--new-paymentsearchqueryorg-456-0-10--------result--this-querybus-handlequery----------------this-assertgreaterthan0-result-gettotal--------public-function-testquerycachingwithmultisource-void------------query--new-paymentsearchqueryorg-456-0-10-----------------premi√®re-recherche--------result1--this-querybus-handlequery-----------------deuxi√®me-recherche-devrait-utiliser-le-cache--------result2--this-querybus-handlequery----------------this-assertequalsresult1-gettotal-result2-gettotal------performance-et-optimisation-strat√©gies-d-1-cache-multi-niveaux-avec-multi-sourcesphppublic-function-searchpaymentswithcachepaymentsearchquery-query-paymentsearchresult-----cache-l1-m√©moire----if-issetthis-memorycachequery-getcachekey---------return-this-memorycachequery-getcachekey-------------cache-l2-redis----if-cached--this-redis-getpayment_search_ms_cqrsquery-getcachekey---------result--paymentsearchresultfromarrayjson_decodecached-true--------this-memorycachequery-getcachekey--result--------return-result-------------multi-source-cqrs----result--this-searchpaymentswithmultisourcecqrsquery---------mettre-en-cache----this-memorycachequery-getcachekey--result----this-redis-setexpayment_search_ms_cqrsquery-getcachekey-300-json_encoderesult-toarray--------return-result-2-projections-asynchrones-avec-multi-sourcesphppublic-function-handleeventasyncdomainevent-event-void-----mettre-en-queue-pour-traitement-asynchrone----this-messagebus-dispatchnew-processmultisourcecqrsprojectioncommandevent-3-monitoring-des-sources-multi-sourcesphppublic-function-getmultisourcecqrsmetrics-array----return---------commandsources--this-getcommandsourcemetrics--------querysources--this-getquerysourcemetrics--------projections--this-getprojectionmetrics--------cachehitrate--this-getcachehitrate--------sourcehealth--this-getsourcehealth--------averageexecutiontime--this-getaverageexecutiontime------crit√®res-d-quand-utiliser-cqrs-avec-multi-sources--avantages--s√©paration-totale--commandes-et-requ√™tes-compl√®tement-d√©coupl√©es--flexibilit√©-maximale--choix-du-meilleur-stockage-pour-chaque-op√©ration--scalabilit√©-maximale--possibilit√©-de-scaler-ind√©pendamment--performance-optimale--chaque-c√¥t√©-optimis√©-pour-son-usage--r√©silience--redondance-et-failover-entre-sources--maintenabilit√©--code-plus-clair-et-organis√©--inconv√©nients--complexit√©-maximale--gestion-de-plusieurs-sources-de-donn√©es--coh√©rence--risque-dincoh√©rence-entre-sources--maintenance--plus-de-sources-√†-maintenir--expertise--√©quipe-tr√®s-exp√©riment√©e-requise--co√ªt--infrastructure-tr√®s-co√ªteuse--crit√®res-d--syst√®me-tr√®s-complexe--besoins-de-scalabilit√©-maximale--donn√©es-h√©t√©rog√®nes--types-de-donn√©es-diff√©rents-n√©cessitant-diff√©rents-stockages--performance-critique--besoins-de-performance-maximale--s√©paration-des-responsabilit√©s--besoin-de-s√©parer-clairement-les-commandes-et-requ√™tes--√©quipe-tr√®s-exp√©riment√©e--ma√Ætrise-de-plusieurs-technologies-de-stockage-et-cqrs--budget-important--investissement-en-infrastructure-multiple--temps-de-d√©veloppement--suffisant-pour-impl√©menter-cette-complexit√©--maintenance--√©quipe-capable-de-maintenir-cette-complexit√©--votre-prochaine-√©tapehahahugoshortcode60s0hbhbcqrs-avec-multi-sources-repr√©sente-l"&gt;üéØ &lt;strong&gt;Contexte et Objectifs&lt;/strong&gt;### &lt;strong&gt;L&amp;rsquo;Architecture Maximale : CQRS avec Multi-sources&lt;/strong&gt;Nous arrivons maintenant √† l&amp;rsquo;approche la plus sophistiqu√©e pour Multi-sources : &lt;strong&gt;CQRS complet&lt;/strong&gt;. Cette combinaison offre une architecture hautement scalable et flexible, parfaite pour les syst√®mes n√©cessitant s√©paration maximale des responsabilit√©s et optimisation des performances.#### &lt;strong&gt;Pourquoi CQRS avec Multi-sources ?&lt;/strong&gt;- &lt;strong&gt;S√©paration totale&lt;/strong&gt; : Commandes et requ√™tes compl√®tement d√©coupl√©es- &lt;strong&gt;Flexibilit√© maximale&lt;/strong&gt; : Choix du meilleur stockage pour chaque op√©ration- &lt;strong&gt;Scalabilit√© maximale&lt;/strong&gt; : Possibilit√© de scaler ind√©pendamment chaque c√¥t√©- &lt;strong&gt;Performance optimale&lt;/strong&gt; : Chaque c√¥t√© optimis√© pour son usage- &lt;strong&gt;R√©silience&lt;/strong&gt; : Redondance et failover entre sources- &lt;strong&gt;Maintenabilit√©&lt;/strong&gt; : Code plus clair et organis√©### &lt;strong&gt;Contexte Gyroscops&lt;/strong&gt;Dans notre √©cosyst√®me &lt;strong&gt;User ‚Üí Organization ‚Üí Workflow ‚Üí Cloud Resources ‚Üí Billing&lt;/strong&gt;, CQRS avec Multi-sources est la solution ultime pour :- &lt;strong&gt;Workflows de commande&lt;/strong&gt; : Orchestration des processus de modification avec sources optimis√©es- &lt;strong&gt;Workflows de requ√™te&lt;/strong&gt; : Optimisation des lectures avec sources sp√©cialis√©es- &lt;strong&gt;Processus de facturation&lt;/strong&gt; : S√©paration compl√®te des √©critures et lectures de facturation- &lt;strong&gt;Int√©grations complexes&lt;/strong&gt; : Orchestration des int√©grations avec sources multiples## üèóÔ∏è &lt;strong&gt;Architecture CQRS avec Multi-sources&lt;/strong&gt;### &lt;strong&gt;S√©paration Compl√®te des Responsabilit√©s&lt;/strong&gt;#### &lt;strong&gt;Command Side (Write) avec Multi-sources&lt;/strong&gt;- &lt;strong&gt;Command Workflows&lt;/strong&gt; : Orchestration des processus de modification- &lt;strong&gt;Command Activities&lt;/strong&gt; : Ex√©cution des activit√©s de modification- &lt;strong&gt;Event Handlers&lt;/strong&gt; : Gestion des √©v√©nements de domaine- &lt;strong&gt;Command Bus&lt;/strong&gt; : Orchestration des commandes- &lt;strong&gt;Write Sources&lt;/strong&gt; : Sources optimis√©es pour les √©critures- &lt;strong&gt;Command Models&lt;/strong&gt; : Mod√®les optimis√©s pour les √©critures- &lt;strong&gt;Projections&lt;/strong&gt; : Mise √† jour des vues mat√©rialis√©es#### &lt;strong&gt;Query Side (Read) avec Multi-sources&lt;/strong&gt;- &lt;strong&gt;Query Workflows&lt;/strong&gt; : Orchestration des processus de lecture- &lt;strong&gt;Query Activities&lt;/strong&gt; : Ex√©cution des activit√©s de lecture- &lt;strong&gt;Search Services&lt;/strong&gt; : Services de recherche sp√©cialis√©s- &lt;strong&gt;Query Bus&lt;/strong&gt; : Orchestration des requ√™tes- &lt;strong&gt;Read Sources&lt;/strong&gt; : Sources optimis√©es pour les lectures- &lt;strong&gt;Query Models&lt;/strong&gt; : Mod√®les optimis√©s pour les lectures- &lt;strong&gt;Caches&lt;/strong&gt; : Optimisation des performances### &lt;strong&gt;Flux de Donn√©es Complet&lt;/strong&gt;&lt;code&gt;mermaidgraph TD A[Command] --&amp;gt; B[Command Bus] B --&amp;gt; C[Command Workflow] C --&amp;gt; D[Command Activities] D --&amp;gt; E[Write Sources] E --&amp;gt; F[SQL Database] E --&amp;gt; G[Redis Cache] E --&amp;gt; H[File System] E --&amp;gt; I[Event Store] J[Query] --&amp;gt; K[Query Bus] K --&amp;gt; L[Query Workflow] L --&amp;gt; M[Query Activities] M --&amp;gt; N[Read Sources] N --&amp;gt; O[ElasticSearch] N --&amp;gt; P[Redis Cache] N --&amp;gt; Q[SQL Database] N --&amp;gt; R[Read Models] S[Event] --&amp;gt; T[Event Handler] T --&amp;gt; C U[Projection] --&amp;gt; V[Read Model Update] V --&amp;gt; R W[Command Model] --&amp;gt; X[Write Optimization] X --&amp;gt; E Y[Query Model] --&amp;gt; Z[Read Optimization] Z --&amp;gt; N&lt;/code&gt;## üíª &lt;strong&gt;Impl√©mentation Compl√®te&lt;/strong&gt;### &lt;strong&gt;1. Command Side avec Multi-sources&lt;/strong&gt;#### &lt;strong&gt;Command Bus avec Multi-sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\CommandBus\MultiSource;use App\Domain\Command\CommandInterface;use App\Domain\Command\CommandHandlerInterface;use App\Infrastructure\MultiSource\SourceRouter;use Psr\Log\LoggerInterface;class MultiSourceCqrsCommandBus{ private array $handlers = []; private array $middleware = []; private SourceRouter $sourceRouter; private LoggerInterface $logger; public function __construct( SourceRouter $sourceRouter, LoggerInterface $logger ) { $this-&amp;gt;sourceRouter = $sourceRouter; $this-&amp;gt;logger = $logger; } public function registerHandler(string $commandClass, CommandHandlerInterface $handler): void { $this-&amp;gt;handlers[$commandClass] = $handler; } public function addMiddleware(callable $middleware): void { $this-&amp;gt;middleware[] = $middleware; } public function handle(CommandInterface $command): void { $commandClass = get_class($command); if (!isset($this-&amp;gt;handlers[$commandClass])) { throw new \InvalidArgumentException(&amp;quot;No handler registered for command: $commandClass&amp;quot;); } $handler = $this-&amp;gt;handlers[$commandClass]; // Ex√©cuter les middleware $this-&amp;gt;executeMiddleware($command, function() use ($handler, $command) { $this-&amp;gt;logger-&amp;gt;info('Executing command via Multi-source CQRS', [ 'command' =&amp;gt; get_class($command), 'data' =&amp;gt; $command-&amp;gt;toArray() ]); $handler-&amp;gt;handle($command); }); } private function executeMiddleware(CommandInterface $command, callable $next): void { $middleware = array_reverse($this-&amp;gt;middleware); foreach ($middleware as $mw) { $next = function() use ($mw, $command, $next) { return $mw($command, $next); }; } $next(); }}&lt;/code&gt;#### &lt;strong&gt;Command Workflow avec Multi-sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Workflow\Command\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Infrastructure\MultiSource\SourceRouter;#[WorkflowInterface]interface PaymentMultiSourceCqrsCommandWorkflowInterface{ #[WorkflowMethod] public function processPaymentCommandWithMultiSourceCqrs(PaymentCommandRequest $request): PaymentCommandResult; #[WorkflowMethod] public function updatePaymentCommandWithMultiSourceCqrs(PaymentUpdateCommandRequest $request): PaymentCommandResult; #[WorkflowMethod] public function deletePaymentCommandWithMultiSourceCqrs(PaymentDeleteCommandRequest $request): PaymentCommandResult;}#[ActivityInterface]interface PaymentMultiSourceCqrsCommandActivityInterface{ #[ActivityMethod] public function validatePaymentCommand(PaymentCommandRequest $request): ValidationResult; #[ActivityMethod] public function executePaymentCommand(PaymentCommandRequest $request): CommandExecutionResult; #[ActivityMethod] public function persistToWriteSources(Payment $payment, array $sources): void; #[ActivityMethod] public function updateProjections(Payment $payment): void; #[ActivityMethod] public function updateCommandModels(Payment $payment): void;}class PaymentMultiSourceCqrsCommandWorkflow implements PaymentMultiSourceCqrsCommandWorkflowInterface{ private PaymentMultiSourceCqrsCommandActivityInterface $commandActivity; private SourceRouter $sourceRouter; public function __construct() { $this-&amp;gt;commandActivity = Workflow::newActivityStub(PaymentMultiSourceCqrsCommandActivityInterface::class); $this-&amp;gt;sourceRouter = Workflow::newActivityStub(SourceRouter::class); } public function processPaymentCommandWithMultiSourceCqrs(PaymentCommandRequest $request): PaymentCommandResult { try { // Validation de la commande $validation = yield $this-&amp;gt;commandActivity-&amp;gt;validatePaymentCommand($request); if (!$validation-&amp;gt;isValid()) { return new PaymentCommandResult(false, $validation-&amp;gt;getError()); } // Ex√©cution de la commande $execution = yield $this-&amp;gt;commandActivity-&amp;gt;executePaymentCommand($request); if (!$execution-&amp;gt;isSuccess()) { return new PaymentCommandResult(false, $execution-&amp;gt;getError()); } // D√©terminer les sources d'√©criture optimales $writeSources = yield $this-&amp;gt;sourceRouter-&amp;gt;routeWrite('save', $execution-&amp;gt;getPayment()); // Persister dans les sources d'√©criture yield $this-&amp;gt;commandActivity-&amp;gt;persistToWriteSources($execution-&amp;gt;getPayment(), $writeSources); // Mettre √† jour les projections yield $this-&amp;gt;commandActivity-&amp;gt;updateProjections($execution-&amp;gt;getPayment()); // Mettre √† jour les mod√®les de commande yield $this-&amp;gt;commandActivity-&amp;gt;updateCommandModels($execution-&amp;gt;getPayment()); return new PaymentCommandResult(true, 'Payment command processed with Multi-source CQRS'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e-&amp;gt;getMessage()); } } public function updatePaymentCommandWithMultiSourceCqrs(PaymentUpdateCommandRequest $request): PaymentCommandResult { try { // Validation de la commande de mise √† jour $validation = yield $this-&amp;gt;commandActivity-&amp;gt;validatePaymentCommand($request); if (!$validation-&amp;gt;isValid()) { return new PaymentCommandResult(false, $validation-&amp;gt;getError()); } // Ex√©cution de la mise √† jour $execution = yield $this-&amp;gt;commandActivity-&amp;gt;executePaymentCommand($request); if (!$execution-&amp;gt;isSuccess()) { return new PaymentCommandResult(false, $execution-&amp;gt;getError()); } // D√©terminer les sources d'√©criture optimales $writeSources = yield $this-&amp;gt;sourceRouter-&amp;gt;routeWrite('update', $execution-&amp;gt;getPayment()); // Persister dans les sources d'√©criture yield $this-&amp;gt;commandActivity-&amp;gt;persistToWriteSources($execution-&amp;gt;getPayment(), $writeSources); // Mettre √† jour les projections yield $this-&amp;gt;commandActivity-&amp;gt;updateProjections($execution-&amp;gt;getPayment()); // Mettre √† jour les mod√®les de commande yield $this-&amp;gt;commandActivity-&amp;gt;updateCommandModels($execution-&amp;gt;getPayment()); return new PaymentCommandResult(true, 'Payment update command processed with Multi-source CQRS'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e-&amp;gt;getMessage()); } } public function deletePaymentCommandWithMultiSourceCqrs(PaymentDeleteCommandRequest $request): PaymentCommandResult { try { // Validation de la commande de suppression $validation = yield $this-&amp;gt;commandActivity-&amp;gt;validatePaymentCommand($request); if (!$validation-&amp;gt;isValid()) { return new PaymentCommandResult(false, $validation-&amp;gt;getError()); } // Ex√©cution de la suppression $execution = yield $this-&amp;gt;commandActivity-&amp;gt;executePaymentCommand($request); if (!$execution-&amp;gt;isSuccess()) { return new PaymentCommandResult(false, $execution-&amp;gt;getError()); } // D√©terminer les sources d'√©criture optimales $writeSources = yield $this-&amp;gt;sourceRouter-&amp;gt;routeWrite('delete', $execution-&amp;gt;getPayment()); // Persister dans les sources d'√©criture yield $this-&amp;gt;commandActivity-&amp;gt;persistToWriteSources($execution-&amp;gt;getPayment(), $writeSources); // Mettre √† jour les projections yield $this-&amp;gt;commandActivity-&amp;gt;updateProjections($execution-&amp;gt;getPayment()); // Mettre √† jour les mod√®les de commande yield $this-&amp;gt;commandActivity-&amp;gt;updateCommandModels($execution-&amp;gt;getPayment()); return new PaymentCommandResult(true, 'Payment delete command processed with Multi-source CQRS'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e-&amp;gt;getMessage()); } }}&lt;/code&gt;### &lt;strong&gt;2. Query Side avec Multi-sources&lt;/strong&gt;#### &lt;strong&gt;Query Bus avec Cache et Multi-sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\QueryBus\MultiSource;use App\Domain\Query\QueryInterface;use App\Domain\Query\QueryHandlerInterface;use App\Infrastructure\MultiSource\SourceRouter;use App\Infrastructure\MultiSource\MultiSourceCacheManager;use Psr\Log\LoggerInterface;class MultiSourceCqrsQueryBus{ private array $handlers = []; private SourceRouter $sourceRouter; private MultiSourceCacheManager $cacheManager; private LoggerInterface $logger; public function __construct( SourceRouter $sourceRouter, MultiSourceCacheManager $cacheManager, LoggerInterface $logger ) { $this-&amp;gt;sourceRouter = $sourceRouter; $this-&amp;gt;cacheManager = $cacheManager; $this-&amp;gt;logger = $logger; } public function registerHandler(string $queryClass, QueryHandlerInterface $handler): void { $this-&amp;gt;handlers[$queryClass] = $handler; } public function handle(QueryInterface $query): mixed { $queryClass = get_class($query); if (!isset($this-&amp;gt;handlers[$queryClass])) { throw new \InvalidArgumentException(&amp;quot;No handler registered for query: $queryClass&amp;quot;); } // V√©rifier le cache $cacheKey = $this-&amp;gt;generateCacheKey($query); $cachedResult = $this-&amp;gt;cacheManager-&amp;gt;get($cacheKey); if ($cachedResult !== null) { $this-&amp;gt;logger-&amp;gt;debug('Query result served from cache', [ 'query' =&amp;gt; $queryClass, 'cacheKey' =&amp;gt; $cacheKey ]); return $cachedResult; } // D√©terminer la source de lecture optimale $readSource = $this-&amp;gt;sourceRouter-&amp;gt;routeRead($queryClass, $query-&amp;gt;toArray()); // Ex√©cuter la requ√™te via la source optimale $handler = $this-&amp;gt;handlers[$queryClass]; $result = $handler-&amp;gt;handle($query, $readSource); // Mettre en cache $this-&amp;gt;cacheManager-&amp;gt;set($cacheKey, $result, 300); $this-&amp;gt;logger-&amp;gt;info('Query executed and cached via Multi-source CQRS', [ 'query' =&amp;gt; $queryClass, 'source' =&amp;gt; $readSource, 'cacheKey' =&amp;gt; $cacheKey ]); return $result; } private function generateCacheKey(QueryInterface $query): string { return 'multi_source_cqrs_query_' . md5(serialize($query)); }}&lt;/code&gt;#### &lt;strong&gt;Query Workflow avec Multi-sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Workflow\Query\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Infrastructure\MultiSource\SourceRouter;#[WorkflowInterface]interface PaymentMultiSourceCqrsQueryWorkflowInterface{ #[WorkflowMethod] public function searchPaymentsWithMultiSourceCqrs(PaymentSearchQuery $query): PaymentSearchResult; #[WorkflowMethod] public function getPaymentByIdWithMultiSourceCqrs(PaymentByIdQuery $query): ?Payment; #[WorkflowMethod] public function getPaymentStatisticsWithMultiSourceCqrs(PaymentStatisticsQuery $query): array; #[WorkflowMethod] public function getPaymentAnalyticsWithMultiSourceCqrs(PaymentAnalyticsQuery $query): array; #[WorkflowMethod] public function getPaymentTimelineWithMultiSourceCqrs(PaymentTimelineQuery $query): array;}#[ActivityInterface]interface PaymentMultiSourceCqrsQueryActivityInterface{ #[ActivityMethod] public function searchPaymentsInSource(PaymentSearchQuery $query, string $source): array; #[ActivityMethod] public function getPaymentFromSource(string $paymentId, string $source): ?Payment; #[ActivityMethod] public function calculatePaymentStatisticsInSource(PaymentStatisticsQuery $query, string $source): array; #[ActivityMethod] public function generatePaymentAnalyticsInSource(PaymentAnalyticsQuery $query, string $source): array; #[ActivityMethod] public function getEventsByCorrelationId(string $correlationId, string $source): array; #[ActivityMethod] public function updateQueryModels(array $events): void;}class PaymentMultiSourceCqrsQueryWorkflow implements PaymentMultiSourceCqrsQueryWorkflowInterface{ private PaymentMultiSourceCqrsQueryActivityInterface $queryActivity; private SourceRouter $sourceRouter; public function __construct() { $this-&amp;gt;queryActivity = Workflow::newActivityStub(PaymentMultiSourceCqrsQueryActivityInterface::class); $this-&amp;gt;sourceRouter = Workflow::newActivityStub(SourceRouter::class); } public function searchPaymentsWithMultiSourceCqrs(PaymentSearchQuery $query): PaymentSearchResult { try { // D√©terminer la source de lecture optimale $readSource = yield $this-&amp;gt;sourceRouter-&amp;gt;routeRead('search', $query-&amp;gt;toArray()); // Recherche dans la source optimale $payments = yield $this-&amp;gt;queryActivity-&amp;gt;searchPaymentsInSource($query, $readSource); // Filtrage et tri $filteredPayments = $this-&amp;gt;filterPayments($payments, $query); $sortedPayments = $this-&amp;gt;sortPayments($filteredPayments, $query); // Pagination $paginatedPayments = $this-&amp;gt;paginatePayments($sortedPayments, $query); return new PaymentSearchResult( $paginatedPayments, count($filteredPayments), $query-&amp;gt;getPage(), $query-&amp;gt;getSize() ); } catch (\Exception $e) { return new PaymentSearchResult([], 0, $query-&amp;gt;getPage(), $query-&amp;gt;getSize()); } } public function getPaymentByIdWithMultiSourceCqrs(PaymentByIdQuery $query): ?Payment { try { // D√©terminer la source de lecture optimale $readSource = yield $this-&amp;gt;sourceRouter-&amp;gt;routeRead('findById', ['id' =&amp;gt; $query-&amp;gt;getPaymentId()]); return yield $this-&amp;gt;queryActivity-&amp;gt;getPaymentFromSource($query-&amp;gt;getPaymentId(), $readSource); } catch (\Exception $e) { return null; } } public function getPaymentStatisticsWithMultiSourceCqrs(PaymentStatisticsQuery $query): array { try { // D√©terminer la source de lecture optimale $readSource = yield $this-&amp;gt;sourceRouter-&amp;gt;routeRead('statistics', $query-&amp;gt;toArray()); return yield $this-&amp;gt;queryActivity-&amp;gt;calculatePaymentStatisticsInSource($query, $readSource); } catch (\Exception $e) { return []; } } public function getPaymentAnalyticsWithMultiSourceCqrs(PaymentAnalyticsQuery $query): array { try { // D√©terminer la source de lecture optimale $readSource = yield $this-&amp;gt;sourceRouter-&amp;gt;routeRead('analytics', $query-&amp;gt;toArray()); return yield $this-&amp;gt;queryActivity-&amp;gt;generatePaymentAnalyticsInSource($query, $readSource); } catch (\Exception $e) { return []; } } public function getPaymentTimelineWithMultiSourceCqrs(PaymentTimelineQuery $query): array { try { // D√©terminer la source de lecture optimale $readSource = yield $this-&amp;gt;sourceRouter-&amp;gt;routeRead('timeline', $query-&amp;gt;toArray()); $events = yield $this-&amp;gt;queryActivity-&amp;gt;getEventsByCorrelationId($query-&amp;gt;getCorrelationId(), $readSource); $timeline = []; foreach ($events as $event) { $timeline[] = [ 'eventId' =&amp;gt; $event-&amp;gt;getId(), 'aggregateId' =&amp;gt; $event-&amp;gt;getAggregateId(), 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'timestamp' =&amp;gt; $event-&amp;gt;getTimestamp(), 'data' =&amp;gt; $event-&amp;gt;toArray(), 'metadata' =&amp;gt; $event-&amp;gt;getMetadata() ]; } return $timeline; } catch (\Exception $e) { return []; } } private function filterPayments(array $payments, PaymentSearchQuery $query): array { return array_filter($payments, function($payment) use ($query) { if ($query-&amp;gt;getOrganizationId() &amp;amp;&amp;amp; $payment-&amp;gt;getOrganizationId() !== $query-&amp;gt;getOrganizationId()) { return false; } if ($query-&amp;gt;getStatus() &amp;amp;&amp;amp; $payment-&amp;gt;getStatus() !== $query-&amp;gt;getStatus()) { return false; } if ($query-&amp;gt;getMinAmount() &amp;amp;&amp;amp; $payment-&amp;gt;getAmount() &amp;lt; $query-&amp;gt;getMinAmount()) { return false; } if ($query-&amp;gt;getMaxAmount() &amp;amp;&amp;amp; $payment-&amp;gt;getAmount() &amp;gt; $query-&amp;gt;getMaxAmount()) { return false; } return true; }); } private function sortPayments(array $payments, PaymentSearchQuery $query): array { $sortField = $query-&amp;gt;getSortField() ?? 'createdAt'; $sortDirection = $query-&amp;gt;getSortDirection() ?? 'desc'; usort($payments, function($a, $b) use ($sortField, $sortDirection) { $valueA = $this-&amp;gt;getFieldValue($a, $sortField); $valueB = $this-&amp;gt;getFieldValue($b, $sortField); if ($sortDirection === 'asc') { return $valueA &amp;lt;=&amp;gt; $valueB; } else { return $valueB &amp;lt;=&amp;gt; $valueA; } }); return $payments; } private function paginatePayments(array $payments, PaymentSearchQuery $query): array { $page = $query-&amp;gt;getPage() ?? 1; $size = $query-&amp;gt;getSize() ?? 10; $offset = ($page - 1) * $size; return array_slice($payments, $offset, $size); } private function getFieldValue(Payment $payment, string $field): mixed { switch ($field) { case 'amount': return $payment-&amp;gt;getAmount(); case 'createdAt': return $payment-&amp;gt;getCreatedAt(); case 'status': return $payment-&amp;gt;getStatus(); default: return $payment-&amp;gt;getCreatedAt(); } }}&lt;/code&gt;### &lt;strong&gt;3. Service de Projection Avanc√© avec Multi-sources&lt;/strong&gt;#### &lt;strong&gt;Service de Projection avec Multi-sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Service\MultiSource;use App\Domain\Event\DomainEvent;use App\Infrastructure\MultiSource\SourceRouter;use App\Infrastructure\MultiSource\MultiSourceCacheManager;use Psr\Log\LoggerInterface;class MultiSourceCqrsProjectionService{ private SourceRouter $sourceRouter; private MultiSourceCacheManager $cacheManager; private LoggerInterface $logger; public function __construct( SourceRouter $sourceRouter, MultiSourceCacheManager $cacheManager, LoggerInterface $logger ) { $this-&amp;gt;sourceRouter = $sourceRouter; $this-&amp;gt;cacheManager = $cacheManager; $this-&amp;gt;logger = $logger; } public function handleEvent(DomainEvent $event): void { try { $this-&amp;gt;logger-&amp;gt;info('Handling event via Multi-source CQRS', [ 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'eventId' =&amp;gt; $event-&amp;gt;getId() ]); // D√©terminer les sources affect√©es $affectedSources = $this-&amp;gt;determineAffectedSources($event); // Mettre √† jour chaque source foreach ($affectedSources as $source) { $this-&amp;gt;updateSource($source, $event); } // Invalider le cache si n√©cessaire if ($this-&amp;gt;shouldInvalidateCache($event)) { $this-&amp;gt;invalidateCache($event); } } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to handle event via Multi-source CQRS', [ 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } public function rebuildProjection(string $projectionType): void { try { $this-&amp;gt;logger-&amp;gt;info('Rebuilding projection via Multi-source CQRS', [ 'projectionType' =&amp;gt; $projectionType ]); // Reconstruire la projection dans toutes les sources pertinentes $sources = $this-&amp;gt;getProjectionSources($projectionType); foreach ($sources as $source) { $this-&amp;gt;rebuildProjectionInSource($projectionType, $source); } $this-&amp;gt;logger-&amp;gt;info('Projection rebuilt successfully via Multi-source CQRS', [ 'projectionType' =&amp;gt; $projectionType ]); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to rebuild projection via Multi-source CQRS', [ 'projectionType' =&amp;gt; $projectionType, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } private function determineAffectedSources(DomainEvent $event): array { $sources = []; // Toujours affecter la base de donn√©es pour les √©v√©nements critiques if ($this-&amp;gt;isCriticalEvent($event)) { $sources[] = 'database'; } // Affecter le cache pour les √©v√©nements de lecture if ($this-&amp;gt;isReadEvent($event)) { $sources[] = 'cache'; } // Affecter ElasticSearch pour les √©v√©nements de recherche if ($this-&amp;gt;isSearchEvent($event)) { $sources[] = 'elasticsearch'; } // Affecter les Read Models pour les projections if ($this-&amp;gt;isProjectionEvent($event)) { $sources[] = 'read_models'; } return $sources; } private function updateSource(string $source, DomainEvent $event): void { $this-&amp;gt;logger-&amp;gt;debug('Updating source', [ 'source' =&amp;gt; $source, 'eventType' =&amp;gt; $event-&amp;gt;getEventType() ]); // Impl√©mentation sp√©cifique √† chaque source switch ($source) { case 'database': $this-&amp;gt;updateDatabase($event); break; case 'cache': $this-&amp;gt;updateCache($event); break; case 'elasticsearch': $this-&amp;gt;updateElasticSearch($event); break; case 'read_models': $this-&amp;gt;updateReadModels($event); break; } } private function shouldInvalidateCache(DomainEvent $event): bool { return in_array($event-&amp;gt;getEventType(), [ 'PaymentUpdated', 'PaymentDeleted', 'PaymentStatusChanged' ]); } private function invalidateCache(DomainEvent $event): void { $this-&amp;gt;logger-&amp;gt;debug('Invalidating cache', [ 'eventType' =&amp;gt; $event-&amp;gt;getEventType() ]); // Invalider les caches pertinents if (isset($event-&amp;gt;getData()['paymentId'])) { $this-&amp;gt;cacheManager-&amp;gt;deletePayment($event-&amp;gt;getData()['paymentId']); } } private function isCriticalEvent(DomainEvent $event): bool { return in_array($event-&amp;gt;getEventType(), [ 'PaymentCreated', 'PaymentUpdated', 'PaymentDeleted' ]); } private function isReadEvent(DomainEvent $event): bool { return in_array($event-&amp;gt;getEventType(), [ 'PaymentViewed', 'PaymentSearched' ]); } private function isSearchEvent(DomainEvent $event): bool { return in_array($event-&amp;gt;getEventType(), [ 'PaymentCreated', 'PaymentUpdated', 'PaymentDeleted' ]); } private function isProjectionEvent(DomainEvent $event): bool { return in_array($event-&amp;gt;getEventType(), [ 'PaymentCreated', 'PaymentUpdated', 'PaymentDeleted', 'PaymentStatusChanged' ]); } private function getProjectionSources(string $projectionType): array { switch ($projectionType) { case 'payment_summary': return ['database', 'cache', 'elasticsearch']; case 'payment_analytics': return ['elasticsearch', 'read_models']; case 'payment_timeline': return ['read_models', 'cache']; default: return ['database']; } } private function rebuildProjectionInSource(string $projectionType, string $source): void { $this-&amp;gt;logger-&amp;gt;debug('Rebuilding projection in source', [ 'projectionType' =&amp;gt; $projectionType, 'source' =&amp;gt; $source ]); // Impl√©mentation sp√©cifique √† chaque source switch ($source) { case 'database': $this-&amp;gt;rebuildDatabaseProjection($projectionType); break; case 'cache': $this-&amp;gt;rebuildCacheProjection($projectionType); break; case 'elasticsearch': $this-&amp;gt;rebuildElasticSearchProjection($projectionType); break; case 'read_models': $this-&amp;gt;rebuildReadModelsProjection($projectionType); break; } } private function updateDatabase(DomainEvent $event): void { // Impl√©mentation de la mise √† jour de la base de donn√©es } private function updateCache(DomainEvent $event): void { // Impl√©mentation de la mise √† jour du cache } private function updateElasticSearch(DomainEvent $event): void { // Impl√©mentation de la mise √† jour d'ElasticSearch } private function updateReadModels(DomainEvent $event): void { // Impl√©mentation de la mise √† jour des Read Models } private function rebuildDatabaseProjection(string $projectionType): void { // Impl√©mentation de la reconstruction de la projection en base de donn√©es } private function rebuildCacheProjection(string $projectionType): void { // Impl√©mentation de la reconstruction de la projection en cache } private function rebuildElasticSearchProjection(string $projectionType): void { // Impl√©mentation de la reconstruction de la projection en ElasticSearch } private function rebuildReadModelsProjection(string $projectionType): void { // Impl√©mentation de la reconstruction de la projection dans les Read Models }}&lt;/code&gt;## üß™ &lt;strong&gt;Tests et Validation&lt;/strong&gt;### &lt;strong&gt;Tests d&amp;rsquo;Int√©gration CQRS Multi-Sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Tests\Integration\MultiSource;use App\Workflow\Command\Payment\PaymentCommandRequest;use App\Workflow\Query\Payment\PaymentSearchQuery;use App\Application\CommandBus\MultiSource\MultiSourceCqrsCommandBus;use App\Application\QueryBus\MultiSource\MultiSourceCqrsQueryBus;use App\Infrastructure\MultiSource\SourceRouter;class MultiSourceCqrsTest extends TestCase{ private MultiSourceCqrsCommandBus $commandBus; private MultiSourceCqrsQueryBus $queryBus; private SourceRouter $sourceRouter; protected function setUp(): void { $this-&amp;gt;sourceRouter = $this-&amp;gt;createMock(SourceRouter::class); $this-&amp;gt;commandBus = new MultiSourceCqrsCommandBus( $this-&amp;gt;sourceRouter, $this-&amp;gt;createMock(LoggerInterface::class) ); $this-&amp;gt;queryBus = new MultiSourceCqrsQueryBus( $this-&amp;gt;sourceRouter, $this-&amp;gt;createMock(MultiSourceCacheManager::class), $this-&amp;gt;createMock(LoggerInterface::class) ); } public function testCqrsSeparationWithMultiSource(): void { // Ex√©cuter une commande avec Multi-source CQRS $command = new PaymentCommandRequest( 'CREATE', 'payment-123', 'org-456', 'user-789', 100.00, 'EUR', 'Test payment' ); $this-&amp;gt;commandBus-&amp;gt;handle($command); // V√©rifier avec une requ√™te $query = new PaymentSearchQuery('org-456', 0, 10); $result = $this-&amp;gt;queryBus-&amp;gt;handle($query); $this-&amp;gt;assertGreaterThan(0, $result-&amp;gt;getTotal()); } public function testQueryCachingWithMultiSource(): void { $query = new PaymentSearchQuery('org-456', 0, 10); // Premi√®re recherche $result1 = $this-&amp;gt;queryBus-&amp;gt;handle($query); // Deuxi√®me recherche (devrait utiliser le cache) $result2 = $this-&amp;gt;queryBus-&amp;gt;handle($query); $this-&amp;gt;assertEquals($result1-&amp;gt;getTotal(), $result2-&amp;gt;getTotal()); }}&lt;/code&gt;## üìä &lt;strong&gt;Performance et Optimisation&lt;/strong&gt;### &lt;strong&gt;Strat√©gies d&amp;rsquo;Optimisation CQRS Multi-Sources&lt;/strong&gt;#### &lt;strong&gt;1. Cache Multi-Niveaux avec Multi-sources&lt;/strong&gt;&lt;code&gt;phppublic function searchPaymentsWithCache(PaymentSearchQuery $query): PaymentSearchResult{ // Cache L1: M√©moire if (isset($this-&amp;gt;memoryCache[$query-&amp;gt;getCacheKey()])) { return $this-&amp;gt;memoryCache[$query-&amp;gt;getCacheKey()]; } // Cache L2: Redis if ($cached = $this-&amp;gt;redis-&amp;gt;get(&amp;quot;payment_search_ms_cqrs:{$query-&amp;gt;getCacheKey()}&amp;quot;)) { $result = PaymentSearchResult::fromArray(json_decode($cached, true)); $this-&amp;gt;memoryCache[$query-&amp;gt;getCacheKey()] = $result; return $result; } // Multi-source CQRS $result = $this-&amp;gt;searchPaymentsWithMultiSourceCqrs($query); // Mettre en cache $this-&amp;gt;memoryCache[$query-&amp;gt;getCacheKey()] = $result; $this-&amp;gt;redis-&amp;gt;setex(&amp;quot;payment_search_ms_cqrs:{$query-&amp;gt;getCacheKey()}&amp;quot;, 300, json_encode($result-&amp;gt;toArray())); return $result;}&lt;/code&gt;#### &lt;strong&gt;2. Projections Asynchrones avec Multi-sources&lt;/strong&gt;&lt;code&gt;phppublic function handleEventAsync(DomainEvent $event): void{ // Mettre en queue pour traitement asynchrone $this-&amp;gt;messageBus-&amp;gt;dispatch(new ProcessMultiSourceCqrsProjectionCommand($event));}&lt;/code&gt;#### &lt;strong&gt;3. Monitoring des Sources Multi-sources&lt;/strong&gt;&lt;code&gt;phppublic function getMultiSourceCqrsMetrics(): array{ return [ 'commandSources' =&amp;gt; $this-&amp;gt;getCommandSourceMetrics(), 'querySources' =&amp;gt; $this-&amp;gt;getQuerySourceMetrics(), 'projections' =&amp;gt; $this-&amp;gt;getProjectionMetrics(), 'cacheHitRate' =&amp;gt; $this-&amp;gt;getCacheHitRate(), 'sourceHealth' =&amp;gt; $this-&amp;gt;getSourceHealth(), 'averageExecutionTime' =&amp;gt; $this-&amp;gt;getAverageExecutionTime() ];}&lt;/code&gt;## üéØ &lt;strong&gt;Crit√®res d&amp;rsquo;Adoption&lt;/strong&gt;### &lt;strong&gt;Quand Utiliser CQRS avec Multi-sources&lt;/strong&gt;#### &lt;strong&gt;‚úÖ Avantages&lt;/strong&gt;- &lt;strong&gt;S√©paration totale&lt;/strong&gt; : Commandes et requ√™tes compl√®tement d√©coupl√©es- &lt;strong&gt;Flexibilit√© maximale&lt;/strong&gt; : Choix du meilleur stockage pour chaque op√©ration- &lt;strong&gt;Scalabilit√© maximale&lt;/strong&gt; : Possibilit√© de scaler ind√©pendamment- &lt;strong&gt;Performance optimale&lt;/strong&gt; : Chaque c√¥t√© optimis√© pour son usage- &lt;strong&gt;R√©silience&lt;/strong&gt; : Redondance et failover entre sources- &lt;strong&gt;Maintenabilit√©&lt;/strong&gt; : Code plus clair et organis√©#### &lt;strong&gt;‚ùå Inconv√©nients&lt;/strong&gt;- &lt;strong&gt;Complexit√© maximale&lt;/strong&gt; : Gestion de plusieurs sources de donn√©es- &lt;strong&gt;Coh√©rence&lt;/strong&gt; : Risque d&amp;rsquo;incoh√©rence entre sources- &lt;strong&gt;Maintenance&lt;/strong&gt; : Plus de sources √† maintenir- &lt;strong&gt;Expertise&lt;/strong&gt; : √âquipe tr√®s exp√©riment√©e requise- &lt;strong&gt;Co√ªt&lt;/strong&gt; : Infrastructure tr√®s co√ªteuse#### &lt;strong&gt;üéØ Crit√®res d&amp;rsquo;Adoption&lt;/strong&gt;- &lt;strong&gt;Syst√®me tr√®s complexe&lt;/strong&gt; : Besoins de scalabilit√© maximale- &lt;strong&gt;Donn√©es h√©t√©rog√®nes&lt;/strong&gt; : Types de donn√©es diff√©rents n√©cessitant diff√©rents stockages- &lt;strong&gt;Performance critique&lt;/strong&gt; : Besoins de performance maximale- &lt;strong&gt;S√©paration des responsabilit√©s&lt;/strong&gt; : Besoin de s√©parer clairement les commandes et requ√™tes- &lt;strong&gt;√âquipe tr√®s exp√©riment√©e&lt;/strong&gt; : Ma√Ætrise de plusieurs technologies de stockage et CQRS- &lt;strong&gt;Budget important&lt;/strong&gt; : Investissement en infrastructure multiple- &lt;strong&gt;Temps de d√©veloppement&lt;/strong&gt; : Suffisant pour impl√©menter cette complexit√©- &lt;strong&gt;Maintenance&lt;/strong&gt; : √âquipe capable de maintenir cette complexit√©## üöÄ &lt;strong&gt;Votre Prochaine √âtape&lt;/strong&gt;

&lt;div class="chapter-navigation"&gt;
 &lt;h2 class="chapter-nav-title"&gt;üéØ Votre Prochaine √âtape&lt;/h2&gt;
 &lt;p class="chapter-nav-subtitle"&gt;Maintenant que vous comprenez les concepts de base et que j'ai partag√© mon exp√©rience avec Gyroscops, quel est votre contexte ?&lt;/p&gt;</description></item><item><title>Stockage Multi-sources avec Event Sourcing</title><link>http://localhost:1313/chapitres/stockage/multi-sources/chapitre-55-stockage-multi-sources-event-sourcing/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/multi-sources/chapitre-55-stockage-multi-sources-event-sourcing/</guid><description/></item><item><title>Strat√©gies Avanc√©es de R√©plication Multi-sources</title><link>http://localhost:1313/chapitres/stockage/multi-sources/chapitre-56-stockage-multi-sources-strategies-avancees/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/multi-sources/chapitre-56-stockage-multi-sources-strategies-avancees/</guid><description>&lt;h2 id="-objectif-du-chapitrece-chapitre-explore-les-strat√©gies-avanc√©es-de-r√©plication-pour-les-syst√®mes-multi-sources-couvrant-les-patterns-sophistiqu√©s-de-synchronisation-de-coh√©rence-et-doptimisation-des-performances--concepts-cl√©s-r√©plication-avanc√©ela-r√©plication-avanc√©e-va-au-del√†-de-la-simple-duplication-de-donn√©es---r√©plication-intelligente--s√©lection-dynamique-des-sources--synchronisation-bidirectionnelle--mise-√†-jour-dans-les-deux-sens--r√©plication-conditionnelle--bas√©e-sur-des-crit√®res-m√©tier--optimisation-des-performances--r√©plication-asynchrone-et-parall√®le-architecture-de-r√©plication-avanc√©emermaidgraph-tb----aevent-source----breplication-manager----b----cstrategy-selector--------c----dimmediate-replication----c----ebatch-replication----c----fconditional-replication--------d----gprimary-store----d----hsecondary-store--------e----ibatch-processor----i----jmultiple-stores--------f----krule-engine----k----ltarget-stores--------mconflict-resolver----nconsistency-checker----n----osync-status--patterns-de-r√©plication-1-r√©plication-en-cascadeles-donn√©es-sont-r√©pliqu√©es-de-mani√®re-s√©quentielle-phpphpnamespace-gyroscopscloudinfrastructurereplicationclass-cascadereplicationstrategy-implements-replicationstrategyinterface----private-array-storechain----private-int-maxretries----public-function-replicateeventstream-stream-void------------currentstream--stream----------------foreach-this-storechain-as-store-------------try-----------------store-appendcurrentstream----------------currentstream--this-transformstreamcurrentstream-store-------------catch-exception-e-----------------this-handlereplicationfailurestore-e----------------break--arr√™ter-la-cascade-en-cas-d√©chec----------------------------private-function-transformstreameventstream-stream-eventstoreinterface-store-eventstream-------------transformation-des-√©v√©nements-selon-le-type-de-store--------transformedevents------------------foreach-stream-getevents-as-event-------------transformedevents--this-transformeventevent-store------------------------return-new-eventstreamtransformedevents-----2-r√©plication-en-√©toiletoutes-les-sources-sont-mises-√†-jour-simultan√©ment-phpphpnamespace-gyroscopscloudinfrastructurereplicationclass-starreplicationstrategy-implements-replicationstrategyinterface----private-array-stores----private-replicationcoordinator-coordinator----public-function-replicateeventstream-stream-void------------replicationtasks------------------foreach-this-stores-as-storeid--store-------------replicationtasks--this-createreplicationtaskstore-stream------------------------this-coordinator-executeparallelreplicationtasks--------private-function-createreplicationtaskeventstoreinterface-store-eventstream-stream-replicationtask------------return-new-replicationtaskfunction-use-store-stream-------------try-----------------store-appendstream----------------return-replicationresultsuccess-------------catch-exception-e-----------------return-replicationresultfailuree-------------------------3-r√©plication-conditionnellela-r√©plication-d√©pend-de-crit√®res-m√©tier-phpphpnamespace-gyroscopscloudinfrastructurereplicationclass-conditionalreplicationstrategy-implements-replicationstrategyinterface----private-array-replicationrules----private-ruleengine-ruleengine----public-function-replicateeventstream-stream-void------------foreach-stream-getevents-as-event-------------targetstores--this-ruleengine-evaluateevent-this-replicationrules------------------------foreach-targetstores-as-store-----------------this-replicatetostorestore-event----------------------------private-function-replicatetostoreeventstoreinterface-store-domainevent-event-void------------try-------------store-appendnew-eventstreamevent---------catch-exception-e-------------this-handlereplicationerrorstore-event-e--------------strat√©gies-de-coh√©rence-1-coh√©rence-√©ventuelle-avec-compensationphpphpnamespace-gyroscopscloudinfrastructureconsistencyclass-eventualconsistencywithcompensation-implements-consistencystrategyinterface----private-consistencychecker-checker----private-compensationmanager-compensation----public-function-ensureconsistencyarray-stores-void------------inconsistencies--this-checker-detectinconsistenciesstores----------------foreach-inconsistencies-as-inconsistency-------------this-compensation-applycompensationinconsistency-------------2-coh√©rence-forte-avec-quorumphpphpnamespace-gyroscopscloudinfrastructureconsistencyclass-strongconsistencywithquorum-implements-consistencystrategyinterface----private-int-quorumsize----private-array-stores----public-function-writeeventstream-stream-void------------successcount--0--------errors------------------foreach-this-stores-as-store-------------try-----------------store-appendstream----------------successcount-------------catch-exception-e-----------------errors--e------------------------------------if-successcount--this-quorumsize-------------throw-new-quorumnotreachedexceptionerrors--------------optimisations-de-performance-1-r√©plication-asynchrone-avec-queuephpphpnamespace-gyroscopscloudinfrastructurereplicationclass-asyncreplicationwithqueue-implements-replicationstrategyinterface----private-messagequeue-queue----private-replicationworker-worker----public-function-replicateeventstream-stream-void-------------√©criture-imm√©diate-dans-la-source-principale--------this-primarystore-appendstream-----------------mise-en-queue-pour-r√©plication-asynchrone--------this-queue-publishnew-replicationmessagestream--------public-function-processreplicationqueue-void------------while-message--this-queue-consume-------------this-worker-processmessage-------------2-r√©plication-par-batchphpphpnamespace-gyroscopscloudinfrastructurereplicationclass-batchreplicationstrategy-implements-replicationstrategyinterface----private-batchprocessor-batchprocessor----private-int-batchsize----private-int-batchtimeout----public-function-replicateeventstream-stream-void------------this-batchprocessor-addtobatchstream----------------if-this-shouldprocessbatch-------------this-processbatch----------------private-function-shouldprocessbatch-bool------------return-this-batchprocessor-getbatchsize--this-batchsize----------------this-batchprocessor-getbatchage--this-batchtimeout------monitoring-et-observabilit√©-1-m√©triques-de-r√©plicationphpphpnamespace-gyroscopscloudinfrastructuremonitoringclass-replicationmetrics----private-metricscollector-collector----public-function-recordreplicationlatencystring-storeid-float-latency-void------------this-collector-histogramreplicationlatency-latency-------------store--storeid----------------public-function-recordreplicationsuccessstring-storeid-void------------this-collector-incrementreplicationsuccess-------------store--storeid----------------public-function-recordreplicationfailurestring-storeid-string-error-void------------this-collector-incrementreplicationfailure-------------store--storeid------------error--error-------------2-health-checksphpphpnamespace-gyroscopscloudinfrastructurehealthclass-replicationhealthcheck-implements-healthcheckinterface----private-array-stores----private-consistencychecker-checker----public-function-check-healthstatus------------status--new-healthstatus----------------foreach-this-stores-as-storeid--store-------------try-----------------this-checkstorehealthstore----------------status-addstorestatusstoreid-healthy-------------catch-exception-e-----------------status-addstorestatusstoreid-unhealthy-e-getmessage------------------------------------return-status------patterns-avanc√©s-1-r√©plication-g√©ographiquephpphpnamespace-gyroscopscloudinfrastructurereplicationclass-geographicreplicationstrategy-implements-replicationstrategyinterface----private-array-regions----private-latencyoptimizer-optimizer----public-function-replicateeventstream-stream-void------------userregion--this-getuserregion--------targetregions--this-optimizer-selectoptimalregionsuserregion----------------foreach-targetregions-as-region-------------this-replicatetoregionregion-stream-------------2-r√©plication-adaptativephpphpnamespace-gyroscopscloudinfrastructurereplicationclass-adaptivereplicationstrategy-implements-replicationstrategyinterface----private-performancemonitor-monitor----private-strategyselector-selector----public-function-replicateeventstream-stream-void------------currentperformance--this-monitor-getcurrentperformance--------strategy--this-selector-selectstrategycurrentperformance----------------strategy-replicatestream------cas-d-syst√®mes-multi-r√©gion--latence-optimis√©e--r√©plication-bas√©e-sur-la-proximit√©-g√©ographique--disaster-recovery--r√©plication-cross-region-pour-la-continuit√©--compliance--respect-des-r√©glementations-par-r√©gion-syst√®mes-de-trading--latence-ultra-faible--r√©plication-imm√©diate-pour-les-donn√©es-critiques--coh√©rence-forte--garantie-de-coh√©rence-pour-les-transactions-financi√®res--audit-trail--tra√ßabilit√©-compl√®te-des-modifications--m√©triques-et-kpis-m√©triques-de-performance--latence-de-r√©plication--temps-moyen-de-r√©plication--throughput--nombre-d√©v√©nements-r√©pliqu√©s-par-seconde--taux-de-succ√®s--pourcentage-de-r√©plications-r√©ussies--d√©lai-de-synchronisation--temps-de-convergence-entre-stores-m√©triques-de-qualit√©--coh√©rence--pourcentage-de-donn√©es-coh√©rentes--int√©grit√©--absence-de-corruption-des-donn√©es--disponibilit√©--temps-de-fonctionnement-des-stores--r√©cup√©ration--temps-de-r√©cup√©ration-apr√®s-panne--prochaines-√©tapesapr√®s-avoir-ma√Ætris√©-les-strat√©gies-avanc√©es-de-r√©plication-vous-pouvez---explorer-la-r√©solution-de-conflits-dans-les-environnements-multi-sources--d√©couvrir-les-techniques-de-monitoring-et-dobservabilit√©-avanc√©es--apprendre-les-patterns-de-migration-et-de-maintenance--impl√©menter-des-solutions-de-disaster-recovery-sophistiqu√©eshahahugoshortcode62s0hbhb"&gt;üéØ &lt;strong&gt;Objectif du Chapitre&lt;/strong&gt;Ce chapitre explore les &lt;strong&gt;strat√©gies avanc√©es de r√©plication&lt;/strong&gt; pour les syst√®mes multi-sources, couvrant les patterns sophistiqu√©s de synchronisation, de coh√©rence et d&amp;rsquo;optimisation des performances.## üåü &lt;strong&gt;Concepts Cl√©s&lt;/strong&gt;### &lt;strong&gt;R√©plication Avanc√©e&lt;/strong&gt;La r√©plication avanc√©e va au-del√† de la simple duplication de donn√©es :- &lt;strong&gt;R√©plication intelligente&lt;/strong&gt; : S√©lection dynamique des sources- &lt;strong&gt;Synchronisation bidirectionnelle&lt;/strong&gt; : Mise √† jour dans les deux sens- &lt;strong&gt;R√©plication conditionnelle&lt;/strong&gt; : Bas√©e sur des crit√®res m√©tier- &lt;strong&gt;Optimisation des performances&lt;/strong&gt; : R√©plication asynchrone et parall√®le### &lt;strong&gt;Architecture de R√©plication Avanc√©e&lt;/strong&gt;&lt;code&gt;mermaidgraph TB A[Event Source] --&amp;gt; B[Replication Manager] B --&amp;gt; C[Strategy Selector] C --&amp;gt; D[Immediate Replication] C --&amp;gt; E[Batch Replication] C --&amp;gt; F[Conditional Replication] D --&amp;gt; G[Primary Store] D --&amp;gt; H[Secondary Store] E --&amp;gt; I[Batch Processor] I --&amp;gt; J[Multiple Stores] F --&amp;gt; K[Rule Engine] K --&amp;gt; L[Target Stores] M[Conflict Resolver] --&amp;gt; N[Consistency Checker] N --&amp;gt; O[Sync Status]&lt;/code&gt;## üèóÔ∏è &lt;strong&gt;Patterns de R√©plication&lt;/strong&gt;### &lt;strong&gt;1. R√©plication en Cascade&lt;/strong&gt;Les donn√©es sont r√©pliqu√©es de mani√®re s√©quentielle :&lt;code&gt;php&amp;lt;?phpnamespace Gyroscops\Cloud\Infrastructure\Replication;class CascadeReplicationStrategy implements ReplicationStrategyInterface{ private array $storeChain; private int $maxRetries; public function replicate(EventStream $stream): void { $currentStream = $stream; foreach ($this-&amp;gt;storeChain as $store) { try { $store-&amp;gt;append($currentStream); $currentStream = $this-&amp;gt;transformStream($currentStream, $store); } catch (Exception $e) { $this-&amp;gt;handleReplicationFailure($store, $e); break; // Arr√™ter la cascade en cas d'√©chec } } } private function transformStream(EventStream $stream, EventStoreInterface $store): EventStream { // Transformation des √©v√©nements selon le type de store $transformedEvents = []; foreach ($stream-&amp;gt;getEvents() as $event) { $transformedEvents[] = $this-&amp;gt;transformEvent($event, $store); } return new EventStream($transformedEvents); }}&lt;/code&gt;### &lt;strong&gt;2. R√©plication en √âtoile&lt;/strong&gt;Toutes les sources sont mises √† jour simultan√©ment :&lt;code&gt;php&amp;lt;?phpnamespace Gyroscops\Cloud\Infrastructure\Replication;class StarReplicationStrategy implements ReplicationStrategyInterface{ private array $stores; private ReplicationCoordinator $coordinator; public function replicate(EventStream $stream): void { $replicationTasks = []; foreach ($this-&amp;gt;stores as $storeId =&amp;gt; $store) { $replicationTasks[] = $this-&amp;gt;createReplicationTask($store, $stream); } $this-&amp;gt;coordinator-&amp;gt;executeParallel($replicationTasks); } private function createReplicationTask(EventStoreInterface $store, EventStream $stream): ReplicationTask { return new ReplicationTask(function() use ($store, $stream) { try { $store-&amp;gt;append($stream); return ReplicationResult::success(); } catch (Exception $e) { return ReplicationResult::failure($e); } }); }}&lt;/code&gt;### &lt;strong&gt;3. R√©plication Conditionnelle&lt;/strong&gt;La r√©plication d√©pend de crit√®res m√©tier :&lt;code&gt;php&amp;lt;?phpnamespace Gyroscops\Cloud\Infrastructure\Replication;class ConditionalReplicationStrategy implements ReplicationStrategyInterface{ private array $replicationRules; private RuleEngine $ruleEngine; public function replicate(EventStream $stream): void { foreach ($stream-&amp;gt;getEvents() as $event) { $targetStores = $this-&amp;gt;ruleEngine-&amp;gt;evaluate($event, $this-&amp;gt;replicationRules); foreach ($targetStores as $store) { $this-&amp;gt;replicateToStore($store, $event); } } } private function replicateToStore(EventStoreInterface $store, DomainEvent $event): void { try { $store-&amp;gt;append(new EventStream([$event])); } catch (Exception $e) { $this-&amp;gt;handleReplicationError($store, $event, $e); } }}&lt;/code&gt;## üîÑ &lt;strong&gt;Strat√©gies de Coh√©rence&lt;/strong&gt;### &lt;strong&gt;1. Coh√©rence √âventuelle avec Compensation&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace Gyroscops\Cloud\Infrastructure\Consistency;class EventualConsistencyWithCompensation implements ConsistencyStrategyInterface{ private ConsistencyChecker $checker; private CompensationManager $compensation; public function ensureConsistency(array $stores): void { $inconsistencies = $this-&amp;gt;checker-&amp;gt;detectInconsistencies($stores); foreach ($inconsistencies as $inconsistency) { $this-&amp;gt;compensation-&amp;gt;applyCompensation($inconsistency); } }}&lt;/code&gt;### &lt;strong&gt;2. Coh√©rence Forte avec Quorum&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace Gyroscops\Cloud\Infrastructure\Consistency;class StrongConsistencyWithQuorum implements ConsistencyStrategyInterface{ private int $quorumSize; private array $stores; public function write(EventStream $stream): void { $successCount = 0; $errors = []; foreach ($this-&amp;gt;stores as $store) { try { $store-&amp;gt;append($stream); $successCount++; } catch (Exception $e) { $errors[] = $e; } } if ($successCount &amp;lt; $this-&amp;gt;quorumSize) { throw new QuorumNotReachedException($errors); } }}&lt;/code&gt;## ‚ö° &lt;strong&gt;Optimisations de Performance&lt;/strong&gt;### &lt;strong&gt;1. R√©plication Asynchrone avec Queue&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace Gyroscops\Cloud\Infrastructure\Replication;class AsyncReplicationWithQueue implements ReplicationStrategyInterface{ private MessageQueue $queue; private ReplicationWorker $worker; public function replicate(EventStream $stream): void { // √âcriture imm√©diate dans la source principale $this-&amp;gt;primaryStore-&amp;gt;append($stream); // Mise en queue pour r√©plication asynchrone $this-&amp;gt;queue-&amp;gt;publish(new ReplicationMessage($stream)); } public function processReplicationQueue(): void { while ($message = $this-&amp;gt;queue-&amp;gt;consume()) { $this-&amp;gt;worker-&amp;gt;process($message); } }}&lt;/code&gt;### &lt;strong&gt;2. R√©plication par Batch&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace Gyroscops\Cloud\Infrastructure\Replication;class BatchReplicationStrategy implements ReplicationStrategyInterface{ private BatchProcessor $batchProcessor; private int $batchSize; private int $batchTimeout; public function replicate(EventStream $stream): void { $this-&amp;gt;batchProcessor-&amp;gt;addToBatch($stream); if ($this-&amp;gt;shouldProcessBatch()) { $this-&amp;gt;processBatch(); } } private function shouldProcessBatch(): bool { return $this-&amp;gt;batchProcessor-&amp;gt;getBatchSize() &amp;gt;= $this-&amp;gt;batchSize || $this-&amp;gt;batchProcessor-&amp;gt;getBatchAge() &amp;gt;= $this-&amp;gt;batchTimeout; }}&lt;/code&gt;## üîç &lt;strong&gt;Monitoring et Observabilit√©&lt;/strong&gt;### &lt;strong&gt;1. M√©triques de R√©plication&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace Gyroscops\Cloud\Infrastructure\Monitoring;class ReplicationMetrics{ private MetricsCollector $collector; public function recordReplicationLatency(string $storeId, float $latency): void { $this-&amp;gt;collector-&amp;gt;histogram('replication.latency', $latency, [ 'store' =&amp;gt; $storeId ]); } public function recordReplicationSuccess(string $storeId): void { $this-&amp;gt;collector-&amp;gt;increment('replication.success', [ 'store' =&amp;gt; $storeId ]); } public function recordReplicationFailure(string $storeId, string $error): void { $this-&amp;gt;collector-&amp;gt;increment('replication.failure', [ 'store' =&amp;gt; $storeId, 'error' =&amp;gt; $error ]); }}&lt;/code&gt;### &lt;strong&gt;2. Health Checks&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace Gyroscops\Cloud\Infrastructure\Health;class ReplicationHealthCheck implements HealthCheckInterface{ private array $stores; private ConsistencyChecker $checker; public function check(): HealthStatus { $status = new HealthStatus(); foreach ($this-&amp;gt;stores as $storeId =&amp;gt; $store) { try { $this-&amp;gt;checkStoreHealth($store); $status-&amp;gt;addStoreStatus($storeId, 'healthy'); } catch (Exception $e) { $status-&amp;gt;addStoreStatus($storeId, 'unhealthy', $e-&amp;gt;getMessage()); } } return $status; }}&lt;/code&gt;## üéØ &lt;strong&gt;Patterns Avanc√©s&lt;/strong&gt;### &lt;strong&gt;1. R√©plication G√©ographique&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace Gyroscops\Cloud\Infrastructure\Replication;class GeographicReplicationStrategy implements ReplicationStrategyInterface{ private array $regions; private LatencyOptimizer $optimizer; public function replicate(EventStream $stream): void { $userRegion = $this-&amp;gt;getUserRegion(); $targetRegions = $this-&amp;gt;optimizer-&amp;gt;selectOptimalRegions($userRegion); foreach ($targetRegions as $region) { $this-&amp;gt;replicateToRegion($region, $stream); } }}&lt;/code&gt;### &lt;strong&gt;2. R√©plication Adaptative&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace Gyroscops\Cloud\Infrastructure\Replication;class AdaptiveReplicationStrategy implements ReplicationStrategyInterface{ private PerformanceMonitor $monitor; private StrategySelector $selector; public function replicate(EventStream $stream): void { $currentPerformance = $this-&amp;gt;monitor-&amp;gt;getCurrentPerformance(); $strategy = $this-&amp;gt;selector-&amp;gt;selectStrategy($currentPerformance); $strategy-&amp;gt;replicate($stream); }}&lt;/code&gt;## üöÄ &lt;strong&gt;Cas d&amp;rsquo;Usage Avanc√©s&lt;/strong&gt;### &lt;strong&gt;Syst√®mes Multi-r√©gion&lt;/strong&gt;- &lt;strong&gt;Latence optimis√©e&lt;/strong&gt; : R√©plication bas√©e sur la proximit√© g√©ographique- &lt;strong&gt;Disaster recovery&lt;/strong&gt; : R√©plication cross-region pour la continuit√©- &lt;strong&gt;Compliance&lt;/strong&gt; : Respect des r√©glementations par r√©gion### &lt;strong&gt;Syst√®mes de Trading&lt;/strong&gt;- &lt;strong&gt;Latence ultra-faible&lt;/strong&gt; : R√©plication imm√©diate pour les donn√©es critiques- &lt;strong&gt;Coh√©rence forte&lt;/strong&gt; : Garantie de coh√©rence pour les transactions financi√®res- &lt;strong&gt;Audit trail&lt;/strong&gt; : Tra√ßabilit√© compl√®te des modifications## üìä &lt;strong&gt;M√©triques et KPIs&lt;/strong&gt;### &lt;strong&gt;M√©triques de Performance&lt;/strong&gt;- &lt;strong&gt;Latence de r√©plication&lt;/strong&gt; : Temps moyen de r√©plication- &lt;strong&gt;Throughput&lt;/strong&gt; : Nombre d&amp;rsquo;√©v√©nements r√©pliqu√©s par seconde- &lt;strong&gt;Taux de succ√®s&lt;/strong&gt; : Pourcentage de r√©plications r√©ussies- &lt;strong&gt;D√©lai de synchronisation&lt;/strong&gt; : Temps de convergence entre stores### &lt;strong&gt;M√©triques de Qualit√©&lt;/strong&gt;- &lt;strong&gt;Coh√©rence&lt;/strong&gt; : Pourcentage de donn√©es coh√©rentes- &lt;strong&gt;Int√©grit√©&lt;/strong&gt; : Absence de corruption des donn√©es- &lt;strong&gt;Disponibilit√©&lt;/strong&gt; : Temps de fonctionnement des stores- &lt;strong&gt;R√©cup√©ration&lt;/strong&gt; : Temps de r√©cup√©ration apr√®s panne## üéØ &lt;strong&gt;Prochaines √âtapes&lt;/strong&gt;Apr√®s avoir ma√Ætris√© les strat√©gies avanc√©es de r√©plication, vous pouvez :- &lt;strong&gt;Explorer la r√©solution de conflits&lt;/strong&gt; dans les environnements multi-sources- &lt;strong&gt;D√©couvrir les techniques de monitoring&lt;/strong&gt; et d&amp;rsquo;observabilit√© avanc√©es- &lt;strong&gt;Apprendre les patterns de migration&lt;/strong&gt; et de maintenance- &lt;strong&gt;Impl√©menter des solutions de disaster recovery&lt;/strong&gt; sophistiqu√©es&amp;mdash;

&lt;div class="chapter-navigation"&gt;
 &lt;h2 class="chapter-nav-title"&gt;üéØ Votre Prochaine √âtape&lt;/h2&gt;
 &lt;p class="chapter-nav-subtitle"&gt;Maintenant que vous comprenez les concepts de base et que j'ai partag√© mon exp√©rience avec Gyroscops, quel est votre contexte ?&lt;/p&gt;</description></item><item><title>R√©solution de Conflits Multi-sources</title><link>http://localhost:1313/chapitres/stockage/multi-sources/chapitre-57-stockage-multi-sources-resolution-conflits/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/multi-sources/chapitre-57-stockage-multi-sources-resolution-conflits/</guid><description/></item></channel></rss>