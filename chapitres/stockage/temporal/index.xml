<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Stockage Composite piloté par Temporal on DDD Adventure</title><link>http://localhost:1313/chapitres/stockage/temporal/</link><description>Recent content in Stockage Composite piloté par Temporal on DDD Adventure</description><generator>Hugo</generator><language>fr-fr</language><lastBuildDate>Thu, 19 Dec 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/chapitres/stockage/temporal/index.xml" rel="self" type="application/rss+xml"/><item><title>Stockage Temporal - Approche Classique</title><link>http://localhost:1313/chapitres/stockage/temporal/chapitre-46-stockage-temporal-classique/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/temporal/chapitre-46-stockage-temporal-classique/</guid><description>&lt;h2 id="-contexte-et-objectifs-pourquoi-temporal-pour-le-stockage-temporal-workflows-offre-une-approche-unique-pour-le-stockage-en-gérant-létat-des-processus-métier-complexes-de-manière-durable-et-résiliente-cette-approche-est-particulièrement-adaptée-aux-workflows-qui-nécessitent-de-la-persistance-de-la-reprise-sur-panne-et-de-lorchestration-avantages-du-stockage-temporal--durabilité--état-des-workflows-persisté-automatiquement--résilience--reprise-automatique-après-panne--orchestration--gestion-complexe-des-processus-métier--observabilité--visibilité-complète-sur-lexécution--scalabilité--exécution-distribuée-des-workflows-contexte-gyroscopsdans-notre-écosystème-user--organization--workflow--cloud-resources--billing-temporal-est-particulièrement-pertinent-pour---workflows-de-provisioning--orchestration-des-ressources-cloud--processus-de-facturation--gestion-des-cycles-de-facturation--intégrations-complexes--orchestration-des-intégrations-api--processus-métier-longs--workflows-qui-sétalent-sur-plusieurs-jours--architecture-temporal-classique-structure-des-workflows-workflow-de-basephpphpnamespace-appworkflowpaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowworkflowinterfaceinterface-paymentworkflowinterface----workflowmethod----public-function-processpaymentpaymentrequest-request-paymentresultactivityinterfaceinterface-paymentactivityinterface----activitymethod----public-function-validatepaymentpaymentrequest-request-validationresult--------activitymethod----public-function-chargepaymentpaymentrequest-request-chargeresult--------activitymethod----public-function-sendnotificationpaymentresult-result-voidclass-paymentworkflow-implements-paymentworkflowinterface----private-paymentactivityinterface-paymentactivity----public-function-__construct------------this-paymentactivity--workflownewactivitystubpaymentactivityinterfaceclass--------public-function-processpaymentpaymentrequest-request-paymentresult-------------validation-du-paiement--------validation--yield-this-paymentactivity-validatepaymentrequest----------------if-validation-isvalid-------------return-new-paymentresultfalse-validation-geterror-------------------------traitement-du-paiement--------charge--yield-this-paymentactivity-chargepaymentrequest----------------if-charge-issuccess-------------return-new-paymentresultfalse-charge-geterror-------------------------notification--------yield-this-paymentactivity-sendnotification------------new-paymentresulttrue-payment-processed-successfully------------------------return-new-paymentresulttrue-payment-processed-successfully-----activités-de-persistancephpphpnamespace-appworkflowpaymentuse-temporalactivityactivityinterfaceuse-temporalactivityactivitymethoduse-appdomainpaymentpaymentrepositoryinterfaceuse-appdomainpaymentpaymentuse-psrlogloggerinterfaceclass-paymentactivity-implements-paymentactivityinterface----private-paymentrepositoryinterface-paymentrepository----private-loggerinterface-logger----public-function-__construct--------paymentrepositoryinterface-paymentrepository--------loggerinterface-logger-------------this-paymentrepository--paymentrepository--------this-logger--logger--------activitymethod----public-function-validatepaymentpaymentrequest-request-validationresult------------try-------------this-logger-infovalidating-payment-----------------paymentid--request-getpaymentid----------------amount--request-getamount-------------------------------------validation-métier------------if-request-getamount--0-----------------return-new-validationresultfalse-invalid-amount------------------------------------if-emptyrequest-getcurrency-----------------return-new-validationresultfalse-currency-required-------------------------------------vérification-de-lorganisation------------if-this-paymentrepository-organizationexistsrequest-getorganizationid-----------------return-new-validationresultfalse-organization-not-found------------------------------------return-new-validationresulttrue---------------------catch-exception-e-------------this-logger-errorpayment-validation-failed-----------------paymentid--request-getpaymentid----------------error--e-getmessage------------------------------------return-new-validationresultfalse-e-getmessage----------------activitymethod----public-function-chargepaymentpaymentrequest-request-chargeresult------------try-------------this-logger-infocharging-payment-----------------paymentid--request-getpaymentid----------------amount--request-getamount-------------------------------------créer-le-paiement------------payment--new-payment----------------request-getpaymentid----------------request-getorganizationid----------------request-getuserid----------------request-getamount----------------request-getcurrency----------------processing----------------request-getdescription----------------new-datetime-------------------------------------sauvegarder-le-paiement------------this-paymentrepository-savepayment-------------------------simuler-le-traitement-du-paiement-------------dans-un-vrai-système-ceci-appellerait-un-service-de-paiement------------this-simulatepaymentprocessingrequest-------------------------mettre-à-jour-le-statut------------payment-markascompleted------------this-paymentrepository-savepayment------------------------return-new-chargeresulttrue-payment-charged-successfully---------------------catch-exception-e-------------this-logger-errorpayment-charging-failed-----------------paymentid--request-getpaymentid----------------error--e-getmessage------------------------------------return-new-chargeresultfalse-e-getmessage----------------activitymethod----public-function-sendnotificationpaymentresult-result-void------------try-------------this-logger-infosending-payment-notification-----------------success--result-issuccess----------------message--result-getmessage-------------------------------------envoyer-une-notification-email-webhook-etc------------this-sendemailnotificationresult------------this-sendwebhooknotificationresult---------------------catch-exception-e-------------this-logger-errornotification-sending-failed-----------------error--e-getmessage----------------------------private-function-simulatepaymentprocessingpaymentrequest-request-void-------------simuler-un-délai-de-traitement--------sleep2-----------------simuler-une-échec-aléatoire-5-de-chance--------if-rand1-100--5-------------throw-new-exceptionpayment-processing-failed----------------private-function-sendemailnotificationpaymentresult-result-void-------------implémentation-de-lenvoi-demail--------private-function-sendwebhooknotificationpaymentresult-result-void-------------implémentation-de-lenvoi-de-webhook-----flux-de-donnéesmermaidgraph-td----aclient-request----btemporal-client----b----cworkflow-execution----c----dactivity-1-validation----d----eactivity-2-charging----e----factivity-3-notification----f----gworkflow-complete--------hpersistence-layer----ipayment-repository----i----jdatabase--------c----h----d----h----e----h----f----h--------ktemporal-server----lworkflow-state----l----mactivity-state----m----nevent-history--implémentation-pratique-1-configuration-temporal-configuration-du-clientphpphpnamespace-appinfrastructuretemporaluse-temporalclientworkflowclientuse-temporalclientworkflowclientinterfaceuse-temporalclientworkflowoptionsuse-temporaldataconverterdataconverteruse-temporaldataconverterjsondataconverterclass-temporalclientfactory----private-string-host----private-int-port----private-string-namespace----public-function-__constructstring-host--localhost-int-port--7233-string-namespace--default------------this-host--host--------this-port--port--------this-namespace--namespace--------public-function-createclient-workflowclientinterface------------dataconverter--new-dataconverter------------new-jsondataconverter----------------return-workflowclientcreate------------this-host----this-port----------------------------namespace--this-namespace----------------dataconverter--dataconverter----------------------------public-function-createworkflowoptions-workflowoptions------------return-workflowoptionsnew-------------withworkflowidpayment-workflow---uniqid-------------withworkflowexecutiontimeout300--5-minutes-------------withworkflowruntimeout300-------------withworkflowtasktimeout60-----service-de-workflowphpphpnamespace-appapplicationservicetemporaluse-appworkflowpaymentpaymentworkflowinterfaceuse-appworkflowpaymentpaymentrequestuse-appworkflowpaymentpaymentresultuse-temporalclientworkflowclientinterfaceuse-temporalclientworkflowoptionsuse-psrlogloggerinterfaceclass-paymentworkflowservice----private-workflowclientinterface-workflowclient----private-loggerinterface-logger----public-function-__construct--------workflowclientinterface-workflowclient--------loggerinterface-logger-------------this-workflowclient--workflowclient--------this-logger--logger--------public-function-processpaymentpaymentrequest-request-paymentresult------------try-------------this-logger-infostarting-payment-workflow-----------------paymentid--request-getpaymentid----------------amount--request-getamount------------------------workflowoptions--workflowoptionsnew-----------------withworkflowidpayment---request-getpaymentid-----------------withworkflowexecutiontimeout300-----------------withworkflowruntimeout300-----------------withworkflowtasktimeout60------------workflow--this-workflowclient-newworkflowstub----------------paymentworkflowinterfaceclass----------------workflowoptions------------------------result--workflow-processpaymentrequest------------this-logger-infopayment-workflow-completed-----------------paymentid--request-getpaymentid----------------success--result-issuccess------------------------return-result---------catch-exception-e-------------this-logger-errorpayment-workflow-failed-----------------paymentid--request-getpaymentid----------------error--e-getmessage------------------------throw-e----------------public-function-getworkflowstatusstring-workflowid-array------------try-------------workflow--this-workflowclient-newworkflowstub----------------paymentworkflowinterfaceclass----------------workflowid------------------------status--workflow-getstatus------------return-----------------workflowid--workflowid----------------status--status----------------isrunning--status--running----------------iscompleted--status--completed----------------isfailed--status--failed---------------------catch-exception-e-------------this-logger-errorfailed-to-get-workflow-status-----------------workflowid--workflowid----------------error--e-getmessage------------------------throw-e----------------public-function-cancelworkflowstring-workflowid-void------------try-------------workflow--this-workflowclient-newworkflowstub----------------paymentworkflowinterfaceclass----------------workflowid------------------------workflow-cancel------------this-logger-infoworkflow-cancelled-----------------workflowid--workflowid---------------------catch-exception-e-------------this-logger-errorfailed-to-cancel-workflow-----------------workflowid--workflowid----------------error--e-getmessage------------------------throw-e-------------2-repository-temporal-repository-avec-persistance-temporalphpphpnamespace-appinfrastructuretemporalrepositoryuse-appdomainpaymentpaymentuse-appdomainpaymentpaymentrepositoryinterfaceuse-appinfrastructuretemporaltemporalclientfactoryuse-psrlogloggerinterfaceclass-temporalpaymentrepository-implements-paymentrepositoryinterface----private-temporalclientfactory-temporalfactory----private-loggerinterface-logger----private-array-cache------public-function-__construct--------temporalclientfactory-temporalfactory--------loggerinterface-logger-------------this-temporalfactory--temporalfactory--------this-logger--logger--------public-function-savepayment-payment-void------------try-------------workflowid--payment---payment-getid-------------------------créer-un-workflow-de-persistance------------workflowoptions--this-temporalfactory-createworkflowoptions-----------------withworkflowidworkflowid------------------------workflow--this-temporalfactory-createclient-----------------newworkflowstubpaymentpersistenceworkflowinterfaceclass-workflowoptions-------------------------exécuter-le-workflow-de-persistance------------workflow-persistpaymentpayment-------------------------mettre-en-cache------------this-cachepayment-getid--payment------------------------this-logger-infopayment-persisted-via-temporal-----------------paymentid--payment-getid----------------workflowid--workflowid---------------------------------catch-exception-e-------------this-logger-errorfailed-to-persist-payment-via-temporal-----------------paymentid--payment-getid----------------error--e-getmessage------------------------------------throw-e----------------public-function-findbyidstring-id-payment-------------vérifier-le-cache-dabord--------if-issetthis-cacheid-------------return-this-cacheid------------------------try-------------workflowid--payment---id-------------------------récupérer-depuis-temporal------------workflow--this-temporalfactory-createclient-----------------newworkflowstubpaymentpersistenceworkflowinterfaceclass-workflowid------------------------payment--workflow-getpaymentid------------------------if-payment-----------------this-cacheid--payment------------------------------------return-payment---------------------catch-exception-e-------------this-logger-errorfailed-to-retrieve-payment-from-temporal-----------------paymentid--id----------------error--e-getmessage------------------------------------return-null----------------public-function-findbyorganizationstring-organizationid-array------------try-------------workflowid--payment-search---organizationid-----uniqid-------------------------créer-un-workflow-de-recherche------------workflowoptions--this-temporalfactory-createworkflowoptions-----------------withworkflowidworkflowid------------------------workflow--this-temporalfactory-createclient-----------------newworkflowstubpaymentsearchworkflowinterfaceclass-workflowoptions------------------------payments--workflow-searchbyorganizationorganizationid-------------------------mettre-en-cache------------foreach-payments-as-payment-----------------this-cachepayment-getid--payment------------------------------------return-payments---------------------catch-exception-e-------------this-logger-errorfailed-to-search-payments-via-temporal-----------------organizationid--organizationid----------------error--e-getmessage------------------------------------return-----------------public-function-deletestring-id-void------------try-------------workflowid--payment-delete---id-------------------------créer-un-workflow-de-suppression------------workflowoptions--this-temporalfactory-createworkflowoptions-----------------withworkflowidworkflowid------------------------workflow--this-temporalfactory-createclient-----------------newworkflowstubpaymentpersistenceworkflowinterfaceclass-workflowoptions------------------------workflow-deletepaymentid-------------------------supprimer-du-cache------------unsetthis-cacheid------------------------this-logger-infopayment-deleted-via-temporal-----------------paymentid--id----------------workflowid--workflowid---------------------------------catch-exception-e-------------this-logger-errorfailed-to-delete-payment-via-temporal-----------------paymentid--id----------------error--e-getmessage------------------------------------throw-e----------------public-function-count-int------------try-------------workflowid--payment-count---uniqid-------------------------créer-un-workflow-de-comptage------------workflowoptions--this-temporalfactory-createworkflowoptions-----------------withworkflowidworkflowid------------------------workflow--this-temporalfactory-createclient-----------------newworkflowstubpaymentsearchworkflowinterfaceclass-workflowoptions------------------------return-workflow-getpaymentcount---------------------catch-exception-e-------------this-logger-errorfailed-to-count-payments-via-temporal-----------------error--e-getmessage------------------------------------return-0-------------3-workflows-de-persistance-workflow-de-persistance-des-paiementsphpphpnamespace-appworkflowpersistenceuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowuse-appdomainpaymentpaymentworkflowinterfaceinterface-paymentpersistenceworkflowinterface----workflowmethod----public-function-persistpaymentpayment-payment-void--------workflowmethod----public-function-getpaymentstring-paymentid-payment--------workflowmethod----public-function-deletepaymentstring-paymentid-voidactivityinterfaceinterface-paymentpersistenceactivityinterface----activitymethod----public-function-savetodatabasepayment-payment-void--------activitymethod----public-function-loadfromdatabasestring-paymentid-payment--------activitymethod----public-function-deletefromdatabasestring-paymentid-voidclass-paymentpersistenceworkflow-implements-paymentpersistenceworkflowinterface----private-paymentpersistenceactivityinterface-persistenceactivity----public-function-__construct------------this-persistenceactivity--workflownewactivitystubpaymentpersistenceactivityinterfaceclass--------public-function-persistpaymentpayment-payment-void------------yield-this-persistenceactivity-savetodatabasepayment--------public-function-getpaymentstring-paymentid-payment------------return-yield-this-persistenceactivity-loadfromdatabasepaymentid--------public-function-deletepaymentstring-paymentid-void------------yield-this-persistenceactivity-deletefromdatabasepaymentid------tests-et-validation-tests-dphpphpnamespace-apptestsintegrationtemporaluse-appworkflowpaymentpaymentrequestuse-appapplicationservicetemporalpaymentworkflowserviceuse-appinfrastructuretemporaltemporalclientfactoryclass-temporalpaymentworkflowtest-extends-testcase----private-paymentworkflowservice-workflowservice----private-temporalclientfactory-temporalfactory----protected-function-setup-void------------this-temporalfactory--new-temporalclientfactorylocalhost-7233-test--------this-workflowservice--new-paymentworkflowservice------------this-temporalfactory-createclient------------this-createmockloggerinterfaceclass----------------public-function-testpaymentworkflowexecution-void------------request--new-paymentrequest------------payment-123------------org-456------------user-789------------10000------------eur------------test-payment------------------------result--this-workflowservice-processpaymentrequest----------------this-asserttrueresult-issuccess--------this-assertequalspayment-processed-successfully-result-getmessage--------public-function-testworkflowstatus-void------------request--new-paymentrequest------------payment-456------------org-789------------user-123------------20000------------usd------------test-payment-2------------------------this-workflowservice-processpaymentrequest----------------status--this-workflowservice-getworkflowstatuspayment-payment-456----------------this-assertarrayhaskeyworkflowid-status--------this-assertarrayhaskeystatus-status--------this-assertarrayhaskeyiscompleted-status------performance-et-optimisation-stratégies-d-1-configuration-des-timeoutsphppublic-function-createoptimizedworkflowoptions-workflowoptions----return-workflowoptionsnew---------withworkflowidpayment-workflow---uniqid---------withworkflowexecutiontimeout600--10-minutes---------withworkflowruntimeout600---------withworkflowtasktimeout120---------withretryoptions------------initialinterval--1s------------maximuminterval--60s------------backoffcoefficient--20------------maximumattempts--3---------2-cache-des-workflowsphppublic-function-getworkflowwithcachestring-workflowid-paymentworkflowinterface----if-issetthis-workflowcacheworkflowid---------return-this-workflowcacheworkflowid------------workflow--this-workflowclient-newworkflowstub--------paymentworkflowinterfaceclass--------workflowid------------this-workflowcacheworkflowid--workflow--------return-workflow-3-monitoring-et-observabilitéphppublic-function-getworkflowmetrics-array----return---------activeworkflows--this-getactiveworkflowcount--------completedworkflows--this-getcompletedworkflowcount--------failedworkflows--this-getfailedworkflowcount--------averageexecutiontime--this-getaverageexecutiontime------critères-d-quand-utiliser-temporal-classique--avantages--durabilité--état-des-workflows-persisté-automatiquement--résilience--reprise-automatique-après-panne--orchestration--gestion-complexe-des-processus-métier--observabilité--visibilité-complète-sur-lexécution--scalabilité--exécution-distribuée-des-workflows--inconvénients--complexité--courbe-dapprentissage-importante--infrastructure--nécessite-un-serveur-temporal--latence--overhead-pour-les-opérations-simples--expertise--équipe-expérimentée-requise--critères-d--processus-métier-complexes--workflows-qui-nécessitent-de-lorchestration--résilience-critique--besoin-de-reprise-automatique-après-panne--processus-longs--workflows-qui-sétalent-sur-plusieurs-jours--intégrations-multiples--orchestration-de-plusieurs-services--équipe-expérimentée--maîtrise-de-temporal-et-des-workflows--infrastructure-disponible--serveur-temporal-opérationnel--votre-prochaine-étapehahahugoshortcode77s0hbhbtemporal-classique-offre-une-approche-puissante-pour-l"&gt;🎯 &lt;strong&gt;Contexte et Objectifs&lt;/strong&gt;### **Pourquoi Temporal pour le Stockage ?**Temporal Workflows offre une approche unique pour le stockage en gérant l&amp;rsquo;état des processus métier complexes de manière durable et résiliente. Cette approche est particulièrement adaptée aux workflows qui nécessitent de la persistance, de la reprise sur panne et de l&amp;rsquo;orchestration.#### &lt;strong&gt;Avantages du Stockage Temporal&lt;/strong&gt;- &lt;strong&gt;Durabilité&lt;/strong&gt; : État des workflows persisté automatiquement- &lt;strong&gt;Résilience&lt;/strong&gt; : Reprise automatique après panne- &lt;strong&gt;Orchestration&lt;/strong&gt; : Gestion complexe des processus métier- &lt;strong&gt;Observabilité&lt;/strong&gt; : Visibilité complète sur l&amp;rsquo;exécution- &lt;strong&gt;Scalabilité&lt;/strong&gt; : Exécution distribuée des workflows### &lt;strong&gt;Contexte Gyroscops&lt;/strong&gt;Dans notre écosystème &lt;strong&gt;User → Organization → Workflow → Cloud Resources → Billing&lt;/strong&gt;, Temporal est particulièrement pertinent pour :- &lt;strong&gt;Workflows de provisioning&lt;/strong&gt; : Orchestration des ressources cloud- &lt;strong&gt;Processus de facturation&lt;/strong&gt; : Gestion des cycles de facturation- &lt;strong&gt;Intégrations complexes&lt;/strong&gt; : Orchestration des intégrations API- &lt;strong&gt;Processus métier longs&lt;/strong&gt; : Workflows qui s&amp;rsquo;étalent sur plusieurs jours## 🏗️ &lt;strong&gt;Architecture Temporal Classique&lt;/strong&gt;### &lt;strong&gt;Structure des Workflows&lt;/strong&gt;#### &lt;strong&gt;Workflow de Base&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Workflow\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;#[WorkflowInterface]interface PaymentWorkflowInterface{ #[WorkflowMethod] public function processPayment(PaymentRequest $request): PaymentResult;}#[ActivityInterface]interface PaymentActivityInterface{ #[ActivityMethod] public function validatePayment(PaymentRequest $request): ValidationResult; #[ActivityMethod] public function chargePayment(PaymentRequest $request): ChargeResult; #[ActivityMethod] public function sendNotification(PaymentResult $result): void;}class PaymentWorkflow implements PaymentWorkflowInterface{ private PaymentActivityInterface $paymentActivity; public function __construct() { $this-&amp;gt;paymentActivity = Workflow::newActivityStub(PaymentActivityInterface::class); } public function processPayment(PaymentRequest $request): PaymentResult { // Validation du paiement $validation = yield $this-&amp;gt;paymentActivity-&amp;gt;validatePayment($request); if (!$validation-&amp;gt;isValid()) { return new PaymentResult(false, $validation-&amp;gt;getError()); } // Traitement du paiement $charge = yield $this-&amp;gt;paymentActivity-&amp;gt;chargePayment($request); if (!$charge-&amp;gt;isSuccess()) { return new PaymentResult(false, $charge-&amp;gt;getError()); } // Notification yield $this-&amp;gt;paymentActivity-&amp;gt;sendNotification( new PaymentResult(true, 'Payment processed successfully') ); return new PaymentResult(true, 'Payment processed successfully'); }}&lt;/code&gt;#### &lt;strong&gt;Activités de Persistance&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Workflow\Payment;use Temporal\Activity\ActivityInterface;use Temporal\Activity\ActivityMethod;use App\Domain\Payment\PaymentRepositoryInterface;use App\Domain\Payment\Payment;use Psr\Log\LoggerInterface;class PaymentActivity implements PaymentActivityInterface{ private PaymentRepositoryInterface $paymentRepository; private LoggerInterface $logger; public function __construct( PaymentRepositoryInterface $paymentRepository, LoggerInterface $logger ) { $this-&amp;gt;paymentRepository = $paymentRepository; $this-&amp;gt;logger = $logger; } #[ActivityMethod] public function validatePayment(PaymentRequest $request): ValidationResult { try { $this-&amp;gt;logger-&amp;gt;info('Validating payment', [ 'paymentId' =&amp;gt; $request-&amp;gt;getPaymentId(), 'amount' =&amp;gt; $request-&amp;gt;getAmount() ]); // Validation métier if ($request-&amp;gt;getAmount() &amp;lt;= 0) { return new ValidationResult(false, 'Invalid amount'); } if (empty($request-&amp;gt;getCurrency())) { return new ValidationResult(false, 'Currency required'); } // Vérification de l'organisation if (!$this-&amp;gt;paymentRepository-&amp;gt;organizationExists($request-&amp;gt;getOrganizationId())) { return new ValidationResult(false, 'Organization not found'); } return new ValidationResult(true); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Payment validation failed', [ 'paymentId' =&amp;gt; $request-&amp;gt;getPaymentId(), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); return new ValidationResult(false, $e-&amp;gt;getMessage()); } } #[ActivityMethod] public function chargePayment(PaymentRequest $request): ChargeResult { try { $this-&amp;gt;logger-&amp;gt;info('Charging payment', [ 'paymentId' =&amp;gt; $request-&amp;gt;getPaymentId(), 'amount' =&amp;gt; $request-&amp;gt;getAmount() ]); // Créer le paiement $payment = new Payment( $request-&amp;gt;getPaymentId(), $request-&amp;gt;getOrganizationId(), $request-&amp;gt;getUserId(), $request-&amp;gt;getAmount(), $request-&amp;gt;getCurrency(), 'processing', $request-&amp;gt;getDescription(), new \DateTime() ); // Sauvegarder le paiement $this-&amp;gt;paymentRepository-&amp;gt;save($payment); // Simuler le traitement du paiement // Dans un vrai système, ceci appellerait un service de paiement $this-&amp;gt;simulatePaymentProcessing($request); // Mettre à jour le statut $payment-&amp;gt;markAsCompleted(); $this-&amp;gt;paymentRepository-&amp;gt;save($payment); return new ChargeResult(true, 'Payment charged successfully'); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Payment charging failed', [ 'paymentId' =&amp;gt; $request-&amp;gt;getPaymentId(), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); return new ChargeResult(false, $e-&amp;gt;getMessage()); } } #[ActivityMethod] public function sendNotification(PaymentResult $result): void { try { $this-&amp;gt;logger-&amp;gt;info('Sending payment notification', [ 'success' =&amp;gt; $result-&amp;gt;isSuccess(), 'message' =&amp;gt; $result-&amp;gt;getMessage() ]); // Envoyer une notification (email, webhook, etc.) $this-&amp;gt;sendEmailNotification($result); $this-&amp;gt;sendWebhookNotification($result); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Notification sending failed', [ 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); } } private function simulatePaymentProcessing(PaymentRequest $request): void { // Simuler un délai de traitement sleep(2); // Simuler une échec aléatoire (5% de chance) if (rand(1, 100) &amp;lt;= 5) { throw new \Exception('Payment processing failed'); } } private function sendEmailNotification(PaymentResult $result): void { // Implémentation de l'envoi d'email } private function sendWebhookNotification(PaymentResult $result): void { // Implémentation de l'envoi de webhook }}&lt;/code&gt;### &lt;strong&gt;Flux de Données&lt;/strong&gt;&lt;code&gt;mermaidgraph TD A[Client Request] --&amp;gt; B[Temporal Client] B --&amp;gt; C[Workflow Execution] C --&amp;gt; D[Activity 1: Validation] D --&amp;gt; E[Activity 2: Charging] E --&amp;gt; F[Activity 3: Notification] F --&amp;gt; G[Workflow Complete] H[Persistence Layer] --&amp;gt; I[Payment Repository] I --&amp;gt; J[Database] C --&amp;gt; H D --&amp;gt; H E --&amp;gt; H F --&amp;gt; H K[Temporal Server] --&amp;gt; L[Workflow State] L --&amp;gt; M[Activity State] M --&amp;gt; N[Event History]&lt;/code&gt;## 💻 &lt;strong&gt;Implémentation Pratique&lt;/strong&gt;### &lt;strong&gt;1. Configuration Temporal&lt;/strong&gt;#### &lt;strong&gt;Configuration du Client&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Infrastructure\Temporal;use Temporal\Client\WorkflowClient;use Temporal\Client\WorkflowClientInterface;use Temporal\Client\WorkflowOptions;use Temporal\DataConverter\DataConverter;use Temporal\DataConverter\JsonDataConverter;class TemporalClientFactory{ private string $host; private int $port; private string $namespace; public function __construct(string $host = 'localhost', int $port = 7233, string $namespace = 'default') { $this-&amp;gt;host = $host; $this-&amp;gt;port = $port; $this-&amp;gt;namespace = $namespace; } public function createClient(): WorkflowClientInterface { $dataConverter = new DataConverter( new JsonDataConverter() ); return WorkflowClient::create( $this-&amp;gt;host . ':' . $this-&amp;gt;port, [ 'namespace' =&amp;gt; $this-&amp;gt;namespace, 'dataConverter' =&amp;gt; $dataConverter, ] ); } public function createWorkflowOptions(): WorkflowOptions { return WorkflowOptions::new() -&amp;gt;withWorkflowId('payment-workflow-' . uniqid()) -&amp;gt;withWorkflowExecutionTimeout(300) // 5 minutes -&amp;gt;withWorkflowRunTimeout(300) -&amp;gt;withWorkflowTaskTimeout(60); }}&lt;/code&gt;#### &lt;strong&gt;Service de Workflow&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Service\Temporal;use App\Workflow\Payment\PaymentWorkflowInterface;use App\Workflow\Payment\PaymentRequest;use App\Workflow\Payment\PaymentResult;use Temporal\Client\WorkflowClientInterface;use Temporal\Client\WorkflowOptions;use Psr\Log\LoggerInterface;class PaymentWorkflowService{ private WorkflowClientInterface $workflowClient; private LoggerInterface $logger; public function __construct( WorkflowClientInterface $workflowClient, LoggerInterface $logger ) { $this-&amp;gt;workflowClient = $workflowClient; $this-&amp;gt;logger = $logger; } public function processPayment(PaymentRequest $request): PaymentResult { try { $this-&amp;gt;logger-&amp;gt;info('Starting payment workflow', [ 'paymentId' =&amp;gt; $request-&amp;gt;getPaymentId(), 'amount' =&amp;gt; $request-&amp;gt;getAmount() ]); $workflowOptions = WorkflowOptions::new() -&amp;gt;withWorkflowId('payment-' . $request-&amp;gt;getPaymentId()) -&amp;gt;withWorkflowExecutionTimeout(300) -&amp;gt;withWorkflowRunTimeout(300) -&amp;gt;withWorkflowTaskTimeout(60); $workflow = $this-&amp;gt;workflowClient-&amp;gt;newWorkflowStub( PaymentWorkflowInterface::class, $workflowOptions ); $result = $workflow-&amp;gt;processPayment($request); $this-&amp;gt;logger-&amp;gt;info('Payment workflow completed', [ 'paymentId' =&amp;gt; $request-&amp;gt;getPaymentId(), 'success' =&amp;gt; $result-&amp;gt;isSuccess() ]); return $result; } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Payment workflow failed', [ 'paymentId' =&amp;gt; $request-&amp;gt;getPaymentId(), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } public function getWorkflowStatus(string $workflowId): array { try { $workflow = $this-&amp;gt;workflowClient-&amp;gt;newWorkflowStub( PaymentWorkflowInterface::class, $workflowId ); $status = $workflow-&amp;gt;getStatus(); return [ 'workflowId' =&amp;gt; $workflowId, 'status' =&amp;gt; $status, 'isRunning' =&amp;gt; $status === 'RUNNING', 'isCompleted' =&amp;gt; $status === 'COMPLETED', 'isFailed' =&amp;gt; $status === 'FAILED' ]; } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to get workflow status', [ 'workflowId' =&amp;gt; $workflowId, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } public function cancelWorkflow(string $workflowId): void { try { $workflow = $this-&amp;gt;workflowClient-&amp;gt;newWorkflowStub( PaymentWorkflowInterface::class, $workflowId ); $workflow-&amp;gt;cancel(); $this-&amp;gt;logger-&amp;gt;info('Workflow cancelled', [ 'workflowId' =&amp;gt; $workflowId ]); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to cancel workflow', [ 'workflowId' =&amp;gt; $workflowId, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } }}&lt;/code&gt;### &lt;strong&gt;2. Repository Temporal&lt;/strong&gt;#### &lt;strong&gt;Repository avec Persistance Temporal&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Infrastructure\Temporal\Repository;use App\Domain\Payment\Payment;use App\Domain\Payment\PaymentRepositoryInterface;use App\Infrastructure\Temporal\TemporalClientFactory;use Psr\Log\LoggerInterface;class TemporalPaymentRepository implements PaymentRepositoryInterface{ private TemporalClientFactory $temporalFactory; private LoggerInterface $logger; private array $cache = []; public function __construct( TemporalClientFactory $temporalFactory, LoggerInterface $logger ) { $this-&amp;gt;temporalFactory = $temporalFactory; $this-&amp;gt;logger = $logger; } public function save(Payment $payment): void { try { $workflowId = 'payment-' . $payment-&amp;gt;getId(); // Créer un workflow de persistance $workflowOptions = $this-&amp;gt;temporalFactory-&amp;gt;createWorkflowOptions() -&amp;gt;withWorkflowId($workflowId); $workflow = $this-&amp;gt;temporalFactory-&amp;gt;createClient() -&amp;gt;newWorkflowStub(PaymentPersistenceWorkflowInterface::class, $workflowOptions); // Exécuter le workflow de persistance $workflow-&amp;gt;persistPayment($payment); // Mettre en cache $this-&amp;gt;cache[$payment-&amp;gt;getId()] = $payment; $this-&amp;gt;logger-&amp;gt;info('Payment persisted via Temporal', [ 'paymentId' =&amp;gt; $payment-&amp;gt;getId(), 'workflowId' =&amp;gt; $workflowId ]); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to persist payment via Temporal', [ 'paymentId' =&amp;gt; $payment-&amp;gt;getId(), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } public function findById(string $id): ?Payment { // Vérifier le cache d'abord if (isset($this-&amp;gt;cache[$id])) { return $this-&amp;gt;cache[$id]; } try { $workflowId = 'payment-' . $id; // Récupérer depuis Temporal $workflow = $this-&amp;gt;temporalFactory-&amp;gt;createClient() -&amp;gt;newWorkflowStub(PaymentPersistenceWorkflowInterface::class, $workflowId); $payment = $workflow-&amp;gt;getPayment($id); if ($payment) { $this-&amp;gt;cache[$id] = $payment; } return $payment; } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to retrieve payment from Temporal', [ 'paymentId' =&amp;gt; $id, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); return null; } } public function findByOrganization(string $organizationId): array { try { $workflowId = 'payment-search-' . $organizationId . '-' . uniqid(); // Créer un workflow de recherche $workflowOptions = $this-&amp;gt;temporalFactory-&amp;gt;createWorkflowOptions() -&amp;gt;withWorkflowId($workflowId); $workflow = $this-&amp;gt;temporalFactory-&amp;gt;createClient() -&amp;gt;newWorkflowStub(PaymentSearchWorkflowInterface::class, $workflowOptions); $payments = $workflow-&amp;gt;searchByOrganization($organizationId); // Mettre en cache foreach ($payments as $payment) { $this-&amp;gt;cache[$payment-&amp;gt;getId()] = $payment; } return $payments; } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to search payments via Temporal', [ 'organizationId' =&amp;gt; $organizationId, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); return []; } } public function delete(string $id): void { try { $workflowId = 'payment-delete-' . $id; // Créer un workflow de suppression $workflowOptions = $this-&amp;gt;temporalFactory-&amp;gt;createWorkflowOptions() -&amp;gt;withWorkflowId($workflowId); $workflow = $this-&amp;gt;temporalFactory-&amp;gt;createClient() -&amp;gt;newWorkflowStub(PaymentPersistenceWorkflowInterface::class, $workflowOptions); $workflow-&amp;gt;deletePayment($id); // Supprimer du cache unset($this-&amp;gt;cache[$id]); $this-&amp;gt;logger-&amp;gt;info('Payment deleted via Temporal', [ 'paymentId' =&amp;gt; $id, 'workflowId' =&amp;gt; $workflowId ]); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to delete payment via Temporal', [ 'paymentId' =&amp;gt; $id, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } public function count(): int { try { $workflowId = 'payment-count-' . uniqid(); // Créer un workflow de comptage $workflowOptions = $this-&amp;gt;temporalFactory-&amp;gt;createWorkflowOptions() -&amp;gt;withWorkflowId($workflowId); $workflow = $this-&amp;gt;temporalFactory-&amp;gt;createClient() -&amp;gt;newWorkflowStub(PaymentSearchWorkflowInterface::class, $workflowOptions); return $workflow-&amp;gt;getPaymentCount(); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to count payments via Temporal', [ 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); return 0; } }}&lt;/code&gt;### &lt;strong&gt;3. Workflows de Persistance&lt;/strong&gt;#### &lt;strong&gt;Workflow de Persistance des Paiements&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Workflow\Persistence;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Domain\Payment\Payment;#[WorkflowInterface]interface PaymentPersistenceWorkflowInterface{ #[WorkflowMethod] public function persistPayment(Payment $payment): void; #[WorkflowMethod] public function getPayment(string $paymentId): ?Payment; #[WorkflowMethod] public function deletePayment(string $paymentId): void;}#[ActivityInterface]interface PaymentPersistenceActivityInterface{ #[ActivityMethod] public function saveToDatabase(Payment $payment): void; #[ActivityMethod] public function loadFromDatabase(string $paymentId): ?Payment; #[ActivityMethod] public function deleteFromDatabase(string $paymentId): void;}class PaymentPersistenceWorkflow implements PaymentPersistenceWorkflowInterface{ private PaymentPersistenceActivityInterface $persistenceActivity; public function __construct() { $this-&amp;gt;persistenceActivity = Workflow::newActivityStub(PaymentPersistenceActivityInterface::class); } public function persistPayment(Payment $payment): void { yield $this-&amp;gt;persistenceActivity-&amp;gt;saveToDatabase($payment); } public function getPayment(string $paymentId): ?Payment { return yield $this-&amp;gt;persistenceActivity-&amp;gt;loadFromDatabase($paymentId); } public function deletePayment(string $paymentId): void { yield $this-&amp;gt;persistenceActivity-&amp;gt;deleteFromDatabase($paymentId); }}&lt;/code&gt;## 🧪 &lt;strong&gt;Tests et Validation&lt;/strong&gt;### &lt;strong&gt;Tests d&amp;rsquo;Intégration Temporal&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Tests\Integration\Temporal;use App\Workflow\Payment\PaymentRequest;use App\Application\Service\Temporal\PaymentWorkflowService;use App\Infrastructure\Temporal\TemporalClientFactory;class TemporalPaymentWorkflowTest extends TestCase{ private PaymentWorkflowService $workflowService; private TemporalClientFactory $temporalFactory; protected function setUp(): void { $this-&amp;gt;temporalFactory = new TemporalClientFactory('localhost', 7233, 'test'); $this-&amp;gt;workflowService = new PaymentWorkflowService( $this-&amp;gt;temporalFactory-&amp;gt;createClient(), $this-&amp;gt;createMock(LoggerInterface::class) ); } public function testPaymentWorkflowExecution(): void { $request = new PaymentRequest( 'payment-123', 'org-456', 'user-789', 100.00, 'EUR', 'Test payment' ); $result = $this-&amp;gt;workflowService-&amp;gt;processPayment($request); $this-&amp;gt;assertTrue($result-&amp;gt;isSuccess()); $this-&amp;gt;assertEquals('Payment processed successfully', $result-&amp;gt;getMessage()); } public function testWorkflowStatus(): void { $request = new PaymentRequest( 'payment-456', 'org-789', 'user-123', 200.00, 'USD', 'Test payment 2' ); $this-&amp;gt;workflowService-&amp;gt;processPayment($request); $status = $this-&amp;gt;workflowService-&amp;gt;getWorkflowStatus('payment-payment-456'); $this-&amp;gt;assertArrayHasKey('workflowId', $status); $this-&amp;gt;assertArrayHasKey('status', $status); $this-&amp;gt;assertArrayHasKey('isCompleted', $status); }}&lt;/code&gt;## 📊 &lt;strong&gt;Performance et Optimisation&lt;/strong&gt;### &lt;strong&gt;Stratégies d&amp;rsquo;Optimisation Temporal&lt;/strong&gt;#### &lt;strong&gt;1. Configuration des Timeouts&lt;/strong&gt;&lt;code&gt;phppublic function createOptimizedWorkflowOptions(): WorkflowOptions{ return WorkflowOptions::new() -&amp;gt;withWorkflowId('payment-workflow-' . uniqid()) -&amp;gt;withWorkflowExecutionTimeout(600) // 10 minutes -&amp;gt;withWorkflowRunTimeout(600) -&amp;gt;withWorkflowTaskTimeout(120) -&amp;gt;withRetryOptions([ 'initialInterval' =&amp;gt; '1s', 'maximumInterval' =&amp;gt; '60s', 'backoffCoefficient' =&amp;gt; 2.0, 'maximumAttempts' =&amp;gt; 3 ]);}&lt;/code&gt;#### &lt;strong&gt;2. Cache des Workflows&lt;/strong&gt;&lt;code&gt;phppublic function getWorkflowWithCache(string $workflowId): PaymentWorkflowInterface{ if (isset($this-&amp;gt;workflowCache[$workflowId])) { return $this-&amp;gt;workflowCache[$workflowId]; } $workflow = $this-&amp;gt;workflowClient-&amp;gt;newWorkflowStub( PaymentWorkflowInterface::class, $workflowId ); $this-&amp;gt;workflowCache[$workflowId] = $workflow; return $workflow;}&lt;/code&gt;#### &lt;strong&gt;3. Monitoring et Observabilité&lt;/strong&gt;&lt;code&gt;phppublic function getWorkflowMetrics(): array{ return [ 'activeWorkflows' =&amp;gt; $this-&amp;gt;getActiveWorkflowCount(), 'completedWorkflows' =&amp;gt; $this-&amp;gt;getCompletedWorkflowCount(), 'failedWorkflows' =&amp;gt; $this-&amp;gt;getFailedWorkflowCount(), 'averageExecutionTime' =&amp;gt; $this-&amp;gt;getAverageExecutionTime() ];}&lt;/code&gt;## 🎯 &lt;strong&gt;Critères d&amp;rsquo;Adoption&lt;/strong&gt;### &lt;strong&gt;Quand Utiliser Temporal Classique&lt;/strong&gt;#### &lt;strong&gt;✅ Avantages&lt;/strong&gt;- &lt;strong&gt;Durabilité&lt;/strong&gt; : État des workflows persisté automatiquement- &lt;strong&gt;Résilience&lt;/strong&gt; : Reprise automatique après panne- &lt;strong&gt;Orchestration&lt;/strong&gt; : Gestion complexe des processus métier- &lt;strong&gt;Observabilité&lt;/strong&gt; : Visibilité complète sur l&amp;rsquo;exécution- &lt;strong&gt;Scalabilité&lt;/strong&gt; : Exécution distribuée des workflows#### &lt;strong&gt;❌ Inconvénients&lt;/strong&gt;- &lt;strong&gt;Complexité&lt;/strong&gt; : Courbe d&amp;rsquo;apprentissage importante- &lt;strong&gt;Infrastructure&lt;/strong&gt; : Nécessite un serveur Temporal- &lt;strong&gt;Latence&lt;/strong&gt; : Overhead pour les opérations simples- &lt;strong&gt;Expertise&lt;/strong&gt; : Équipe expérimentée requise#### &lt;strong&gt;🎯 Critères d&amp;rsquo;Adoption&lt;/strong&gt;- &lt;strong&gt;Processus métier complexes&lt;/strong&gt; : Workflows qui nécessitent de l&amp;rsquo;orchestration- &lt;strong&gt;Résilience critique&lt;/strong&gt; : Besoin de reprise automatique après panne- &lt;strong&gt;Processus longs&lt;/strong&gt; : Workflows qui s&amp;rsquo;étalent sur plusieurs jours- &lt;strong&gt;Intégrations multiples&lt;/strong&gt; : Orchestration de plusieurs services- &lt;strong&gt;Équipe expérimentée&lt;/strong&gt; : Maîtrise de Temporal et des workflows- &lt;strong&gt;Infrastructure disponible&lt;/strong&gt; : Serveur Temporal opérationnel## 🚀 &lt;strong&gt;Votre Prochaine Étape&lt;/strong&gt;

&lt;div class="chapter-navigation"&gt;
 &lt;h2 class="chapter-nav-title"&gt;🎯 Votre Prochaine Étape&lt;/h2&gt;
 &lt;p class="chapter-nav-subtitle"&gt;Maintenant que vous comprenez les concepts de base et que j'ai partagé mon expérience avec Gyroscops, quel est votre contexte ?&lt;/p&gt;</description></item><item><title>Stockage Temporal - CQS</title><link>http://localhost:1313/chapitres/stockage/temporal/chapitre-47-stockage-temporal-cqs/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/temporal/chapitre-47-stockage-temporal-cqs/</guid><description>&lt;h2 id="-contexte-et-objectifs-pourquoi-cqs-avec-temporal-la-combinaison-cqs-avec-temporal-offre-une-architecture-optimisée-qui-sépare-clairement-les-responsabilités-tout-en-conservant-les-avantages-de-lorchestration-et-de-la-résilience-des-workflows-avantages-de-cqs-avec-temporal--performance-optimisée--séparation-claire-entre-écriture-et-lecture--scalabilité--possibilité-de-scaler-indépendamment-les-commandes-et-requêtes--flexibilité--requêtes-optimisées-pour-chaque-usage--maintenabilité--code-plus-clair-et-organisé--résilience--workflows-robustes-avec-reprise-automatique-contexte-gyroscopsdans-notre-écosystème-user--organization--workflow--cloud-resources--billing-cqs-avec-temporal-est-particulièrement-pertinent-pour---workflows-de-commande--orchestration-des-processus-de-modification--workflows-de-requête--optimisation-des-lectures-et-analytics--processus-de-facturation--séparation-des-écritures-et-lectures-de-facturation--intégrations-complexes--orchestration-des-intégrations-avec-séparation-des-responsabilités--architecture-cqs-avec-temporal-séparation-des-responsabilités-côté-commande-write--command-workflows--orchestration-des-processus-de-modification--command-activities--exécution-des-activités-de-modification--event-handlers--gestion-des-événements-de-domaine--bulk-operations--optimisation-des-écritures-côté-requête-read--query-workflows--orchestration-des-processus-de-lecture--query-activities--exécution-des-activités-de-lecture--search-services--services-de-recherche-spécialisés--caches--optimisation-des-performances-flux-de-donnéesmermaidgraph-td----acommand----bcommand-workflow----b----ccommand-activities----c----dwrite-operations----d----eevent-handlers----e----fstate-updates--------gquery----hquery-workflow----h----iquery-activities----i----jread-operations----j----ksearch-results----k----lresponse--------mevent----nevent-handler----n----b--------ocache----pcache-manager----p----j----j----qcached-data----q----rfast-response--implémentation-pratique-1-command-side-implementation-command-workflow-pour-les-paiementsphpphpnamespace-appworkflowcommandpaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowworkflowinterfaceinterface-paymentcommandworkflowinterface----workflowmethod----public-function-processpaymentcommandpaymentcommandrequest-request-paymentcommandresult--------workflowmethod----public-function-updatepaymentcommandpaymentupdatecommandrequest-request-paymentcommandresult--------workflowmethod----public-function-deletepaymentcommandpaymentdeletecommandrequest-request-paymentcommandresultactivityinterfaceinterface-paymentcommandactivityinterface----activitymethod----public-function-validatepaymentcommandpaymentcommandrequest-request-validationresult--------activitymethod----public-function-executepaymentcommandpaymentcommandrequest-request-commandexecutionresult--------activitymethod----public-function-publishpaymenteventpaymentevent-event-voidclass-paymentcommandworkflow-implements-paymentcommandworkflowinterface----private-paymentcommandactivityinterface-commandactivity----public-function-__construct------------this-commandactivity--workflownewactivitystubpaymentcommandactivityinterfaceclass--------public-function-processpaymentcommandpaymentcommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------exécution-de-la-commande------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------publication-de-lévénement------------event--new-paymentprocessedevent----------------request-getpaymentid----------------request-getamount----------------request-getcurrency----------------request-getorganizationid------------------------------------yield-this-commandactivity-publishpaymenteventevent------------------------return-new-paymentcommandresulttrue-payment-command-processed-successfully---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage----------------public-function-updatepaymentcommandpaymentupdatecommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande-de-mise-à-jour------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------exécution-de-la-mise-à-jour------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------publication-de-lévénement-de-mise-à-jour------------event--new-paymentupdatedevent----------------request-getpaymentid----------------request-getupdates----------------request-getorganizationid------------------------------------yield-this-commandactivity-publishpaymenteventevent------------------------return-new-paymentcommandresulttrue-payment-update-command-processed-successfully---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage----------------public-function-deletepaymentcommandpaymentdeletecommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande-de-suppression------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------exécution-de-la-suppression------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------publication-de-lévénement-de-suppression------------event--new-paymentdeletedevent----------------request-getpaymentid----------------request-getorganizationid------------------------------------yield-this-commandactivity-publishpaymenteventevent------------------------return-new-paymentcommandresulttrue-payment-delete-command-processed-successfully---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage-------------command-activitiesphpphpnamespace-appworkflowcommandpaymentuse-temporalactivityactivityinterfaceuse-temporalactivityactivitymethoduse-appdomainpaymentpaymentrepositoryinterfaceuse-appdomainpaymentpaymentuse-psrlogloggerinterfaceclass-paymentcommandactivity-implements-paymentcommandactivityinterface----private-paymentrepositoryinterface-paymentrepository----private-loggerinterface-logger----public-function-__construct--------paymentrepositoryinterface-paymentrepository--------loggerinterface-logger-------------this-paymentrepository--paymentrepository--------this-logger--logger--------activitymethod----public-function-validatepaymentcommandpaymentcommandrequest-request-validationresult------------try-------------this-logger-infovalidating-payment-command-----------------paymentid--request-getpaymentid----------------commandtype--request-getcommandtype-------------------------------------validation-métier-spécifique-au-type-de-commande------------switch-request-getcommandtype-----------------case-create--------------------return-this-validatecreatecommandrequest----------------case-update--------------------return-this-validateupdatecommandrequest----------------case-delete--------------------return-this-validatedeletecommandrequest----------------default--------------------return-new-validationresultfalse-unknown-command-type---------------------------------catch-exception-e-------------this-logger-errorpayment-command-validation-failed-----------------paymentid--request-getpaymentid----------------error--e-getmessage------------------------------------return-new-validationresultfalse-e-getmessage----------------activitymethod----public-function-executepaymentcommandpaymentcommandrequest-request-commandexecutionresult------------try-------------this-logger-infoexecuting-payment-command-----------------paymentid--request-getpaymentid----------------commandtype--request-getcommandtype-------------------------------------exécution-spécifique-au-type-de-commande------------switch-request-getcommandtype-----------------case-create--------------------return-this-executecreatecommandrequest----------------case-update--------------------return-this-executeupdatecommandrequest----------------case-delete--------------------return-this-executedeletecommandrequest----------------default--------------------return-new-commandexecutionresultfalse-unknown-command-type---------------------------------catch-exception-e-------------this-logger-errorpayment-command-execution-failed-----------------paymentid--request-getpaymentid----------------error--e-getmessage------------------------------------return-new-commandexecutionresultfalse-e-getmessage----------------activitymethod----public-function-publishpaymenteventpaymentevent-event-void------------try-------------this-logger-infopublishing-payment-event-----------------eventtype--event-geteventtype----------------paymentid--event-getpaymentid-------------------------------------publication-de-lévénement-ex-via-event-bus------------this-eventbus-publishevent---------------------catch-exception-e-------------this-logger-errorfailed-to-publish-payment-event-----------------eventtype--event-geteventtype----------------error--e-getmessage------------------------------------throw-e----------------private-function-validatecreatecommandpaymentcommandrequest-request-validationresult------------if-request-getamount--0-------------return-new-validationresultfalse-invalid-amount------------------------if-emptyrequest-getcurrency-------------return-new-validationresultfalse-currency-required------------------------return-new-validationresulttrue--------private-function-executecreatecommandpaymentcommandrequest-request-commandexecutionresult------------payment--new-payment------------request-getpaymentid------------request-getorganizationid------------request-getuserid------------request-getamount------------request-getcurrency------------processing------------request-getdescription------------new-datetime------------------------this-paymentrepository-savepayment----------------return-new-commandexecutionresulttrue-payment-created-successfully--------private-function-validateupdatecommandpaymentcommandrequest-request-validationresult------------payment--this-paymentrepository-findbyidrequest-getpaymentid----------------if-payment-------------return-new-validationresultfalse-payment-not-found------------------------return-new-validationresulttrue--------private-function-executeupdatecommandpaymentcommandrequest-request-commandexecutionresult------------payment--this-paymentrepository-findbyidrequest-getpaymentid----------------if-request-getamount-------------payment-updateamountrequest-getamount------------------------if-request-getdescription-------------payment-updatedescriptionrequest-getdescription------------------------this-paymentrepository-savepayment----------------return-new-commandexecutionresulttrue-payment-updated-successfully--------private-function-validatedeletecommandpaymentcommandrequest-request-validationresult------------payment--this-paymentrepository-findbyidrequest-getpaymentid----------------if-payment-------------return-new-validationresultfalse-payment-not-found------------------------if-payment-getstatus--completed-------------return-new-validationresultfalse-cannot-delete-completed-payment------------------------return-new-validationresulttrue--------private-function-executedeletecommandpaymentcommandrequest-request-commandexecutionresult------------this-paymentrepository-deleterequest-getpaymentid----------------return-new-commandexecutionresulttrue-payment-deleted-successfully-----2-query-side-implementation-query-workflow-pour-les-paiementsphpphpnamespace-appworkflowquerypaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowworkflowinterfaceinterface-paymentqueryworkflowinterface----workflowmethod----public-function-searchpaymentspaymentsearchquery-query-paymentsearchresult--------workflowmethod----public-function-getpaymentbyidpaymentbyidquery-query-payment--------workflowmethod----public-function-getpaymentstatisticspaymentstatisticsquery-query-arrayactivityinterfaceinterface-paymentqueryactivityinterface----activitymethod----public-function-searchpaymentsindatabasepaymentsearchquery-query-array--------activitymethod----public-function-getpaymentfromdatabasestring-paymentid-payment--------activitymethod----public-function-calculatepaymentstatisticspaymentstatisticsquery-query-arrayclass-paymentqueryworkflow-implements-paymentqueryworkflowinterface----private-paymentqueryactivityinterface-queryactivity----public-function-__construct------------this-queryactivity--workflownewactivitystubpaymentqueryactivityinterfaceclass--------public-function-searchpaymentspaymentsearchquery-query-paymentsearchresult------------try--------------recherche-dans-la-base-de-données------------payments--yield-this-queryactivity-searchpaymentsindatabasequery-------------------------filtrage-et-tri------------filteredpayments--this-filterpaymentspayments-query------------sortedpayments--this-sortpaymentsfilteredpayments-query-------------------------pagination------------paginatedpayments--this-paginatepaymentssortedpayments-query------------------------return-new-paymentsearchresult----------------paginatedpayments----------------countfilteredpayments----------------query-getpage----------------query-getsize---------------------------------catch-exception-e-------------return-new-paymentsearchresult-0-query-getpage-query-getsize----------------public-function-getpaymentbyidpaymentbyidquery-query-payment------------try-------------return-yield-this-queryactivity-getpaymentfromdatabasequery-getpaymentid---------catch-exception-e-------------return-null----------------public-function-getpaymentstatisticspaymentstatisticsquery-query-array------------try-------------return-yield-this-queryactivity-calculatepaymentstatisticsquery---------catch-exception-e-------------return-----------------private-function-filterpaymentsarray-payments-paymentsearchquery-query-array------------return-array_filterpayments-functionpayment-use-query-------------if-query-getorganizationid--payment-getorganizationid--query-getorganizationid-----------------return-false------------------------------------if-query-getstatus--payment-getstatus--query-getstatus-----------------return-false------------------------------------if-query-getminamount--payment-getamount--query-getminamount-----------------return-false------------------------------------if-query-getmaxamount--payment-getamount--query-getmaxamount-----------------return-false------------------------------------return-true----------------private-function-sortpaymentsarray-payments-paymentsearchquery-query-array------------sortfield--query-getsortfield--createdat--------sortdirection--query-getsortdirection--desc----------------usortpayments-functiona-b-use-sortfield-sortdirection-------------valuea--this-getfieldvaluea-sortfield------------valueb--this-getfieldvalueb-sortfield------------------------if-sortdirection--asc-----------------return-valuea--valueb-------------else-----------------return-valueb--valuea------------------------------------return-payments--------private-function-paginatepaymentsarray-payments-paymentsearchquery-query-array------------page--query-getpage--1--------size--query-getsize--10--------offset--page---1--size----------------return-array_slicepayments-offset-size--------private-function-getfieldvaluepayment-payment-string-field-mixed------------switch-field-------------case-amount----------------return-payment-getamount------------case-createdat----------------return-payment-getcreatedat------------case-status----------------return-payment-getstatus------------default----------------return-payment-getcreatedat-------------query-activitiesphpphpnamespace-appworkflowquerypaymentuse-temporalactivityactivityinterfaceuse-temporalactivityactivitymethoduse-appdomainpaymentpaymentrepositoryinterfaceuse-psrlogloggerinterfaceuse-psrcachecacheitempoolinterfaceclass-paymentqueryactivity-implements-paymentqueryactivityinterface----private-paymentrepositoryinterface-paymentrepository----private-loggerinterface-logger----private-cacheitempoolinterface-cache----public-function-__construct--------paymentrepositoryinterface-paymentrepository--------loggerinterface-logger--------cacheitempoolinterface-cache-------------this-paymentrepository--paymentrepository--------this-logger--logger--------this-cache--cache--------activitymethod----public-function-searchpaymentsindatabasepaymentsearchquery-query-array------------try-------------cachekey--payment_search_--md5serializequery------------cacheditem--this-cache-getitemcachekey------------------------if-cacheditem-ishit-----------------this-logger-debugpayment-search-result-served-from-cache---------------------query--query-toarray--------------------------------return-cacheditem-get------------------------------------this-logger-infosearching-payments-in-database-----------------query--query-toarray------------------------------------payments--this-paymentrepository-searchquery-------------------------mettre-en-cache------------cacheditem-setpayments------------cacheditem-expiresafter300--5-minutes------------this-cache-savecacheditem------------------------return-payments---------------------catch-exception-e-------------this-logger-errorpayment-search-failed-----------------query--query-toarray----------------error--e-getmessage------------------------------------return-----------------activitymethod----public-function-getpaymentfromdatabasestring-paymentid-payment------------try-------------cachekey--payment_--paymentid------------cacheditem--this-cache-getitemcachekey------------------------if-cacheditem-ishit-----------------this-logger-debugpayment-served-from-cache---------------------paymentid--paymentid--------------------------------return-cacheditem-get------------------------------------this-logger-infogetting-payment-from-database-----------------paymentid--paymentid------------------------------------payment--this-paymentrepository-findbyidpaymentid-------------------------mettre-en-cache------------if-payment-----------------cacheditem-setpayment----------------cacheditem-expiresafter600--10-minutes----------------this-cache-savecacheditem------------------------------------return-payment---------------------catch-exception-e-------------this-logger-errorfailed-to-get-payment-from-database-----------------paymentid--paymentid----------------error--e-getmessage------------------------------------return-null----------------activitymethod----public-function-calculatepaymentstatisticspaymentstatisticsquery-query-array------------try-------------cachekey--payment_stats_--md5serializequery------------cacheditem--this-cache-getitemcachekey------------------------if-cacheditem-ishit-----------------this-logger-debugpayment-statistics-served-from-cache---------------------query--query-toarray--------------------------------return-cacheditem-get------------------------------------this-logger-infocalculating-payment-statistics-----------------query--query-toarray------------------------------------statistics--this-paymentrepository-getstatisticsquery-------------------------mettre-en-cache------------cacheditem-setstatistics------------cacheditem-expiresafter300--5-minutes------------this-cache-savecacheditem------------------------return-statistics---------------------catch-exception-e-------------this-logger-errorfailed-to-calculate-payment-statistics-----------------query--query-toarray----------------error--e-getmessage------------------------------------return--------------3-service-de-synchronisation-service-de-synchronisation-cqsphpphpnamespace-appapplicationservicetemporaluse-appworkflowcommandpaymentpaymentcommandworkflowinterfaceuse-appworkflowquerypaymentpaymentqueryworkflowinterfaceuse-appworkflowcommandpaymentpaymentcommandrequestuse-appworkflowquerypaymentpaymentsearchqueryuse-temporalclientworkflowclientinterfaceuse-psrlogloggerinterfaceclass-paymentcqsservice----private-workflowclientinterface-workflowclient----private-loggerinterface-logger----public-function-__construct--------workflowclientinterface-workflowclient--------loggerinterface-logger-------------this-workflowclient--workflowclient--------this-logger--logger--------public-function-processpaymentcommandpaymentcommandrequest-request-paymentcommandresult------------try-------------workflowoptions--this-createcommandworkflowoptionsrequest-getpaymentid------------------------workflow--this-workflowclient-newworkflowstub----------------paymentcommandworkflowinterfaceclass----------------workflowoptions------------------------------------result--workflow-processpaymentcommandrequest------------------------this-logger-infopayment-command-processed-----------------paymentid--request-getpaymentid----------------success--result-issuccess------------------------------------return-result---------------------catch-exception-e-------------this-logger-errorpayment-command-processing-failed-----------------paymentid--request-getpaymentid----------------error--e-getmessage------------------------------------throw-e----------------public-function-searchpaymentspaymentsearchquery-query-paymentsearchresult------------try-------------workflowoptions--this-createqueryworkflowoptionspayment-search---uniqid------------------------workflow--this-workflowclient-newworkflowstub----------------paymentqueryworkflowinterfaceclass----------------workflowoptions------------------------------------result--workflow-searchpaymentsquery------------------------this-logger-infopayment-search-completed-----------------query--query-toarray----------------results--result-gettotal------------------------------------return-result---------------------catch-exception-e-------------this-logger-errorpayment-search-failed-----------------query--query-toarray----------------error--e-getmessage------------------------------------throw-e----------------private-function-createcommandworkflowoptionsstring-paymentid-workflowoptions------------return-workflowoptionsnew-------------withworkflowidpayment-command---paymentid-------------withworkflowexecutiontimeout300-------------withworkflowruntimeout300-------------withworkflowtasktimeout60--------private-function-createqueryworkflowoptionsstring-workflowid-workflowoptions------------return-workflowoptionsnew-------------withworkflowidworkflowid-------------withworkflowexecutiontimeout120-------------withworkflowruntimeout120-------------withworkflowtasktimeout30------tests-et-validation-tests-dphpphpnamespace-apptestsintegrationtemporaluse-appworkflowcommandpaymentpaymentcommandrequestuse-appworkflowquerypaymentpaymentsearchqueryuse-appapplicationservicetemporalpaymentcqsserviceuse-appinfrastructuretemporaltemporalclientfactoryclass-temporalpaymentcqstest-extends-testcase----private-paymentcqsservice-cqsservice----private-temporalclientfactory-temporalfactory----protected-function-setup-void------------this-temporalfactory--new-temporalclientfactorylocalhost-7233-test--------this-cqsservice--new-paymentcqsservice------------this-temporalfactory-createclient------------this-createmockloggerinterfaceclass----------------public-function-testcommandqueryseparation-void-------------exécuter-une-commande--------command--new-paymentcommandrequest------------create------------payment-123------------org-456------------user-789------------10000------------eur------------test-payment------------------------result--this-cqsservice-processpaymentcommandcommand----------------this-asserttrueresult-issuccess-----------------vérifier-avec-une-requête--------query--new-paymentsearchqueryorg-456-0-10--------searchresult--this-cqsservice-searchpaymentsquery----------------this-assertgreaterthan0-searchresult-gettotal--------public-function-testquerycaching-void------------query--new-paymentsearchqueryorg-456-0-10-----------------première-recherche--------result1--this-cqsservice-searchpaymentsquery-----------------deuxième-recherche-devrait-utiliser-le-cache--------result2--this-cqsservice-searchpaymentsquery----------------this-assertequalsresult1-gettotal-result2-gettotal------performance-et-optimisation-stratégies-d-1-cache-stratégiquephppublic-function-searchpaymentswithcachepaymentsearchquery-query-paymentsearchresult----cachekey--payment_search_--md5serializequery--------if-cached--this-cache-getcachekey---------return-cached------------result--this-searchpaymentsquery----this-cache-setcachekey-result-300--------return-result-2-workflows-asynchronesphppublic-function-processpaymentcommandasyncpaymentcommandrequest-request-string----workflowoptions--this-createcommandworkflowoptionsrequest-getpaymentid--------workflow--this-workflowclient-newworkflowstub--------paymentcommandworkflowinterfaceclass--------workflowoptions-------------démarrer-le-workflow-de-manière-asynchrone----this-workflowclient-startworkflow-request--------return-workflowoptions-getworkflowid-3-monitoring-des-workflowsphppublic-function-getworkflowmetrics-array----return---------commandworkflows--this-getcommandworkflowmetrics--------queryworkflows--this-getqueryworkflowmetrics--------cachehitrate--this-getcachehitrate--------averageexecutiontime--this-getaverageexecutiontime------critères-d-quand-utiliser-cqs-avec-temporal--avantages--performance-optimisée--séparation-claire-entre-écriture-et-lecture--scalabilité--possibilité-de-scaler-indépendamment--flexibilité--requêtes-optimisées-pour-chaque-usage--maintenabilité--code-plus-clair-et-organisé--résilience--workflows-robustes-avec-reprise-automatique--inconvénients--complexité--architecture-plus-complexe--infrastructure--nécessite-un-serveur-temporal--latence--overhead-pour-les-opérations-simples--expertise--équipe-expérimentée-requise--critères-d--performance-importante--besoins-de-performance-élevée--processus-métier-complexes--workflows-qui-nécessitent-de-lorchestration--séparation-des-responsabilités--besoin-de-séparer-clairement-les-commandes-et-requêtes--équipe-expérimentée--maîtrise-de-temporal-et-cqs--infrastructure-disponible--serveur-temporal-opérationnel--cache-nécessaire--besoin-de-mise-en-cache-des-requêtes--votre-prochaine-étapehahahugoshortcode72s0hbhbcqs-avec-temporal-offre-un-équilibre-optimal-entre-performance-et-orchestration-parfaitement-adapté-aux-besoins-de-workflows-complexes-de-gyroscops"&gt;🎯 &lt;strong&gt;Contexte et Objectifs&lt;/strong&gt;### **Pourquoi CQS avec Temporal ?**La combinaison CQS avec Temporal offre une architecture optimisée qui sépare clairement les responsabilités tout en conservant les avantages de l&amp;rsquo;orchestration et de la résilience des workflows.#### &lt;strong&gt;Avantages de CQS avec Temporal&lt;/strong&gt;- &lt;strong&gt;Performance optimisée&lt;/strong&gt; : Séparation claire entre écriture et lecture- &lt;strong&gt;Scalabilité&lt;/strong&gt; : Possibilité de scaler indépendamment les commandes et requêtes- &lt;strong&gt;Flexibilité&lt;/strong&gt; : Requêtes optimisées pour chaque usage- &lt;strong&gt;Maintenabilité&lt;/strong&gt; : Code plus clair et organisé- &lt;strong&gt;Résilience&lt;/strong&gt; : Workflows robustes avec reprise automatique### &lt;strong&gt;Contexte Gyroscops&lt;/strong&gt;Dans notre écosystème &lt;strong&gt;User → Organization → Workflow → Cloud Resources → Billing&lt;/strong&gt;, CQS avec Temporal est particulièrement pertinent pour :- &lt;strong&gt;Workflows de commande&lt;/strong&gt; : Orchestration des processus de modification- &lt;strong&gt;Workflows de requête&lt;/strong&gt; : Optimisation des lectures et analytics- &lt;strong&gt;Processus de facturation&lt;/strong&gt; : Séparation des écritures et lectures de facturation- &lt;strong&gt;Intégrations complexes&lt;/strong&gt; : Orchestration des intégrations avec séparation des responsabilités## 🏗️ &lt;strong&gt;Architecture CQS avec Temporal&lt;/strong&gt;### &lt;strong&gt;Séparation des Responsabilités&lt;/strong&gt;#### &lt;strong&gt;Côté Commande (Write)&lt;/strong&gt;- &lt;strong&gt;Command Workflows&lt;/strong&gt; : Orchestration des processus de modification- &lt;strong&gt;Command Activities&lt;/strong&gt; : Exécution des activités de modification- &lt;strong&gt;Event Handlers&lt;/strong&gt; : Gestion des événements de domaine- &lt;strong&gt;Bulk Operations&lt;/strong&gt; : Optimisation des écritures#### &lt;strong&gt;Côté Requête (Read)&lt;/strong&gt;- &lt;strong&gt;Query Workflows&lt;/strong&gt; : Orchestration des processus de lecture- &lt;strong&gt;Query Activities&lt;/strong&gt; : Exécution des activités de lecture- &lt;strong&gt;Search Services&lt;/strong&gt; : Services de recherche spécialisés- &lt;strong&gt;Caches&lt;/strong&gt; : Optimisation des performances### &lt;strong&gt;Flux de Données&lt;/strong&gt;&lt;code&gt;mermaidgraph TD A[Command] --&amp;gt; B[Command Workflow] B --&amp;gt; C[Command Activities] C --&amp;gt; D[Write Operations] D --&amp;gt; E[Event Handlers] E --&amp;gt; F[State Updates] G[Query] --&amp;gt; H[Query Workflow] H --&amp;gt; I[Query Activities] I --&amp;gt; J[Read Operations] J --&amp;gt; K[Search Results] K --&amp;gt; L[Response] M[Event] --&amp;gt; N[Event Handler] N --&amp;gt; B O[Cache] --&amp;gt; P[Cache Manager] P --&amp;gt; J J --&amp;gt; Q[Cached Data] Q --&amp;gt; R[Fast Response]&lt;/code&gt;## 💻 &lt;strong&gt;Implémentation Pratique&lt;/strong&gt;### &lt;strong&gt;1. Command Side Implementation&lt;/strong&gt;#### &lt;strong&gt;Command Workflow pour les Paiements&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Workflow\Command\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;#[WorkflowInterface]interface PaymentCommandWorkflowInterface{ #[WorkflowMethod] public function processPaymentCommand(PaymentCommandRequest $request): PaymentCommandResult; #[WorkflowMethod] public function updatePaymentCommand(PaymentUpdateCommandRequest $request): PaymentCommandResult; #[WorkflowMethod] public function deletePaymentCommand(PaymentDeleteCommandRequest $request): PaymentCommandResult;}#[ActivityInterface]interface PaymentCommandActivityInterface{ #[ActivityMethod] public function validatePaymentCommand(PaymentCommandRequest $request): ValidationResult; #[ActivityMethod] public function executePaymentCommand(PaymentCommandRequest $request): CommandExecutionResult; #[ActivityMethod] public function publishPaymentEvent(PaymentEvent $event): void;}class PaymentCommandWorkflow implements PaymentCommandWorkflowInterface{ private PaymentCommandActivityInterface $commandActivity; public function __construct() { $this-&amp;gt;commandActivity = Workflow::newActivityStub(PaymentCommandActivityInterface::class); } public function processPaymentCommand(PaymentCommandRequest $request): PaymentCommandResult { try { // Validation de la commande $validation = yield $this-&amp;gt;commandActivity-&amp;gt;validatePaymentCommand($request); if (!$validation-&amp;gt;isValid()) { return new PaymentCommandResult(false, $validation-&amp;gt;getError()); } // Exécution de la commande $execution = yield $this-&amp;gt;commandActivity-&amp;gt;executePaymentCommand($request); if (!$execution-&amp;gt;isSuccess()) { return new PaymentCommandResult(false, $execution-&amp;gt;getError()); } // Publication de l'événement $event = new PaymentProcessedEvent( $request-&amp;gt;getPaymentId(), $request-&amp;gt;getAmount(), $request-&amp;gt;getCurrency(), $request-&amp;gt;getOrganizationId() ); yield $this-&amp;gt;commandActivity-&amp;gt;publishPaymentEvent($event); return new PaymentCommandResult(true, 'Payment command processed successfully'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e-&amp;gt;getMessage()); } } public function updatePaymentCommand(PaymentUpdateCommandRequest $request): PaymentCommandResult { try { // Validation de la commande de mise à jour $validation = yield $this-&amp;gt;commandActivity-&amp;gt;validatePaymentCommand($request); if (!$validation-&amp;gt;isValid()) { return new PaymentCommandResult(false, $validation-&amp;gt;getError()); } // Exécution de la mise à jour $execution = yield $this-&amp;gt;commandActivity-&amp;gt;executePaymentCommand($request); if (!$execution-&amp;gt;isSuccess()) { return new PaymentCommandResult(false, $execution-&amp;gt;getError()); } // Publication de l'événement de mise à jour $event = new PaymentUpdatedEvent( $request-&amp;gt;getPaymentId(), $request-&amp;gt;getUpdates(), $request-&amp;gt;getOrganizationId() ); yield $this-&amp;gt;commandActivity-&amp;gt;publishPaymentEvent($event); return new PaymentCommandResult(true, 'Payment update command processed successfully'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e-&amp;gt;getMessage()); } } public function deletePaymentCommand(PaymentDeleteCommandRequest $request): PaymentCommandResult { try { // Validation de la commande de suppression $validation = yield $this-&amp;gt;commandActivity-&amp;gt;validatePaymentCommand($request); if (!$validation-&amp;gt;isValid()) { return new PaymentCommandResult(false, $validation-&amp;gt;getError()); } // Exécution de la suppression $execution = yield $this-&amp;gt;commandActivity-&amp;gt;executePaymentCommand($request); if (!$execution-&amp;gt;isSuccess()) { return new PaymentCommandResult(false, $execution-&amp;gt;getError()); } // Publication de l'événement de suppression $event = new PaymentDeletedEvent( $request-&amp;gt;getPaymentId(), $request-&amp;gt;getOrganizationId() ); yield $this-&amp;gt;commandActivity-&amp;gt;publishPaymentEvent($event); return new PaymentCommandResult(true, 'Payment delete command processed successfully'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e-&amp;gt;getMessage()); } }}&lt;/code&gt;#### &lt;strong&gt;Command Activities&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Workflow\Command\Payment;use Temporal\Activity\ActivityInterface;use Temporal\Activity\ActivityMethod;use App\Domain\Payment\PaymentRepositoryInterface;use App\Domain\Payment\Payment;use Psr\Log\LoggerInterface;class PaymentCommandActivity implements PaymentCommandActivityInterface{ private PaymentRepositoryInterface $paymentRepository; private LoggerInterface $logger; public function __construct( PaymentRepositoryInterface $paymentRepository, LoggerInterface $logger ) { $this-&amp;gt;paymentRepository = $paymentRepository; $this-&amp;gt;logger = $logger; } #[ActivityMethod] public function validatePaymentCommand(PaymentCommandRequest $request): ValidationResult { try { $this-&amp;gt;logger-&amp;gt;info('Validating payment command', [ 'paymentId' =&amp;gt; $request-&amp;gt;getPaymentId(), 'commandType' =&amp;gt; $request-&amp;gt;getCommandType() ]); // Validation métier spécifique au type de commande switch ($request-&amp;gt;getCommandType()) { case 'CREATE': return $this-&amp;gt;validateCreateCommand($request); case 'UPDATE': return $this-&amp;gt;validateUpdateCommand($request); case 'DELETE': return $this-&amp;gt;validateDeleteCommand($request); default: return new ValidationResult(false, 'Unknown command type'); } } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Payment command validation failed', [ 'paymentId' =&amp;gt; $request-&amp;gt;getPaymentId(), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); return new ValidationResult(false, $e-&amp;gt;getMessage()); } } #[ActivityMethod] public function executePaymentCommand(PaymentCommandRequest $request): CommandExecutionResult { try { $this-&amp;gt;logger-&amp;gt;info('Executing payment command', [ 'paymentId' =&amp;gt; $request-&amp;gt;getPaymentId(), 'commandType' =&amp;gt; $request-&amp;gt;getCommandType() ]); // Exécution spécifique au type de commande switch ($request-&amp;gt;getCommandType()) { case 'CREATE': return $this-&amp;gt;executeCreateCommand($request); case 'UPDATE': return $this-&amp;gt;executeUpdateCommand($request); case 'DELETE': return $this-&amp;gt;executeDeleteCommand($request); default: return new CommandExecutionResult(false, 'Unknown command type'); } } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Payment command execution failed', [ 'paymentId' =&amp;gt; $request-&amp;gt;getPaymentId(), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); return new CommandExecutionResult(false, $e-&amp;gt;getMessage()); } } #[ActivityMethod] public function publishPaymentEvent(PaymentEvent $event): void { try { $this-&amp;gt;logger-&amp;gt;info('Publishing payment event', [ 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'paymentId' =&amp;gt; $event-&amp;gt;getPaymentId() ]); // Publication de l'événement (ex: via Event Bus) $this-&amp;gt;eventBus-&amp;gt;publish($event); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to publish payment event', [ 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } private function validateCreateCommand(PaymentCommandRequest $request): ValidationResult { if ($request-&amp;gt;getAmount() &amp;lt;= 0) { return new ValidationResult(false, 'Invalid amount'); } if (empty($request-&amp;gt;getCurrency())) { return new ValidationResult(false, 'Currency required'); } return new ValidationResult(true); } private function executeCreateCommand(PaymentCommandRequest $request): CommandExecutionResult { $payment = new Payment( $request-&amp;gt;getPaymentId(), $request-&amp;gt;getOrganizationId(), $request-&amp;gt;getUserId(), $request-&amp;gt;getAmount(), $request-&amp;gt;getCurrency(), 'processing', $request-&amp;gt;getDescription(), new \DateTime() ); $this-&amp;gt;paymentRepository-&amp;gt;save($payment); return new CommandExecutionResult(true, 'Payment created successfully'); } private function validateUpdateCommand(PaymentCommandRequest $request): ValidationResult { $payment = $this-&amp;gt;paymentRepository-&amp;gt;findById($request-&amp;gt;getPaymentId()); if (!$payment) { return new ValidationResult(false, 'Payment not found'); } return new ValidationResult(true); } private function executeUpdateCommand(PaymentCommandRequest $request): CommandExecutionResult { $payment = $this-&amp;gt;paymentRepository-&amp;gt;findById($request-&amp;gt;getPaymentId()); if ($request-&amp;gt;getAmount()) { $payment-&amp;gt;updateAmount($request-&amp;gt;getAmount()); } if ($request-&amp;gt;getDescription()) { $payment-&amp;gt;updateDescription($request-&amp;gt;getDescription()); } $this-&amp;gt;paymentRepository-&amp;gt;save($payment); return new CommandExecutionResult(true, 'Payment updated successfully'); } private function validateDeleteCommand(PaymentCommandRequest $request): ValidationResult { $payment = $this-&amp;gt;paymentRepository-&amp;gt;findById($request-&amp;gt;getPaymentId()); if (!$payment) { return new ValidationResult(false, 'Payment not found'); } if ($payment-&amp;gt;getStatus() === 'completed') { return new ValidationResult(false, 'Cannot delete completed payment'); } return new ValidationResult(true); } private function executeDeleteCommand(PaymentCommandRequest $request): CommandExecutionResult { $this-&amp;gt;paymentRepository-&amp;gt;delete($request-&amp;gt;getPaymentId()); return new CommandExecutionResult(true, 'Payment deleted successfully'); }}&lt;/code&gt;### &lt;strong&gt;2. Query Side Implementation&lt;/strong&gt;#### &lt;strong&gt;Query Workflow pour les Paiements&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Workflow\Query\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;#[WorkflowInterface]interface PaymentQueryWorkflowInterface{ #[WorkflowMethod] public function searchPayments(PaymentSearchQuery $query): PaymentSearchResult; #[WorkflowMethod] public function getPaymentById(PaymentByIdQuery $query): ?Payment; #[WorkflowMethod] public function getPaymentStatistics(PaymentStatisticsQuery $query): array;}#[ActivityInterface]interface PaymentQueryActivityInterface{ #[ActivityMethod] public function searchPaymentsInDatabase(PaymentSearchQuery $query): array; #[ActivityMethod] public function getPaymentFromDatabase(string $paymentId): ?Payment; #[ActivityMethod] public function calculatePaymentStatistics(PaymentStatisticsQuery $query): array;}class PaymentQueryWorkflow implements PaymentQueryWorkflowInterface{ private PaymentQueryActivityInterface $queryActivity; public function __construct() { $this-&amp;gt;queryActivity = Workflow::newActivityStub(PaymentQueryActivityInterface::class); } public function searchPayments(PaymentSearchQuery $query): PaymentSearchResult { try { // Recherche dans la base de données $payments = yield $this-&amp;gt;queryActivity-&amp;gt;searchPaymentsInDatabase($query); // Filtrage et tri $filteredPayments = $this-&amp;gt;filterPayments($payments, $query); $sortedPayments = $this-&amp;gt;sortPayments($filteredPayments, $query); // Pagination $paginatedPayments = $this-&amp;gt;paginatePayments($sortedPayments, $query); return new PaymentSearchResult( $paginatedPayments, count($filteredPayments), $query-&amp;gt;getPage(), $query-&amp;gt;getSize() ); } catch (\Exception $e) { return new PaymentSearchResult([], 0, $query-&amp;gt;getPage(), $query-&amp;gt;getSize()); } } public function getPaymentById(PaymentByIdQuery $query): ?Payment { try { return yield $this-&amp;gt;queryActivity-&amp;gt;getPaymentFromDatabase($query-&amp;gt;getPaymentId()); } catch (\Exception $e) { return null; } } public function getPaymentStatistics(PaymentStatisticsQuery $query): array { try { return yield $this-&amp;gt;queryActivity-&amp;gt;calculatePaymentStatistics($query); } catch (\Exception $e) { return []; } } private function filterPayments(array $payments, PaymentSearchQuery $query): array { return array_filter($payments, function($payment) use ($query) { if ($query-&amp;gt;getOrganizationId() &amp;amp;&amp;amp; $payment-&amp;gt;getOrganizationId() !== $query-&amp;gt;getOrganizationId()) { return false; } if ($query-&amp;gt;getStatus() &amp;amp;&amp;amp; $payment-&amp;gt;getStatus() !== $query-&amp;gt;getStatus()) { return false; } if ($query-&amp;gt;getMinAmount() &amp;amp;&amp;amp; $payment-&amp;gt;getAmount() &amp;lt; $query-&amp;gt;getMinAmount()) { return false; } if ($query-&amp;gt;getMaxAmount() &amp;amp;&amp;amp; $payment-&amp;gt;getAmount() &amp;gt; $query-&amp;gt;getMaxAmount()) { return false; } return true; }); } private function sortPayments(array $payments, PaymentSearchQuery $query): array { $sortField = $query-&amp;gt;getSortField() ?? 'createdAt'; $sortDirection = $query-&amp;gt;getSortDirection() ?? 'desc'; usort($payments, function($a, $b) use ($sortField, $sortDirection) { $valueA = $this-&amp;gt;getFieldValue($a, $sortField); $valueB = $this-&amp;gt;getFieldValue($b, $sortField); if ($sortDirection === 'asc') { return $valueA &amp;lt;=&amp;gt; $valueB; } else { return $valueB &amp;lt;=&amp;gt; $valueA; } }); return $payments; } private function paginatePayments(array $payments, PaymentSearchQuery $query): array { $page = $query-&amp;gt;getPage() ?? 1; $size = $query-&amp;gt;getSize() ?? 10; $offset = ($page - 1) * $size; return array_slice($payments, $offset, $size); } private function getFieldValue(Payment $payment, string $field): mixed { switch ($field) { case 'amount': return $payment-&amp;gt;getAmount(); case 'createdAt': return $payment-&amp;gt;getCreatedAt(); case 'status': return $payment-&amp;gt;getStatus(); default: return $payment-&amp;gt;getCreatedAt(); } }}&lt;/code&gt;#### &lt;strong&gt;Query Activities&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Workflow\Query\Payment;use Temporal\Activity\ActivityInterface;use Temporal\Activity\ActivityMethod;use App\Domain\Payment\PaymentRepositoryInterface;use Psr\Log\LoggerInterface;use Psr\Cache\CacheItemPoolInterface;class PaymentQueryActivity implements PaymentQueryActivityInterface{ private PaymentRepositoryInterface $paymentRepository; private LoggerInterface $logger; private CacheItemPoolInterface $cache; public function __construct( PaymentRepositoryInterface $paymentRepository, LoggerInterface $logger, CacheItemPoolInterface $cache ) { $this-&amp;gt;paymentRepository = $paymentRepository; $this-&amp;gt;logger = $logger; $this-&amp;gt;cache = $cache; } #[ActivityMethod] public function searchPaymentsInDatabase(PaymentSearchQuery $query): array { try { $cacheKey = 'payment_search_' . md5(serialize($query)); $cachedItem = $this-&amp;gt;cache-&amp;gt;getItem($cacheKey); if ($cachedItem-&amp;gt;isHit()) { $this-&amp;gt;logger-&amp;gt;debug('Payment search result served from cache', [ 'query' =&amp;gt; $query-&amp;gt;toArray() ]); return $cachedItem-&amp;gt;get(); } $this-&amp;gt;logger-&amp;gt;info('Searching payments in database', [ 'query' =&amp;gt; $query-&amp;gt;toArray() ]); $payments = $this-&amp;gt;paymentRepository-&amp;gt;search($query); // Mettre en cache $cachedItem-&amp;gt;set($payments); $cachedItem-&amp;gt;expiresAfter(300); // 5 minutes $this-&amp;gt;cache-&amp;gt;save($cachedItem); return $payments; } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Payment search failed', [ 'query' =&amp;gt; $query-&amp;gt;toArray(), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); return []; } } #[ActivityMethod] public function getPaymentFromDatabase(string $paymentId): ?Payment { try { $cacheKey = 'payment_' . $paymentId; $cachedItem = $this-&amp;gt;cache-&amp;gt;getItem($cacheKey); if ($cachedItem-&amp;gt;isHit()) { $this-&amp;gt;logger-&amp;gt;debug('Payment served from cache', [ 'paymentId' =&amp;gt; $paymentId ]); return $cachedItem-&amp;gt;get(); } $this-&amp;gt;logger-&amp;gt;info('Getting payment from database', [ 'paymentId' =&amp;gt; $paymentId ]); $payment = $this-&amp;gt;paymentRepository-&amp;gt;findById($paymentId); // Mettre en cache if ($payment) { $cachedItem-&amp;gt;set($payment); $cachedItem-&amp;gt;expiresAfter(600); // 10 minutes $this-&amp;gt;cache-&amp;gt;save($cachedItem); } return $payment; } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to get payment from database', [ 'paymentId' =&amp;gt; $paymentId, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); return null; } } #[ActivityMethod] public function calculatePaymentStatistics(PaymentStatisticsQuery $query): array { try { $cacheKey = 'payment_stats_' . md5(serialize($query)); $cachedItem = $this-&amp;gt;cache-&amp;gt;getItem($cacheKey); if ($cachedItem-&amp;gt;isHit()) { $this-&amp;gt;logger-&amp;gt;debug('Payment statistics served from cache', [ 'query' =&amp;gt; $query-&amp;gt;toArray() ]); return $cachedItem-&amp;gt;get(); } $this-&amp;gt;logger-&amp;gt;info('Calculating payment statistics', [ 'query' =&amp;gt; $query-&amp;gt;toArray() ]); $statistics = $this-&amp;gt;paymentRepository-&amp;gt;getStatistics($query); // Mettre en cache $cachedItem-&amp;gt;set($statistics); $cachedItem-&amp;gt;expiresAfter(300); // 5 minutes $this-&amp;gt;cache-&amp;gt;save($cachedItem); return $statistics; } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to calculate payment statistics', [ 'query' =&amp;gt; $query-&amp;gt;toArray(), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); return []; } }}&lt;/code&gt;### &lt;strong&gt;3. Service de Synchronisation&lt;/strong&gt;#### &lt;strong&gt;Service de Synchronisation CQS&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Service\Temporal;use App\Workflow\Command\Payment\PaymentCommandWorkflowInterface;use App\Workflow\Query\Payment\PaymentQueryWorkflowInterface;use App\Workflow\Command\Payment\PaymentCommandRequest;use App\Workflow\Query\Payment\PaymentSearchQuery;use Temporal\Client\WorkflowClientInterface;use Psr\Log\LoggerInterface;class PaymentCqsService{ private WorkflowClientInterface $workflowClient; private LoggerInterface $logger; public function __construct( WorkflowClientInterface $workflowClient, LoggerInterface $logger ) { $this-&amp;gt;workflowClient = $workflowClient; $this-&amp;gt;logger = $logger; } public function processPaymentCommand(PaymentCommandRequest $request): PaymentCommandResult { try { $workflowOptions = $this-&amp;gt;createCommandWorkflowOptions($request-&amp;gt;getPaymentId()); $workflow = $this-&amp;gt;workflowClient-&amp;gt;newWorkflowStub( PaymentCommandWorkflowInterface::class, $workflowOptions ); $result = $workflow-&amp;gt;processPaymentCommand($request); $this-&amp;gt;logger-&amp;gt;info('Payment command processed', [ 'paymentId' =&amp;gt; $request-&amp;gt;getPaymentId(), 'success' =&amp;gt; $result-&amp;gt;isSuccess() ]); return $result; } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Payment command processing failed', [ 'paymentId' =&amp;gt; $request-&amp;gt;getPaymentId(), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } public function searchPayments(PaymentSearchQuery $query): PaymentSearchResult { try { $workflowOptions = $this-&amp;gt;createQueryWorkflowOptions('payment-search-' . uniqid()); $workflow = $this-&amp;gt;workflowClient-&amp;gt;newWorkflowStub( PaymentQueryWorkflowInterface::class, $workflowOptions ); $result = $workflow-&amp;gt;searchPayments($query); $this-&amp;gt;logger-&amp;gt;info('Payment search completed', [ 'query' =&amp;gt; $query-&amp;gt;toArray(), 'results' =&amp;gt; $result-&amp;gt;getTotal() ]); return $result; } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Payment search failed', [ 'query' =&amp;gt; $query-&amp;gt;toArray(), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } private function createCommandWorkflowOptions(string $paymentId): WorkflowOptions { return WorkflowOptions::new() -&amp;gt;withWorkflowId('payment-command-' . $paymentId) -&amp;gt;withWorkflowExecutionTimeout(300) -&amp;gt;withWorkflowRunTimeout(300) -&amp;gt;withWorkflowTaskTimeout(60); } private function createQueryWorkflowOptions(string $workflowId): WorkflowOptions { return WorkflowOptions::new() -&amp;gt;withWorkflowId($workflowId) -&amp;gt;withWorkflowExecutionTimeout(120) -&amp;gt;withWorkflowRunTimeout(120) -&amp;gt;withWorkflowTaskTimeout(30); }}&lt;/code&gt;## 🧪 &lt;strong&gt;Tests et Validation&lt;/strong&gt;### &lt;strong&gt;Tests d&amp;rsquo;Intégration CQS&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Tests\Integration\Temporal;use App\Workflow\Command\Payment\PaymentCommandRequest;use App\Workflow\Query\Payment\PaymentSearchQuery;use App\Application\Service\Temporal\PaymentCqsService;use App\Infrastructure\Temporal\TemporalClientFactory;class TemporalPaymentCqsTest extends TestCase{ private PaymentCqsService $cqsService; private TemporalClientFactory $temporalFactory; protected function setUp(): void { $this-&amp;gt;temporalFactory = new TemporalClientFactory('localhost', 7233, 'test'); $this-&amp;gt;cqsService = new PaymentCqsService( $this-&amp;gt;temporalFactory-&amp;gt;createClient(), $this-&amp;gt;createMock(LoggerInterface::class) ); } public function testCommandQuerySeparation(): void { // Exécuter une commande $command = new PaymentCommandRequest( 'CREATE', 'payment-123', 'org-456', 'user-789', 100.00, 'EUR', 'Test payment' ); $result = $this-&amp;gt;cqsService-&amp;gt;processPaymentCommand($command); $this-&amp;gt;assertTrue($result-&amp;gt;isSuccess()); // Vérifier avec une requête $query = new PaymentSearchQuery('org-456', 0, 10); $searchResult = $this-&amp;gt;cqsService-&amp;gt;searchPayments($query); $this-&amp;gt;assertGreaterThan(0, $searchResult-&amp;gt;getTotal()); } public function testQueryCaching(): void { $query = new PaymentSearchQuery('org-456', 0, 10); // Première recherche $result1 = $this-&amp;gt;cqsService-&amp;gt;searchPayments($query); // Deuxième recherche (devrait utiliser le cache) $result2 = $this-&amp;gt;cqsService-&amp;gt;searchPayments($query); $this-&amp;gt;assertEquals($result1-&amp;gt;getTotal(), $result2-&amp;gt;getTotal()); }}&lt;/code&gt;## 📊 &lt;strong&gt;Performance et Optimisation&lt;/strong&gt;### &lt;strong&gt;Stratégies d&amp;rsquo;Optimisation CQS&lt;/strong&gt;#### &lt;strong&gt;1. Cache Stratégique&lt;/strong&gt;&lt;code&gt;phppublic function searchPaymentsWithCache(PaymentSearchQuery $query): PaymentSearchResult{ $cacheKey = 'payment_search_' . md5(serialize($query)); if ($cached = $this-&amp;gt;cache-&amp;gt;get($cacheKey)) { return $cached; } $result = $this-&amp;gt;searchPayments($query); $this-&amp;gt;cache-&amp;gt;set($cacheKey, $result, 300); return $result;}&lt;/code&gt;#### &lt;strong&gt;2. Workflows Asynchrones&lt;/strong&gt;&lt;code&gt;phppublic function processPaymentCommandAsync(PaymentCommandRequest $request): string{ $workflowOptions = $this-&amp;gt;createCommandWorkflowOptions($request-&amp;gt;getPaymentId()); $workflow = $this-&amp;gt;workflowClient-&amp;gt;newWorkflowStub( PaymentCommandWorkflowInterface::class, $workflowOptions ); // Démarrer le workflow de manière asynchrone $this-&amp;gt;workflowClient-&amp;gt;start($workflow, $request); return $workflowOptions-&amp;gt;getWorkflowId();}&lt;/code&gt;#### &lt;strong&gt;3. Monitoring des Workflows&lt;/strong&gt;&lt;code&gt;phppublic function getWorkflowMetrics(): array{ return [ 'commandWorkflows' =&amp;gt; $this-&amp;gt;getCommandWorkflowMetrics(), 'queryWorkflows' =&amp;gt; $this-&amp;gt;getQueryWorkflowMetrics(), 'cacheHitRate' =&amp;gt; $this-&amp;gt;getCacheHitRate(), 'averageExecutionTime' =&amp;gt; $this-&amp;gt;getAverageExecutionTime() ];}&lt;/code&gt;## 🎯 &lt;strong&gt;Critères d&amp;rsquo;Adoption&lt;/strong&gt;### &lt;strong&gt;Quand Utiliser CQS avec Temporal&lt;/strong&gt;#### &lt;strong&gt;✅ Avantages&lt;/strong&gt;- &lt;strong&gt;Performance optimisée&lt;/strong&gt; : Séparation claire entre écriture et lecture- &lt;strong&gt;Scalabilité&lt;/strong&gt; : Possibilité de scaler indépendamment- &lt;strong&gt;Flexibilité&lt;/strong&gt; : Requêtes optimisées pour chaque usage- &lt;strong&gt;Maintenabilité&lt;/strong&gt; : Code plus clair et organisé- &lt;strong&gt;Résilience&lt;/strong&gt; : Workflows robustes avec reprise automatique#### &lt;strong&gt;❌ Inconvénients&lt;/strong&gt;- &lt;strong&gt;Complexité&lt;/strong&gt; : Architecture plus complexe- &lt;strong&gt;Infrastructure&lt;/strong&gt; : Nécessite un serveur Temporal- &lt;strong&gt;Latence&lt;/strong&gt; : Overhead pour les opérations simples- &lt;strong&gt;Expertise&lt;/strong&gt; : Équipe expérimentée requise#### &lt;strong&gt;🎯 Critères d&amp;rsquo;Adoption&lt;/strong&gt;- &lt;strong&gt;Performance importante&lt;/strong&gt; : Besoins de performance élevée- &lt;strong&gt;Processus métier complexes&lt;/strong&gt; : Workflows qui nécessitent de l&amp;rsquo;orchestration- &lt;strong&gt;Séparation des responsabilités&lt;/strong&gt; : Besoin de séparer clairement les commandes et requêtes- &lt;strong&gt;Équipe expérimentée&lt;/strong&gt; : Maîtrise de Temporal et CQS- &lt;strong&gt;Infrastructure disponible&lt;/strong&gt; : Serveur Temporal opérationnel- &lt;strong&gt;Cache nécessaire&lt;/strong&gt; : Besoin de mise en cache des requêtes## 🚀 &lt;strong&gt;Votre Prochaine Étape&lt;/strong&gt;

&lt;div class="chapter-navigation"&gt;
 &lt;h2 class="chapter-nav-title"&gt;🎯 Votre Prochaine Étape&lt;/h2&gt;
 &lt;p class="chapter-nav-subtitle"&gt;Maintenant que vous comprenez les concepts de base et que j'ai partagé mon expérience avec Gyroscops, quel est votre contexte ?&lt;/p&gt;</description></item><item><title>Stockage Temporal - CQRS</title><link>http://localhost:1313/chapitres/stockage/temporal/chapitre-48-stockage-temporal-cqrs/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/temporal/chapitre-48-stockage-temporal-cqrs/</guid><description>&lt;h2 id="-contexte-et-objectifs-lnous-arrivons-maintenant-à-lapproche-la-plus-sophistiquée-pour-temporal--cqrs-complet-cette-combinaison-offre-une-architecture-hautement-scalable-et-flexible-parfaite-pour-les-systèmes-nécessitant-orchestration-maximale-et-séparation-claire-des-responsabilités-pourquoi-cqrs-avec-temporal---séparation-totale--commandes-et-requêtes-complètement-découplées--scalabilité-maximale--possibilité-de-scaler-indépendamment-chaque-côté--performance-optimale--chaque-côté-optimisé-pour-son-usage--flexibilité--projections-multiples-pour-différents-besoins--résilience--workflows-robustes-avec-reprise-automatique-contexte-gyroscopsdans-notre-écosystème-user--organization--workflow--cloud-resources--billing-cqrs-avec-temporal-est-la-solution-ultime-pour---workflows-de-commande--orchestration-des-processus-de-modification-avec-projections--workflows-de-requête--optimisation-des-lectures-avec-analytics-avancées--processus-de-facturation--séparation-complète-des-écritures-et-lectures-de-facturation--intégrations-complexes--orchestration-des-intégrations-avec-projections-multiples--architecture-cqrs-avec-temporal-séparation-complète-des-responsabilités-command-side-write--command-workflows--orchestration-des-processus-de-modification--command-activities--exécution-des-activités-de-modification--event-handlers--gestion-des-événements-de-domaine--command-bus--orchestration-des-commandes--projections--mise-à-jour-des-vues-matérialisées-query-side-read--query-workflows--orchestration-des-processus-de-lecture--query-activities--exécution-des-activités-de-lecture--search-services--services-de-recherche-spécialisés--query-bus--orchestration-des-requêtes--caches--optimisation-des-performances-flux-de-données-completmermaidgraph-td----acommand----bcommand-bus----b----ccommand-workflow----c----dcommand-activities----d----ewrite-operations----e----fevent-handlers----f----gprojections----g----hread-models--------iquery----jquery-bus----j----kquery-workflow----k----lquery-activities----l----mread-operations----m----nsearch-results----n----oresponse--------pevent----qevent-handler----q----c--------rprojection----sread-model-update----s----h--implémentation-complète-1-command-side-implementation-command-bus-avec-middlewarephpphpnamespace-appapplicationcommandbustemporaluse-appdomaincommandcommandinterfaceuse-appdomaincommandcommandhandlerinterfaceuse-temporalclientworkflowclientinterfaceuse-psrlogloggerinterfaceclass-temporalcommandbus----private-array-handlers------private-array-middleware------private-workflowclientinterface-workflowclient----private-loggerinterface-logger----public-function-__construct--------workflowclientinterface-workflowclient--------loggerinterface-logger-------------this-workflowclient--workflowclient--------this-logger--logger--------public-function-registerhandlerstring-commandclass-commandhandlerinterface-handler-void------------this-handlerscommandclass--handler--------public-function-addmiddlewarecallable-middleware-void------------this-middleware--middleware--------public-function-handlecommandinterface-command-void------------commandclass--get_classcommand----------------if-issetthis-handlerscommandclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-command-commandclass----------------handler--this-handlerscommandclass-----------------exécuter-les-middleware--------this-executemiddlewarecommand-function-use-handler-command-------------this-logger-infoexecuting-command-via-temporal-----------------command--get_classcommand----------------data--command-toarray------------------------------------handler-handlecommand----------------private-function-executemiddlewarecommandinterface-command-callable-next-void------------middleware--array_reversethis-middleware----------------foreach-middleware-as-mw-------------next--function-use-mw-command-next-----------------return-mwcommand-next------------------------------------next-----command-workflow-avancéphpphpnamespace-appworkflowcommandpaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowworkflowinterfaceinterface-paymentcommandworkflowinterface----workflowmethod----public-function-processpaymentcommandpaymentcommandrequest-request-paymentcommandresult--------workflowmethod----public-function-updatepaymentcommandpaymentupdatecommandrequest-request-paymentcommandresult--------workflowmethod----public-function-deletepaymentcommandpaymentdeletecommandrequest-request-paymentcommandresultactivityinterfaceinterface-paymentcommandactivityinterface----activitymethod----public-function-validatepaymentcommandpaymentcommandrequest-request-validationresult--------activitymethod----public-function-executepaymentcommandpaymentcommandrequest-request-commandexecutionresult--------activitymethod----public-function-updateprojectionspaymentevent-event-voidclass-paymentcommandworkflow-implements-paymentcommandworkflowinterface----private-paymentcommandactivityinterface-commandactivity----public-function-__construct------------this-commandactivity--workflownewactivitystubpaymentcommandactivityinterfaceclass--------public-function-processpaymentcommandpaymentcommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------exécution-de-la-commande------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------mise-à-jour-des-projections------------event--new-paymentprocessedevent----------------request-getpaymentid----------------request-getamount----------------request-getcurrency----------------request-getorganizationid------------------------------------yield-this-commandactivity-updateprojectionsevent------------------------return-new-paymentcommandresulttrue-payment-command-processed-successfully---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage----------------public-function-updatepaymentcommandpaymentupdatecommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande-de-mise-à-jour------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------exécution-de-la-mise-à-jour------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------mise-à-jour-des-projections------------event--new-paymentupdatedevent----------------request-getpaymentid----------------request-getupdates----------------request-getorganizationid------------------------------------yield-this-commandactivity-updateprojectionsevent------------------------return-new-paymentcommandresulttrue-payment-update-command-processed-successfully---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage----------------public-function-deletepaymentcommandpaymentdeletecommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande-de-suppression------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------exécution-de-la-suppression------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------mise-à-jour-des-projections------------event--new-paymentdeletedevent----------------request-getpaymentid----------------request-getorganizationid------------------------------------yield-this-commandactivity-updateprojectionsevent------------------------return-new-paymentcommandresulttrue-payment-delete-command-processed-successfully---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage-------------2-query-side-implementation-query-bus-avec-cachephpphpnamespace-appapplicationquerybustemporaluse-appdomainqueryqueryinterfaceuse-appdomainqueryqueryhandlerinterfaceuse-temporalclientworkflowclientinterfaceuse-psrcachecacheitempoolinterfaceuse-psrlogloggerinterfaceclass-temporalquerybus----private-array-handlers------private-workflowclientinterface-workflowclient----private-cacheitempoolinterface-cache----private-loggerinterface-logger----public-function-__construct--------workflowclientinterface-workflowclient--------cacheitempoolinterface-cache--------loggerinterface-logger-------------this-workflowclient--workflowclient--------this-cache--cache--------this-logger--logger--------public-function-registerhandlerstring-queryclass-queryhandlerinterface-handler-void------------this-handlersqueryclass--handler--------public-function-handlequeryinterface-query-mixed------------queryclass--get_classquery----------------if-issetthis-handlersqueryclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-query-queryclass-----------------vérifier-le-cache--------cachekey--this-generatecachekeyquery--------cacheditem--this-cache-getitemcachekey----------------if-cacheditem-ishit-------------this-logger-debugquery-result-served-from-cache-----------------query--queryclass----------------cachekey--cachekey------------------------------------return-cacheditem-get-----------------exécuter-la-requête-via-temporal--------handler--this-handlersqueryclass--------result--handler-handlequery-----------------mettre-en-cache--------cacheditem-setresult--------cacheditem-expiresafter300--5-minutes--------this-cache-savecacheditem----------------this-logger-infoquery-executed-and-cached-via-temporal-------------query--queryclass------------cachekey--cachekey------------------------return-result--------private-function-generatecachekeyqueryinterface-query-string------------return-temporal_query_--md5serializequery-----query-workflow-avancéphpphpnamespace-appworkflowquerypaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowworkflowinterfaceinterface-paymentqueryworkflowinterface----workflowmethod----public-function-searchpaymentspaymentsearchquery-query-paymentsearchresult--------workflowmethod----public-function-getpaymentbyidpaymentbyidquery-query-payment--------workflowmethod----public-function-getpaymentstatisticspaymentstatisticsquery-query-array--------workflowmethod----public-function-getpaymentanalyticspaymentanalyticsquery-query-arrayactivityinterfaceinterface-paymentqueryactivityinterface----activitymethod----public-function-searchpaymentsinreadmodelpaymentsearchquery-query-array--------activitymethod----public-function-getpaymentfromreadmodelstring-paymentid-payment--------activitymethod----public-function-calculatepaymentstatisticspaymentstatisticsquery-query-array--------activitymethod----public-function-generatepaymentanalyticspaymentanalyticsquery-query-arrayclass-paymentqueryworkflow-implements-paymentqueryworkflowinterface----private-paymentqueryactivityinterface-queryactivity----public-function-__construct------------this-queryactivity--workflownewactivitystubpaymentqueryactivityinterfaceclass--------public-function-searchpaymentspaymentsearchquery-query-paymentsearchresult------------try--------------recherche-dans-le-read-model------------payments--yield-this-queryactivity-searchpaymentsinreadmodelquery-------------------------filtrage-et-tri------------filteredpayments--this-filterpaymentspayments-query------------sortedpayments--this-sortpaymentsfilteredpayments-query-------------------------pagination------------paginatedpayments--this-paginatepaymentssortedpayments-query------------------------return-new-paymentsearchresult----------------paginatedpayments----------------countfilteredpayments----------------query-getpage----------------query-getsize---------------------------------catch-exception-e-------------return-new-paymentsearchresult-0-query-getpage-query-getsize----------------public-function-getpaymentbyidpaymentbyidquery-query-payment------------try-------------return-yield-this-queryactivity-getpaymentfromreadmodelquery-getpaymentid---------catch-exception-e-------------return-null----------------public-function-getpaymentstatisticspaymentstatisticsquery-query-array------------try-------------return-yield-this-queryactivity-calculatepaymentstatisticsquery---------catch-exception-e-------------return-----------------public-function-getpaymentanalyticspaymentanalyticsquery-query-array------------try-------------return-yield-this-queryactivity-generatepaymentanalyticsquery---------catch-exception-e-------------return-----------------private-function-filterpaymentsarray-payments-paymentsearchquery-query-array------------return-array_filterpayments-functionpayment-use-query-------------if-query-getorganizationid--payment-getorganizationid--query-getorganizationid-----------------return-false------------------------------------if-query-getstatus--payment-getstatus--query-getstatus-----------------return-false------------------------------------if-query-getminamount--payment-getamount--query-getminamount-----------------return-false------------------------------------if-query-getmaxamount--payment-getamount--query-getmaxamount-----------------return-false------------------------------------return-true----------------private-function-sortpaymentsarray-payments-paymentsearchquery-query-array------------sortfield--query-getsortfield--createdat--------sortdirection--query-getsortdirection--desc----------------usortpayments-functiona-b-use-sortfield-sortdirection-------------valuea--this-getfieldvaluea-sortfield------------valueb--this-getfieldvalueb-sortfield------------------------if-sortdirection--asc-----------------return-valuea--valueb-------------else-----------------return-valueb--valuea------------------------------------return-payments--------private-function-paginatepaymentsarray-payments-paymentsearchquery-query-array------------page--query-getpage--1--------size--query-getsize--10--------offset--page---1--size----------------return-array_slicepayments-offset-size--------private-function-getfieldvaluepayment-payment-string-field-mixed------------switch-field-------------case-amount----------------return-payment-getamount------------case-createdat----------------return-payment-getcreatedat------------case-status----------------return-payment-getstatus------------default----------------return-payment-getcreatedat-------------3-service-de-projection-service-de-projection-pour-les-read-modelsphpphpnamespace-appapplicationservicetemporaluse-appdomaineventdomaineventuse-appinfrastructuretemporaltemporalclientfactoryuse-psrlogloggerinterfaceclass-paymentprojectionservice----private-temporalclientfactory-temporalfactory----private-loggerinterface-logger----public-function-__construct--------temporalclientfactory-temporalfactory--------loggerinterface-logger-------------this-temporalfactory--temporalfactory--------this-logger--logger--------public-function-handleeventdomainevent-event-void------------try-------------workflowoptions--this-temporalfactory-createworkflowoptions-----------------withworkflowidprojection---event-geteventtype-----uniqid------------------------workflow--this-temporalfactory-createclient-----------------newworkflowstubpaymentprojectionworkflowinterfaceclass-workflowoptions------------------------workflow-updateprojectionevent------------------------this-logger-infoprojection-updated-via-temporal-----------------eventtype--event-geteventtype----------------eventid--event-getid---------------------------------catch-exception-e-------------this-logger-errorfailed-to-update-projection-via-temporal-----------------eventtype--event-geteventtype----------------error--e-getmessage------------------------------------throw-e----------------public-function-rebuildprojectionstring-projectiontype-void------------try-------------workflowoptions--this-temporalfactory-createworkflowoptions-----------------withworkflowidrebuild-projection---projectiontype-----uniqid------------------------workflow--this-temporalfactory-createclient-----------------newworkflowstubpaymentprojectionworkflowinterfaceclass-workflowoptions------------------------workflow-rebuildprojectionprojectiontype------------------------this-logger-infoprojection-rebuilt-via-temporal-----------------projectiontype--projectiontype---------------------------------catch-exception-e-------------this-logger-errorfailed-to-rebuild-projection-via-temporal-----------------projectiontype--projectiontype----------------error--e-getmessage------------------------------------throw-e--------------tests-et-validation-tests-dphpphpnamespace-apptestsintegrationtemporaluse-appworkflowcommandpaymentpaymentcommandrequestuse-appworkflowquerypaymentpaymentsearchqueryuse-appapplicationcommandbustemporaltemporalcommandbususe-appapplicationquerybustemporaltemporalquerybususe-appinfrastructuretemporaltemporalclientfactoryclass-temporalpaymentcqrstest-extends-testcase----private-temporalcommandbus-commandbus----private-temporalquerybus-querybus----private-temporalclientfactory-temporalfactory----protected-function-setup-void------------this-temporalfactory--new-temporalclientfactorylocalhost-7233-test--------this-commandbus--new-temporalcommandbus------------this-temporalfactory-createclient------------this-createmockloggerinterfaceclass----------------this-querybus--new-temporalquerybus------------this-temporalfactory-createclient------------this-createmockcacheitempoolinterfaceclass------------this-createmockloggerinterfaceclass----------------public-function-testcqrsseparation-void-------------exécuter-une-commande--------command--new-paymentcommandrequest------------create------------payment-123------------org-456------------user-789------------10000------------eur------------test-payment------------------------this-commandbus-handlecommand-----------------vérifier-avec-une-requête--------query--new-paymentsearchqueryorg-456-0-10--------result--this-querybus-handlequery----------------this-assertgreaterthan0-result-gettotal--------public-function-testquerycaching-void------------query--new-paymentsearchqueryorg-456-0-10-----------------première-recherche--------result1--this-querybus-handlequery-----------------deuxième-recherche-devrait-utiliser-le-cache--------result2--this-querybus-handlequery----------------this-assertequalsresult1-gettotal-result2-gettotal------performance-et-optimisation-stratégies-d-1-cache-multi-niveauxphppublic-function-searchpaymentswithcachepaymentsearchquery-query-paymentsearchresult-----cache-l1-mémoire----if-issetthis-memorycachequery-getcachekey---------return-this-memorycachequery-getcachekey-------------cache-l2-redis----if-cached--this-redis-getpayment_searchquery-getcachekey---------result--paymentsearchresultfromarrayjson_decodecached-true--------this-memorycachequery-getcachekey--result--------return-result-------------temporal----result--this-searchpaymentsquery---------mettre-en-cache----this-memorycachequery-getcachekey--result----this-redis-setexpayment_searchquery-getcachekey-300-json_encoderesult-toarray--------return-result-2-projections-asynchronesphppublic-function-handleeventasyncdomainevent-event-void-----mettre-en-queue-pour-traitement-asynchrone----this-messagebus-dispatchnew-processprojectioncommandevent-3-monitoring-des-workflowsphppublic-function-getworkflowmetrics-array----return---------commandworkflows--this-getcommandworkflowmetrics--------queryworkflows--this-getqueryworkflowmetrics--------projections--this-getprojectionmetrics--------cachehitrate--this-getcachehitrate--------averageexecutiontime--this-getaverageexecutiontime------critères-d-quand-utiliser-cqrs-avec-temporal--avantages--scalabilité-maximale--possibilité-de-scaler-indépendamment--performance-optimale--chaque-côté-optimisé-pour-son-usage--flexibilité-maximale--projections-multiples-pour-différents-besoins--résilience--workflows-robustes-avec-reprise-automatique--maintenabilité--code-plus-clair-et-organisé--inconvénients--complexité-maximale--architecture-très-complexe--infrastructure--nécessite-un-serveur-temporal--latence--overhead-pour-les-opérations-simples--expertise--équipe-très-expérimentée-requise--coût--infrastructure-très-coûteuse--critères-d--système-très-complexe--besoins-de-scalabilité-maximale--processus-métier-complexes--workflows-qui-nécessitent-de-lorchestration--performance-critique--besoins-de-performance-maximale--projections-multiples--besoin-de-vues-différentes-des-données--équipe-très-expérimentée--maîtrise-de-temporal-et-cqrs--budget-important--investissement-en-complexité-justifié--infrastructure-disponible--serveur-temporal-opérationnel--votre-prochaine-étapehahahugoshortcode78s0hbhbcqrs-avec-temporal-représente-l"&gt;🎯 &lt;strong&gt;Contexte et Objectifs&lt;/strong&gt;### &lt;strong&gt;L&amp;rsquo;Architecture Maximale : CQRS avec Temporal&lt;/strong&gt;Nous arrivons maintenant à l&amp;rsquo;approche la plus sophistiquée pour Temporal : &lt;strong&gt;CQRS complet&lt;/strong&gt;. Cette combinaison offre une architecture hautement scalable et flexible, parfaite pour les systèmes nécessitant orchestration maximale et séparation claire des responsabilités.#### &lt;strong&gt;Pourquoi CQRS avec Temporal ?&lt;/strong&gt;- &lt;strong&gt;Séparation totale&lt;/strong&gt; : Commandes et requêtes complètement découplées- &lt;strong&gt;Scalabilité maximale&lt;/strong&gt; : Possibilité de scaler indépendamment chaque côté- &lt;strong&gt;Performance optimale&lt;/strong&gt; : Chaque côté optimisé pour son usage- &lt;strong&gt;Flexibilité&lt;/strong&gt; : Projections multiples pour différents besoins- &lt;strong&gt;Résilience&lt;/strong&gt; : Workflows robustes avec reprise automatique### &lt;strong&gt;Contexte Gyroscops&lt;/strong&gt;Dans notre écosystème &lt;strong&gt;User → Organization → Workflow → Cloud Resources → Billing&lt;/strong&gt;, CQRS avec Temporal est la solution ultime pour :- &lt;strong&gt;Workflows de commande&lt;/strong&gt; : Orchestration des processus de modification avec projections- &lt;strong&gt;Workflows de requête&lt;/strong&gt; : Optimisation des lectures avec analytics avancées- &lt;strong&gt;Processus de facturation&lt;/strong&gt; : Séparation complète des écritures et lectures de facturation- &lt;strong&gt;Intégrations complexes&lt;/strong&gt; : Orchestration des intégrations avec projections multiples## 🏗️ &lt;strong&gt;Architecture CQRS avec Temporal&lt;/strong&gt;### &lt;strong&gt;Séparation Complète des Responsabilités&lt;/strong&gt;#### &lt;strong&gt;Command Side (Write)&lt;/strong&gt;- &lt;strong&gt;Command Workflows&lt;/strong&gt; : Orchestration des processus de modification- &lt;strong&gt;Command Activities&lt;/strong&gt; : Exécution des activités de modification- &lt;strong&gt;Event Handlers&lt;/strong&gt; : Gestion des événements de domaine- &lt;strong&gt;Command Bus&lt;/strong&gt; : Orchestration des commandes- &lt;strong&gt;Projections&lt;/strong&gt; : Mise à jour des vues matérialisées#### &lt;strong&gt;Query Side (Read)&lt;/strong&gt;- &lt;strong&gt;Query Workflows&lt;/strong&gt; : Orchestration des processus de lecture- &lt;strong&gt;Query Activities&lt;/strong&gt; : Exécution des activités de lecture- &lt;strong&gt;Search Services&lt;/strong&gt; : Services de recherche spécialisés- &lt;strong&gt;Query Bus&lt;/strong&gt; : Orchestration des requêtes- &lt;strong&gt;Caches&lt;/strong&gt; : Optimisation des performances### &lt;strong&gt;Flux de Données Complet&lt;/strong&gt;&lt;code&gt;mermaidgraph TD A[Command] --&amp;gt; B[Command Bus] B --&amp;gt; C[Command Workflow] C --&amp;gt; D[Command Activities] D --&amp;gt; E[Write Operations] E --&amp;gt; F[Event Handlers] F --&amp;gt; G[Projections] G --&amp;gt; H[Read Models] I[Query] --&amp;gt; J[Query Bus] J --&amp;gt; K[Query Workflow] K --&amp;gt; L[Query Activities] L --&amp;gt; M[Read Operations] M --&amp;gt; N[Search Results] N --&amp;gt; O[Response] P[Event] --&amp;gt; Q[Event Handler] Q --&amp;gt; C R[Projection] --&amp;gt; S[Read Model Update] S --&amp;gt; H&lt;/code&gt;## 💻 &lt;strong&gt;Implémentation Complète&lt;/strong&gt;### &lt;strong&gt;1. Command Side Implementation&lt;/strong&gt;#### &lt;strong&gt;Command Bus avec Middleware&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\CommandBus\Temporal;use App\Domain\Command\CommandInterface;use App\Domain\Command\CommandHandlerInterface;use Temporal\Client\WorkflowClientInterface;use Psr\Log\LoggerInterface;class TemporalCommandBus{ private array $handlers = []; private array $middleware = []; private WorkflowClientInterface $workflowClient; private LoggerInterface $logger; public function __construct( WorkflowClientInterface $workflowClient, LoggerInterface $logger ) { $this-&amp;gt;workflowClient = $workflowClient; $this-&amp;gt;logger = $logger; } public function registerHandler(string $commandClass, CommandHandlerInterface $handler): void { $this-&amp;gt;handlers[$commandClass] = $handler; } public function addMiddleware(callable $middleware): void { $this-&amp;gt;middleware[] = $middleware; } public function handle(CommandInterface $command): void { $commandClass = get_class($command); if (!isset($this-&amp;gt;handlers[$commandClass])) { throw new \InvalidArgumentException(&amp;quot;No handler registered for command: $commandClass&amp;quot;); } $handler = $this-&amp;gt;handlers[$commandClass]; // Exécuter les middleware $this-&amp;gt;executeMiddleware($command, function() use ($handler, $command) { $this-&amp;gt;logger-&amp;gt;info('Executing command via Temporal', [ 'command' =&amp;gt; get_class($command), 'data' =&amp;gt; $command-&amp;gt;toArray() ]); $handler-&amp;gt;handle($command); }); } private function executeMiddleware(CommandInterface $command, callable $next): void { $middleware = array_reverse($this-&amp;gt;middleware); foreach ($middleware as $mw) { $next = function() use ($mw, $command, $next) { return $mw($command, $next); }; } $next(); }}&lt;/code&gt;#### &lt;strong&gt;Command Workflow Avancé&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Workflow\Command\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;#[WorkflowInterface]interface PaymentCommandWorkflowInterface{ #[WorkflowMethod] public function processPaymentCommand(PaymentCommandRequest $request): PaymentCommandResult; #[WorkflowMethod] public function updatePaymentCommand(PaymentUpdateCommandRequest $request): PaymentCommandResult; #[WorkflowMethod] public function deletePaymentCommand(PaymentDeleteCommandRequest $request): PaymentCommandResult;}#[ActivityInterface]interface PaymentCommandActivityInterface{ #[ActivityMethod] public function validatePaymentCommand(PaymentCommandRequest $request): ValidationResult; #[ActivityMethod] public function executePaymentCommand(PaymentCommandRequest $request): CommandExecutionResult; #[ActivityMethod] public function updateProjections(PaymentEvent $event): void;}class PaymentCommandWorkflow implements PaymentCommandWorkflowInterface{ private PaymentCommandActivityInterface $commandActivity; public function __construct() { $this-&amp;gt;commandActivity = Workflow::newActivityStub(PaymentCommandActivityInterface::class); } public function processPaymentCommand(PaymentCommandRequest $request): PaymentCommandResult { try { // Validation de la commande $validation = yield $this-&amp;gt;commandActivity-&amp;gt;validatePaymentCommand($request); if (!$validation-&amp;gt;isValid()) { return new PaymentCommandResult(false, $validation-&amp;gt;getError()); } // Exécution de la commande $execution = yield $this-&amp;gt;commandActivity-&amp;gt;executePaymentCommand($request); if (!$execution-&amp;gt;isSuccess()) { return new PaymentCommandResult(false, $execution-&amp;gt;getError()); } // Mise à jour des projections $event = new PaymentProcessedEvent( $request-&amp;gt;getPaymentId(), $request-&amp;gt;getAmount(), $request-&amp;gt;getCurrency(), $request-&amp;gt;getOrganizationId() ); yield $this-&amp;gt;commandActivity-&amp;gt;updateProjections($event); return new PaymentCommandResult(true, 'Payment command processed successfully'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e-&amp;gt;getMessage()); } } public function updatePaymentCommand(PaymentUpdateCommandRequest $request): PaymentCommandResult { try { // Validation de la commande de mise à jour $validation = yield $this-&amp;gt;commandActivity-&amp;gt;validatePaymentCommand($request); if (!$validation-&amp;gt;isValid()) { return new PaymentCommandResult(false, $validation-&amp;gt;getError()); } // Exécution de la mise à jour $execution = yield $this-&amp;gt;commandActivity-&amp;gt;executePaymentCommand($request); if (!$execution-&amp;gt;isSuccess()) { return new PaymentCommandResult(false, $execution-&amp;gt;getError()); } // Mise à jour des projections $event = new PaymentUpdatedEvent( $request-&amp;gt;getPaymentId(), $request-&amp;gt;getUpdates(), $request-&amp;gt;getOrganizationId() ); yield $this-&amp;gt;commandActivity-&amp;gt;updateProjections($event); return new PaymentCommandResult(true, 'Payment update command processed successfully'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e-&amp;gt;getMessage()); } } public function deletePaymentCommand(PaymentDeleteCommandRequest $request): PaymentCommandResult { try { // Validation de la commande de suppression $validation = yield $this-&amp;gt;commandActivity-&amp;gt;validatePaymentCommand($request); if (!$validation-&amp;gt;isValid()) { return new PaymentCommandResult(false, $validation-&amp;gt;getError()); } // Exécution de la suppression $execution = yield $this-&amp;gt;commandActivity-&amp;gt;executePaymentCommand($request); if (!$execution-&amp;gt;isSuccess()) { return new PaymentCommandResult(false, $execution-&amp;gt;getError()); } // Mise à jour des projections $event = new PaymentDeletedEvent( $request-&amp;gt;getPaymentId(), $request-&amp;gt;getOrganizationId() ); yield $this-&amp;gt;commandActivity-&amp;gt;updateProjections($event); return new PaymentCommandResult(true, 'Payment delete command processed successfully'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e-&amp;gt;getMessage()); } }}&lt;/code&gt;### &lt;strong&gt;2. Query Side Implementation&lt;/strong&gt;#### &lt;strong&gt;Query Bus avec Cache&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\QueryBus\Temporal;use App\Domain\Query\QueryInterface;use App\Domain\Query\QueryHandlerInterface;use Temporal\Client\WorkflowClientInterface;use Psr\Cache\CacheItemPoolInterface;use Psr\Log\LoggerInterface;class TemporalQueryBus{ private array $handlers = []; private WorkflowClientInterface $workflowClient; private CacheItemPoolInterface $cache; private LoggerInterface $logger; public function __construct( WorkflowClientInterface $workflowClient, CacheItemPoolInterface $cache, LoggerInterface $logger ) { $this-&amp;gt;workflowClient = $workflowClient; $this-&amp;gt;cache = $cache; $this-&amp;gt;logger = $logger; } public function registerHandler(string $queryClass, QueryHandlerInterface $handler): void { $this-&amp;gt;handlers[$queryClass] = $handler; } public function handle(QueryInterface $query): mixed { $queryClass = get_class($query); if (!isset($this-&amp;gt;handlers[$queryClass])) { throw new \InvalidArgumentException(&amp;quot;No handler registered for query: $queryClass&amp;quot;); } // Vérifier le cache $cacheKey = $this-&amp;gt;generateCacheKey($query); $cachedItem = $this-&amp;gt;cache-&amp;gt;getItem($cacheKey); if ($cachedItem-&amp;gt;isHit()) { $this-&amp;gt;logger-&amp;gt;debug('Query result served from cache', [ 'query' =&amp;gt; $queryClass, 'cacheKey' =&amp;gt; $cacheKey ]); return $cachedItem-&amp;gt;get(); } // Exécuter la requête via Temporal $handler = $this-&amp;gt;handlers[$queryClass]; $result = $handler-&amp;gt;handle($query); // Mettre en cache $cachedItem-&amp;gt;set($result); $cachedItem-&amp;gt;expiresAfter(300); // 5 minutes $this-&amp;gt;cache-&amp;gt;save($cachedItem); $this-&amp;gt;logger-&amp;gt;info('Query executed and cached via Temporal', [ 'query' =&amp;gt; $queryClass, 'cacheKey' =&amp;gt; $cacheKey ]); return $result; } private function generateCacheKey(QueryInterface $query): string { return 'temporal_query_' . md5(serialize($query)); }}&lt;/code&gt;#### &lt;strong&gt;Query Workflow Avancé&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Workflow\Query\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;#[WorkflowInterface]interface PaymentQueryWorkflowInterface{ #[WorkflowMethod] public function searchPayments(PaymentSearchQuery $query): PaymentSearchResult; #[WorkflowMethod] public function getPaymentById(PaymentByIdQuery $query): ?Payment; #[WorkflowMethod] public function getPaymentStatistics(PaymentStatisticsQuery $query): array; #[WorkflowMethod] public function getPaymentAnalytics(PaymentAnalyticsQuery $query): array;}#[ActivityInterface]interface PaymentQueryActivityInterface{ #[ActivityMethod] public function searchPaymentsInReadModel(PaymentSearchQuery $query): array; #[ActivityMethod] public function getPaymentFromReadModel(string $paymentId): ?Payment; #[ActivityMethod] public function calculatePaymentStatistics(PaymentStatisticsQuery $query): array; #[ActivityMethod] public function generatePaymentAnalytics(PaymentAnalyticsQuery $query): array;}class PaymentQueryWorkflow implements PaymentQueryWorkflowInterface{ private PaymentQueryActivityInterface $queryActivity; public function __construct() { $this-&amp;gt;queryActivity = Workflow::newActivityStub(PaymentQueryActivityInterface::class); } public function searchPayments(PaymentSearchQuery $query): PaymentSearchResult { try { // Recherche dans le Read Model $payments = yield $this-&amp;gt;queryActivity-&amp;gt;searchPaymentsInReadModel($query); // Filtrage et tri $filteredPayments = $this-&amp;gt;filterPayments($payments, $query); $sortedPayments = $this-&amp;gt;sortPayments($filteredPayments, $query); // Pagination $paginatedPayments = $this-&amp;gt;paginatePayments($sortedPayments, $query); return new PaymentSearchResult( $paginatedPayments, count($filteredPayments), $query-&amp;gt;getPage(), $query-&amp;gt;getSize() ); } catch (\Exception $e) { return new PaymentSearchResult([], 0, $query-&amp;gt;getPage(), $query-&amp;gt;getSize()); } } public function getPaymentById(PaymentByIdQuery $query): ?Payment { try { return yield $this-&amp;gt;queryActivity-&amp;gt;getPaymentFromReadModel($query-&amp;gt;getPaymentId()); } catch (\Exception $e) { return null; } } public function getPaymentStatistics(PaymentStatisticsQuery $query): array { try { return yield $this-&amp;gt;queryActivity-&amp;gt;calculatePaymentStatistics($query); } catch (\Exception $e) { return []; } } public function getPaymentAnalytics(PaymentAnalyticsQuery $query): array { try { return yield $this-&amp;gt;queryActivity-&amp;gt;generatePaymentAnalytics($query); } catch (\Exception $e) { return []; } } private function filterPayments(array $payments, PaymentSearchQuery $query): array { return array_filter($payments, function($payment) use ($query) { if ($query-&amp;gt;getOrganizationId() &amp;amp;&amp;amp; $payment-&amp;gt;getOrganizationId() !== $query-&amp;gt;getOrganizationId()) { return false; } if ($query-&amp;gt;getStatus() &amp;amp;&amp;amp; $payment-&amp;gt;getStatus() !== $query-&amp;gt;getStatus()) { return false; } if ($query-&amp;gt;getMinAmount() &amp;amp;&amp;amp; $payment-&amp;gt;getAmount() &amp;lt; $query-&amp;gt;getMinAmount()) { return false; } if ($query-&amp;gt;getMaxAmount() &amp;amp;&amp;amp; $payment-&amp;gt;getAmount() &amp;gt; $query-&amp;gt;getMaxAmount()) { return false; } return true; }); } private function sortPayments(array $payments, PaymentSearchQuery $query): array { $sortField = $query-&amp;gt;getSortField() ?? 'createdAt'; $sortDirection = $query-&amp;gt;getSortDirection() ?? 'desc'; usort($payments, function($a, $b) use ($sortField, $sortDirection) { $valueA = $this-&amp;gt;getFieldValue($a, $sortField); $valueB = $this-&amp;gt;getFieldValue($b, $sortField); if ($sortDirection === 'asc') { return $valueA &amp;lt;=&amp;gt; $valueB; } else { return $valueB &amp;lt;=&amp;gt; $valueA; } }); return $payments; } private function paginatePayments(array $payments, PaymentSearchQuery $query): array { $page = $query-&amp;gt;getPage() ?? 1; $size = $query-&amp;gt;getSize() ?? 10; $offset = ($page - 1) * $size; return array_slice($payments, $offset, $size); } private function getFieldValue(Payment $payment, string $field): mixed { switch ($field) { case 'amount': return $payment-&amp;gt;getAmount(); case 'createdAt': return $payment-&amp;gt;getCreatedAt(); case 'status': return $payment-&amp;gt;getStatus(); default: return $payment-&amp;gt;getCreatedAt(); } }}&lt;/code&gt;### &lt;strong&gt;3. Service de Projection&lt;/strong&gt;#### &lt;strong&gt;Service de Projection pour les Read Models&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Service\Temporal;use App\Domain\Event\DomainEvent;use App\Infrastructure\Temporal\TemporalClientFactory;use Psr\Log\LoggerInterface;class PaymentProjectionService{ private TemporalClientFactory $temporalFactory; private LoggerInterface $logger; public function __construct( TemporalClientFactory $temporalFactory, LoggerInterface $logger ) { $this-&amp;gt;temporalFactory = $temporalFactory; $this-&amp;gt;logger = $logger; } public function handleEvent(DomainEvent $event): void { try { $workflowOptions = $this-&amp;gt;temporalFactory-&amp;gt;createWorkflowOptions() -&amp;gt;withWorkflowId('projection-' . $event-&amp;gt;getEventType() . '-' . uniqid()); $workflow = $this-&amp;gt;temporalFactory-&amp;gt;createClient() -&amp;gt;newWorkflowStub(PaymentProjectionWorkflowInterface::class, $workflowOptions); $workflow-&amp;gt;updateProjection($event); $this-&amp;gt;logger-&amp;gt;info('Projection updated via Temporal', [ 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'eventId' =&amp;gt; $event-&amp;gt;getId() ]); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to update projection via Temporal', [ 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } public function rebuildProjection(string $projectionType): void { try { $workflowOptions = $this-&amp;gt;temporalFactory-&amp;gt;createWorkflowOptions() -&amp;gt;withWorkflowId('rebuild-projection-' . $projectionType . '-' . uniqid()); $workflow = $this-&amp;gt;temporalFactory-&amp;gt;createClient() -&amp;gt;newWorkflowStub(PaymentProjectionWorkflowInterface::class, $workflowOptions); $workflow-&amp;gt;rebuildProjection($projectionType); $this-&amp;gt;logger-&amp;gt;info('Projection rebuilt via Temporal', [ 'projectionType' =&amp;gt; $projectionType ]); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to rebuild projection via Temporal', [ 'projectionType' =&amp;gt; $projectionType, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } }}&lt;/code&gt;## 🧪 &lt;strong&gt;Tests et Validation&lt;/strong&gt;### &lt;strong&gt;Tests d&amp;rsquo;Intégration CQRS&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Tests\Integration\Temporal;use App\Workflow\Command\Payment\PaymentCommandRequest;use App\Workflow\Query\Payment\PaymentSearchQuery;use App\Application\CommandBus\Temporal\TemporalCommandBus;use App\Application\QueryBus\Temporal\TemporalQueryBus;use App\Infrastructure\Temporal\TemporalClientFactory;class TemporalPaymentCqrsTest extends TestCase{ private TemporalCommandBus $commandBus; private TemporalQueryBus $queryBus; private TemporalClientFactory $temporalFactory; protected function setUp(): void { $this-&amp;gt;temporalFactory = new TemporalClientFactory('localhost', 7233, 'test'); $this-&amp;gt;commandBus = new TemporalCommandBus( $this-&amp;gt;temporalFactory-&amp;gt;createClient(), $this-&amp;gt;createMock(LoggerInterface::class) ); $this-&amp;gt;queryBus = new TemporalQueryBus( $this-&amp;gt;temporalFactory-&amp;gt;createClient(), $this-&amp;gt;createMock(CacheItemPoolInterface::class), $this-&amp;gt;createMock(LoggerInterface::class) ); } public function testCqrsSeparation(): void { // Exécuter une commande $command = new PaymentCommandRequest( 'CREATE', 'payment-123', 'org-456', 'user-789', 100.00, 'EUR', 'Test payment' ); $this-&amp;gt;commandBus-&amp;gt;handle($command); // Vérifier avec une requête $query = new PaymentSearchQuery('org-456', 0, 10); $result = $this-&amp;gt;queryBus-&amp;gt;handle($query); $this-&amp;gt;assertGreaterThan(0, $result-&amp;gt;getTotal()); } public function testQueryCaching(): void { $query = new PaymentSearchQuery('org-456', 0, 10); // Première recherche $result1 = $this-&amp;gt;queryBus-&amp;gt;handle($query); // Deuxième recherche (devrait utiliser le cache) $result2 = $this-&amp;gt;queryBus-&amp;gt;handle($query); $this-&amp;gt;assertEquals($result1-&amp;gt;getTotal(), $result2-&amp;gt;getTotal()); }}&lt;/code&gt;## 📊 &lt;strong&gt;Performance et Optimisation&lt;/strong&gt;### &lt;strong&gt;Stratégies d&amp;rsquo;Optimisation CQRS&lt;/strong&gt;#### &lt;strong&gt;1. Cache Multi-Niveaux&lt;/strong&gt;&lt;code&gt;phppublic function searchPaymentsWithCache(PaymentSearchQuery $query): PaymentSearchResult{ // Cache L1: Mémoire if (isset($this-&amp;gt;memoryCache[$query-&amp;gt;getCacheKey()])) { return $this-&amp;gt;memoryCache[$query-&amp;gt;getCacheKey()]; } // Cache L2: Redis if ($cached = $this-&amp;gt;redis-&amp;gt;get(&amp;quot;payment_search:{$query-&amp;gt;getCacheKey()}&amp;quot;)) { $result = PaymentSearchResult::fromArray(json_decode($cached, true)); $this-&amp;gt;memoryCache[$query-&amp;gt;getCacheKey()] = $result; return $result; } // Temporal $result = $this-&amp;gt;searchPayments($query); // Mettre en cache $this-&amp;gt;memoryCache[$query-&amp;gt;getCacheKey()] = $result; $this-&amp;gt;redis-&amp;gt;setex(&amp;quot;payment_search:{$query-&amp;gt;getCacheKey()}&amp;quot;, 300, json_encode($result-&amp;gt;toArray())); return $result;}&lt;/code&gt;#### &lt;strong&gt;2. Projections Asynchrones&lt;/strong&gt;&lt;code&gt;phppublic function handleEventAsync(DomainEvent $event): void{ // Mettre en queue pour traitement asynchrone $this-&amp;gt;messageBus-&amp;gt;dispatch(new ProcessProjectionCommand($event));}&lt;/code&gt;#### &lt;strong&gt;3. Monitoring des Workflows&lt;/strong&gt;&lt;code&gt;phppublic function getWorkflowMetrics(): array{ return [ 'commandWorkflows' =&amp;gt; $this-&amp;gt;getCommandWorkflowMetrics(), 'queryWorkflows' =&amp;gt; $this-&amp;gt;getQueryWorkflowMetrics(), 'projections' =&amp;gt; $this-&amp;gt;getProjectionMetrics(), 'cacheHitRate' =&amp;gt; $this-&amp;gt;getCacheHitRate(), 'averageExecutionTime' =&amp;gt; $this-&amp;gt;getAverageExecutionTime() ];}&lt;/code&gt;## 🎯 &lt;strong&gt;Critères d&amp;rsquo;Adoption&lt;/strong&gt;### &lt;strong&gt;Quand Utiliser CQRS avec Temporal&lt;/strong&gt;#### &lt;strong&gt;✅ Avantages&lt;/strong&gt;- &lt;strong&gt;Scalabilité maximale&lt;/strong&gt; : Possibilité de scaler indépendamment- &lt;strong&gt;Performance optimale&lt;/strong&gt; : Chaque côté optimisé pour son usage- &lt;strong&gt;Flexibilité maximale&lt;/strong&gt; : Projections multiples pour différents besoins- &lt;strong&gt;Résilience&lt;/strong&gt; : Workflows robustes avec reprise automatique- &lt;strong&gt;Maintenabilité&lt;/strong&gt; : Code plus clair et organisé#### &lt;strong&gt;❌ Inconvénients&lt;/strong&gt;- &lt;strong&gt;Complexité maximale&lt;/strong&gt; : Architecture très complexe- &lt;strong&gt;Infrastructure&lt;/strong&gt; : Nécessite un serveur Temporal- &lt;strong&gt;Latence&lt;/strong&gt; : Overhead pour les opérations simples- &lt;strong&gt;Expertise&lt;/strong&gt; : Équipe très expérimentée requise- &lt;strong&gt;Coût&lt;/strong&gt; : Infrastructure très coûteuse#### &lt;strong&gt;🎯 Critères d&amp;rsquo;Adoption&lt;/strong&gt;- &lt;strong&gt;Système très complexe&lt;/strong&gt; : Besoins de scalabilité maximale- &lt;strong&gt;Processus métier complexes&lt;/strong&gt; : Workflows qui nécessitent de l&amp;rsquo;orchestration- &lt;strong&gt;Performance critique&lt;/strong&gt; : Besoins de performance maximale- &lt;strong&gt;Projections multiples&lt;/strong&gt; : Besoin de vues différentes des données- &lt;strong&gt;Équipe très expérimentée&lt;/strong&gt; : Maîtrise de Temporal et CQRS- &lt;strong&gt;Budget important&lt;/strong&gt; : Investissement en complexité justifié- &lt;strong&gt;Infrastructure disponible&lt;/strong&gt; : Serveur Temporal opérationnel## 🚀 &lt;strong&gt;Votre Prochaine Étape&lt;/strong&gt;

&lt;div class="chapter-navigation"&gt;
 &lt;h2 class="chapter-nav-title"&gt;🎯 Votre Prochaine Étape&lt;/h2&gt;
 &lt;p class="chapter-nav-subtitle"&gt;Maintenant que vous comprenez les concepts de base et que j'ai partagé mon expérience avec Gyroscops, quel est votre contexte ?&lt;/p&gt;</description></item><item><title>Stockage Temporal - Event Sourcing</title><link>http://localhost:1313/chapitres/stockage/temporal/chapitre-49-stockage-temporal-event-sourcing/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/temporal/chapitre-49-stockage-temporal-event-sourcing/</guid><description/></item><item><title>Stockage Temporal - Event Sourcing + CQS</title><link>http://localhost:1313/chapitres/stockage/temporal/chapitre-50-stockage-temporal-event-sourcing-cqs/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/temporal/chapitre-50-stockage-temporal-event-sourcing-cqs/</guid><description>&lt;h2 id="-contexte-et-objectifs-la-combinaison-ultime--event-sourcing--cqs-avec-temporalnous-arrivons-maintenant-à-lapproche-la-plus-sophistiquée-pour-temporal--event-sourcing--cqs-cette-combinaison-offre-une-architecture-hautement-performante-et-traçable-parfaite-pour-les-systèmes-nécessitant-audit-trail-complet-et-séparation-claire-des-responsabilités-pourquoi-cette-combinaison---performance-optimisée--séparation-claire-entre-écriture-et-lecture--audit-trail-complet--historique-immuable-de-tous-les-événements--scalabilité--possibilité-de-scaler-indépendamment-chaque-côté--flexibilité--projections-multiples-pour-différents-besoins--résilience--workflows-robustes-avec-reprise-automatique-contexte-gyroscopsdans-notre-écosystème-user--organization--workflow--cloud-resources--billing-event-sourcing--cqs-avec-temporal-est-la-solution-ultime-pour---workflows-de-commande--orchestration-des-processus-de-modification-avec-projections--workflows-de-requête--optimisation-des-lectures-avec-analytics-avancées--processus-de-facturation--séparation-complète-des-écritures-et-lectures-de-facturation--intégrations-complexes--orchestration-des-intégrations-avec-projections-multiples--architecture-event-sourcing--cqs-avec-temporal-séparation-complète-des-responsabilités-command-side-write-avec-event-sourcing--command-workflows--orchestration-des-processus-de-modification--command-activities--exécution-des-activités-de-modification--event-handlers--gestion-des-événements-de-domaine--command-bus--orchestration-des-commandes--event-store--persistance-des-événements--projections--mise-à-jour-des-vues-matérialisées-query-side-read-avec-event-sourcing--query-workflows--orchestration-des-processus-de-lecture--query-activities--exécution-des-activités-de-lecture--search-services--services-de-recherche-spécialisés--query-bus--orchestration-des-requêtes--caches--optimisation-des-performances--read-models--vues-matérialisées-des-événements-flux-de-données-completmermaidgraph-td----acommand----bcommand-bus----b----ccommand-workflow----c----dcommand-activities----d----eaggregate----e----fevents----f----gevent-store-workflow----g----hevent-store-activity----h----ievent-store-in-memory----i----jevent-handlers----j----kprojections----k----lread-models--------mquery----nquery-bus----n----oquery-workflow----o----pquery-activities----p----qread-operations----q----rsearch-results----r----sresponse--------tevent----uevent-handler----u----c--------vprojection----wread-model-update----w----l--implémentation-complète-1-command-side-avec-event-sourcing-command-bus-avec-event-sourcingphpphpnamespace-appapplicationcommandbustemporaluse-appdomaincommandcommandinterfaceuse-appdomaincommandcommandhandlerinterfaceuse-appdomaineventdomaineventuse-temporalclientworkflowclientinterfaceuse-psrlogloggerinterfaceclass-temporaleventsourcingcommandbus----private-array-handlers------private-array-middleware------private-workflowclientinterface-workflowclient----private-loggerinterface-logger----public-function-__construct--------workflowclientinterface-workflowclient--------loggerinterface-logger-------------this-workflowclient--workflowclient--------this-logger--logger--------public-function-registerhandlerstring-commandclass-commandhandlerinterface-handler-void------------this-handlerscommandclass--handler--------public-function-addmiddlewarecallable-middleware-void------------this-middleware--middleware--------public-function-handlecommandinterface-command-void------------commandclass--get_classcommand----------------if-issetthis-handlerscommandclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-command-commandclass----------------handler--this-handlerscommandclass-----------------exécuter-les-middleware--------this-executemiddlewarecommand-function-use-handler-command-------------this-logger-infoexecuting-command-via-temporal-with-event-sourcing-----------------command--get_classcommand----------------data--command-toarray------------------------------------handler-handlecommand----------------private-function-executemiddlewarecommandinterface-command-callable-next-void------------middleware--array_reversethis-middleware----------------foreach-middleware-as-mw-------------next--function-use-mw-command-next-----------------return-mwcommand-next------------------------------------next-----command-workflow-avec-event-sourcingphpphpnamespace-appworkflowcommandpaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowuse-appdomainpaymentpaymentaggregateuse-appinfrastructureeventstoretemporaleventstoreworkflowinterfaceworkflowinterfaceinterface-paymenteventsourcingcommandworkflowinterface----workflowmethod----public-function-processpaymentcommandwitheventsourcingpaymentcommandrequest-request-paymentcommandresult--------workflowmethod----public-function-updatepaymentcommandwitheventsourcingpaymentupdatecommandrequest-request-paymentcommandresult--------workflowmethod----public-function-deletepaymentcommandwitheventsourcingpaymentdeletecommandrequest-request-paymentcommandresultactivityinterfaceinterface-paymenteventsourcingcommandactivityinterface----activitymethod----public-function-validatepaymentcommandpaymentcommandrequest-request-validationresult--------activitymethod----public-function-loadpaymentaggregatestring-paymentid-paymentaggregate--------activitymethod----public-function-executepaymentcommandpaymentaggregate-payment-paymentcommandrequest-request-array--------activitymethod----public-function-persisteventsstring-aggregateid-array-events-int-expectedversion-void--------activitymethod----public-function-updateprojectionsarray-events-voidclass-paymenteventsourcingcommandworkflow-implements-paymenteventsourcingcommandworkflowinterface----private-paymenteventsourcingcommandactivityinterface-commandactivity----private-eventstoreworkflowinterface-eventstoreworkflow----public-function-__construct------------this-commandactivity--workflownewactivitystubpaymenteventsourcingcommandactivityinterfaceclass--------this-eventstoreworkflow--workflownewworkflowstubeventstoreworkflowinterfaceclass--------public-function-processpaymentcommandwitheventsourcingpaymentcommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------charger-lagrégat-depuis-les-événements------------payment--yield-this-commandactivity-loadpaymentaggregaterequest-getpaymentid------------------------if-payment-----------------payment--new-paymentaggregaterequest-getpaymentid-------------------------------------exécuter-la-commande------------events--yield-this-commandactivity-executepaymentcommandpayment-request------------------------if-emptyevents-----------------return-new-paymentcommandresultfalse-no-events-generated-------------------------------------persister-les-événements------------yield-this-commandactivity-persistevents----------------request-getpaymentid----------------events----------------payment-getversion-------------------------------------mettre-à-jour-les-projections------------yield-this-commandactivity-updateprojectionsevents------------------------return-new-paymentcommandresulttrue-payment-command-processed-with-event-sourcing---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage----------------public-function-updatepaymentcommandwitheventsourcingpaymentupdatecommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande-de-mise-à-jour------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------charger-lagrégat-depuis-les-événements------------payment--yield-this-commandactivity-loadpaymentaggregaterequest-getpaymentid------------------------if-payment-----------------return-new-paymentcommandresultfalse-payment-not-found-------------------------------------exécuter-la-commande-de-mise-à-jour------------events--yield-this-commandactivity-executepaymentcommandpayment-request------------------------if-emptyevents-----------------return-new-paymentcommandresultfalse-no-events-generated-------------------------------------persister-les-événements------------yield-this-commandactivity-persistevents----------------request-getpaymentid----------------events----------------payment-getversion-------------------------------------mettre-à-jour-les-projections------------yield-this-commandactivity-updateprojectionsevents------------------------return-new-paymentcommandresulttrue-payment-update-command-processed-with-event-sourcing---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage----------------public-function-deletepaymentcommandwitheventsourcingpaymentdeletecommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande-de-suppression------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------charger-lagrégat-depuis-les-événements------------payment--yield-this-commandactivity-loadpaymentaggregaterequest-getpaymentid------------------------if-payment-----------------return-new-paymentcommandresultfalse-payment-not-found-------------------------------------exécuter-la-commande-de-suppression------------events--yield-this-commandactivity-executepaymentcommandpayment-request------------------------if-emptyevents-----------------return-new-paymentcommandresultfalse-no-events-generated-------------------------------------persister-les-événements------------yield-this-commandactivity-persistevents----------------request-getpaymentid----------------events----------------payment-getversion-------------------------------------mettre-à-jour-les-projections------------yield-this-commandactivity-updateprojectionsevents------------------------return-new-paymentcommandresulttrue-payment-delete-command-processed-with-event-sourcing---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage-------------2-query-side-avec-event-sourcing-query-bus-avec-cache-et-event-sourcingphpphpnamespace-appapplicationquerybustemporaluse-appdomainqueryqueryinterfaceuse-appdomainqueryqueryhandlerinterfaceuse-temporalclientworkflowclientinterfaceuse-psrcachecacheitempoolinterfaceuse-psrlogloggerinterfaceclass-temporaleventsourcingquerybus----private-array-handlers------private-workflowclientinterface-workflowclient----private-cacheitempoolinterface-cache----private-loggerinterface-logger----public-function-__construct--------workflowclientinterface-workflowclient--------cacheitempoolinterface-cache--------loggerinterface-logger-------------this-workflowclient--workflowclient--------this-cache--cache--------this-logger--logger--------public-function-registerhandlerstring-queryclass-queryhandlerinterface-handler-void------------this-handlersqueryclass--handler--------public-function-handlequeryinterface-query-mixed------------queryclass--get_classquery----------------if-issetthis-handlersqueryclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-query-queryclass-----------------vérifier-le-cache--------cachekey--this-generatecachekeyquery--------cacheditem--this-cache-getitemcachekey----------------if-cacheditem-ishit-------------this-logger-debugquery-result-served-from-cache-----------------query--queryclass----------------cachekey--cachekey------------------------------------return-cacheditem-get-----------------exécuter-la-requête-via-temporal--------handler--this-handlersqueryclass--------result--handler-handlequery-----------------mettre-en-cache--------cacheditem-setresult--------cacheditem-expiresafter300--5-minutes--------this-cache-savecacheditem----------------this-logger-infoquery-executed-and-cached-via-temporal-with-event-sourcing-------------query--queryclass------------cachekey--cachekey------------------------return-result--------private-function-generatecachekeyqueryinterface-query-string------------return-temporal_event_sourcing_query_--md5serializequery-----query-workflow-avec-event-sourcingphpphpnamespace-appworkflowquerypaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowuse-appinfrastructureeventstoretemporaleventstoreworkflowinterfaceworkflowinterfaceinterface-paymenteventsourcingqueryworkflowinterface----workflowmethod----public-function-searchpaymentswitheventsourcingpaymentsearchquery-query-paymentsearchresult--------workflowmethod----public-function-getpaymentbyidwitheventsourcingpaymentbyidquery-query-payment--------workflowmethod----public-function-getpaymenthistorypaymenthistoryquery-query-array--------workflowmethod----public-function-getpaymentstatisticswitheventsourcingpaymentstatisticsquery-query-array--------workflowmethod----public-function-getpaymentanalyticswitheventsourcingpaymentanalyticsquery-query-arrayactivityinterfaceinterface-paymenteventsourcingqueryactivityinterface----activitymethod----public-function-searchpaymentsinreadmodelpaymentsearchquery-query-array--------activitymethod----public-function-getpaymentfromreadmodelstring-paymentid-payment--------activitymethod----public-function-geteventsbyaggregatestring-aggregateid-array--------activitymethod----public-function-calculatepaymentstatisticsfromeventspaymentstatisticsquery-query-array--------activitymethod----public-function-generatepaymentanalyticsfromeventspaymentanalyticsquery-query-arrayclass-paymenteventsourcingqueryworkflow-implements-paymenteventsourcingqueryworkflowinterface----private-paymenteventsourcingqueryactivityinterface-queryactivity----private-eventstoreworkflowinterface-eventstoreworkflow----public-function-__construct------------this-queryactivity--workflownewactivitystubpaymenteventsourcingqueryactivityinterfaceclass--------this-eventstoreworkflow--workflownewworkflowstubeventstoreworkflowinterfaceclass--------public-function-searchpaymentswitheventsourcingpaymentsearchquery-query-paymentsearchresult------------try--------------recherche-dans-le-read-model------------payments--yield-this-queryactivity-searchpaymentsinreadmodelquery-------------------------filtrage-et-tri------------filteredpayments--this-filterpaymentspayments-query------------sortedpayments--this-sortpaymentsfilteredpayments-query-------------------------pagination------------paginatedpayments--this-paginatepaymentssortedpayments-query------------------------return-new-paymentsearchresult----------------paginatedpayments----------------countfilteredpayments----------------query-getpage----------------query-getsize---------------------------------catch-exception-e-------------return-new-paymentsearchresult-0-query-getpage-query-getsize----------------public-function-getpaymentbyidwitheventsourcingpaymentbyidquery-query-payment------------try-------------return-yield-this-queryactivity-getpaymentfromreadmodelquery-getpaymentid---------catch-exception-e-------------return-null----------------public-function-getpaymenthistorypaymenthistoryquery-query-array------------try-------------events--yield-this-queryactivity-geteventsbyaggregatequery-getpaymentid------------------------history--------------foreach-events-as-event-----------------history----------------------eventid--event-getid--------------------eventtype--event-geteventtype--------------------timestamp--event-gettimestamp--------------------data--event-toarray--------------------metadata--event-getmetadata----------------------------------------------------return-history---------------------catch-exception-e-------------return-----------------public-function-getpaymentstatisticswitheventsourcingpaymentstatisticsquery-query-array------------try-------------return-yield-this-queryactivity-calculatepaymentstatisticsfromeventsquery---------catch-exception-e-------------return-----------------public-function-getpaymentanalyticswitheventsourcingpaymentanalyticsquery-query-array------------try-------------return-yield-this-queryactivity-generatepaymentanalyticsfromeventsquery---------catch-exception-e-------------return-----------------private-function-filterpaymentsarray-payments-paymentsearchquery-query-array------------return-array_filterpayments-functionpayment-use-query-------------if-query-getorganizationid--payment-getorganizationid--query-getorganizationid-----------------return-false------------------------------------if-query-getstatus--payment-getstatus--query-getstatus-----------------return-false------------------------------------if-query-getminamount--payment-getamount--query-getminamount-----------------return-false------------------------------------if-query-getmaxamount--payment-getamount--query-getmaxamount-----------------return-false------------------------------------return-true----------------private-function-sortpaymentsarray-payments-paymentsearchquery-query-array------------sortfield--query-getsortfield--createdat--------sortdirection--query-getsortdirection--desc----------------usortpayments-functiona-b-use-sortfield-sortdirection-------------valuea--this-getfieldvaluea-sortfield------------valueb--this-getfieldvalueb-sortfield------------------------if-sortdirection--asc-----------------return-valuea--valueb-------------else-----------------return-valueb--valuea------------------------------------return-payments--------private-function-paginatepaymentsarray-payments-paymentsearchquery-query-array------------page--query-getpage--1--------size--query-getsize--10--------offset--page---1--size----------------return-array_slicepayments-offset-size--------private-function-getfieldvaluepayment-payment-string-field-mixed------------switch-field-------------case-amount----------------return-payment-getamount------------case-createdat----------------return-payment-getcreatedat------------case-status----------------return-payment-getstatus------------default----------------return-payment-getcreatedat-------------3-service-de-projection-avancé-service-de-projection-avec-event-sourcingphpphpnamespace-appapplicationservicetemporaluse-appdomaineventdomaineventuse-appinfrastructureeventstoretemporaleventstoreworkflowinterfaceuse-temporalclientworkflowclientinterfaceuse-psrlogloggerinterfaceclass-eventsourcingprojectionservice----private-workflowclientinterface-workflowclient----private-eventstoreworkflowinterface-eventstoreworkflow----private-loggerinterface-logger----public-function-__construct--------workflowclientinterface-workflowclient--------eventstoreworkflowinterface-eventstoreworkflow--------loggerinterface-logger-------------this-workflowclient--workflowclient--------this-eventstoreworkflow--eventstoreworkflow--------this-logger--logger--------public-function-handleeventdomainevent-event-void------------try-------------workflowoptions--this-createprojectionworkflowoptions------------------------workflow--this-workflowclient-newworkflowstub----------------eventsourcingprojectionworkflowinterfaceclass----------------workflowoptions------------------------------------workflow-updateprojectionevent------------------------this-logger-infoprojection-updated-via-temporal-with-event-sourcing-----------------eventtype--event-geteventtype----------------eventid--event-getid---------------------------------catch-exception-e-------------this-logger-errorfailed-to-update-projection-via-temporal-with-event-sourcing-----------------eventtype--event-geteventtype----------------error--e-getmessage------------------------------------throw-e----------------public-function-rebuildprojectionstring-projectiontype-void------------try-------------workflowoptions--this-createprojectionworkflowoptions------------------------workflow--this-workflowclient-newworkflowstub----------------eventsourcingprojectionworkflowinterfaceclass----------------workflowoptions------------------------------------workflow-rebuildprojectionprojectiontype------------------------this-logger-infoprojection-rebuilt-via-temporal-with-event-sourcing-----------------projectiontype--projectiontype---------------------------------catch-exception-e-------------this-logger-errorfailed-to-rebuild-projection-via-temporal-with-event-sourcing-----------------projectiontype--projectiontype----------------error--e-getmessage------------------------------------throw-e----------------private-function-createprojectionworkflowoptions-workflowoptions------------return-workflowoptionsnew-------------withworkflowidevent-sourcing-projection---uniqid-------------withworkflowexecutiontimeout600-------------withworkflowruntimeout600-------------withworkflowtasktimeout120------tests-et-validation-tests-dphpphpnamespace-apptestsintegrationtemporaluse-appworkflowcommandpaymentpaymentcommandrequestuse-appworkflowquerypaymentpaymentsearchqueryuse-appapplicationcommandbustemporaltemporaleventsourcingcommandbususe-appapplicationquerybustemporaltemporaleventsourcingquerybususe-appinfrastructuretemporaltemporalclientfactoryclass-temporaleventsourcingcqstest-extends-testcase----private-temporaleventsourcingcommandbus-commandbus----private-temporaleventsourcingquerybus-querybus----private-temporalclientfactory-temporalfactory----protected-function-setup-void------------this-temporalfactory--new-temporalclientfactorylocalhost-7233-test--------this-commandbus--new-temporaleventsourcingcommandbus------------this-temporalfactory-createclient------------this-createmockloggerinterfaceclass----------------this-querybus--new-temporaleventsourcingquerybus------------this-temporalfactory-createclient------------this-createmockcacheitempoolinterfaceclass------------this-createmockloggerinterfaceclass----------------public-function-testeventsourcingcqsseparation-void-------------exécuter-une-commande-avec-event-sourcing--------command--new-paymentcommandrequest------------create------------payment-123------------org-456------------user-789------------10000------------eur------------test-payment------------------------this-commandbus-handlecommand-----------------vérifier-avec-une-requête--------query--new-paymentsearchqueryorg-456-0-10--------result--this-querybus-handlequery----------------this-assertgreaterthan0-result-gettotal--------public-function-testeventsourcingquerycaching-void------------query--new-paymentsearchqueryorg-456-0-10-----------------première-recherche--------result1--this-querybus-handlequery-----------------deuxième-recherche-devrait-utiliser-le-cache--------result2--this-querybus-handlequery----------------this-assertequalsresult1-gettotal-result2-gettotal------performance-et-optimisation-stratégies-d-1-cache-multi-niveaux-avec-event-sourcingphppublic-function-searchpaymentswithcachepaymentsearchquery-query-paymentsearchresult-----cache-l1-mémoire----if-issetthis-memorycachequery-getcachekey---------return-this-memorycachequery-getcachekey-------------cache-l2-redis----if-cached--this-redis-getpayment_search_esquery-getcachekey---------result--paymentsearchresultfromarrayjson_decodecached-true--------this-memorycachequery-getcachekey--result--------return-result-------------temporal-avec-event-sourcing----result--this-searchpaymentswitheventsourcingquery---------mettre-en-cache----this-memorycachequery-getcachekey--result----this-redis-setexpayment_search_esquery-getcachekey-300-json_encoderesult-toarray--------return-result-2-projections-asynchrones-avec-event-sourcingphppublic-function-handleeventasyncdomainevent-event-void-----mettre-en-queue-pour-traitement-asynchrone----this-messagebus-dispatchnew-processeventsourcingprojectioncommandevent-3-monitoring-des-workflows-event-sourcingphppublic-function-getworkflowmetrics-array----return---------commandworkflows--this-getcommandworkflowmetrics--------queryworkflows--this-getqueryworkflowmetrics--------eventstoreworkflows--this-geteventstoreworkflowmetrics--------projections--this-getprojectionmetrics--------cachehitrate--this-getcachehitrate--------averageexecutiontime--this-getaverageexecutiontime------critères-d-quand-utiliser-event-sourcing--cqs-avec-temporal--avantages--performance-optimisée--séparation-claire-entre-écriture-et-lecture--audit-trail-complet--historique-immuable-de-tous-les-événements--scalabilité-maximale--possibilité-de-scaler-indépendamment--flexibilité-maximale--projections-multiples-pour-différents-besoins--résilience--workflows-robustes-avec-reprise-automatique--maintenabilité--code-plus-clair-et-organisé--inconvénients--complexité-maximale--architecture-très-complexe--infrastructure--nécessite-un-serveur-temporal--latence--overhead-pour-les-opérations-simples--expertise--équipe-très-expérimentée-requise--coût--infrastructure-très-coûteuse--courbe-d--très-élevée--critères-d--système-très-complexe--besoins-de-scalabilité-maximale--audit-trail-critique--besoin-de-traçabilité-complète--performance-critique--besoins-de-performance-maximale--projections-multiples--besoin-de-vues-différentes-des-données--équipe-très-expérimentée--maîtrise-de-temporal-event-sourcing-et-cqs--budget-important--investissement-en-complexité-justifié--infrastructure-disponible--serveur-temporal-opérationnel--temps-de-développement--suffisant-pour-implémenter-cette-complexité--votre-prochaine-étapehahahugoshortcode75s0hbhbevent-sourcing--cqs-avec-temporal-représente-l"&gt;🎯 &lt;strong&gt;Contexte et Objectifs&lt;/strong&gt;### &lt;strong&gt;La Combinaison Ultime : Event Sourcing + CQS avec Temporal&lt;/strong&gt;Nous arrivons maintenant à l&amp;rsquo;approche la plus sophistiquée pour Temporal : &lt;strong&gt;Event Sourcing + CQS&lt;/strong&gt;. Cette combinaison offre une architecture hautement performante et traçable, parfaite pour les systèmes nécessitant audit trail complet et séparation claire des responsabilités.#### &lt;strong&gt;Pourquoi cette Combinaison ?&lt;/strong&gt;- &lt;strong&gt;Performance optimisée&lt;/strong&gt; : Séparation claire entre écriture et lecture- &lt;strong&gt;Audit trail complet&lt;/strong&gt; : Historique immuable de tous les événements- &lt;strong&gt;Scalabilité&lt;/strong&gt; : Possibilité de scaler indépendamment chaque côté- &lt;strong&gt;Flexibilité&lt;/strong&gt; : Projections multiples pour différents besoins- &lt;strong&gt;Résilience&lt;/strong&gt; : Workflows robustes avec reprise automatique### &lt;strong&gt;Contexte Gyroscops&lt;/strong&gt;Dans notre écosystème &lt;strong&gt;User → Organization → Workflow → Cloud Resources → Billing&lt;/strong&gt;, Event Sourcing + CQS avec Temporal est la solution ultime pour :- &lt;strong&gt;Workflows de commande&lt;/strong&gt; : Orchestration des processus de modification avec projections- &lt;strong&gt;Workflows de requête&lt;/strong&gt; : Optimisation des lectures avec analytics avancées- &lt;strong&gt;Processus de facturation&lt;/strong&gt; : Séparation complète des écritures et lectures de facturation- &lt;strong&gt;Intégrations complexes&lt;/strong&gt; : Orchestration des intégrations avec projections multiples## 🏗️ &lt;strong&gt;Architecture Event Sourcing + CQS avec Temporal&lt;/strong&gt;### &lt;strong&gt;Séparation Complète des Responsabilités&lt;/strong&gt;#### &lt;strong&gt;Command Side (Write) avec Event Sourcing&lt;/strong&gt;- &lt;strong&gt;Command Workflows&lt;/strong&gt; : Orchestration des processus de modification- &lt;strong&gt;Command Activities&lt;/strong&gt; : Exécution des activités de modification- &lt;strong&gt;Event Handlers&lt;/strong&gt; : Gestion des événements de domaine- &lt;strong&gt;Command Bus&lt;/strong&gt; : Orchestration des commandes- &lt;strong&gt;Event Store&lt;/strong&gt; : Persistance des événements- &lt;strong&gt;Projections&lt;/strong&gt; : Mise à jour des vues matérialisées#### &lt;strong&gt;Query Side (Read) avec Event Sourcing&lt;/strong&gt;- &lt;strong&gt;Query Workflows&lt;/strong&gt; : Orchestration des processus de lecture- &lt;strong&gt;Query Activities&lt;/strong&gt; : Exécution des activités de lecture- &lt;strong&gt;Search Services&lt;/strong&gt; : Services de recherche spécialisés- &lt;strong&gt;Query Bus&lt;/strong&gt; : Orchestration des requêtes- &lt;strong&gt;Caches&lt;/strong&gt; : Optimisation des performances- &lt;strong&gt;Read Models&lt;/strong&gt; : Vues matérialisées des événements### &lt;strong&gt;Flux de Données Complet&lt;/strong&gt;&lt;code&gt;mermaidgraph TD A[Command] --&amp;gt; B[Command Bus] B --&amp;gt; C[Command Workflow] C --&amp;gt; D[Command Activities] D --&amp;gt; E[Aggregate] E --&amp;gt; F[Events] F --&amp;gt; G[Event Store Workflow] G --&amp;gt; H[Event Store Activity] H --&amp;gt; I[Event Store In-Memory] I --&amp;gt; J[Event Handlers] J --&amp;gt; K[Projections] K --&amp;gt; L[Read Models] M[Query] --&amp;gt; N[Query Bus] N --&amp;gt; O[Query Workflow] O --&amp;gt; P[Query Activities] P --&amp;gt; Q[Read Operations] Q --&amp;gt; R[Search Results] R --&amp;gt; S[Response] T[Event] --&amp;gt; U[Event Handler] U --&amp;gt; C V[Projection] --&amp;gt; W[Read Model Update] W --&amp;gt; L&lt;/code&gt;## 💻 &lt;strong&gt;Implémentation Complète&lt;/strong&gt;### &lt;strong&gt;1. Command Side avec Event Sourcing&lt;/strong&gt;#### &lt;strong&gt;Command Bus avec Event Sourcing&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\CommandBus\Temporal;use App\Domain\Command\CommandInterface;use App\Domain\Command\CommandHandlerInterface;use App\Domain\Event\DomainEvent;use Temporal\Client\WorkflowClientInterface;use Psr\Log\LoggerInterface;class TemporalEventSourcingCommandBus{ private array $handlers = []; private array $middleware = []; private WorkflowClientInterface $workflowClient; private LoggerInterface $logger; public function __construct( WorkflowClientInterface $workflowClient, LoggerInterface $logger ) { $this-&amp;gt;workflowClient = $workflowClient; $this-&amp;gt;logger = $logger; } public function registerHandler(string $commandClass, CommandHandlerInterface $handler): void { $this-&amp;gt;handlers[$commandClass] = $handler; } public function addMiddleware(callable $middleware): void { $this-&amp;gt;middleware[] = $middleware; } public function handle(CommandInterface $command): void { $commandClass = get_class($command); if (!isset($this-&amp;gt;handlers[$commandClass])) { throw new \InvalidArgumentException(&amp;quot;No handler registered for command: $commandClass&amp;quot;); } $handler = $this-&amp;gt;handlers[$commandClass]; // Exécuter les middleware $this-&amp;gt;executeMiddleware($command, function() use ($handler, $command) { $this-&amp;gt;logger-&amp;gt;info('Executing command via Temporal with Event Sourcing', [ 'command' =&amp;gt; get_class($command), 'data' =&amp;gt; $command-&amp;gt;toArray() ]); $handler-&amp;gt;handle($command); }); } private function executeMiddleware(CommandInterface $command, callable $next): void { $middleware = array_reverse($this-&amp;gt;middleware); foreach ($middleware as $mw) { $next = function() use ($mw, $command, $next) { return $mw($command, $next); }; } $next(); }}&lt;/code&gt;#### &lt;strong&gt;Command Workflow avec Event Sourcing&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Workflow\Command\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Domain\Payment\PaymentAggregate;use App\Infrastructure\EventStore\Temporal\EventStoreWorkflowInterface;#[WorkflowInterface]interface PaymentEventSourcingCommandWorkflowInterface{ #[WorkflowMethod] public function processPaymentCommandWithEventSourcing(PaymentCommandRequest $request): PaymentCommandResult; #[WorkflowMethod] public function updatePaymentCommandWithEventSourcing(PaymentUpdateCommandRequest $request): PaymentCommandResult; #[WorkflowMethod] public function deletePaymentCommandWithEventSourcing(PaymentDeleteCommandRequest $request): PaymentCommandResult;}#[ActivityInterface]interface PaymentEventSourcingCommandActivityInterface{ #[ActivityMethod] public function validatePaymentCommand(PaymentCommandRequest $request): ValidationResult; #[ActivityMethod] public function loadPaymentAggregate(string $paymentId): ?PaymentAggregate; #[ActivityMethod] public function executePaymentCommand(PaymentAggregate $payment, PaymentCommandRequest $request): array; #[ActivityMethod] public function persistEvents(string $aggregateId, array $events, int $expectedVersion): void; #[ActivityMethod] public function updateProjections(array $events): void;}class PaymentEventSourcingCommandWorkflow implements PaymentEventSourcingCommandWorkflowInterface{ private PaymentEventSourcingCommandActivityInterface $commandActivity; private EventStoreWorkflowInterface $eventStoreWorkflow; public function __construct() { $this-&amp;gt;commandActivity = Workflow::newActivityStub(PaymentEventSourcingCommandActivityInterface::class); $this-&amp;gt;eventStoreWorkflow = Workflow::newWorkflowStub(EventStoreWorkflowInterface::class); } public function processPaymentCommandWithEventSourcing(PaymentCommandRequest $request): PaymentCommandResult { try { // Validation de la commande $validation = yield $this-&amp;gt;commandActivity-&amp;gt;validatePaymentCommand($request); if (!$validation-&amp;gt;isValid()) { return new PaymentCommandResult(false, $validation-&amp;gt;getError()); } // Charger l'agrégat depuis les événements $payment = yield $this-&amp;gt;commandActivity-&amp;gt;loadPaymentAggregate($request-&amp;gt;getPaymentId()); if (!$payment) { $payment = new PaymentAggregate($request-&amp;gt;getPaymentId()); } // Exécuter la commande $events = yield $this-&amp;gt;commandActivity-&amp;gt;executePaymentCommand($payment, $request); if (empty($events)) { return new PaymentCommandResult(false, 'No events generated'); } // Persister les événements yield $this-&amp;gt;commandActivity-&amp;gt;persistEvents( $request-&amp;gt;getPaymentId(), $events, $payment-&amp;gt;getVersion() ); // Mettre à jour les projections yield $this-&amp;gt;commandActivity-&amp;gt;updateProjections($events); return new PaymentCommandResult(true, 'Payment command processed with event sourcing'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e-&amp;gt;getMessage()); } } public function updatePaymentCommandWithEventSourcing(PaymentUpdateCommandRequest $request): PaymentCommandResult { try { // Validation de la commande de mise à jour $validation = yield $this-&amp;gt;commandActivity-&amp;gt;validatePaymentCommand($request); if (!$validation-&amp;gt;isValid()) { return new PaymentCommandResult(false, $validation-&amp;gt;getError()); } // Charger l'agrégat depuis les événements $payment = yield $this-&amp;gt;commandActivity-&amp;gt;loadPaymentAggregate($request-&amp;gt;getPaymentId()); if (!$payment) { return new PaymentCommandResult(false, 'Payment not found'); } // Exécuter la commande de mise à jour $events = yield $this-&amp;gt;commandActivity-&amp;gt;executePaymentCommand($payment, $request); if (empty($events)) { return new PaymentCommandResult(false, 'No events generated'); } // Persister les événements yield $this-&amp;gt;commandActivity-&amp;gt;persistEvents( $request-&amp;gt;getPaymentId(), $events, $payment-&amp;gt;getVersion() ); // Mettre à jour les projections yield $this-&amp;gt;commandActivity-&amp;gt;updateProjections($events); return new PaymentCommandResult(true, 'Payment update command processed with event sourcing'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e-&amp;gt;getMessage()); } } public function deletePaymentCommandWithEventSourcing(PaymentDeleteCommandRequest $request): PaymentCommandResult { try { // Validation de la commande de suppression $validation = yield $this-&amp;gt;commandActivity-&amp;gt;validatePaymentCommand($request); if (!$validation-&amp;gt;isValid()) { return new PaymentCommandResult(false, $validation-&amp;gt;getError()); } // Charger l'agrégat depuis les événements $payment = yield $this-&amp;gt;commandActivity-&amp;gt;loadPaymentAggregate($request-&amp;gt;getPaymentId()); if (!$payment) { return new PaymentCommandResult(false, 'Payment not found'); } // Exécuter la commande de suppression $events = yield $this-&amp;gt;commandActivity-&amp;gt;executePaymentCommand($payment, $request); if (empty($events)) { return new PaymentCommandResult(false, 'No events generated'); } // Persister les événements yield $this-&amp;gt;commandActivity-&amp;gt;persistEvents( $request-&amp;gt;getPaymentId(), $events, $payment-&amp;gt;getVersion() ); // Mettre à jour les projections yield $this-&amp;gt;commandActivity-&amp;gt;updateProjections($events); return new PaymentCommandResult(true, 'Payment delete command processed with event sourcing'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e-&amp;gt;getMessage()); } }}&lt;/code&gt;### &lt;strong&gt;2. Query Side avec Event Sourcing&lt;/strong&gt;#### &lt;strong&gt;Query Bus avec Cache et Event Sourcing&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\QueryBus\Temporal;use App\Domain\Query\QueryInterface;use App\Domain\Query\QueryHandlerInterface;use Temporal\Client\WorkflowClientInterface;use Psr\Cache\CacheItemPoolInterface;use Psr\Log\LoggerInterface;class TemporalEventSourcingQueryBus{ private array $handlers = []; private WorkflowClientInterface $workflowClient; private CacheItemPoolInterface $cache; private LoggerInterface $logger; public function __construct( WorkflowClientInterface $workflowClient, CacheItemPoolInterface $cache, LoggerInterface $logger ) { $this-&amp;gt;workflowClient = $workflowClient; $this-&amp;gt;cache = $cache; $this-&amp;gt;logger = $logger; } public function registerHandler(string $queryClass, QueryHandlerInterface $handler): void { $this-&amp;gt;handlers[$queryClass] = $handler; } public function handle(QueryInterface $query): mixed { $queryClass = get_class($query); if (!isset($this-&amp;gt;handlers[$queryClass])) { throw new \InvalidArgumentException(&amp;quot;No handler registered for query: $queryClass&amp;quot;); } // Vérifier le cache $cacheKey = $this-&amp;gt;generateCacheKey($query); $cachedItem = $this-&amp;gt;cache-&amp;gt;getItem($cacheKey); if ($cachedItem-&amp;gt;isHit()) { $this-&amp;gt;logger-&amp;gt;debug('Query result served from cache', [ 'query' =&amp;gt; $queryClass, 'cacheKey' =&amp;gt; $cacheKey ]); return $cachedItem-&amp;gt;get(); } // Exécuter la requête via Temporal $handler = $this-&amp;gt;handlers[$queryClass]; $result = $handler-&amp;gt;handle($query); // Mettre en cache $cachedItem-&amp;gt;set($result); $cachedItem-&amp;gt;expiresAfter(300); // 5 minutes $this-&amp;gt;cache-&amp;gt;save($cachedItem); $this-&amp;gt;logger-&amp;gt;info('Query executed and cached via Temporal with Event Sourcing', [ 'query' =&amp;gt; $queryClass, 'cacheKey' =&amp;gt; $cacheKey ]); return $result; } private function generateCacheKey(QueryInterface $query): string { return 'temporal_event_sourcing_query_' . md5(serialize($query)); }}&lt;/code&gt;#### &lt;strong&gt;Query Workflow avec Event Sourcing&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Workflow\Query\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Infrastructure\EventStore\Temporal\EventStoreWorkflowInterface;#[WorkflowInterface]interface PaymentEventSourcingQueryWorkflowInterface{ #[WorkflowMethod] public function searchPaymentsWithEventSourcing(PaymentSearchQuery $query): PaymentSearchResult; #[WorkflowMethod] public function getPaymentByIdWithEventSourcing(PaymentByIdQuery $query): ?Payment; #[WorkflowMethod] public function getPaymentHistory(PaymentHistoryQuery $query): array; #[WorkflowMethod] public function getPaymentStatisticsWithEventSourcing(PaymentStatisticsQuery $query): array; #[WorkflowMethod] public function getPaymentAnalyticsWithEventSourcing(PaymentAnalyticsQuery $query): array;}#[ActivityInterface]interface PaymentEventSourcingQueryActivityInterface{ #[ActivityMethod] public function searchPaymentsInReadModel(PaymentSearchQuery $query): array; #[ActivityMethod] public function getPaymentFromReadModel(string $paymentId): ?Payment; #[ActivityMethod] public function getEventsByAggregate(string $aggregateId): array; #[ActivityMethod] public function calculatePaymentStatisticsFromEvents(PaymentStatisticsQuery $query): array; #[ActivityMethod] public function generatePaymentAnalyticsFromEvents(PaymentAnalyticsQuery $query): array;}class PaymentEventSourcingQueryWorkflow implements PaymentEventSourcingQueryWorkflowInterface{ private PaymentEventSourcingQueryActivityInterface $queryActivity; private EventStoreWorkflowInterface $eventStoreWorkflow; public function __construct() { $this-&amp;gt;queryActivity = Workflow::newActivityStub(PaymentEventSourcingQueryActivityInterface::class); $this-&amp;gt;eventStoreWorkflow = Workflow::newWorkflowStub(EventStoreWorkflowInterface::class); } public function searchPaymentsWithEventSourcing(PaymentSearchQuery $query): PaymentSearchResult { try { // Recherche dans le Read Model $payments = yield $this-&amp;gt;queryActivity-&amp;gt;searchPaymentsInReadModel($query); // Filtrage et tri $filteredPayments = $this-&amp;gt;filterPayments($payments, $query); $sortedPayments = $this-&amp;gt;sortPayments($filteredPayments, $query); // Pagination $paginatedPayments = $this-&amp;gt;paginatePayments($sortedPayments, $query); return new PaymentSearchResult( $paginatedPayments, count($filteredPayments), $query-&amp;gt;getPage(), $query-&amp;gt;getSize() ); } catch (\Exception $e) { return new PaymentSearchResult([], 0, $query-&amp;gt;getPage(), $query-&amp;gt;getSize()); } } public function getPaymentByIdWithEventSourcing(PaymentByIdQuery $query): ?Payment { try { return yield $this-&amp;gt;queryActivity-&amp;gt;getPaymentFromReadModel($query-&amp;gt;getPaymentId()); } catch (\Exception $e) { return null; } } public function getPaymentHistory(PaymentHistoryQuery $query): array { try { $events = yield $this-&amp;gt;queryActivity-&amp;gt;getEventsByAggregate($query-&amp;gt;getPaymentId()); $history = []; foreach ($events as $event) { $history[] = [ 'eventId' =&amp;gt; $event-&amp;gt;getId(), 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'timestamp' =&amp;gt; $event-&amp;gt;getTimestamp(), 'data' =&amp;gt; $event-&amp;gt;toArray(), 'metadata' =&amp;gt; $event-&amp;gt;getMetadata() ]; } return $history; } catch (\Exception $e) { return []; } } public function getPaymentStatisticsWithEventSourcing(PaymentStatisticsQuery $query): array { try { return yield $this-&amp;gt;queryActivity-&amp;gt;calculatePaymentStatisticsFromEvents($query); } catch (\Exception $e) { return []; } } public function getPaymentAnalyticsWithEventSourcing(PaymentAnalyticsQuery $query): array { try { return yield $this-&amp;gt;queryActivity-&amp;gt;generatePaymentAnalyticsFromEvents($query); } catch (\Exception $e) { return []; } } private function filterPayments(array $payments, PaymentSearchQuery $query): array { return array_filter($payments, function($payment) use ($query) { if ($query-&amp;gt;getOrganizationId() &amp;amp;&amp;amp; $payment-&amp;gt;getOrganizationId() !== $query-&amp;gt;getOrganizationId()) { return false; } if ($query-&amp;gt;getStatus() &amp;amp;&amp;amp; $payment-&amp;gt;getStatus() !== $query-&amp;gt;getStatus()) { return false; } if ($query-&amp;gt;getMinAmount() &amp;amp;&amp;amp; $payment-&amp;gt;getAmount() &amp;lt; $query-&amp;gt;getMinAmount()) { return false; } if ($query-&amp;gt;getMaxAmount() &amp;amp;&amp;amp; $payment-&amp;gt;getAmount() &amp;gt; $query-&amp;gt;getMaxAmount()) { return false; } return true; }); } private function sortPayments(array $payments, PaymentSearchQuery $query): array { $sortField = $query-&amp;gt;getSortField() ?? 'createdAt'; $sortDirection = $query-&amp;gt;getSortDirection() ?? 'desc'; usort($payments, function($a, $b) use ($sortField, $sortDirection) { $valueA = $this-&amp;gt;getFieldValue($a, $sortField); $valueB = $this-&amp;gt;getFieldValue($b, $sortField); if ($sortDirection === 'asc') { return $valueA &amp;lt;=&amp;gt; $valueB; } else { return $valueB &amp;lt;=&amp;gt; $valueA; } }); return $payments; } private function paginatePayments(array $payments, PaymentSearchQuery $query): array { $page = $query-&amp;gt;getPage() ?? 1; $size = $query-&amp;gt;getSize() ?? 10; $offset = ($page - 1) * $size; return array_slice($payments, $offset, $size); } private function getFieldValue(Payment $payment, string $field): mixed { switch ($field) { case 'amount': return $payment-&amp;gt;getAmount(); case 'createdAt': return $payment-&amp;gt;getCreatedAt(); case 'status': return $payment-&amp;gt;getStatus(); default: return $payment-&amp;gt;getCreatedAt(); } }}&lt;/code&gt;### &lt;strong&gt;3. Service de Projection Avancé&lt;/strong&gt;#### &lt;strong&gt;Service de Projection avec Event Sourcing&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Service\Temporal;use App\Domain\Event\DomainEvent;use App\Infrastructure\EventStore\Temporal\EventStoreWorkflowInterface;use Temporal\Client\WorkflowClientInterface;use Psr\Log\LoggerInterface;class EventSourcingProjectionService{ private WorkflowClientInterface $workflowClient; private EventStoreWorkflowInterface $eventStoreWorkflow; private LoggerInterface $logger; public function __construct( WorkflowClientInterface $workflowClient, EventStoreWorkflowInterface $eventStoreWorkflow, LoggerInterface $logger ) { $this-&amp;gt;workflowClient = $workflowClient; $this-&amp;gt;eventStoreWorkflow = $eventStoreWorkflow; $this-&amp;gt;logger = $logger; } public function handleEvent(DomainEvent $event): void { try { $workflowOptions = $this-&amp;gt;createProjectionWorkflowOptions(); $workflow = $this-&amp;gt;workflowClient-&amp;gt;newWorkflowStub( EventSourcingProjectionWorkflowInterface::class, $workflowOptions ); $workflow-&amp;gt;updateProjection($event); $this-&amp;gt;logger-&amp;gt;info('Projection updated via Temporal with Event Sourcing', [ 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'eventId' =&amp;gt; $event-&amp;gt;getId() ]); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to update projection via Temporal with Event Sourcing', [ 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } public function rebuildProjection(string $projectionType): void { try { $workflowOptions = $this-&amp;gt;createProjectionWorkflowOptions(); $workflow = $this-&amp;gt;workflowClient-&amp;gt;newWorkflowStub( EventSourcingProjectionWorkflowInterface::class, $workflowOptions ); $workflow-&amp;gt;rebuildProjection($projectionType); $this-&amp;gt;logger-&amp;gt;info('Projection rebuilt via Temporal with Event Sourcing', [ 'projectionType' =&amp;gt; $projectionType ]); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to rebuild projection via Temporal with Event Sourcing', [ 'projectionType' =&amp;gt; $projectionType, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } private function createProjectionWorkflowOptions(): WorkflowOptions { return WorkflowOptions::new() -&amp;gt;withWorkflowId('event-sourcing-projection-' . uniqid()) -&amp;gt;withWorkflowExecutionTimeout(600) -&amp;gt;withWorkflowRunTimeout(600) -&amp;gt;withWorkflowTaskTimeout(120); }}&lt;/code&gt;## 🧪 &lt;strong&gt;Tests et Validation&lt;/strong&gt;### &lt;strong&gt;Tests d&amp;rsquo;Intégration Event Sourcing + CQS&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Tests\Integration\Temporal;use App\Workflow\Command\Payment\PaymentCommandRequest;use App\Workflow\Query\Payment\PaymentSearchQuery;use App\Application\CommandBus\Temporal\TemporalEventSourcingCommandBus;use App\Application\QueryBus\Temporal\TemporalEventSourcingQueryBus;use App\Infrastructure\Temporal\TemporalClientFactory;class TemporalEventSourcingCqsTest extends TestCase{ private TemporalEventSourcingCommandBus $commandBus; private TemporalEventSourcingQueryBus $queryBus; private TemporalClientFactory $temporalFactory; protected function setUp(): void { $this-&amp;gt;temporalFactory = new TemporalClientFactory('localhost', 7233, 'test'); $this-&amp;gt;commandBus = new TemporalEventSourcingCommandBus( $this-&amp;gt;temporalFactory-&amp;gt;createClient(), $this-&amp;gt;createMock(LoggerInterface::class) ); $this-&amp;gt;queryBus = new TemporalEventSourcingQueryBus( $this-&amp;gt;temporalFactory-&amp;gt;createClient(), $this-&amp;gt;createMock(CacheItemPoolInterface::class), $this-&amp;gt;createMock(LoggerInterface::class) ); } public function testEventSourcingCqsSeparation(): void { // Exécuter une commande avec Event Sourcing $command = new PaymentCommandRequest( 'CREATE', 'payment-123', 'org-456', 'user-789', 100.00, 'EUR', 'Test payment' ); $this-&amp;gt;commandBus-&amp;gt;handle($command); // Vérifier avec une requête $query = new PaymentSearchQuery('org-456', 0, 10); $result = $this-&amp;gt;queryBus-&amp;gt;handle($query); $this-&amp;gt;assertGreaterThan(0, $result-&amp;gt;getTotal()); } public function testEventSourcingQueryCaching(): void { $query = new PaymentSearchQuery('org-456', 0, 10); // Première recherche $result1 = $this-&amp;gt;queryBus-&amp;gt;handle($query); // Deuxième recherche (devrait utiliser le cache) $result2 = $this-&amp;gt;queryBus-&amp;gt;handle($query); $this-&amp;gt;assertEquals($result1-&amp;gt;getTotal(), $result2-&amp;gt;getTotal()); }}&lt;/code&gt;## 📊 &lt;strong&gt;Performance et Optimisation&lt;/strong&gt;### &lt;strong&gt;Stratégies d&amp;rsquo;Optimisation Event Sourcing + CQS&lt;/strong&gt;#### &lt;strong&gt;1. Cache Multi-Niveaux avec Event Sourcing&lt;/strong&gt;&lt;code&gt;phppublic function searchPaymentsWithCache(PaymentSearchQuery $query): PaymentSearchResult{ // Cache L1: Mémoire if (isset($this-&amp;gt;memoryCache[$query-&amp;gt;getCacheKey()])) { return $this-&amp;gt;memoryCache[$query-&amp;gt;getCacheKey()]; } // Cache L2: Redis if ($cached = $this-&amp;gt;redis-&amp;gt;get(&amp;quot;payment_search_es:{$query-&amp;gt;getCacheKey()}&amp;quot;)) { $result = PaymentSearchResult::fromArray(json_decode($cached, true)); $this-&amp;gt;memoryCache[$query-&amp;gt;getCacheKey()] = $result; return $result; } // Temporal avec Event Sourcing $result = $this-&amp;gt;searchPaymentsWithEventSourcing($query); // Mettre en cache $this-&amp;gt;memoryCache[$query-&amp;gt;getCacheKey()] = $result; $this-&amp;gt;redis-&amp;gt;setex(&amp;quot;payment_search_es:{$query-&amp;gt;getCacheKey()}&amp;quot;, 300, json_encode($result-&amp;gt;toArray())); return $result;}&lt;/code&gt;#### &lt;strong&gt;2. Projections Asynchrones avec Event Sourcing&lt;/strong&gt;&lt;code&gt;phppublic function handleEventAsync(DomainEvent $event): void{ // Mettre en queue pour traitement asynchrone $this-&amp;gt;messageBus-&amp;gt;dispatch(new ProcessEventSourcingProjectionCommand($event));}&lt;/code&gt;#### &lt;strong&gt;3. Monitoring des Workflows Event Sourcing&lt;/strong&gt;&lt;code&gt;phppublic function getWorkflowMetrics(): array{ return [ 'commandWorkflows' =&amp;gt; $this-&amp;gt;getCommandWorkflowMetrics(), 'queryWorkflows' =&amp;gt; $this-&amp;gt;getQueryWorkflowMetrics(), 'eventStoreWorkflows' =&amp;gt; $this-&amp;gt;getEventStoreWorkflowMetrics(), 'projections' =&amp;gt; $this-&amp;gt;getProjectionMetrics(), 'cacheHitRate' =&amp;gt; $this-&amp;gt;getCacheHitRate(), 'averageExecutionTime' =&amp;gt; $this-&amp;gt;getAverageExecutionTime() ];}&lt;/code&gt;## 🎯 &lt;strong&gt;Critères d&amp;rsquo;Adoption&lt;/strong&gt;### &lt;strong&gt;Quand Utiliser Event Sourcing + CQS avec Temporal&lt;/strong&gt;#### &lt;strong&gt;✅ Avantages&lt;/strong&gt;- &lt;strong&gt;Performance optimisée&lt;/strong&gt; : Séparation claire entre écriture et lecture- &lt;strong&gt;Audit trail complet&lt;/strong&gt; : Historique immuable de tous les événements- &lt;strong&gt;Scalabilité maximale&lt;/strong&gt; : Possibilité de scaler indépendamment- &lt;strong&gt;Flexibilité maximale&lt;/strong&gt; : Projections multiples pour différents besoins- &lt;strong&gt;Résilience&lt;/strong&gt; : Workflows robustes avec reprise automatique- &lt;strong&gt;Maintenabilité&lt;/strong&gt; : Code plus clair et organisé#### &lt;strong&gt;❌ Inconvénients&lt;/strong&gt;- &lt;strong&gt;Complexité maximale&lt;/strong&gt; : Architecture très complexe- &lt;strong&gt;Infrastructure&lt;/strong&gt; : Nécessite un serveur Temporal- &lt;strong&gt;Latence&lt;/strong&gt; : Overhead pour les opérations simples- &lt;strong&gt;Expertise&lt;/strong&gt; : Équipe très expérimentée requise- &lt;strong&gt;Coût&lt;/strong&gt; : Infrastructure très coûteuse- &lt;strong&gt;Courbe d&amp;rsquo;apprentissage&lt;/strong&gt; : Très élevée#### &lt;strong&gt;🎯 Critères d&amp;rsquo;Adoption&lt;/strong&gt;- &lt;strong&gt;Système très complexe&lt;/strong&gt; : Besoins de scalabilité maximale- &lt;strong&gt;Audit trail critique&lt;/strong&gt; : Besoin de traçabilité complète- &lt;strong&gt;Performance critique&lt;/strong&gt; : Besoins de performance maximale- &lt;strong&gt;Projections multiples&lt;/strong&gt; : Besoin de vues différentes des données- &lt;strong&gt;Équipe très expérimentée&lt;/strong&gt; : Maîtrise de Temporal, Event Sourcing et CQS- &lt;strong&gt;Budget important&lt;/strong&gt; : Investissement en complexité justifié- &lt;strong&gt;Infrastructure disponible&lt;/strong&gt; : Serveur Temporal opérationnel- &lt;strong&gt;Temps de développement&lt;/strong&gt; : Suffisant pour implémenter cette complexité## 🚀 &lt;strong&gt;Votre Prochaine Étape&lt;/strong&gt;

&lt;div class="chapter-navigation"&gt;
 &lt;h2 class="chapter-nav-title"&gt;🎯 Votre Prochaine Étape&lt;/h2&gt;
 &lt;p class="chapter-nav-subtitle"&gt;Maintenant que vous comprenez les concepts de base et que j'ai partagé mon expérience avec Gyroscops, quel est votre contexte ?&lt;/p&gt;</description></item><item><title>Stockage Temporal - Event Sourcing + CQRS</title><link>http://localhost:1313/chapitres/stockage/temporal/chapitre-51-stockage-temporal-event-sourcing-cqrs/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/temporal/chapitre-51-stockage-temporal-event-sourcing-cqrs/</guid><description>&lt;h2 id="-contexte-et-objectifs-lnous-arrivons-maintenant-à-lapproche-la-plus-sophistiquée-et-puissante-pour-temporal--event-sourcing--cqrs-complet-cette-combinaison-représente-létat-de-lart-en-matière-darchitecture-scalable-offrant-une-solution-complète-pour-les-systèmes-les-plus-exigeants-pourquoi-cette-combinaison-ultime---séparation-totale--commandes-et-requêtes-complètement-découplées--audit-trail-complet--historique-immuable-de-tous-les-événements--scalabilité-maximale--possibilité-de-scaler-indépendamment-chaque-côté--performance-optimale--chaque-côté-optimisé-pour-son-usage--flexibilité-maximale--projections-multiples-pour-différents-besoins--résilience--workflows-robustes-avec-reprise-automatique-contexte-gyroscopsdans-notre-écosystème-user--organization--workflow--cloud-resources--billing-event-sourcing--cqrs-avec-temporal-est-la-solution-ultime-pour---workflows-de-commande--orchestration-des-processus-de-modification-avec-projections--workflows-de-requête--optimisation-des-lectures-avec-analytics-avancées--processus-de-facturation--séparation-complète-des-écritures-et-lectures-de-facturation--intégrations-complexes--orchestration-des-intégrations-avec-projections-multiples--architecture-event-sourcing--cqrs-avec-temporal-séparation-complète-des-responsabilités-command-side-write-avec-event-sourcing--command-workflows--orchestration-des-processus-de-modification--command-activities--exécution-des-activités-de-modification--event-handlers--gestion-des-événements-de-domaine--command-bus--orchestration-des-commandes--event-store--persistance-des-événements--projections--mise-à-jour-des-vues-matérialisées--command-models--modèles-optimisés-pour-les-écritures-query-side-read-avec-event-sourcing--query-workflows--orchestration-des-processus-de-lecture--query-activities--exécution-des-activités-de-lecture--search-services--services-de-recherche-spécialisés--query-bus--orchestration-des-requêtes--caches--optimisation-des-performances--read-models--vues-matérialisées-des-événements--query-models--modèles-optimisés-pour-les-lectures-flux-de-données-completmermaidgraph-td----acommand----bcommand-bus----b----ccommand-workflow----c----dcommand-activities----d----eaggregate----e----fevents----f----gevent-store-workflow----g----hevent-store-activity----h----ievent-store-in-memory----i----jevent-handlers----j----kprojections----k----lread-models--------mquery----nquery-bus----n----oquery-workflow----o----pquery-activities----p----qread-operations----q----rsearch-results----r----sresponse--------tevent----uevent-handler----u----c--------vprojection----wread-model-update----w----l--------xcommand-model----ywrite-optimization----y----e--------zquery-model----aaread-optimization----aa----q--implémentation-complète-1-command-side-avec-event-sourcing--cqrs-command-bus-avec-event-sourcing--cqrsphpphpnamespace-appapplicationcommandbustemporaluse-appdomaincommandcommandinterfaceuse-appdomaincommandcommandhandlerinterfaceuse-appdomaineventdomaineventuse-temporalclientworkflowclientinterfaceuse-psrlogloggerinterfaceclass-temporaleventsourcingcqrscommandbus----private-array-handlers------private-array-middleware------private-workflowclientinterface-workflowclient----private-loggerinterface-logger----public-function-__construct--------workflowclientinterface-workflowclient--------loggerinterface-logger-------------this-workflowclient--workflowclient--------this-logger--logger--------public-function-registerhandlerstring-commandclass-commandhandlerinterface-handler-void------------this-handlerscommandclass--handler--------public-function-addmiddlewarecallable-middleware-void------------this-middleware--middleware--------public-function-handlecommandinterface-command-void------------commandclass--get_classcommand----------------if-issetthis-handlerscommandclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-command-commandclass----------------handler--this-handlerscommandclass-----------------exécuter-les-middleware--------this-executemiddlewarecommand-function-use-handler-command-------------this-logger-infoexecuting-command-via-temporal-with-event-sourcing--cqrs-----------------command--get_classcommand----------------data--command-toarray------------------------------------handler-handlecommand----------------private-function-executemiddlewarecommandinterface-command-callable-next-void------------middleware--array_reversethis-middleware----------------foreach-middleware-as-mw-------------next--function-use-mw-command-next-----------------return-mwcommand-next------------------------------------next-----command-workflow-avec-event-sourcing--cqrsphpphpnamespace-appworkflowcommandpaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowuse-appdomainpaymentpaymentaggregateuse-appinfrastructureeventstoretemporaleventstoreworkflowinterfaceworkflowinterfaceinterface-paymenteventsourcingcqrscommandworkflowinterface----workflowmethod----public-function-processpaymentcommandwitheventsourcingcqrspaymentcommandrequest-request-paymentcommandresult--------workflowmethod----public-function-updatepaymentcommandwitheventsourcingcqrspaymentupdatecommandrequest-request-paymentcommandresult--------workflowmethod----public-function-deletepaymentcommandwitheventsourcingcqrspaymentdeletecommandrequest-request-paymentcommandresultactivityinterfaceinterface-paymenteventsourcingcqrscommandactivityinterface----activitymethod----public-function-validatepaymentcommandpaymentcommandrequest-request-validationresult--------activitymethod----public-function-loadpaymentaggregatestring-paymentid-paymentaggregate--------activitymethod----public-function-executepaymentcommandpaymentaggregate-payment-paymentcommandrequest-request-array--------activitymethod----public-function-persisteventsstring-aggregateid-array-events-int-expectedversion-void--------activitymethod----public-function-updateprojectionsarray-events-void--------activitymethod----public-function-updatecommandmodelsarray-events-voidclass-paymenteventsourcingcqrscommandworkflow-implements-paymenteventsourcingcqrscommandworkflowinterface----private-paymenteventsourcingcqrscommandactivityinterface-commandactivity----private-eventstoreworkflowinterface-eventstoreworkflow----public-function-__construct------------this-commandactivity--workflownewactivitystubpaymenteventsourcingcqrscommandactivityinterfaceclass--------this-eventstoreworkflow--workflownewworkflowstubeventstoreworkflowinterfaceclass--------public-function-processpaymentcommandwitheventsourcingcqrspaymentcommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------charger-lagrégat-depuis-les-événements------------payment--yield-this-commandactivity-loadpaymentaggregaterequest-getpaymentid------------------------if-payment-----------------payment--new-paymentaggregaterequest-getpaymentid-------------------------------------exécuter-la-commande------------events--yield-this-commandactivity-executepaymentcommandpayment-request------------------------if-emptyevents-----------------return-new-paymentcommandresultfalse-no-events-generated-------------------------------------persister-les-événements------------yield-this-commandactivity-persistevents----------------request-getpaymentid----------------events----------------payment-getversion-------------------------------------mettre-à-jour-les-projections------------yield-this-commandactivity-updateprojectionsevents-------------------------mettre-à-jour-les-modèles-de-commande------------yield-this-commandactivity-updatecommandmodelsevents------------------------return-new-paymentcommandresulttrue-payment-command-processed-with-event-sourcing--cqrs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage----------------public-function-updatepaymentcommandwitheventsourcingcqrspaymentupdatecommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande-de-mise-à-jour------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------charger-lagrégat-depuis-les-événements------------payment--yield-this-commandactivity-loadpaymentaggregaterequest-getpaymentid------------------------if-payment-----------------return-new-paymentcommandresultfalse-payment-not-found-------------------------------------exécuter-la-commande-de-mise-à-jour------------events--yield-this-commandactivity-executepaymentcommandpayment-request------------------------if-emptyevents-----------------return-new-paymentcommandresultfalse-no-events-generated-------------------------------------persister-les-événements------------yield-this-commandactivity-persistevents----------------request-getpaymentid----------------events----------------payment-getversion-------------------------------------mettre-à-jour-les-projections------------yield-this-commandactivity-updateprojectionsevents-------------------------mettre-à-jour-les-modèles-de-commande------------yield-this-commandactivity-updatecommandmodelsevents------------------------return-new-paymentcommandresulttrue-payment-update-command-processed-with-event-sourcing--cqrs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage----------------public-function-deletepaymentcommandwitheventsourcingcqrspaymentdeletecommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande-de-suppression------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------charger-lagrégat-depuis-les-événements------------payment--yield-this-commandactivity-loadpaymentaggregaterequest-getpaymentid------------------------if-payment-----------------return-new-paymentcommandresultfalse-payment-not-found-------------------------------------exécuter-la-commande-de-suppression------------events--yield-this-commandactivity-executepaymentcommandpayment-request------------------------if-emptyevents-----------------return-new-paymentcommandresultfalse-no-events-generated-------------------------------------persister-les-événements------------yield-this-commandactivity-persistevents----------------request-getpaymentid----------------events----------------payment-getversion-------------------------------------mettre-à-jour-les-projections------------yield-this-commandactivity-updateprojectionsevents-------------------------mettre-à-jour-les-modèles-de-commande------------yield-this-commandactivity-updatecommandmodelsevents------------------------return-new-paymentcommandresulttrue-payment-delete-command-processed-with-event-sourcing--cqrs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage-------------2-query-side-avec-event-sourcing--cqrs-query-bus-avec-cache-et-event-sourcing--cqrsphpphpnamespace-appapplicationquerybustemporaluse-appdomainqueryqueryinterfaceuse-appdomainqueryqueryhandlerinterfaceuse-temporalclientworkflowclientinterfaceuse-psrcachecacheitempoolinterfaceuse-psrlogloggerinterfaceclass-temporaleventsourcingcqrsquerybus----private-array-handlers------private-workflowclientinterface-workflowclient----private-cacheitempoolinterface-cache----private-loggerinterface-logger----public-function-__construct--------workflowclientinterface-workflowclient--------cacheitempoolinterface-cache--------loggerinterface-logger-------------this-workflowclient--workflowclient--------this-cache--cache--------this-logger--logger--------public-function-registerhandlerstring-queryclass-queryhandlerinterface-handler-void------------this-handlersqueryclass--handler--------public-function-handlequeryinterface-query-mixed------------queryclass--get_classquery----------------if-issetthis-handlersqueryclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-query-queryclass-----------------vérifier-le-cache--------cachekey--this-generatecachekeyquery--------cacheditem--this-cache-getitemcachekey----------------if-cacheditem-ishit-------------this-logger-debugquery-result-served-from-cache-----------------query--queryclass----------------cachekey--cachekey------------------------------------return-cacheditem-get-----------------exécuter-la-requête-via-temporal--------handler--this-handlersqueryclass--------result--handler-handlequery-----------------mettre-en-cache--------cacheditem-setresult--------cacheditem-expiresafter300--5-minutes--------this-cache-savecacheditem----------------this-logger-infoquery-executed-and-cached-via-temporal-with-event-sourcing--cqrs-------------query--queryclass------------cachekey--cachekey------------------------return-result--------private-function-generatecachekeyqueryinterface-query-string------------return-temporal_event_sourcing_cqrs_query_--md5serializequery-----query-workflow-avec-event-sourcing--cqrsphpphpnamespace-appworkflowquerypaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowuse-appinfrastructureeventstoretemporaleventstoreworkflowinterfaceworkflowinterfaceinterface-paymenteventsourcingcqrsqueryworkflowinterface----workflowmethod----public-function-searchpaymentswitheventsourcingcqrspaymentsearchquery-query-paymentsearchresult--------workflowmethod----public-function-getpaymentbyidwitheventsourcingcqrspaymentbyidquery-query-payment--------workflowmethod----public-function-getpaymenthistorywitheventsourcingcqrspaymenthistoryquery-query-array--------workflowmethod----public-function-getpaymentstatisticswitheventsourcingcqrspaymentstatisticsquery-query-array--------workflowmethod----public-function-getpaymentanalyticswitheventsourcingcqrspaymentanalyticsquery-query-array--------workflowmethod----public-function-getpaymenttimelinewitheventsourcingcqrspaymenttimelinequery-query-arrayactivityinterfaceinterface-paymenteventsourcingcqrsqueryactivityinterface----activitymethod----public-function-searchpaymentsinreadmodelpaymentsearchquery-query-array--------activitymethod----public-function-getpaymentfromreadmodelstring-paymentid-payment--------activitymethod----public-function-geteventsbyaggregatestring-aggregateid-array--------activitymethod----public-function-calculatepaymentstatisticsfromeventspaymentstatisticsquery-query-array--------activitymethod----public-function-generatepaymentanalyticsfromeventspaymentanalyticsquery-query-array--------activitymethod----public-function-geteventsbycorrelationidstring-correlationid-array--------activitymethod----public-function-updatequerymodelsarray-events-voidclass-paymenteventsourcingcqrsqueryworkflow-implements-paymenteventsourcingcqrsqueryworkflowinterface----private-paymenteventsourcingcqrsqueryactivityinterface-queryactivity----private-eventstoreworkflowinterface-eventstoreworkflow----public-function-__construct------------this-queryactivity--workflownewactivitystubpaymenteventsourcingcqrsqueryactivityinterfaceclass--------this-eventstoreworkflow--workflownewworkflowstubeventstoreworkflowinterfaceclass--------public-function-searchpaymentswitheventsourcingcqrspaymentsearchquery-query-paymentsearchresult------------try--------------recherche-dans-le-read-model------------payments--yield-this-queryactivity-searchpaymentsinreadmodelquery-------------------------filtrage-et-tri------------filteredpayments--this-filterpaymentspayments-query------------sortedpayments--this-sortpaymentsfilteredpayments-query-------------------------pagination------------paginatedpayments--this-paginatepaymentssortedpayments-query------------------------return-new-paymentsearchresult----------------paginatedpayments----------------countfilteredpayments----------------query-getpage----------------query-getsize---------------------------------catch-exception-e-------------return-new-paymentsearchresult-0-query-getpage-query-getsize----------------public-function-getpaymentbyidwitheventsourcingcqrspaymentbyidquery-query-payment------------try-------------return-yield-this-queryactivity-getpaymentfromreadmodelquery-getpaymentid---------catch-exception-e-------------return-null----------------public-function-getpaymenthistorywitheventsourcingcqrspaymenthistoryquery-query-array------------try-------------events--yield-this-queryactivity-geteventsbyaggregatequery-getpaymentid------------------------history--------------foreach-events-as-event-----------------history----------------------eventid--event-getid--------------------eventtype--event-geteventtype--------------------timestamp--event-gettimestamp--------------------data--event-toarray--------------------metadata--event-getmetadata----------------------------------------------------return-history---------------------catch-exception-e-------------return-----------------public-function-getpaymentstatisticswitheventsourcingcqrspaymentstatisticsquery-query-array------------try-------------return-yield-this-queryactivity-calculatepaymentstatisticsfromeventsquery---------catch-exception-e-------------return-----------------public-function-getpaymentanalyticswitheventsourcingcqrspaymentanalyticsquery-query-array------------try-------------return-yield-this-queryactivity-generatepaymentanalyticsfromeventsquery---------catch-exception-e-------------return-----------------public-function-getpaymenttimelinewitheventsourcingcqrspaymenttimelinequery-query-array------------try-------------events--yield-this-queryactivity-geteventsbycorrelationidquery-getcorrelationid------------------------timeline--------------foreach-events-as-event-----------------timeline----------------------eventid--event-getid--------------------aggregateid--event-getaggregateid--------------------eventtype--event-geteventtype--------------------timestamp--event-gettimestamp--------------------data--event-toarray--------------------metadata--event-getmetadata----------------------------------------------------return-timeline---------------------catch-exception-e-------------return-----------------private-function-filterpaymentsarray-payments-paymentsearchquery-query-array------------return-array_filterpayments-functionpayment-use-query-------------if-query-getorganizationid--payment-getorganizationid--query-getorganizationid-----------------return-false------------------------------------if-query-getstatus--payment-getstatus--query-getstatus-----------------return-false------------------------------------if-query-getminamount--payment-getamount--query-getminamount-----------------return-false------------------------------------if-query-getmaxamount--payment-getamount--query-getmaxamount-----------------return-false------------------------------------return-true----------------private-function-sortpaymentsarray-payments-paymentsearchquery-query-array------------sortfield--query-getsortfield--createdat--------sortdirection--query-getsortdirection--desc----------------usortpayments-functiona-b-use-sortfield-sortdirection-------------valuea--this-getfieldvaluea-sortfield------------valueb--this-getfieldvalueb-sortfield------------------------if-sortdirection--asc-----------------return-valuea--valueb-------------else-----------------return-valueb--valuea------------------------------------return-payments--------private-function-paginatepaymentsarray-payments-paymentsearchquery-query-array------------page--query-getpage--1--------size--query-getsize--10--------offset--page---1--size----------------return-array_slicepayments-offset-size--------private-function-getfieldvaluepayment-payment-string-field-mixed------------switch-field-------------case-amount----------------return-payment-getamount------------case-createdat----------------return-payment-getcreatedat------------case-status----------------return-payment-getstatus------------default----------------return-payment-getcreatedat-------------3-service-de-projection-avancé-avec-cqrs-service-de-projection-avec-event-sourcing--cqrsphpphpnamespace-appapplicationservicetemporaluse-appdomaineventdomaineventuse-appinfrastructureeventstoretemporaleventstoreworkflowinterfaceuse-temporalclientworkflowclientinterfaceuse-psrlogloggerinterfaceclass-eventsourcingcqrsprojectionservice----private-workflowclientinterface-workflowclient----private-eventstoreworkflowinterface-eventstoreworkflow----private-loggerinterface-logger----public-function-__construct--------workflowclientinterface-workflowclient--------eventstoreworkflowinterface-eventstoreworkflow--------loggerinterface-logger-------------this-workflowclient--workflowclient--------this-eventstoreworkflow--eventstoreworkflow--------this-logger--logger--------public-function-handleeventdomainevent-event-void------------try-------------workflowoptions--this-createprojectionworkflowoptions------------------------workflow--this-workflowclient-newworkflowstub----------------eventsourcingcqrsprojectionworkflowinterfaceclass----------------workflowoptions------------------------------------workflow-updateprojectionevent------------------------this-logger-infoprojection-updated-via-temporal-with-event-sourcing--cqrs-----------------eventtype--event-geteventtype----------------eventid--event-getid---------------------------------catch-exception-e-------------this-logger-errorfailed-to-update-projection-via-temporal-with-event-sourcing--cqrs-----------------eventtype--event-geteventtype----------------error--e-getmessage------------------------------------throw-e----------------public-function-rebuildprojectionstring-projectiontype-void------------try-------------workflowoptions--this-createprojectionworkflowoptions------------------------workflow--this-workflowclient-newworkflowstub----------------eventsourcingcqrsprojectionworkflowinterfaceclass----------------workflowoptions------------------------------------workflow-rebuildprojectionprojectiontype------------------------this-logger-infoprojection-rebuilt-via-temporal-with-event-sourcing--cqrs-----------------projectiontype--projectiontype---------------------------------catch-exception-e-------------this-logger-errorfailed-to-rebuild-projection-via-temporal-with-event-sourcing--cqrs-----------------projectiontype--projectiontype----------------error--e-getmessage------------------------------------throw-e----------------private-function-createprojectionworkflowoptions-workflowoptions------------return-workflowoptionsnew-------------withworkflowidevent-sourcing-cqrs-projection---uniqid-------------withworkflowexecutiontimeout600-------------withworkflowruntimeout600-------------withworkflowtasktimeout120------tests-et-validation-tests-dphpphpnamespace-apptestsintegrationtemporaluse-appworkflowcommandpaymentpaymentcommandrequestuse-appworkflowquerypaymentpaymentsearchqueryuse-appapplicationcommandbustemporaltemporaleventsourcingcqrscommandbususe-appapplicationquerybustemporaltemporaleventsourcingcqrsquerybususe-appinfrastructuretemporaltemporalclientfactoryclass-temporaleventsourcingcqrstest-extends-testcase----private-temporaleventsourcingcqrscommandbus-commandbus----private-temporaleventsourcingcqrsquerybus-querybus----private-temporalclientfactory-temporalfactory----protected-function-setup-void------------this-temporalfactory--new-temporalclientfactorylocalhost-7233-test--------this-commandbus--new-temporaleventsourcingcqrscommandbus------------this-temporalfactory-createclient------------this-createmockloggerinterfaceclass----------------this-querybus--new-temporaleventsourcingcqrsquerybus------------this-temporalfactory-createclient------------this-createmockcacheitempoolinterfaceclass------------this-createmockloggerinterfaceclass----------------public-function-testeventsourcingcqrsseparation-void-------------exécuter-une-commande-avec-event-sourcing--cqrs--------command--new-paymentcommandrequest------------create------------payment-123------------org-456------------user-789------------10000------------eur------------test-payment------------------------this-commandbus-handlecommand-----------------vérifier-avec-une-requête--------query--new-paymentsearchqueryorg-456-0-10--------result--this-querybus-handlequery----------------this-assertgreaterthan0-result-gettotal--------public-function-testeventsourcingcqrsquerycaching-void------------query--new-paymentsearchqueryorg-456-0-10-----------------première-recherche--------result1--this-querybus-handlequery-----------------deuxième-recherche-devrait-utiliser-le-cache--------result2--this-querybus-handlequery----------------this-assertequalsresult1-gettotal-result2-gettotal------performance-et-optimisation-stratégies-d-1-cache-multi-niveaux-avec-event-sourcing--cqrsphppublic-function-searchpaymentswithcachepaymentsearchquery-query-paymentsearchresult-----cache-l1-mémoire----if-issetthis-memorycachequery-getcachekey---------return-this-memorycachequery-getcachekey-------------cache-l2-redis----if-cached--this-redis-getpayment_search_es_cqrsquery-getcachekey---------result--paymentsearchresultfromarrayjson_decodecached-true--------this-memorycachequery-getcachekey--result--------return-result-------------temporal-avec-event-sourcing--cqrs----result--this-searchpaymentswitheventsourcingcqrsquery---------mettre-en-cache----this-memorycachequery-getcachekey--result----this-redis-setexpayment_search_es_cqrsquery-getcachekey-300-json_encoderesult-toarray--------return-result-2-projections-asynchrones-avec-event-sourcing--cqrsphppublic-function-handleeventasyncdomainevent-event-void-----mettre-en-queue-pour-traitement-asynchrone----this-messagebus-dispatchnew-processeventsourcingcqrsprojectioncommandevent-3-monitoring-des-workflows-event-sourcing--cqrsphppublic-function-getworkflowmetrics-array----return---------commandworkflows--this-getcommandworkflowmetrics--------queryworkflows--this-getqueryworkflowmetrics--------eventstoreworkflows--this-geteventstoreworkflowmetrics--------projections--this-getprojectionmetrics--------commandmodels--this-getcommandmodelmetrics--------querymodels--this-getquerymodelmetrics--------cachehitrate--this-getcachehitrate--------averageexecutiontime--this-getaverageexecutiontime------critères-d-quand-utiliser-event-sourcing--cqrs-avec-temporal--avantages--séparation-totale--commandes-et-requêtes-complètement-découplées--audit-trail-complet--historique-immuable-de-tous-les-événements--scalabilité-maximale--possibilité-de-scaler-indépendamment--performance-optimale--chaque-côté-optimisé-pour-son-usage--flexibilité-maximale--projections-multiples-pour-différents-besoins--résilience--workflows-robustes-avec-reprise-automatique--maintenabilité--code-plus-clair-et-organisé--inconvénients--complexité-maximale--architecture-très-complexe--infrastructure--nécessite-un-serveur-temporal--latence--overhead-pour-les-opérations-simples--expertise--équipe-très-expérimentée-requise--coût--infrastructure-très-coûteuse--courbe-d--très-élevée--temps-de-développement--très-long--critères-d--système-très-complexe--besoins-de-scalabilité-maximale--audit-trail-critique--besoin-de-traçabilité-complète--performance-critique--besoins-de-performance-maximale--projections-multiples--besoin-de-vues-différentes-des-données--équipe-très-expérimentée--maîtrise-de-temporal-event-sourcing-et-cqrs--budget-important--investissement-en-complexité-justifié--infrastructure-disponible--serveur-temporal-opérationnel--temps-de-développement--suffisant-pour-implémenter-cette-complexité--maintenance--équipe-capable-de-maintenir-cette-complexité--votre-prochaine-étapehahahugoshortcode76s0hbhbevent-sourcing--cqrs-avec-temporal-représente-l"&gt;🎯 &lt;strong&gt;Contexte et Objectifs&lt;/strong&gt;### &lt;strong&gt;L&amp;rsquo;Architecture Ultime : Event Sourcing + CQRS avec Temporal&lt;/strong&gt;Nous arrivons maintenant à l&amp;rsquo;approche la plus sophistiquée et puissante pour Temporal : &lt;strong&gt;Event Sourcing + CQRS complet&lt;/strong&gt;. Cette combinaison représente l&amp;rsquo;état de l&amp;rsquo;art en matière d&amp;rsquo;architecture scalable, offrant une solution complète pour les systèmes les plus exigeants.#### &lt;strong&gt;Pourquoi cette Combinaison Ultime ?&lt;/strong&gt;- &lt;strong&gt;Séparation totale&lt;/strong&gt; : Commandes et requêtes complètement découplées- &lt;strong&gt;Audit trail complet&lt;/strong&gt; : Historique immuable de tous les événements- &lt;strong&gt;Scalabilité maximale&lt;/strong&gt; : Possibilité de scaler indépendamment chaque côté- &lt;strong&gt;Performance optimale&lt;/strong&gt; : Chaque côté optimisé pour son usage- &lt;strong&gt;Flexibilité maximale&lt;/strong&gt; : Projections multiples pour différents besoins- &lt;strong&gt;Résilience&lt;/strong&gt; : Workflows robustes avec reprise automatique### &lt;strong&gt;Contexte Gyroscops&lt;/strong&gt;Dans notre écosystème &lt;strong&gt;User → Organization → Workflow → Cloud Resources → Billing&lt;/strong&gt;, Event Sourcing + CQRS avec Temporal est la solution ultime pour :- &lt;strong&gt;Workflows de commande&lt;/strong&gt; : Orchestration des processus de modification avec projections- &lt;strong&gt;Workflows de requête&lt;/strong&gt; : Optimisation des lectures avec analytics avancées- &lt;strong&gt;Processus de facturation&lt;/strong&gt; : Séparation complète des écritures et lectures de facturation- &lt;strong&gt;Intégrations complexes&lt;/strong&gt; : Orchestration des intégrations avec projections multiples## 🏗️ &lt;strong&gt;Architecture Event Sourcing + CQRS avec Temporal&lt;/strong&gt;### &lt;strong&gt;Séparation Complète des Responsabilités&lt;/strong&gt;#### &lt;strong&gt;Command Side (Write) avec Event Sourcing&lt;/strong&gt;- &lt;strong&gt;Command Workflows&lt;/strong&gt; : Orchestration des processus de modification- &lt;strong&gt;Command Activities&lt;/strong&gt; : Exécution des activités de modification- &lt;strong&gt;Event Handlers&lt;/strong&gt; : Gestion des événements de domaine- &lt;strong&gt;Command Bus&lt;/strong&gt; : Orchestration des commandes- &lt;strong&gt;Event Store&lt;/strong&gt; : Persistance des événements- &lt;strong&gt;Projections&lt;/strong&gt; : Mise à jour des vues matérialisées- &lt;strong&gt;Command Models&lt;/strong&gt; : Modèles optimisés pour les écritures#### &lt;strong&gt;Query Side (Read) avec Event Sourcing&lt;/strong&gt;- &lt;strong&gt;Query Workflows&lt;/strong&gt; : Orchestration des processus de lecture- &lt;strong&gt;Query Activities&lt;/strong&gt; : Exécution des activités de lecture- &lt;strong&gt;Search Services&lt;/strong&gt; : Services de recherche spécialisés- &lt;strong&gt;Query Bus&lt;/strong&gt; : Orchestration des requêtes- &lt;strong&gt;Caches&lt;/strong&gt; : Optimisation des performances- &lt;strong&gt;Read Models&lt;/strong&gt; : Vues matérialisées des événements- &lt;strong&gt;Query Models&lt;/strong&gt; : Modèles optimisés pour les lectures### &lt;strong&gt;Flux de Données Complet&lt;/strong&gt;&lt;code&gt;mermaidgraph TD A[Command] --&amp;gt; B[Command Bus] B --&amp;gt; C[Command Workflow] C --&amp;gt; D[Command Activities] D --&amp;gt; E[Aggregate] E --&amp;gt; F[Events] F --&amp;gt; G[Event Store Workflow] G --&amp;gt; H[Event Store Activity] H --&amp;gt; I[Event Store In-Memory] I --&amp;gt; J[Event Handlers] J --&amp;gt; K[Projections] K --&amp;gt; L[Read Models] M[Query] --&amp;gt; N[Query Bus] N --&amp;gt; O[Query Workflow] O --&amp;gt; P[Query Activities] P --&amp;gt; Q[Read Operations] Q --&amp;gt; R[Search Results] R --&amp;gt; S[Response] T[Event] --&amp;gt; U[Event Handler] U --&amp;gt; C V[Projection] --&amp;gt; W[Read Model Update] W --&amp;gt; L X[Command Model] --&amp;gt; Y[Write Optimization] Y --&amp;gt; E Z[Query Model] --&amp;gt; AA[Read Optimization] AA --&amp;gt; Q&lt;/code&gt;## 💻 &lt;strong&gt;Implémentation Complète&lt;/strong&gt;### &lt;strong&gt;1. Command Side avec Event Sourcing + CQRS&lt;/strong&gt;#### &lt;strong&gt;Command Bus avec Event Sourcing + CQRS&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\CommandBus\Temporal;use App\Domain\Command\CommandInterface;use App\Domain\Command\CommandHandlerInterface;use App\Domain\Event\DomainEvent;use Temporal\Client\WorkflowClientInterface;use Psr\Log\LoggerInterface;class TemporalEventSourcingCqrsCommandBus{ private array $handlers = []; private array $middleware = []; private WorkflowClientInterface $workflowClient; private LoggerInterface $logger; public function __construct( WorkflowClientInterface $workflowClient, LoggerInterface $logger ) { $this-&amp;gt;workflowClient = $workflowClient; $this-&amp;gt;logger = $logger; } public function registerHandler(string $commandClass, CommandHandlerInterface $handler): void { $this-&amp;gt;handlers[$commandClass] = $handler; } public function addMiddleware(callable $middleware): void { $this-&amp;gt;middleware[] = $middleware; } public function handle(CommandInterface $command): void { $commandClass = get_class($command); if (!isset($this-&amp;gt;handlers[$commandClass])) { throw new \InvalidArgumentException(&amp;quot;No handler registered for command: $commandClass&amp;quot;); } $handler = $this-&amp;gt;handlers[$commandClass]; // Exécuter les middleware $this-&amp;gt;executeMiddleware($command, function() use ($handler, $command) { $this-&amp;gt;logger-&amp;gt;info('Executing command via Temporal with Event Sourcing + CQRS', [ 'command' =&amp;gt; get_class($command), 'data' =&amp;gt; $command-&amp;gt;toArray() ]); $handler-&amp;gt;handle($command); }); } private function executeMiddleware(CommandInterface $command, callable $next): void { $middleware = array_reverse($this-&amp;gt;middleware); foreach ($middleware as $mw) { $next = function() use ($mw, $command, $next) { return $mw($command, $next); }; } $next(); }}&lt;/code&gt;#### &lt;strong&gt;Command Workflow avec Event Sourcing + CQRS&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Workflow\Command\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Domain\Payment\PaymentAggregate;use App\Infrastructure\EventStore\Temporal\EventStoreWorkflowInterface;#[WorkflowInterface]interface PaymentEventSourcingCqrsCommandWorkflowInterface{ #[WorkflowMethod] public function processPaymentCommandWithEventSourcingCqrs(PaymentCommandRequest $request): PaymentCommandResult; #[WorkflowMethod] public function updatePaymentCommandWithEventSourcingCqrs(PaymentUpdateCommandRequest $request): PaymentCommandResult; #[WorkflowMethod] public function deletePaymentCommandWithEventSourcingCqrs(PaymentDeleteCommandRequest $request): PaymentCommandResult;}#[ActivityInterface]interface PaymentEventSourcingCqrsCommandActivityInterface{ #[ActivityMethod] public function validatePaymentCommand(PaymentCommandRequest $request): ValidationResult; #[ActivityMethod] public function loadPaymentAggregate(string $paymentId): ?PaymentAggregate; #[ActivityMethod] public function executePaymentCommand(PaymentAggregate $payment, PaymentCommandRequest $request): array; #[ActivityMethod] public function persistEvents(string $aggregateId, array $events, int $expectedVersion): void; #[ActivityMethod] public function updateProjections(array $events): void; #[ActivityMethod] public function updateCommandModels(array $events): void;}class PaymentEventSourcingCqrsCommandWorkflow implements PaymentEventSourcingCqrsCommandWorkflowInterface{ private PaymentEventSourcingCqrsCommandActivityInterface $commandActivity; private EventStoreWorkflowInterface $eventStoreWorkflow; public function __construct() { $this-&amp;gt;commandActivity = Workflow::newActivityStub(PaymentEventSourcingCqrsCommandActivityInterface::class); $this-&amp;gt;eventStoreWorkflow = Workflow::newWorkflowStub(EventStoreWorkflowInterface::class); } public function processPaymentCommandWithEventSourcingCqrs(PaymentCommandRequest $request): PaymentCommandResult { try { // Validation de la commande $validation = yield $this-&amp;gt;commandActivity-&amp;gt;validatePaymentCommand($request); if (!$validation-&amp;gt;isValid()) { return new PaymentCommandResult(false, $validation-&amp;gt;getError()); } // Charger l'agrégat depuis les événements $payment = yield $this-&amp;gt;commandActivity-&amp;gt;loadPaymentAggregate($request-&amp;gt;getPaymentId()); if (!$payment) { $payment = new PaymentAggregate($request-&amp;gt;getPaymentId()); } // Exécuter la commande $events = yield $this-&amp;gt;commandActivity-&amp;gt;executePaymentCommand($payment, $request); if (empty($events)) { return new PaymentCommandResult(false, 'No events generated'); } // Persister les événements yield $this-&amp;gt;commandActivity-&amp;gt;persistEvents( $request-&amp;gt;getPaymentId(), $events, $payment-&amp;gt;getVersion() ); // Mettre à jour les projections yield $this-&amp;gt;commandActivity-&amp;gt;updateProjections($events); // Mettre à jour les modèles de commande yield $this-&amp;gt;commandActivity-&amp;gt;updateCommandModels($events); return new PaymentCommandResult(true, 'Payment command processed with Event Sourcing + CQRS'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e-&amp;gt;getMessage()); } } public function updatePaymentCommandWithEventSourcingCqrs(PaymentUpdateCommandRequest $request): PaymentCommandResult { try { // Validation de la commande de mise à jour $validation = yield $this-&amp;gt;commandActivity-&amp;gt;validatePaymentCommand($request); if (!$validation-&amp;gt;isValid()) { return new PaymentCommandResult(false, $validation-&amp;gt;getError()); } // Charger l'agrégat depuis les événements $payment = yield $this-&amp;gt;commandActivity-&amp;gt;loadPaymentAggregate($request-&amp;gt;getPaymentId()); if (!$payment) { return new PaymentCommandResult(false, 'Payment not found'); } // Exécuter la commande de mise à jour $events = yield $this-&amp;gt;commandActivity-&amp;gt;executePaymentCommand($payment, $request); if (empty($events)) { return new PaymentCommandResult(false, 'No events generated'); } // Persister les événements yield $this-&amp;gt;commandActivity-&amp;gt;persistEvents( $request-&amp;gt;getPaymentId(), $events, $payment-&amp;gt;getVersion() ); // Mettre à jour les projections yield $this-&amp;gt;commandActivity-&amp;gt;updateProjections($events); // Mettre à jour les modèles de commande yield $this-&amp;gt;commandActivity-&amp;gt;updateCommandModels($events); return new PaymentCommandResult(true, 'Payment update command processed with Event Sourcing + CQRS'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e-&amp;gt;getMessage()); } } public function deletePaymentCommandWithEventSourcingCqrs(PaymentDeleteCommandRequest $request): PaymentCommandResult { try { // Validation de la commande de suppression $validation = yield $this-&amp;gt;commandActivity-&amp;gt;validatePaymentCommand($request); if (!$validation-&amp;gt;isValid()) { return new PaymentCommandResult(false, $validation-&amp;gt;getError()); } // Charger l'agrégat depuis les événements $payment = yield $this-&amp;gt;commandActivity-&amp;gt;loadPaymentAggregate($request-&amp;gt;getPaymentId()); if (!$payment) { return new PaymentCommandResult(false, 'Payment not found'); } // Exécuter la commande de suppression $events = yield $this-&amp;gt;commandActivity-&amp;gt;executePaymentCommand($payment, $request); if (empty($events)) { return new PaymentCommandResult(false, 'No events generated'); } // Persister les événements yield $this-&amp;gt;commandActivity-&amp;gt;persistEvents( $request-&amp;gt;getPaymentId(), $events, $payment-&amp;gt;getVersion() ); // Mettre à jour les projections yield $this-&amp;gt;commandActivity-&amp;gt;updateProjections($events); // Mettre à jour les modèles de commande yield $this-&amp;gt;commandActivity-&amp;gt;updateCommandModels($events); return new PaymentCommandResult(true, 'Payment delete command processed with Event Sourcing + CQRS'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e-&amp;gt;getMessage()); } }}&lt;/code&gt;### &lt;strong&gt;2. Query Side avec Event Sourcing + CQRS&lt;/strong&gt;#### &lt;strong&gt;Query Bus avec Cache et Event Sourcing + CQRS&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\QueryBus\Temporal;use App\Domain\Query\QueryInterface;use App\Domain\Query\QueryHandlerInterface;use Temporal\Client\WorkflowClientInterface;use Psr\Cache\CacheItemPoolInterface;use Psr\Log\LoggerInterface;class TemporalEventSourcingCqrsQueryBus{ private array $handlers = []; private WorkflowClientInterface $workflowClient; private CacheItemPoolInterface $cache; private LoggerInterface $logger; public function __construct( WorkflowClientInterface $workflowClient, CacheItemPoolInterface $cache, LoggerInterface $logger ) { $this-&amp;gt;workflowClient = $workflowClient; $this-&amp;gt;cache = $cache; $this-&amp;gt;logger = $logger; } public function registerHandler(string $queryClass, QueryHandlerInterface $handler): void { $this-&amp;gt;handlers[$queryClass] = $handler; } public function handle(QueryInterface $query): mixed { $queryClass = get_class($query); if (!isset($this-&amp;gt;handlers[$queryClass])) { throw new \InvalidArgumentException(&amp;quot;No handler registered for query: $queryClass&amp;quot;); } // Vérifier le cache $cacheKey = $this-&amp;gt;generateCacheKey($query); $cachedItem = $this-&amp;gt;cache-&amp;gt;getItem($cacheKey); if ($cachedItem-&amp;gt;isHit()) { $this-&amp;gt;logger-&amp;gt;debug('Query result served from cache', [ 'query' =&amp;gt; $queryClass, 'cacheKey' =&amp;gt; $cacheKey ]); return $cachedItem-&amp;gt;get(); } // Exécuter la requête via Temporal $handler = $this-&amp;gt;handlers[$queryClass]; $result = $handler-&amp;gt;handle($query); // Mettre en cache $cachedItem-&amp;gt;set($result); $cachedItem-&amp;gt;expiresAfter(300); // 5 minutes $this-&amp;gt;cache-&amp;gt;save($cachedItem); $this-&amp;gt;logger-&amp;gt;info('Query executed and cached via Temporal with Event Sourcing + CQRS', [ 'query' =&amp;gt; $queryClass, 'cacheKey' =&amp;gt; $cacheKey ]); return $result; } private function generateCacheKey(QueryInterface $query): string { return 'temporal_event_sourcing_cqrs_query_' . md5(serialize($query)); }}&lt;/code&gt;#### &lt;strong&gt;Query Workflow avec Event Sourcing + CQRS&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Workflow\Query\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Infrastructure\EventStore\Temporal\EventStoreWorkflowInterface;#[WorkflowInterface]interface PaymentEventSourcingCqrsQueryWorkflowInterface{ #[WorkflowMethod] public function searchPaymentsWithEventSourcingCqrs(PaymentSearchQuery $query): PaymentSearchResult; #[WorkflowMethod] public function getPaymentByIdWithEventSourcingCqrs(PaymentByIdQuery $query): ?Payment; #[WorkflowMethod] public function getPaymentHistoryWithEventSourcingCqrs(PaymentHistoryQuery $query): array; #[WorkflowMethod] public function getPaymentStatisticsWithEventSourcingCqrs(PaymentStatisticsQuery $query): array; #[WorkflowMethod] public function getPaymentAnalyticsWithEventSourcingCqrs(PaymentAnalyticsQuery $query): array; #[WorkflowMethod] public function getPaymentTimelineWithEventSourcingCqrs(PaymentTimelineQuery $query): array;}#[ActivityInterface]interface PaymentEventSourcingCqrsQueryActivityInterface{ #[ActivityMethod] public function searchPaymentsInReadModel(PaymentSearchQuery $query): array; #[ActivityMethod] public function getPaymentFromReadModel(string $paymentId): ?Payment; #[ActivityMethod] public function getEventsByAggregate(string $aggregateId): array; #[ActivityMethod] public function calculatePaymentStatisticsFromEvents(PaymentStatisticsQuery $query): array; #[ActivityMethod] public function generatePaymentAnalyticsFromEvents(PaymentAnalyticsQuery $query): array; #[ActivityMethod] public function getEventsByCorrelationId(string $correlationId): array; #[ActivityMethod] public function updateQueryModels(array $events): void;}class PaymentEventSourcingCqrsQueryWorkflow implements PaymentEventSourcingCqrsQueryWorkflowInterface{ private PaymentEventSourcingCqrsQueryActivityInterface $queryActivity; private EventStoreWorkflowInterface $eventStoreWorkflow; public function __construct() { $this-&amp;gt;queryActivity = Workflow::newActivityStub(PaymentEventSourcingCqrsQueryActivityInterface::class); $this-&amp;gt;eventStoreWorkflow = Workflow::newWorkflowStub(EventStoreWorkflowInterface::class); } public function searchPaymentsWithEventSourcingCqrs(PaymentSearchQuery $query): PaymentSearchResult { try { // Recherche dans le Read Model $payments = yield $this-&amp;gt;queryActivity-&amp;gt;searchPaymentsInReadModel($query); // Filtrage et tri $filteredPayments = $this-&amp;gt;filterPayments($payments, $query); $sortedPayments = $this-&amp;gt;sortPayments($filteredPayments, $query); // Pagination $paginatedPayments = $this-&amp;gt;paginatePayments($sortedPayments, $query); return new PaymentSearchResult( $paginatedPayments, count($filteredPayments), $query-&amp;gt;getPage(), $query-&amp;gt;getSize() ); } catch (\Exception $e) { return new PaymentSearchResult([], 0, $query-&amp;gt;getPage(), $query-&amp;gt;getSize()); } } public function getPaymentByIdWithEventSourcingCqrs(PaymentByIdQuery $query): ?Payment { try { return yield $this-&amp;gt;queryActivity-&amp;gt;getPaymentFromReadModel($query-&amp;gt;getPaymentId()); } catch (\Exception $e) { return null; } } public function getPaymentHistoryWithEventSourcingCqrs(PaymentHistoryQuery $query): array { try { $events = yield $this-&amp;gt;queryActivity-&amp;gt;getEventsByAggregate($query-&amp;gt;getPaymentId()); $history = []; foreach ($events as $event) { $history[] = [ 'eventId' =&amp;gt; $event-&amp;gt;getId(), 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'timestamp' =&amp;gt; $event-&amp;gt;getTimestamp(), 'data' =&amp;gt; $event-&amp;gt;toArray(), 'metadata' =&amp;gt; $event-&amp;gt;getMetadata() ]; } return $history; } catch (\Exception $e) { return []; } } public function getPaymentStatisticsWithEventSourcingCqrs(PaymentStatisticsQuery $query): array { try { return yield $this-&amp;gt;queryActivity-&amp;gt;calculatePaymentStatisticsFromEvents($query); } catch (\Exception $e) { return []; } } public function getPaymentAnalyticsWithEventSourcingCqrs(PaymentAnalyticsQuery $query): array { try { return yield $this-&amp;gt;queryActivity-&amp;gt;generatePaymentAnalyticsFromEvents($query); } catch (\Exception $e) { return []; } } public function getPaymentTimelineWithEventSourcingCqrs(PaymentTimelineQuery $query): array { try { $events = yield $this-&amp;gt;queryActivity-&amp;gt;getEventsByCorrelationId($query-&amp;gt;getCorrelationId()); $timeline = []; foreach ($events as $event) { $timeline[] = [ 'eventId' =&amp;gt; $event-&amp;gt;getId(), 'aggregateId' =&amp;gt; $event-&amp;gt;getAggregateId(), 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'timestamp' =&amp;gt; $event-&amp;gt;getTimestamp(), 'data' =&amp;gt; $event-&amp;gt;toArray(), 'metadata' =&amp;gt; $event-&amp;gt;getMetadata() ]; } return $timeline; } catch (\Exception $e) { return []; } } private function filterPayments(array $payments, PaymentSearchQuery $query): array { return array_filter($payments, function($payment) use ($query) { if ($query-&amp;gt;getOrganizationId() &amp;amp;&amp;amp; $payment-&amp;gt;getOrganizationId() !== $query-&amp;gt;getOrganizationId()) { return false; } if ($query-&amp;gt;getStatus() &amp;amp;&amp;amp; $payment-&amp;gt;getStatus() !== $query-&amp;gt;getStatus()) { return false; } if ($query-&amp;gt;getMinAmount() &amp;amp;&amp;amp; $payment-&amp;gt;getAmount() &amp;lt; $query-&amp;gt;getMinAmount()) { return false; } if ($query-&amp;gt;getMaxAmount() &amp;amp;&amp;amp; $payment-&amp;gt;getAmount() &amp;gt; $query-&amp;gt;getMaxAmount()) { return false; } return true; }); } private function sortPayments(array $payments, PaymentSearchQuery $query): array { $sortField = $query-&amp;gt;getSortField() ?? 'createdAt'; $sortDirection = $query-&amp;gt;getSortDirection() ?? 'desc'; usort($payments, function($a, $b) use ($sortField, $sortDirection) { $valueA = $this-&amp;gt;getFieldValue($a, $sortField); $valueB = $this-&amp;gt;getFieldValue($b, $sortField); if ($sortDirection === 'asc') { return $valueA &amp;lt;=&amp;gt; $valueB; } else { return $valueB &amp;lt;=&amp;gt; $valueA; } }); return $payments; } private function paginatePayments(array $payments, PaymentSearchQuery $query): array { $page = $query-&amp;gt;getPage() ?? 1; $size = $query-&amp;gt;getSize() ?? 10; $offset = ($page - 1) * $size; return array_slice($payments, $offset, $size); } private function getFieldValue(Payment $payment, string $field): mixed { switch ($field) { case 'amount': return $payment-&amp;gt;getAmount(); case 'createdAt': return $payment-&amp;gt;getCreatedAt(); case 'status': return $payment-&amp;gt;getStatus(); default: return $payment-&amp;gt;getCreatedAt(); } }}&lt;/code&gt;### &lt;strong&gt;3. Service de Projection Avancé avec CQRS&lt;/strong&gt;#### &lt;strong&gt;Service de Projection avec Event Sourcing + CQRS&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Service\Temporal;use App\Domain\Event\DomainEvent;use App\Infrastructure\EventStore\Temporal\EventStoreWorkflowInterface;use Temporal\Client\WorkflowClientInterface;use Psr\Log\LoggerInterface;class EventSourcingCqrsProjectionService{ private WorkflowClientInterface $workflowClient; private EventStoreWorkflowInterface $eventStoreWorkflow; private LoggerInterface $logger; public function __construct( WorkflowClientInterface $workflowClient, EventStoreWorkflowInterface $eventStoreWorkflow, LoggerInterface $logger ) { $this-&amp;gt;workflowClient = $workflowClient; $this-&amp;gt;eventStoreWorkflow = $eventStoreWorkflow; $this-&amp;gt;logger = $logger; } public function handleEvent(DomainEvent $event): void { try { $workflowOptions = $this-&amp;gt;createProjectionWorkflowOptions(); $workflow = $this-&amp;gt;workflowClient-&amp;gt;newWorkflowStub( EventSourcingCqrsProjectionWorkflowInterface::class, $workflowOptions ); $workflow-&amp;gt;updateProjection($event); $this-&amp;gt;logger-&amp;gt;info('Projection updated via Temporal with Event Sourcing + CQRS', [ 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'eventId' =&amp;gt; $event-&amp;gt;getId() ]); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to update projection via Temporal with Event Sourcing + CQRS', [ 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } public function rebuildProjection(string $projectionType): void { try { $workflowOptions = $this-&amp;gt;createProjectionWorkflowOptions(); $workflow = $this-&amp;gt;workflowClient-&amp;gt;newWorkflowStub( EventSourcingCqrsProjectionWorkflowInterface::class, $workflowOptions ); $workflow-&amp;gt;rebuildProjection($projectionType); $this-&amp;gt;logger-&amp;gt;info('Projection rebuilt via Temporal with Event Sourcing + CQRS', [ 'projectionType' =&amp;gt; $projectionType ]); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to rebuild projection via Temporal with Event Sourcing + CQRS', [ 'projectionType' =&amp;gt; $projectionType, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } private function createProjectionWorkflowOptions(): WorkflowOptions { return WorkflowOptions::new() -&amp;gt;withWorkflowId('event-sourcing-cqrs-projection-' . uniqid()) -&amp;gt;withWorkflowExecutionTimeout(600) -&amp;gt;withWorkflowRunTimeout(600) -&amp;gt;withWorkflowTaskTimeout(120); }}&lt;/code&gt;## 🧪 &lt;strong&gt;Tests et Validation&lt;/strong&gt;### &lt;strong&gt;Tests d&amp;rsquo;Intégration Event Sourcing + CQRS&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Tests\Integration\Temporal;use App\Workflow\Command\Payment\PaymentCommandRequest;use App\Workflow\Query\Payment\PaymentSearchQuery;use App\Application\CommandBus\Temporal\TemporalEventSourcingCqrsCommandBus;use App\Application\QueryBus\Temporal\TemporalEventSourcingCqrsQueryBus;use App\Infrastructure\Temporal\TemporalClientFactory;class TemporalEventSourcingCqrsTest extends TestCase{ private TemporalEventSourcingCqrsCommandBus $commandBus; private TemporalEventSourcingCqrsQueryBus $queryBus; private TemporalClientFactory $temporalFactory; protected function setUp(): void { $this-&amp;gt;temporalFactory = new TemporalClientFactory('localhost', 7233, 'test'); $this-&amp;gt;commandBus = new TemporalEventSourcingCqrsCommandBus( $this-&amp;gt;temporalFactory-&amp;gt;createClient(), $this-&amp;gt;createMock(LoggerInterface::class) ); $this-&amp;gt;queryBus = new TemporalEventSourcingCqrsQueryBus( $this-&amp;gt;temporalFactory-&amp;gt;createClient(), $this-&amp;gt;createMock(CacheItemPoolInterface::class), $this-&amp;gt;createMock(LoggerInterface::class) ); } public function testEventSourcingCqrsSeparation(): void { // Exécuter une commande avec Event Sourcing + CQRS $command = new PaymentCommandRequest( 'CREATE', 'payment-123', 'org-456', 'user-789', 100.00, 'EUR', 'Test payment' ); $this-&amp;gt;commandBus-&amp;gt;handle($command); // Vérifier avec une requête $query = new PaymentSearchQuery('org-456', 0, 10); $result = $this-&amp;gt;queryBus-&amp;gt;handle($query); $this-&amp;gt;assertGreaterThan(0, $result-&amp;gt;getTotal()); } public function testEventSourcingCqrsQueryCaching(): void { $query = new PaymentSearchQuery('org-456', 0, 10); // Première recherche $result1 = $this-&amp;gt;queryBus-&amp;gt;handle($query); // Deuxième recherche (devrait utiliser le cache) $result2 = $this-&amp;gt;queryBus-&amp;gt;handle($query); $this-&amp;gt;assertEquals($result1-&amp;gt;getTotal(), $result2-&amp;gt;getTotal()); }}&lt;/code&gt;## 📊 &lt;strong&gt;Performance et Optimisation&lt;/strong&gt;### &lt;strong&gt;Stratégies d&amp;rsquo;Optimisation Event Sourcing + CQRS&lt;/strong&gt;#### &lt;strong&gt;1. Cache Multi-Niveaux avec Event Sourcing + CQRS&lt;/strong&gt;&lt;code&gt;phppublic function searchPaymentsWithCache(PaymentSearchQuery $query): PaymentSearchResult{ // Cache L1: Mémoire if (isset($this-&amp;gt;memoryCache[$query-&amp;gt;getCacheKey()])) { return $this-&amp;gt;memoryCache[$query-&amp;gt;getCacheKey()]; } // Cache L2: Redis if ($cached = $this-&amp;gt;redis-&amp;gt;get(&amp;quot;payment_search_es_cqrs:{$query-&amp;gt;getCacheKey()}&amp;quot;)) { $result = PaymentSearchResult::fromArray(json_decode($cached, true)); $this-&amp;gt;memoryCache[$query-&amp;gt;getCacheKey()] = $result; return $result; } // Temporal avec Event Sourcing + CQRS $result = $this-&amp;gt;searchPaymentsWithEventSourcingCqrs($query); // Mettre en cache $this-&amp;gt;memoryCache[$query-&amp;gt;getCacheKey()] = $result; $this-&amp;gt;redis-&amp;gt;setex(&amp;quot;payment_search_es_cqrs:{$query-&amp;gt;getCacheKey()}&amp;quot;, 300, json_encode($result-&amp;gt;toArray())); return $result;}&lt;/code&gt;#### &lt;strong&gt;2. Projections Asynchrones avec Event Sourcing + CQRS&lt;/strong&gt;&lt;code&gt;phppublic function handleEventAsync(DomainEvent $event): void{ // Mettre en queue pour traitement asynchrone $this-&amp;gt;messageBus-&amp;gt;dispatch(new ProcessEventSourcingCqrsProjectionCommand($event));}&lt;/code&gt;#### &lt;strong&gt;3. Monitoring des Workflows Event Sourcing + CQRS&lt;/strong&gt;&lt;code&gt;phppublic function getWorkflowMetrics(): array{ return [ 'commandWorkflows' =&amp;gt; $this-&amp;gt;getCommandWorkflowMetrics(), 'queryWorkflows' =&amp;gt; $this-&amp;gt;getQueryWorkflowMetrics(), 'eventStoreWorkflows' =&amp;gt; $this-&amp;gt;getEventStoreWorkflowMetrics(), 'projections' =&amp;gt; $this-&amp;gt;getProjectionMetrics(), 'commandModels' =&amp;gt; $this-&amp;gt;getCommandModelMetrics(), 'queryModels' =&amp;gt; $this-&amp;gt;getQueryModelMetrics(), 'cacheHitRate' =&amp;gt; $this-&amp;gt;getCacheHitRate(), 'averageExecutionTime' =&amp;gt; $this-&amp;gt;getAverageExecutionTime() ];}&lt;/code&gt;## 🎯 &lt;strong&gt;Critères d&amp;rsquo;Adoption&lt;/strong&gt;### &lt;strong&gt;Quand Utiliser Event Sourcing + CQRS avec Temporal&lt;/strong&gt;#### &lt;strong&gt;✅ Avantages&lt;/strong&gt;- &lt;strong&gt;Séparation totale&lt;/strong&gt; : Commandes et requêtes complètement découplées- &lt;strong&gt;Audit trail complet&lt;/strong&gt; : Historique immuable de tous les événements- &lt;strong&gt;Scalabilité maximale&lt;/strong&gt; : Possibilité de scaler indépendamment- &lt;strong&gt;Performance optimale&lt;/strong&gt; : Chaque côté optimisé pour son usage- &lt;strong&gt;Flexibilité maximale&lt;/strong&gt; : Projections multiples pour différents besoins- &lt;strong&gt;Résilience&lt;/strong&gt; : Workflows robustes avec reprise automatique- &lt;strong&gt;Maintenabilité&lt;/strong&gt; : Code plus clair et organisé#### &lt;strong&gt;❌ Inconvénients&lt;/strong&gt;- &lt;strong&gt;Complexité maximale&lt;/strong&gt; : Architecture très complexe- &lt;strong&gt;Infrastructure&lt;/strong&gt; : Nécessite un serveur Temporal- &lt;strong&gt;Latence&lt;/strong&gt; : Overhead pour les opérations simples- &lt;strong&gt;Expertise&lt;/strong&gt; : Équipe très expérimentée requise- &lt;strong&gt;Coût&lt;/strong&gt; : Infrastructure très coûteuse- &lt;strong&gt;Courbe d&amp;rsquo;apprentissage&lt;/strong&gt; : Très élevée- &lt;strong&gt;Temps de développement&lt;/strong&gt; : Très long#### &lt;strong&gt;🎯 Critères d&amp;rsquo;Adoption&lt;/strong&gt;- &lt;strong&gt;Système très complexe&lt;/strong&gt; : Besoins de scalabilité maximale- &lt;strong&gt;Audit trail critique&lt;/strong&gt; : Besoin de traçabilité complète- &lt;strong&gt;Performance critique&lt;/strong&gt; : Besoins de performance maximale- &lt;strong&gt;Projections multiples&lt;/strong&gt; : Besoin de vues différentes des données- &lt;strong&gt;Équipe très expérimentée&lt;/strong&gt; : Maîtrise de Temporal, Event Sourcing et CQRS- &lt;strong&gt;Budget important&lt;/strong&gt; : Investissement en complexité justifié- &lt;strong&gt;Infrastructure disponible&lt;/strong&gt; : Serveur Temporal opérationnel- &lt;strong&gt;Temps de développement&lt;/strong&gt; : Suffisant pour implémenter cette complexité- &lt;strong&gt;Maintenance&lt;/strong&gt; : Équipe capable de maintenir cette complexité## 🚀 &lt;strong&gt;Votre Prochaine Étape&lt;/strong&gt;

&lt;div class="chapter-navigation"&gt;
 &lt;h2 class="chapter-nav-title"&gt;🎯 Votre Prochaine Étape&lt;/h2&gt;
 &lt;p class="chapter-nav-subtitle"&gt;Maintenant que vous comprenez les concepts de base et que j'ai partagé mon expérience avec Gyroscops, quel est votre contexte ?&lt;/p&gt;</description></item></channel></rss>