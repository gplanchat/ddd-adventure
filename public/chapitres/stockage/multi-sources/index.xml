<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Stockage Multi-sources on DDD Adventure</title><link>http://localhost:1313/chapitres/stockage/multi-sources/</link><description>Recent content in Stockage Multi-sources on DDD Adventure</description><generator>Hugo</generator><language>fr-fr</language><lastBuildDate>Thu, 19 Dec 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/chapitres/stockage/multi-sources/index.xml" rel="self" type="application/rss+xml"/><item><title>Stockage Multi-sources - Approche Classique</title><link>http://localhost:1313/chapitres/stockage/multi-sources/chapitre-52-stockage-multi-sources-classique/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/multi-sources/chapitre-52-stockage-multi-sources-classique/</guid><description>&lt;h2 id="-contexte-et-objectifs-pourquoi-multi-sources-pour-le-stockage-le-stockage-multi-sources-offre-une-approche-hybride-qui-combine-différents-types-de-stockage-pour-optimiser-les-performances-et-répondre-aux-besoins-spécifiques-de-chaque-partie-du-système-cette-approche-est-particulièrement-adaptée-aux-systèmes-complexes-qui-nécessitent-différents-niveaux-de-performance-et-de-persistance-avantages-du-stockage-multi-sources--flexibilité--choix-du-meilleur-stockage-pour-chaque-cas-dusage--performance--optimisation-des-performances-par-type-dopération--résilience--redondance-et-failover-entre-sources--scalabilité--possibilité-de-scaler-indépendamment-chaque-source--coût--optimisation-des-coûts-selon-les-besoins-contexte-gyroscopsdans-notre-écosystème-user--organization--workflow--cloud-resources--billing-multi-sources-est-particulièrement-pertinent-pour---données-utilisateur--cache-redis--base-de-données-sql--données-de-facturation--base-de-données-sql--elasticsearch-pour-analytics--données-de-workflow--temporal--cache-in-memory--données-de-configuration--base-de-données--fichiers-de-configuration--architecture-multi-sources-classique-structure-des-sources-source-de-données-principale--base-de-données-sql--données-transactionnelles-critiques--cache-redis--données-fréquemment-accédées--elasticsearch--données-de-recherche-et-analytics--fichiers--configuration-et-logs-flux-de-donnéesmermaidgraph-td----aapplication----bmulti-source-manager----b----csource-router----c----dsql-database----c----eredis-cache----c----felasticsearch----c----gfile-system--------hread-operation----icache-check----i----jcache-hit----i----kcache-miss----k----lprimary-source----l----mupdate-cache--------nwrite-operation----oprimary-source----o----pupdate-cache----o----qupdate-search-index--implémentation-pratique-1-multi-source-manager-gestionnaire-multi-sourcesphpphpnamespace-appinfrastructuremultisourceuse-appdomainpaymentpaymentuse-appdomainpaymentpaymentrepositoryinterfaceuse-appinfrastructurerepositorysqlpaymentrepositoryuse-appinfrastructurerepositoryredispaymentrepositoryuse-appinfrastructurerepositoryelasticsearchpaymentrepositoryuse-psrlogloggerinterfaceclass-multisourcepaymentrepository-implements-paymentrepositoryinterface----private-sqlpaymentrepository-sqlrepository----private-redispaymentrepository-redisrepository----private-elasticsearchpaymentrepository-elasticsearchrepository----private-loggerinterface-logger----private-array-sourceconfig----public-function-__construct--------sqlpaymentrepository-sqlrepository--------redispaymentrepository-redisrepository--------elasticsearchpaymentrepository-elasticsearchrepository--------loggerinterface-logger--------array-sourceconfig---------------this-sqlrepository--sqlrepository--------this-redisrepository--redisrepository--------this-elasticsearchrepository--elasticsearchrepository--------this-logger--logger--------this-sourceconfig--array_merge------------read_strategy--cache_first------------write_strategy--write_through------------cache_ttl--300------------fallback_enabled--true---------sourceconfig--------public-function-savepayment-payment-void------------try-------------this-logger-infosaving-payment-via-multi-source-----------------paymentid--payment-getid----------------strategy--this-sourceconfigwrite_strategy------------------------switch-this-sourceconfigwrite_strategy-----------------case-write_through--------------------this-writethroughpayment--------------------break----------------case-write_behind--------------------this-writebehindpayment--------------------break----------------case-write_around--------------------this-writearoundpayment--------------------break----------------default--------------------this-writethroughpayment------------------------this-logger-infopayment-saved-successfully-via-multi-source-----------------paymentid--payment-getid---------------------catch-exception-e-------------this-logger-errorfailed-to-save-payment-via-multi-source-----------------paymentid--payment-getid----------------error--e-getmessage------------------------throw-e----------------public-function-findbyidstring-id-payment------------try-------------this-logger-infofinding-payment-via-multi-source-----------------paymentid--id----------------strategy--this-sourceconfigread_strategy------------------------switch-this-sourceconfigread_strategy-----------------case-cache_first--------------------return-this-cachefirstid----------------case-database_first--------------------return-this-databasefirstid----------------case-parallel--------------------return-this-parallelreadid----------------default--------------------return-this-cachefirstid---------------------catch-exception-e-------------this-logger-errorfailed-to-find-payment-via-multi-source-----------------paymentid--id----------------error--e-getmessage------------------------return-null----------------public-function-findbyorganizationstring-organizationid-array------------try-------------this-logger-infofinding-payments-by-organization-via-multi-source-----------------organizationid--organizationid-------------------------pour-les-requêtes-complexes-utiliser-elasticsearch------------payments--this-elasticsearchrepository-findbyorganizationorganizationid------------this-logger-infopayments-found-by-organization-via-multi-source-----------------organizationid--organizationid----------------count--countpayments------------------------return-payments---------catch-exception-e-------------this-logger-errorfailed-to-find-payments-by-organization-via-multi-source-----------------organizationid--organizationid----------------error--e-getmessage-------------------------fallback-vers-la-base-de-données-sql------------if-this-sourceconfigfallback_enabled-----------------return-this-sqlrepository-findbyorganizationorganizationid------------------------return-----------------public-function-deletestring-id-void------------try-------------this-logger-infodeleting-payment-via-multi-source-----------------paymentid--id-------------------------supprimer-de-toutes-les-sources------------this-sqlrepository-deleteid------------this-redisrepository-deleteid------------this-elasticsearchrepository-deleteid------------this-logger-infopayment-deleted-successfully-via-multi-source-----------------paymentid--id---------------------catch-exception-e-------------this-logger-errorfailed-to-delete-payment-via-multi-source-----------------paymentid--id----------------error--e-getmessage------------------------throw-e----------------public-function-count-int------------try--------------utiliser-la-source-la-plus-fiable-pour-le-comptage------------return-this-sqlrepository-count---------catch-exception-e-------------this-logger-errorfailed-to-count-payments-via-multi-source-----------------error--e-getmessage------------------------return-0----------------private-function-writethroughpayment-payment-void-------------écrire-dans-la-base-de-données-sql-dabord--------this-sqlrepository-savepayment-----------------puis-mettre-à-jour-le-cache--------this-redisrepository-savepayment-----------------et-lindex-de-recherche--------this-elasticsearchrepository-savepayment--------private-function-writebehindpayment-payment-void-------------écrire-dans-le-cache-dabord--------this-redisrepository-savepayment-----------------programmer-lécriture-en-base-de-données--------this-scheduledatabasewritepayment--------private-function-writearoundpayment-payment-void-------------écrire-directement-dans-la-base-de-données--------this-sqlrepository-savepayment-----------------invalider-le-cache--------this-redisrepository-deletepayment-getid--------private-function-cachefirststring-id-payment-------------vérifier-le-cache-dabord--------payment--this-redisrepository-findbyidid----------------if-payment-------------return-payment-------------------------si-pas-en-cache-chercher-en-base-de-données--------payment--this-sqlrepository-findbyidid----------------if-payment--------------mettre-en-cache------------this-redisrepository-savepayment------------------------return-payment--------private-function-databasefirststring-id-payment-------------chercher-en-base-de-données-dabord--------payment--this-sqlrepository-findbyidid----------------if-payment--------------mettre-en-cache------------this-redisrepository-savepayment------------------------return-payment--------private-function-parallelreadstring-id-payment-------------lancer-les-lectures-en-parallèle--------cachepromise--this-redisrepository-findbyidasyncid--------databasepromise--this-sqlrepository-findbyidasyncid-----------------attendre-les-résultats--------cacheresult--cachepromise-wait--------databaseresult--databasepromise-wait-----------------retourner-le-résultat-le-plus-récent--------if-cacheresult--databaseresult-------------return-cacheresult-getupdatedat--databaseresult-getupdatedat------------------cacheresult------------------databaseresult------------------------return-cacheresult--databaseresult--------private-function-scheduledatabasewritepayment-payment-void-------------implémentation-de-lécriture-différée---------ex-via-une-queue-de-messages--------this-messagequeue-pushnew-databasewritejobpayment-----2-source-router-routeur-de-sourcesphpphpnamespace-appinfrastructuremultisourceuse-appdomainpaymentpaymentuse-psrlogloggerinterfaceclass-sourcerouter----private-array-routingrules----private-loggerinterface-logger----public-function-__constructarray-routingrules---loggerinterface-logger------------this-routingrules--array_merge------------read------------------simple_queries--cache----------------complex_queries--elasticsearch----------------critical_data--database------------------------write------------------transactions--database----------------cache_updates--cache----------------search_index--elasticsearch---------------------routingrules--------this-logger--logger--------public-function-routereadstring-operation-array-criteria---string------------this-logger-debugrouting-read-operation-------------operation--operation------------criteria--criteria-----------------logique-de-routage-basée-sur-lopération--------if-this-issimplequeryoperation-criteria-------------return-cache----------------if-this-iscomplexqueryoperation-criteria-------------return-elasticsearch----------------if-this-iscriticaldataoperation-criteria-------------return-database-----------------par-défaut-utiliser-le-cache--------return-cache--------public-function-routewritestring-operation-payment-payment-array------------this-logger-debugrouting-write-operation-------------operation--operation------------paymentid--payment-getid----------------sources-----------toujours-écrire-en-base-de-données-pour-les-transactions--------if-this-istransactionoperation-------------sources--database-----------------mettre-à-jour-le-cache-pour-les-données-fréquemment-accédées--------if-this-shouldupdatecachepayment-------------sources--cache-----------------mettre-à-jour-lindex-de-recherche-pour-les-données-recherchables--------if-this-shouldupdatesearchindexpayment-------------sources--elasticsearch----------------return-sources--------private-function-issimplequerystring-operation-array-criteria-bool------------return-in_arrayoperation-findbyid-findbystatus-----------------countcriteria--2--------private-function-iscomplexquerystring-operation-array-criteria-bool------------return-in_arrayoperation-search-findbyorganization-findbydaterange----------------countcriteria--2--------private-function-iscriticaldatastring-operation-array-criteria-bool------------return-in_arrayoperation-findbyid-----------------issetcriteriacritical-----------------criteriacritical--true--------private-function-istransactionstring-operation-bool------------return-in_arrayoperation-save-update-delete--------private-function-shouldupdatecachepayment-payment-bool-------------mettre-à-jour-le-cache-pour-les-paiements-récents-ou-fréquemment-accédés--------return-payment-getcreatedat--new-datetime-1-hour----------------payment-getstatus--processing--------private-function-shouldupdatesearchindexpayment-payment-bool-------------mettre-à-jour-lindex-de-recherche-pour-les-paiements-avec-des-données-recherchables--------return-emptypayment-getdescription----------------payment-getamount--1000-----3-cache-manager-gestionnaire-de-cache-multi-sourcesphpphpnamespace-appinfrastructuremultisourceuse-appdomainpaymentpaymentuse-psrcachecacheitempoolinterfaceuse-psrlogloggerinterfaceclass-multisourcecachemanager----private-cacheitempoolinterface-cache----private-loggerinterface-logger----private-array-cacheconfig----public-function-__construct--------cacheitempoolinterface-cache--------loggerinterface-logger--------array-cacheconfig---------------this-cache--cache--------this-logger--logger--------this-cacheconfig--array_merge------------default_ttl--300------------payment_ttl--600------------search_ttl--1800------------enable_compression--true---------cacheconfig--------public-function-getstring-key-mixed------------try-------------cacheitem--this-cache-getitemkey------------------------if-cacheitem-ishit-----------------this-logger-debugcache-hit-key--key----------------return-this-unserializecacheitem-get------------------------------------this-logger-debugcache-miss-key--key------------return-null---------------------catch-exception-e-------------this-logger-errorcache-get-failed-----------------key--key----------------error--e-getmessage------------------------------------return-null----------------public-function-setstring-key-mixed-value-int-ttl--null-bool------------try-------------cacheitem--this-cache-getitemkey------------cacheitem-setthis-serializevalue------------cacheitem-expiresafterttl--this-cacheconfigdefault_ttl------------------------result--this-cache-savecacheitem------------------------this-logger-debugcache-set-----------------key--key----------------ttl--ttl--this-cacheconfigdefault_ttl----------------success--result------------------------------------return-result---------------------catch-exception-e-------------this-logger-errorcache-set-failed-----------------key--key----------------error--e-getmessage------------------------------------return-false----------------public-function-deletestring-key-bool------------try-------------result--this-cache-deleteitemkey------------------------this-logger-debugcache-delete-----------------key--key----------------success--result------------------------------------return-result---------------------catch-exception-e-------------this-logger-errorcache-delete-failed-----------------key--key----------------error--e-getmessage------------------------------------return-false----------------public-function-getpaymentstring-paymentid-payment------------key--this-generatepaymentkeypaymentid--------return-this-getkey--------public-function-setpaymentpayment-payment-int-ttl--null-bool------------key--this-generatepaymentkeypayment-getid--------ttl--ttl--this-cacheconfigpayment_ttl----------------return-this-setkey-payment-ttl--------public-function-deletepaymentstring-paymentid-bool------------key--this-generatepaymentkeypaymentid--------return-this-deletekey--------public-function-getsearchresultsstring-query-array-filters---array------------key--this-generatesearchkeyquery-filters--------return-this-getkey--------public-function-setsearchresultsstring-query-array-filters-array-results-int-ttl--null-bool------------key--this-generatesearchkeyquery-filters--------ttl--ttl--this-cacheconfigsearch_ttl----------------return-this-setkey-results-ttl--------private-function-generatepaymentkeystring-paymentid-string------------return-paymentpaymentid--------private-function-generatesearchkeystring-query-array-filters-string------------filterstring--md5serializefilters--------return-search--md5query--filterstring--------private-function-serializemixed-value-string------------if-this-cacheconfigenable_compression-------------return-gzcompressserializevalue------------------------return-serializevalue--------private-function-unserializestring-value-mixed------------if-this-cacheconfigenable_compression-------------return-unserializegzuncompressvalue------------------------return-unserializevalue------tests-et-validation-tests-dphpphpnamespace-apptestsintegrationmultisourceuse-appdomainpaymentpaymentuse-appinfrastructuremultisourcemultisourcepaymentrepositoryuse-appinfrastructurerepositorysqlpaymentrepositoryuse-appinfrastructurerepositoryredispaymentrepositoryuse-appinfrastructurerepositoryelasticsearchpaymentrepositoryclass-multisourcepaymentrepositorytest-extends-testcase----private-multisourcepaymentrepository-repository----private-sqlpaymentrepository-sqlrepository----private-redispaymentrepository-redisrepository----private-elasticsearchpaymentrepository-elasticsearchrepository----protected-function-setup-void------------this-sqlrepository--this-createmocksqlpaymentrepositoryclass--------this-redisrepository--this-createmockredispaymentrepositoryclass--------this-elasticsearchrepository--this-createmockelasticsearchpaymentrepositoryclass----------------this-repository--new-multisourcepaymentrepository------------this-sqlrepository------------this-redisrepository------------this-elasticsearchrepository------------this-createmockloggerinterfaceclass------------read_strategy--cache_first-write_strategy--write_through----------------public-function-testsavewithwritethrough-void------------payment--new-payment------------payment-123------------org-456------------user-789------------10000------------eur------------processing------------test-payment------------new-datetime------------------------this-sqlrepository-expectsthis-once-methodsave-withpayment--------this-redisrepository-expectsthis-once-methodsave-withpayment--------this-elasticsearchrepository-expectsthis-once-methodsave-withpayment----------------this-repository-savepayment--------public-function-testfindbyidwithcachefirst-void------------payment--new-payment------------payment-123------------org-456------------user-789------------10000------------eur------------processing------------test-payment------------new-datetime------------------------this-redisrepository-expectsthis-once-------------methodfindbyid-------------withpayment-123-------------willreturnpayment----------------result--this-repository-findbyidpayment-123----------------this-assertequalspayment-result--------public-function-testfindbyidwithcachemiss-void------------payment--new-payment------------payment-123------------org-456------------user-789------------10000------------eur------------processing------------test-payment------------new-datetime------------------------this-redisrepository-expectsthis-once-------------methodfindbyid-------------withpayment-123-------------willreturnnull----------------this-sqlrepository-expectsthis-once-------------methodfindbyid-------------withpayment-123-------------willreturnpayment----------------this-redisrepository-expectsthis-once-------------methodsave-------------withpayment----------------result--this-repository-findbyidpayment-123----------------this-assertequalspayment-result------performance-et-optimisation-stratégies-d-1-cache-warmingphppublic-function-warmcache-void----this-logger-infowarming-cache-for-frequently-accessed-data---------charger-les-paiements-récents----recentpayments--this-sqlrepository-findrecent100----foreach-recentpayments-as-payment---------this-redisrepository-savepayment-------------charger-les-statistiques----stats--this-sqlrepository-getstatistics----this-redisrepository-setpaymentstats-stats-3600-2-load-balancingphppublic-function-getoptimalsourcestring-operation-string----sourceloads--this-getsourceloads----optimalsource--array_keyssourceloads-minsourceloads0--------this-logger-debugselected-optimal-source---------operation--operation--------source--optimalsource--------loads--sourceloads------------return-optimalsource-3-monitoring-des-sourcesphppublic-function-getsourcemetrics-array----return---------sql--this-getsqlmetrics--------redis--this-getredismetrics--------elasticsearch--this-getelasticsearchmetrics--------overall_health--this-getoverallhealth------critères-d-quand-utiliser-multi-sources-classique--avantages--flexibilité--choix-du-meilleur-stockage-pour-chaque-cas-dusage--performance--optimisation-des-performances-par-type-dopération--résilience--redondance-et-failover-entre-sources--scalabilité--possibilité-de-scaler-indépendamment-chaque-source--coût--optimisation-des-coûts-selon-les-besoins--inconvénients--complexité--gestion-de-plusieurs-sources-de-données--cohérence--risque-dincohérence-entre-sources--maintenance--plus-de-sources-à-maintenir--expertise--équipe-expérimentée-requise--critères-d--système-complexe--besoins-de-performance-différents-par-type-dopération--données-hétérogènes--types-de-données-différents-nécessitant-différents-stockages--performance-critique--besoins-de-performance-optimale--résilience-importante--besoin-de-redondance-et-failover--équipe-expérimentée--maîtrise-de-plusieurs-technologies-de-stockage--budget-suffisant--investissement-en-infrastructure-multiple--temps-de-développement--suffisant-pour-implémenter-cette-complexité--votre-prochaine-étapehahahugoshortcode58s0hbhbmulti-sources-classique-offre-une-approche-flexible-pour-combiner-différents-types-de-stockage-parfaitement-adaptée-aux-besoins-complexes-de-gyroscops"&gt;🎯 &lt;strong&gt;Contexte et Objectifs&lt;/strong&gt;### **Pourquoi Multi-sources pour le Stockage ?**Le stockage multi-sources offre une approche hybride qui combine différents types de stockage pour optimiser les performances et répondre aux besoins spécifiques de chaque partie du système. Cette approche est particulièrement adaptée aux systèmes complexes qui nécessitent différents niveaux de performance et de persistance.#### &lt;strong&gt;Avantages du Stockage Multi-sources&lt;/strong&gt;- &lt;strong&gt;Flexibilité&lt;/strong&gt; : Choix du meilleur stockage pour chaque cas d&amp;rsquo;usage- &lt;strong&gt;Performance&lt;/strong&gt; : Optimisation des performances par type d&amp;rsquo;opération- &lt;strong&gt;Résilience&lt;/strong&gt; : Redondance et failover entre sources- &lt;strong&gt;Scalabilité&lt;/strong&gt; : Possibilité de scaler indépendamment chaque source- &lt;strong&gt;Coût&lt;/strong&gt; : Optimisation des coûts selon les besoins### &lt;strong&gt;Contexte Gyroscops&lt;/strong&gt;Dans notre écosystème &lt;strong&gt;User → Organization → Workflow → Cloud Resources → Billing&lt;/strong&gt;, Multi-sources est particulièrement pertinent pour :- &lt;strong&gt;Données utilisateur&lt;/strong&gt; : Cache Redis + Base de données SQL- &lt;strong&gt;Données de facturation&lt;/strong&gt; : Base de données SQL + ElasticSearch pour analytics- &lt;strong&gt;Données de workflow&lt;/strong&gt; : Temporal + Cache In-Memory- &lt;strong&gt;Données de configuration&lt;/strong&gt; : Base de données + Fichiers de configuration## 🏗️ &lt;strong&gt;Architecture Multi-sources Classique&lt;/strong&gt;### &lt;strong&gt;Structure des Sources&lt;/strong&gt;#### &lt;strong&gt;Source de Données Principale&lt;/strong&gt;- &lt;strong&gt;Base de données SQL&lt;/strong&gt; : Données transactionnelles critiques- &lt;strong&gt;Cache Redis&lt;/strong&gt; : Données fréquemment accédées- &lt;strong&gt;ElasticSearch&lt;/strong&gt; : Données de recherche et analytics- &lt;strong&gt;Fichiers&lt;/strong&gt; : Configuration et logs#### &lt;strong&gt;Flux de Données&lt;/strong&gt;&lt;code&gt;mermaidgraph TD A[Application] --&amp;gt; B[Multi-Source Manager] B --&amp;gt; C[Source Router] C --&amp;gt; D[SQL Database] C --&amp;gt; E[Redis Cache] C --&amp;gt; F[ElasticSearch] C --&amp;gt; G[File System] H[Read Operation] --&amp;gt; I[Cache Check] I --&amp;gt; J[Cache Hit] I --&amp;gt; K[Cache Miss] K --&amp;gt; L[Primary Source] L --&amp;gt; M[Update Cache] N[Write Operation] --&amp;gt; O[Primary Source] O --&amp;gt; P[Update Cache] O --&amp;gt; Q[Update Search Index]&lt;/code&gt;## 💻 &lt;strong&gt;Implémentation Pratique&lt;/strong&gt;### &lt;strong&gt;1. Multi-Source Manager&lt;/strong&gt;#### &lt;strong&gt;Gestionnaire Multi-Sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Infrastructure\MultiSource;use App\Domain\Payment\Payment;use App\Domain\Payment\PaymentRepositoryInterface;use App\Infrastructure\Repository\SqlPaymentRepository;use App\Infrastructure\Repository\RedisPaymentRepository;use App\Infrastructure\Repository\ElasticSearchPaymentRepository;use Psr\Log\LoggerInterface;class MultiSourcePaymentRepository implements PaymentRepositoryInterface{ private SqlPaymentRepository $sqlRepository; private RedisPaymentRepository $redisRepository; private ElasticSearchPaymentRepository $elasticSearchRepository; private LoggerInterface $logger; private array $sourceConfig; public function __construct( SqlPaymentRepository $sqlRepository, RedisPaymentRepository $redisRepository, ElasticSearchPaymentRepository $elasticSearchRepository, LoggerInterface $logger, array $sourceConfig = [] ) { $this-&amp;gt;sqlRepository = $sqlRepository; $this-&amp;gt;redisRepository = $redisRepository; $this-&amp;gt;elasticSearchRepository = $elasticSearchRepository; $this-&amp;gt;logger = $logger; $this-&amp;gt;sourceConfig = array_merge([ 'read_strategy' =&amp;gt; 'cache_first', 'write_strategy' =&amp;gt; 'write_through', 'cache_ttl' =&amp;gt; 300, 'fallback_enabled' =&amp;gt; true ], $sourceConfig); } public function save(Payment $payment): void { try { $this-&amp;gt;logger-&amp;gt;info('Saving payment via multi-source', [ 'paymentId' =&amp;gt; $payment-&amp;gt;getId(), 'strategy' =&amp;gt; $this-&amp;gt;sourceConfig['write_strategy'] ]); switch ($this-&amp;gt;sourceConfig['write_strategy']) { case 'write_through': $this-&amp;gt;writeThrough($payment); break; case 'write_behind': $this-&amp;gt;writeBehind($payment); break; case 'write_around': $this-&amp;gt;writeAround($payment); break; default: $this-&amp;gt;writeThrough($payment); } $this-&amp;gt;logger-&amp;gt;info('Payment saved successfully via multi-source', [ 'paymentId' =&amp;gt; $payment-&amp;gt;getId() ]); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to save payment via multi-source', [ 'paymentId' =&amp;gt; $payment-&amp;gt;getId(), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } public function findById(string $id): ?Payment { try { $this-&amp;gt;logger-&amp;gt;info('Finding payment via multi-source', [ 'paymentId' =&amp;gt; $id, 'strategy' =&amp;gt; $this-&amp;gt;sourceConfig['read_strategy'] ]); switch ($this-&amp;gt;sourceConfig['read_strategy']) { case 'cache_first': return $this-&amp;gt;cacheFirst($id); case 'database_first': return $this-&amp;gt;databaseFirst($id); case 'parallel': return $this-&amp;gt;parallelRead($id); default: return $this-&amp;gt;cacheFirst($id); } } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to find payment via multi-source', [ 'paymentId' =&amp;gt; $id, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); return null; } } public function findByOrganization(string $organizationId): array { try { $this-&amp;gt;logger-&amp;gt;info('Finding payments by organization via multi-source', [ 'organizationId' =&amp;gt; $organizationId ]); // Pour les requêtes complexes, utiliser ElasticSearch $payments = $this-&amp;gt;elasticSearchRepository-&amp;gt;findByOrganization($organizationId); $this-&amp;gt;logger-&amp;gt;info('Payments found by organization via multi-source', [ 'organizationId' =&amp;gt; $organizationId, 'count' =&amp;gt; count($payments) ]); return $payments; } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to find payments by organization via multi-source', [ 'organizationId' =&amp;gt; $organizationId, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); // Fallback vers la base de données SQL if ($this-&amp;gt;sourceConfig['fallback_enabled']) { return $this-&amp;gt;sqlRepository-&amp;gt;findByOrganization($organizationId); } return []; } } public function delete(string $id): void { try { $this-&amp;gt;logger-&amp;gt;info('Deleting payment via multi-source', [ 'paymentId' =&amp;gt; $id ]); // Supprimer de toutes les sources $this-&amp;gt;sqlRepository-&amp;gt;delete($id); $this-&amp;gt;redisRepository-&amp;gt;delete($id); $this-&amp;gt;elasticSearchRepository-&amp;gt;delete($id); $this-&amp;gt;logger-&amp;gt;info('Payment deleted successfully via multi-source', [ 'paymentId' =&amp;gt; $id ]); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to delete payment via multi-source', [ 'paymentId' =&amp;gt; $id, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } public function count(): int { try { // Utiliser la source la plus fiable pour le comptage return $this-&amp;gt;sqlRepository-&amp;gt;count(); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to count payments via multi-source', [ 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); return 0; } } private function writeThrough(Payment $payment): void { // Écrire dans la base de données SQL d'abord $this-&amp;gt;sqlRepository-&amp;gt;save($payment); // Puis mettre à jour le cache $this-&amp;gt;redisRepository-&amp;gt;save($payment); // Et l'index de recherche $this-&amp;gt;elasticSearchRepository-&amp;gt;save($payment); } private function writeBehind(Payment $payment): void { // Écrire dans le cache d'abord $this-&amp;gt;redisRepository-&amp;gt;save($payment); // Programmer l'écriture en base de données $this-&amp;gt;scheduleDatabaseWrite($payment); } private function writeAround(Payment $payment): void { // Écrire directement dans la base de données $this-&amp;gt;sqlRepository-&amp;gt;save($payment); // Invalider le cache $this-&amp;gt;redisRepository-&amp;gt;delete($payment-&amp;gt;getId()); } private function cacheFirst(string $id): ?Payment { // Vérifier le cache d'abord $payment = $this-&amp;gt;redisRepository-&amp;gt;findById($id); if ($payment) { return $payment; } // Si pas en cache, chercher en base de données $payment = $this-&amp;gt;sqlRepository-&amp;gt;findById($id); if ($payment) { // Mettre en cache $this-&amp;gt;redisRepository-&amp;gt;save($payment); } return $payment; } private function databaseFirst(string $id): ?Payment { // Chercher en base de données d'abord $payment = $this-&amp;gt;sqlRepository-&amp;gt;findById($id); if ($payment) { // Mettre en cache $this-&amp;gt;redisRepository-&amp;gt;save($payment); } return $payment; } private function parallelRead(string $id): ?Payment { // Lancer les lectures en parallèle $cachePromise = $this-&amp;gt;redisRepository-&amp;gt;findByIdAsync($id); $databasePromise = $this-&amp;gt;sqlRepository-&amp;gt;findByIdAsync($id); // Attendre les résultats $cacheResult = $cachePromise-&amp;gt;wait(); $databaseResult = $databasePromise-&amp;gt;wait(); // Retourner le résultat le plus récent if ($cacheResult &amp;amp;&amp;amp; $databaseResult) { return $cacheResult-&amp;gt;getUpdatedAt() &amp;gt; $databaseResult-&amp;gt;getUpdatedAt() ? $cacheResult : $databaseResult; } return $cacheResult ?: $databaseResult; } private function scheduleDatabaseWrite(Payment $payment): void { // Implémentation de l'écriture différée // Ex: via une queue de messages $this-&amp;gt;messageQueue-&amp;gt;push(new DatabaseWriteJob($payment)); }}&lt;/code&gt;### &lt;strong&gt;2. Source Router&lt;/strong&gt;#### &lt;strong&gt;Routeur de Sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Infrastructure\MultiSource;use App\Domain\Payment\Payment;use Psr\Log\LoggerInterface;class SourceRouter{ private array $routingRules; private LoggerInterface $logger; public function __construct(array $routingRules = [], LoggerInterface $logger) { $this-&amp;gt;routingRules = array_merge([ 'read' =&amp;gt; [ 'simple_queries' =&amp;gt; 'cache', 'complex_queries' =&amp;gt; 'elasticsearch', 'critical_data' =&amp;gt; 'database' ], 'write' =&amp;gt; [ 'transactions' =&amp;gt; 'database', 'cache_updates' =&amp;gt; 'cache', 'search_index' =&amp;gt; 'elasticsearch' ] ], $routingRules); $this-&amp;gt;logger = $logger; } public function routeRead(string $operation, array $criteria = []): string { $this-&amp;gt;logger-&amp;gt;debug('Routing read operation', [ 'operation' =&amp;gt; $operation, 'criteria' =&amp;gt; $criteria ]); // Logique de routage basée sur l'opération if ($this-&amp;gt;isSimpleQuery($operation, $criteria)) { return 'cache'; } if ($this-&amp;gt;isComplexQuery($operation, $criteria)) { return 'elasticsearch'; } if ($this-&amp;gt;isCriticalData($operation, $criteria)) { return 'database'; } // Par défaut, utiliser le cache return 'cache'; } public function routeWrite(string $operation, Payment $payment): array { $this-&amp;gt;logger-&amp;gt;debug('Routing write operation', [ 'operation' =&amp;gt; $operation, 'paymentId' =&amp;gt; $payment-&amp;gt;getId() ]); $sources = []; // Toujours écrire en base de données pour les transactions if ($this-&amp;gt;isTransaction($operation)) { $sources[] = 'database'; } // Mettre à jour le cache pour les données fréquemment accédées if ($this-&amp;gt;shouldUpdateCache($payment)) { $sources[] = 'cache'; } // Mettre à jour l'index de recherche pour les données recherchables if ($this-&amp;gt;shouldUpdateSearchIndex($payment)) { $sources[] = 'elasticsearch'; } return $sources; } private function isSimpleQuery(string $operation, array $criteria): bool { return in_array($operation, ['findById', 'findByStatus']) &amp;amp;&amp;amp; count($criteria) &amp;lt;= 2; } private function isComplexQuery(string $operation, array $criteria): bool { return in_array($operation, ['search', 'findByOrganization', 'findByDateRange']) || count($criteria) &amp;gt; 2; } private function isCriticalData(string $operation, array $criteria): bool { return in_array($operation, ['findById']) &amp;amp;&amp;amp; isset($criteria['critical']) &amp;amp;&amp;amp; $criteria['critical'] === true; } private function isTransaction(string $operation): bool { return in_array($operation, ['save', 'update', 'delete']); } private function shouldUpdateCache(Payment $payment): bool { // Mettre à jour le cache pour les paiements récents ou fréquemment accédés return $payment-&amp;gt;getCreatedAt() &amp;gt; new \DateTime('-1 hour') || $payment-&amp;gt;getStatus() === 'processing'; } private function shouldUpdateSearchIndex(Payment $payment): bool { // Mettre à jour l'index de recherche pour les paiements avec des données recherchables return !empty($payment-&amp;gt;getDescription()) || $payment-&amp;gt;getAmount() &amp;gt; 1000; }}&lt;/code&gt;### &lt;strong&gt;3. Cache Manager&lt;/strong&gt;#### &lt;strong&gt;Gestionnaire de Cache Multi-Sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Infrastructure\MultiSource;use App\Domain\Payment\Payment;use Psr\Cache\CacheItemPoolInterface;use Psr\Log\LoggerInterface;class MultiSourceCacheManager{ private CacheItemPoolInterface $cache; private LoggerInterface $logger; private array $cacheConfig; public function __construct( CacheItemPoolInterface $cache, LoggerInterface $logger, array $cacheConfig = [] ) { $this-&amp;gt;cache = $cache; $this-&amp;gt;logger = $logger; $this-&amp;gt;cacheConfig = array_merge([ 'default_ttl' =&amp;gt; 300, 'payment_ttl' =&amp;gt; 600, 'search_ttl' =&amp;gt; 1800, 'enable_compression' =&amp;gt; true ], $cacheConfig); } public function get(string $key): mixed { try { $cacheItem = $this-&amp;gt;cache-&amp;gt;getItem($key); if ($cacheItem-&amp;gt;isHit()) { $this-&amp;gt;logger-&amp;gt;debug('Cache hit', ['key' =&amp;gt; $key]); return $this-&amp;gt;unserialize($cacheItem-&amp;gt;get()); } $this-&amp;gt;logger-&amp;gt;debug('Cache miss', ['key' =&amp;gt; $key]); return null; } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Cache get failed', [ 'key' =&amp;gt; $key, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); return null; } } public function set(string $key, mixed $value, int $ttl = null): bool { try { $cacheItem = $this-&amp;gt;cache-&amp;gt;getItem($key); $cacheItem-&amp;gt;set($this-&amp;gt;serialize($value)); $cacheItem-&amp;gt;expiresAfter($ttl ?? $this-&amp;gt;cacheConfig['default_ttl']); $result = $this-&amp;gt;cache-&amp;gt;save($cacheItem); $this-&amp;gt;logger-&amp;gt;debug('Cache set', [ 'key' =&amp;gt; $key, 'ttl' =&amp;gt; $ttl ?? $this-&amp;gt;cacheConfig['default_ttl'], 'success' =&amp;gt; $result ]); return $result; } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Cache set failed', [ 'key' =&amp;gt; $key, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); return false; } } public function delete(string $key): bool { try { $result = $this-&amp;gt;cache-&amp;gt;deleteItem($key); $this-&amp;gt;logger-&amp;gt;debug('Cache delete', [ 'key' =&amp;gt; $key, 'success' =&amp;gt; $result ]); return $result; } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Cache delete failed', [ 'key' =&amp;gt; $key, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); return false; } } public function getPayment(string $paymentId): ?Payment { $key = $this-&amp;gt;generatePaymentKey($paymentId); return $this-&amp;gt;get($key); } public function setPayment(Payment $payment, int $ttl = null): bool { $key = $this-&amp;gt;generatePaymentKey($payment-&amp;gt;getId()); $ttl = $ttl ?? $this-&amp;gt;cacheConfig['payment_ttl']; return $this-&amp;gt;set($key, $payment, $ttl); } public function deletePayment(string $paymentId): bool { $key = $this-&amp;gt;generatePaymentKey($paymentId); return $this-&amp;gt;delete($key); } public function getSearchResults(string $query, array $filters = []): ?array { $key = $this-&amp;gt;generateSearchKey($query, $filters); return $this-&amp;gt;get($key); } public function setSearchResults(string $query, array $filters, array $results, int $ttl = null): bool { $key = $this-&amp;gt;generateSearchKey($query, $filters); $ttl = $ttl ?? $this-&amp;gt;cacheConfig['search_ttl']; return $this-&amp;gt;set($key, $results, $ttl); } private function generatePaymentKey(string $paymentId): string { return &amp;quot;payment:{$paymentId}&amp;quot;; } private function generateSearchKey(string $query, array $filters): string { $filterString = md5(serialize($filters)); return &amp;quot;search:&amp;quot; . md5($query) . &amp;quot;:{$filterString}&amp;quot;; } private function serialize(mixed $value): string { if ($this-&amp;gt;cacheConfig['enable_compression']) { return gzcompress(serialize($value)); } return serialize($value); } private function unserialize(string $value): mixed { if ($this-&amp;gt;cacheConfig['enable_compression']) { return unserialize(gzuncompress($value)); } return unserialize($value); }}&lt;/code&gt;## 🧪 &lt;strong&gt;Tests et Validation&lt;/strong&gt;### &lt;strong&gt;Tests d&amp;rsquo;Intégration Multi-Sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Tests\Integration\MultiSource;use App\Domain\Payment\Payment;use App\Infrastructure\MultiSource\MultiSourcePaymentRepository;use App\Infrastructure\Repository\SqlPaymentRepository;use App\Infrastructure\Repository\RedisPaymentRepository;use App\Infrastructure\Repository\ElasticSearchPaymentRepository;class MultiSourcePaymentRepositoryTest extends TestCase{ private MultiSourcePaymentRepository $repository; private SqlPaymentRepository $sqlRepository; private RedisPaymentRepository $redisRepository; private ElasticSearchPaymentRepository $elasticSearchRepository; protected function setUp(): void { $this-&amp;gt;sqlRepository = $this-&amp;gt;createMock(SqlPaymentRepository::class); $this-&amp;gt;redisRepository = $this-&amp;gt;createMock(RedisPaymentRepository::class); $this-&amp;gt;elasticSearchRepository = $this-&amp;gt;createMock(ElasticSearchPaymentRepository::class); $this-&amp;gt;repository = new MultiSourcePaymentRepository( $this-&amp;gt;sqlRepository, $this-&amp;gt;redisRepository, $this-&amp;gt;elasticSearchRepository, $this-&amp;gt;createMock(LoggerInterface::class), ['read_strategy' =&amp;gt; 'cache_first', 'write_strategy' =&amp;gt; 'write_through'] ); } public function testSaveWithWriteThrough(): void { $payment = new Payment( 'payment-123', 'org-456', 'user-789', 100.00, 'EUR', 'processing', 'Test payment', new \DateTime() ); $this-&amp;gt;sqlRepository-&amp;gt;expects($this-&amp;gt;once())-&amp;gt;method('save')-&amp;gt;with($payment); $this-&amp;gt;redisRepository-&amp;gt;expects($this-&amp;gt;once())-&amp;gt;method('save')-&amp;gt;with($payment); $this-&amp;gt;elasticSearchRepository-&amp;gt;expects($this-&amp;gt;once())-&amp;gt;method('save')-&amp;gt;with($payment); $this-&amp;gt;repository-&amp;gt;save($payment); } public function testFindByIdWithCacheFirst(): void { $payment = new Payment( 'payment-123', 'org-456', 'user-789', 100.00, 'EUR', 'processing', 'Test payment', new \DateTime() ); $this-&amp;gt;redisRepository-&amp;gt;expects($this-&amp;gt;once()) -&amp;gt;method('findById') -&amp;gt;with('payment-123') -&amp;gt;willReturn($payment); $result = $this-&amp;gt;repository-&amp;gt;findById('payment-123'); $this-&amp;gt;assertEquals($payment, $result); } public function testFindByIdWithCacheMiss(): void { $payment = new Payment( 'payment-123', 'org-456', 'user-789', 100.00, 'EUR', 'processing', 'Test payment', new \DateTime() ); $this-&amp;gt;redisRepository-&amp;gt;expects($this-&amp;gt;once()) -&amp;gt;method('findById') -&amp;gt;with('payment-123') -&amp;gt;willReturn(null); $this-&amp;gt;sqlRepository-&amp;gt;expects($this-&amp;gt;once()) -&amp;gt;method('findById') -&amp;gt;with('payment-123') -&amp;gt;willReturn($payment); $this-&amp;gt;redisRepository-&amp;gt;expects($this-&amp;gt;once()) -&amp;gt;method('save') -&amp;gt;with($payment); $result = $this-&amp;gt;repository-&amp;gt;findById('payment-123'); $this-&amp;gt;assertEquals($payment, $result); }}&lt;/code&gt;## 📊 &lt;strong&gt;Performance et Optimisation&lt;/strong&gt;### &lt;strong&gt;Stratégies d&amp;rsquo;Optimisation Multi-Sources&lt;/strong&gt;#### &lt;strong&gt;1. Cache Warming&lt;/strong&gt;&lt;code&gt;phppublic function warmCache(): void{ $this-&amp;gt;logger-&amp;gt;info('Warming cache for frequently accessed data'); // Charger les paiements récents $recentPayments = $this-&amp;gt;sqlRepository-&amp;gt;findRecent(100); foreach ($recentPayments as $payment) { $this-&amp;gt;redisRepository-&amp;gt;save($payment); } // Charger les statistiques $stats = $this-&amp;gt;sqlRepository-&amp;gt;getStatistics(); $this-&amp;gt;redisRepository-&amp;gt;set('payment:stats', $stats, 3600);}&lt;/code&gt;#### &lt;strong&gt;2. Load Balancing&lt;/strong&gt;&lt;code&gt;phppublic function getOptimalSource(string $operation): string{ $sourceLoads = $this-&amp;gt;getSourceLoads(); $optimalSource = array_keys($sourceLoads, min($sourceLoads))[0]; $this-&amp;gt;logger-&amp;gt;debug('Selected optimal source', [ 'operation' =&amp;gt; $operation, 'source' =&amp;gt; $optimalSource, 'loads' =&amp;gt; $sourceLoads ]); return $optimalSource;}&lt;/code&gt;#### &lt;strong&gt;3. Monitoring des Sources&lt;/strong&gt;&lt;code&gt;phppublic function getSourceMetrics(): array{ return [ 'sql' =&amp;gt; $this-&amp;gt;getSqlMetrics(), 'redis' =&amp;gt; $this-&amp;gt;getRedisMetrics(), 'elasticsearch' =&amp;gt; $this-&amp;gt;getElasticSearchMetrics(), 'overall_health' =&amp;gt; $this-&amp;gt;getOverallHealth() ];}&lt;/code&gt;## 🎯 &lt;strong&gt;Critères d&amp;rsquo;Adoption&lt;/strong&gt;### &lt;strong&gt;Quand Utiliser Multi-sources Classique&lt;/strong&gt;#### &lt;strong&gt;✅ Avantages&lt;/strong&gt;- &lt;strong&gt;Flexibilité&lt;/strong&gt; : Choix du meilleur stockage pour chaque cas d&amp;rsquo;usage- &lt;strong&gt;Performance&lt;/strong&gt; : Optimisation des performances par type d&amp;rsquo;opération- &lt;strong&gt;Résilience&lt;/strong&gt; : Redondance et failover entre sources- &lt;strong&gt;Scalabilité&lt;/strong&gt; : Possibilité de scaler indépendamment chaque source- &lt;strong&gt;Coût&lt;/strong&gt; : Optimisation des coûts selon les besoins#### &lt;strong&gt;❌ Inconvénients&lt;/strong&gt;- &lt;strong&gt;Complexité&lt;/strong&gt; : Gestion de plusieurs sources de données- &lt;strong&gt;Cohérence&lt;/strong&gt; : Risque d&amp;rsquo;incohérence entre sources- &lt;strong&gt;Maintenance&lt;/strong&gt; : Plus de sources à maintenir- &lt;strong&gt;Expertise&lt;/strong&gt; : Équipe expérimentée requise#### &lt;strong&gt;🎯 Critères d&amp;rsquo;Adoption&lt;/strong&gt;- &lt;strong&gt;Système complexe&lt;/strong&gt; : Besoins de performance différents par type d&amp;rsquo;opération- &lt;strong&gt;Données hétérogènes&lt;/strong&gt; : Types de données différents nécessitant différents stockages- &lt;strong&gt;Performance critique&lt;/strong&gt; : Besoins de performance optimale- &lt;strong&gt;Résilience importante&lt;/strong&gt; : Besoin de redondance et failover- &lt;strong&gt;Équipe expérimentée&lt;/strong&gt; : Maîtrise de plusieurs technologies de stockage- &lt;strong&gt;Budget suffisant&lt;/strong&gt; : Investissement en infrastructure multiple- &lt;strong&gt;Temps de développement&lt;/strong&gt; : Suffisant pour implémenter cette complexité## 🚀 &lt;strong&gt;Votre Prochaine Étape&lt;/strong&gt;

&lt;div class="chapter-navigation"&gt;
 &lt;h2 class="chapter-nav-title"&gt;🎯 Votre Prochaine Étape&lt;/h2&gt;
 &lt;p class="chapter-nav-subtitle"&gt;Maintenant que vous comprenez les concepts de base et que j'ai partagé mon expérience avec Gyroscops, quel est votre contexte ?&lt;/p&gt;</description></item><item><title>Stockage Multi-sources - CQS</title><link>http://localhost:1313/chapitres/stockage/multi-sources/chapitre-53-stockage-multi-sources-cqs/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/multi-sources/chapitre-53-stockage-multi-sources-cqs/</guid><description>&lt;h2 id="-contexte-et-objectifs-pourquoi-cqs-avec-multi-sources-la-combinaison-cqs-avec-multi-sources-offre-une-architecture-optimisée-qui-sépare-clairement-les-responsabilités-tout-en-exploitant-les-avantages-de-différents-types-de-stockage-cette-approche-permet-doptimiser-chaque-côté-commandes-et-requêtes-avec-les-sources-les-plus-appropriées-avantages-de-cqs-avec-multi-sources--performance-optimisée--séparation-claire-entre-écriture-et-lecture--flexibilité-maximale--choix-du-meilleur-stockage-pour-chaque-opération--scalabilité--possibilité-de-scaler-indépendamment-chaque-côté--résilience--redondance-et-failover-entre-sources--maintenabilité--code-plus-clair-et-organisé-contexte-gyroscopsdans-notre-écosystème-user--organization--workflow--cloud-resources--billing-cqs-avec-multi-sources-est-particulièrement-pertinent-pour---workflows-de-commande--orchestration-des-processus-de-modification-avec-sources-optimisées--workflows-de-requête--optimisation-des-lectures-avec-sources-spécialisées--processus-de-facturation--séparation-des-écritures-et-lectures-de-facturation--intégrations-complexes--orchestration-des-intégrations-avec-sources-multiples--architecture-cqs-avec-multi-sources-séparation-des-responsabilités-côté-commande-write-avec-multi-sources--command-workflows--orchestration-des-processus-de-modification--command-activities--exécution-des-activités-de-modification--event-handlers--gestion-des-événements-de-domaine--command-bus--orchestration-des-commandes--write-sources--sources-optimisées-pour-les-écritures--command-models--modèles-optimisés-pour-les-écritures-côté-requête-read-avec-multi-sources--query-workflows--orchestration-des-processus-de-lecture--query-activities--exécution-des-activités-de-lecture--search-services--services-de-recherche-spécialisés--query-bus--orchestration-des-requêtes--read-sources--sources-optimisées-pour-les-lectures--query-models--modèles-optimisés-pour-les-lectures-flux-de-donnéesmermaidgraph-td----acommand----bcommand-bus----b----ccommand-workflow----c----dcommand-activities----d----ewrite-sources----e----fsql-database----e----gredis-cache----e----hfile-system--------iquery----jquery-bus----j----kquery-workflow----k----lquery-activities----l----mread-sources----m----nelasticsearch----m----oredis-cache----m----psql-database--------qevent----revent-handler----r----c--------sprojection----tread-model-update----t----m--implémentation-pratique-1-command-side-avec-multi-sources-command-bus-avec-multi-sourcesphpphpnamespace-appapplicationcommandbusmultisourceuse-appdomaincommandcommandinterfaceuse-appdomaincommandcommandhandlerinterfaceuse-appinfrastructuremultisourcesourcerouteruse-psrlogloggerinterfaceclass-multisourcecommandbus----private-array-handlers------private-array-middleware------private-sourcerouter-sourcerouter----private-loggerinterface-logger----public-function-__construct--------sourcerouter-sourcerouter--------loggerinterface-logger-------------this-sourcerouter--sourcerouter--------this-logger--logger--------public-function-registerhandlerstring-commandclass-commandhandlerinterface-handler-void------------this-handlerscommandclass--handler--------public-function-addmiddlewarecallable-middleware-void------------this-middleware--middleware--------public-function-handlecommandinterface-command-void------------commandclass--get_classcommand----------------if-issetthis-handlerscommandclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-command-commandclass----------------handler--this-handlerscommandclass-----------------exécuter-les-middleware--------this-executemiddlewarecommand-function-use-handler-command-------------this-logger-infoexecuting-command-via-multi-source-cqs-----------------command--get_classcommand----------------data--command-toarray------------------------------------handler-handlecommand----------------private-function-executemiddlewarecommandinterface-command-callable-next-void------------middleware--array_reversethis-middleware----------------foreach-middleware-as-mw-------------next--function-use-mw-command-next-----------------return-mwcommand-next------------------------------------next-----command-workflow-avec-multi-sourcesphpphpnamespace-appworkflowcommandpaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowuse-appinfrastructuremultisourcesourcerouterworkflowinterfaceinterface-paymentmultisourcecommandworkflowinterface----workflowmethod----public-function-processpaymentcommandwithmultisourcepaymentcommandrequest-request-paymentcommandresult--------workflowmethod----public-function-updatepaymentcommandwithmultisourcepaymentupdatecommandrequest-request-paymentcommandresult--------workflowmethod----public-function-deletepaymentcommandwithmultisourcepaymentdeletecommandrequest-request-paymentcommandresultactivityinterfaceinterface-paymentmultisourcecommandactivityinterface----activitymethod----public-function-validatepaymentcommandpaymentcommandrequest-request-validationresult--------activitymethod----public-function-executepaymentcommandpaymentcommandrequest-request-commandexecutionresult--------activitymethod----public-function-persisttowritesourcespayment-payment-array-sources-void--------activitymethod----public-function-updatecommandmodelspayment-payment-voidclass-paymentmultisourcecommandworkflow-implements-paymentmultisourcecommandworkflowinterface----private-paymentmultisourcecommandactivityinterface-commandactivity----private-sourcerouter-sourcerouter----public-function-__construct------------this-commandactivity--workflownewactivitystubpaymentmultisourcecommandactivityinterfaceclass--------this-sourcerouter--workflownewactivitystubsourcerouterclass--------public-function-processpaymentcommandwithmultisourcepaymentcommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------exécution-de-la-commande------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------déterminer-les-sources-décriture-optimales------------writesources--yield-this-sourcerouter-routewritesave-execution-getpayment-------------------------persister-dans-les-sources-décriture------------yield-this-commandactivity-persisttowritesourcesexecution-getpayment-writesources-------------------------mettre-à-jour-les-modèles-de-commande------------yield-this-commandactivity-updatecommandmodelsexecution-getpayment------------------------return-new-paymentcommandresulttrue-payment-command-processed-with-multi-source-cqs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage----------------public-function-updatepaymentcommandwithmultisourcepaymentupdatecommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande-de-mise-à-jour------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------exécution-de-la-mise-à-jour------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------déterminer-les-sources-décriture-optimales------------writesources--yield-this-sourcerouter-routewriteupdate-execution-getpayment-------------------------persister-dans-les-sources-décriture------------yield-this-commandactivity-persisttowritesourcesexecution-getpayment-writesources-------------------------mettre-à-jour-les-modèles-de-commande------------yield-this-commandactivity-updatecommandmodelsexecution-getpayment------------------------return-new-paymentcommandresulttrue-payment-update-command-processed-with-multi-source-cqs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage----------------public-function-deletepaymentcommandwithmultisourcepaymentdeletecommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande-de-suppression------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------exécution-de-la-suppression------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------déterminer-les-sources-décriture-optimales------------writesources--yield-this-sourcerouter-routewritedelete-execution-getpayment-------------------------persister-dans-les-sources-décriture------------yield-this-commandactivity-persisttowritesourcesexecution-getpayment-writesources-------------------------mettre-à-jour-les-modèles-de-commande------------yield-this-commandactivity-updatecommandmodelsexecution-getpayment------------------------return-new-paymentcommandresulttrue-payment-delete-command-processed-with-multi-source-cqs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage-------------2-query-side-avec-multi-sources-query-bus-avec-cache-et-multi-sourcesphpphpnamespace-appapplicationquerybusmultisourceuse-appdomainqueryqueryinterfaceuse-appdomainqueryqueryhandlerinterfaceuse-appinfrastructuremultisourcesourcerouteruse-appinfrastructuremultisourcemultisourcecachemanageruse-psrlogloggerinterfaceclass-multisourcequerybus----private-array-handlers------private-sourcerouter-sourcerouter----private-multisourcecachemanager-cachemanager----private-loggerinterface-logger----public-function-__construct--------sourcerouter-sourcerouter--------multisourcecachemanager-cachemanager--------loggerinterface-logger-------------this-sourcerouter--sourcerouter--------this-cachemanager--cachemanager--------this-logger--logger--------public-function-registerhandlerstring-queryclass-queryhandlerinterface-handler-void------------this-handlersqueryclass--handler--------public-function-handlequeryinterface-query-mixed------------queryclass--get_classquery----------------if-issetthis-handlersqueryclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-query-queryclass-----------------vérifier-le-cache--------cachekey--this-generatecachekeyquery--------cachedresult--this-cachemanager-getcachekey----------------if-cachedresult--null-------------this-logger-debugquery-result-served-from-cache-----------------query--queryclass----------------cachekey--cachekey------------------------------------return-cachedresult-----------------déterminer-la-source-de-lecture-optimale--------readsource--this-sourcerouter-routereadqueryclass-query-toarray-----------------exécuter-la-requête-via-la-source-optimale--------handler--this-handlersqueryclass--------result--handler-handlequery-readsource-----------------mettre-en-cache--------this-cachemanager-setcachekey-result-300----------------this-logger-infoquery-executed-and-cached-via-multi-source-cqs-------------query--queryclass------------source--readsource------------cachekey--cachekey------------------------return-result--------private-function-generatecachekeyqueryinterface-query-string------------return-multi_source_query_--md5serializequery-----query-workflow-avec-multi-sourcesphpphpnamespace-appworkflowquerypaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowuse-appinfrastructuremultisourcesourcerouterworkflowinterfaceinterface-paymentmultisourcequeryworkflowinterface----workflowmethod----public-function-searchpaymentswithmultisourcepaymentsearchquery-query-paymentsearchresult--------workflowmethod----public-function-getpaymentbyidwithmultisourcepaymentbyidquery-query-payment--------workflowmethod----public-function-getpaymentstatisticswithmultisourcepaymentstatisticsquery-query-array--------workflowmethod----public-function-getpaymentanalyticswithmultisourcepaymentanalyticsquery-query-arrayactivityinterfaceinterface-paymentmultisourcequeryactivityinterface----activitymethod----public-function-searchpaymentsinsourcepaymentsearchquery-query-string-source-array--------activitymethod----public-function-getpaymentfromsourcestring-paymentid-string-source-payment--------activitymethod----public-function-calculatepaymentstatisticsinsourcepaymentstatisticsquery-query-string-source-array--------activitymethod----public-function-generatepaymentanalyticsinsourcepaymentanalyticsquery-query-string-source-arrayclass-paymentmultisourcequeryworkflow-implements-paymentmultisourcequeryworkflowinterface----private-paymentmultisourcequeryactivityinterface-queryactivity----private-sourcerouter-sourcerouter----public-function-__construct------------this-queryactivity--workflownewactivitystubpaymentmultisourcequeryactivityinterfaceclass--------this-sourcerouter--workflownewactivitystubsourcerouterclass--------public-function-searchpaymentswithmultisourcepaymentsearchquery-query-paymentsearchresult------------try--------------déterminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadsearch-query-toarray-------------------------recherche-dans-la-source-optimale------------payments--yield-this-queryactivity-searchpaymentsinsourcequery-readsource-------------------------filtrage-et-tri------------filteredpayments--this-filterpaymentspayments-query------------sortedpayments--this-sortpaymentsfilteredpayments-query-------------------------pagination------------paginatedpayments--this-paginatepaymentssortedpayments-query------------------------return-new-paymentsearchresult----------------paginatedpayments----------------countfilteredpayments----------------query-getpage----------------query-getsize---------------------------------catch-exception-e-------------return-new-paymentsearchresult-0-query-getpage-query-getsize----------------public-function-getpaymentbyidwithmultisourcepaymentbyidquery-query-payment------------try--------------déterminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadfindbyid-id--query-getpaymentid------------------------return-yield-this-queryactivity-getpaymentfromsourcequery-getpaymentid-readsource---------catch-exception-e-------------return-null----------------public-function-getpaymentstatisticswithmultisourcepaymentstatisticsquery-query-array------------try--------------déterminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadstatistics-query-toarray------------------------return-yield-this-queryactivity-calculatepaymentstatisticsinsourcequery-readsource---------catch-exception-e-------------return-----------------public-function-getpaymentanalyticswithmultisourcepaymentanalyticsquery-query-array------------try--------------déterminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadanalytics-query-toarray------------------------return-yield-this-queryactivity-generatepaymentanalyticsinsourcequery-readsource---------catch-exception-e-------------return-----------------private-function-filterpaymentsarray-payments-paymentsearchquery-query-array------------return-array_filterpayments-functionpayment-use-query-------------if-query-getorganizationid--payment-getorganizationid--query-getorganizationid-----------------return-false------------------------------------if-query-getstatus--payment-getstatus--query-getstatus-----------------return-false------------------------------------if-query-getminamount--payment-getamount--query-getminamount-----------------return-false------------------------------------if-query-getmaxamount--payment-getamount--query-getmaxamount-----------------return-false------------------------------------return-true----------------private-function-sortpaymentsarray-payments-paymentsearchquery-query-array------------sortfield--query-getsortfield--createdat--------sortdirection--query-getsortdirection--desc----------------usortpayments-functiona-b-use-sortfield-sortdirection-------------valuea--this-getfieldvaluea-sortfield------------valueb--this-getfieldvalueb-sortfield------------------------if-sortdirection--asc-----------------return-valuea--valueb-------------else-----------------return-valueb--valuea------------------------------------return-payments--------private-function-paginatepaymentsarray-payments-paymentsearchquery-query-array------------page--query-getpage--1--------size--query-getsize--10--------offset--page---1--size----------------return-array_slicepayments-offset-size--------private-function-getfieldvaluepayment-payment-string-field-mixed------------switch-field-------------case-amount----------------return-payment-getamount------------case-createdat----------------return-payment-getcreatedat------------case-status----------------return-payment-getstatus------------default----------------return-payment-getcreatedat-------------3-service-de-synchronisation-multi-sources-service-de-synchronisation-cqsphpphpnamespace-appapplicationservicemultisourceuse-appdomaineventdomaineventuse-appinfrastructuremultisourcesourcerouteruse-appinfrastructuremultisourcemultisourcecachemanageruse-psrlogloggerinterfaceclass-multisourcecqssynchronizationservice----private-sourcerouter-sourcerouter----private-multisourcecachemanager-cachemanager----private-loggerinterface-logger----public-function-__construct--------sourcerouter-sourcerouter--------multisourcecachemanager-cachemanager--------loggerinterface-logger-------------this-sourcerouter--sourcerouter--------this-cachemanager--cachemanager--------this-logger--logger--------public-function-handleeventdomainevent-event-void------------try-------------this-logger-infohandling-event-via-multi-source-cqs-----------------eventtype--event-geteventtype----------------eventid--event-getid-------------------------déterminer-les-sources-affectées------------affectedsources--this-determineaffectedsourcesevent-------------------------mettre-à-jour-chaque-source------------foreach-affectedsources-as-source-----------------this-updatesourcesource-event-------------------------------------invalider-le-cache-si-nécessaire------------if-this-shouldinvalidatecacheevent-----------------this-invalidatecacheevent---------------------------------catch-exception-e-------------this-logger-errorfailed-to-handle-event-via-multi-source-cqs-----------------eventtype--event-geteventtype----------------error--e-getmessage------------------------------------throw-e----------------public-function-synchronizesources-void------------try-------------this-logger-infosynchronizing-sources-via-multi-source-cqs-------------------------synchroniser-les-sources-de-lecture-avec-les-sources-décriture------------this-synchronizereadsources-------------------------nettoyer-les-caches-expirés------------this-cleanexpiredcaches------------------------this-logger-infosources-synchronized-successfully-via-multi-source-cqs---------------------catch-exception-e-------------this-logger-errorfailed-to-synchronize-sources-via-multi-source-cqs-----------------error--e-getmessage------------------------------------throw-e----------------private-function-determineaffectedsourcesdomainevent-event-array------------sources-------------------toujours-affecter-la-base-de-données-pour-les-événements-critiques--------if-this-iscriticaleventevent-------------sources--database-------------------------affecter-le-cache-pour-les-événements-de-lecture--------if-this-isreadeventevent-------------sources--cache-------------------------affecter-elasticsearch-pour-les-événements-de-recherche--------if-this-issearcheventevent-------------sources--elasticsearch------------------------return-sources--------private-function-updatesourcestring-source-domainevent-event-void------------this-logger-debugupdating-source-------------source--source------------eventtype--event-geteventtype-------------------------implémentation-spécifique-à-chaque-source--------switch-source-------------case-database----------------this-updatedatabaseevent----------------break------------case-cache----------------this-updatecacheevent----------------break------------case-elasticsearch----------------this-updateelasticsearchevent----------------break----------------private-function-shouldinvalidatecachedomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentupdated------------paymentdeleted------------paymentstatuschanged----------------private-function-invalidatecachedomainevent-event-void------------this-logger-debuginvalidating-cache-------------eventtype--event-geteventtype-------------------------invalider-les-caches-pertinents--------if-issetevent-getdatapaymentid-------------this-cachemanager-deletepaymentevent-getdatapaymentid----------------private-function-iscriticaleventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentcreated------------paymentupdated------------paymentdeleted----------------private-function-isreadeventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentviewed------------paymentsearched----------------private-function-issearcheventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentcreated------------paymentupdated------------paymentdeleted----------------private-function-updatedatabasedomainevent-event-void-------------implémentation-de-la-mise-à-jour-de-la-base-de-données--------private-function-updatecachedomainevent-event-void-------------implémentation-de-la-mise-à-jour-du-cache--------private-function-updateelasticsearchdomainevent-event-void-------------implémentation-de-la-mise-à-jour-delasticsearch--------private-function-synchronizereadsources-void-------------implémentation-de-la-synchronisation-des-sources-de-lecture--------private-function-cleanexpiredcaches-void-------------implémentation-du-nettoyage-des-caches-expirés------tests-et-validation-tests-dphpphpnamespace-apptestsintegrationmultisourceuse-appworkflowcommandpaymentpaymentcommandrequestuse-appworkflowquerypaymentpaymentsearchqueryuse-appapplicationcommandbusmultisourcemultisourcecommandbususe-appapplicationquerybusmultisourcemultisourcequerybususe-appinfrastructuremultisourcesourcerouterclass-multisourcecqstest-extends-testcase----private-multisourcecommandbus-commandbus----private-multisourcequerybus-querybus----private-sourcerouter-sourcerouter----protected-function-setup-void------------this-sourcerouter--this-createmocksourcerouterclass--------this-commandbus--new-multisourcecommandbus------------this-sourcerouter------------this-createmockloggerinterfaceclass----------------this-querybus--new-multisourcequerybus------------this-sourcerouter------------this-createmockmultisourcecachemanagerclass------------this-createmockloggerinterfaceclass----------------public-function-testcqsseparationwithmultisource-void-------------exécuter-une-commande-avec-multi-source-cqs--------command--new-paymentcommandrequest------------create------------payment-123------------org-456------------user-789------------10000------------eur------------test-payment------------------------this-commandbus-handlecommand-----------------vérifier-avec-une-requête--------query--new-paymentsearchqueryorg-456-0-10--------result--this-querybus-handlequery----------------this-assertgreaterthan0-result-gettotal--------public-function-testquerycachingwithmultisource-void------------query--new-paymentsearchqueryorg-456-0-10-----------------première-recherche--------result1--this-querybus-handlequery-----------------deuxième-recherche-devrait-utiliser-le-cache--------result2--this-querybus-handlequery----------------this-assertequalsresult1-gettotal-result2-gettotal------performance-et-optimisation-stratégies-d-1-cache-stratégique-multi-sourcesphppublic-function-searchpaymentswithcachepaymentsearchquery-query-paymentsearchresult----cachekey--multi_source_payment_search_--md5serializequery--------if-cached--this-cachemanager-getcachekey---------return-cached------------result--this-searchpaymentswithmultisourcequery----this-cachemanager-setcachekey-result-300--------return-result-2-load-balancing-multi-sourcesphppublic-function-getoptimalsourceforoperationstring-operation-array-criteria---string----sourceloads--this-getsourceloads----optimalsource--array_keyssourceloads-minsourceloads0--------this-logger-debugselected-optimal-source-for-operation---------operation--operation--------source--optimalsource--------loads--sourceloads------------return-optimalsource-3-monitoring-des-sources-multi-sourcesphppublic-function-getmultisourcemetrics-array----return---------commandsources--this-getcommandsourcemetrics--------querysources--this-getquerysourcemetrics--------cachehitrate--this-getcachehitrate--------sourcehealth--this-getsourcehealth--------averageexecutiontime--this-getaverageexecutiontime------critères-d-quand-utiliser-cqs-avec-multi-sources--avantages--performance-optimisée--séparation-claire-entre-écriture-et-lecture--flexibilité-maximale--choix-du-meilleur-stockage-pour-chaque-opération--scalabilité--possibilité-de-scaler-indépendamment-chaque-côté--résilience--redondance-et-failover-entre-sources--maintenabilité--code-plus-clair-et-organisé--inconvénients--complexité-élevée--gestion-de-plusieurs-sources-de-données--cohérence--risque-dincohérence-entre-sources--maintenance--plus-de-sources-à-maintenir--expertise--équipe-expérimentée-requise--critères-d--système-complexe--besoins-de-performance-différents-par-type-dopération--données-hétérogènes--types-de-données-différents-nécessitant-différents-stockages--performance-critique--besoins-de-performance-optimale--séparation-des-responsabilités--besoin-de-séparer-clairement-les-commandes-et-requêtes--équipe-expérimentée--maîtrise-de-plusieurs-technologies-de-stockage-et-cqs--budget-suffisant--investissement-en-infrastructure-multiple--temps-de-développement--suffisant-pour-implémenter-cette-complexité--votre-prochaine-étapehahahugoshortcode59s0hbhbcqs-avec-multi-sources-offre-un-équilibre-optimal-entre-performance-et-flexibilité-parfaitement-adapté-aux-besoins-complexes-de-gyroscops"&gt;🎯 &lt;strong&gt;Contexte et Objectifs&lt;/strong&gt;### **Pourquoi CQS avec Multi-sources ?**La combinaison CQS avec Multi-sources offre une architecture optimisée qui sépare clairement les responsabilités tout en exploitant les avantages de différents types de stockage. Cette approche permet d&amp;rsquo;optimiser chaque côté (commandes et requêtes) avec les sources les plus appropriées.#### &lt;strong&gt;Avantages de CQS avec Multi-sources&lt;/strong&gt;- &lt;strong&gt;Performance optimisée&lt;/strong&gt; : Séparation claire entre écriture et lecture- &lt;strong&gt;Flexibilité maximale&lt;/strong&gt; : Choix du meilleur stockage pour chaque opération- &lt;strong&gt;Scalabilité&lt;/strong&gt; : Possibilité de scaler indépendamment chaque côté- &lt;strong&gt;Résilience&lt;/strong&gt; : Redondance et failover entre sources- &lt;strong&gt;Maintenabilité&lt;/strong&gt; : Code plus clair et organisé### &lt;strong&gt;Contexte Gyroscops&lt;/strong&gt;Dans notre écosystème &lt;strong&gt;User → Organization → Workflow → Cloud Resources → Billing&lt;/strong&gt;, CQS avec Multi-sources est particulièrement pertinent pour :- &lt;strong&gt;Workflows de commande&lt;/strong&gt; : Orchestration des processus de modification avec sources optimisées- &lt;strong&gt;Workflows de requête&lt;/strong&gt; : Optimisation des lectures avec sources spécialisées- &lt;strong&gt;Processus de facturation&lt;/strong&gt; : Séparation des écritures et lectures de facturation- &lt;strong&gt;Intégrations complexes&lt;/strong&gt; : Orchestration des intégrations avec sources multiples## 🏗️ &lt;strong&gt;Architecture CQS avec Multi-sources&lt;/strong&gt;### &lt;strong&gt;Séparation des Responsabilités&lt;/strong&gt;#### &lt;strong&gt;Côté Commande (Write) avec Multi-sources&lt;/strong&gt;- &lt;strong&gt;Command Workflows&lt;/strong&gt; : Orchestration des processus de modification- &lt;strong&gt;Command Activities&lt;/strong&gt; : Exécution des activités de modification- &lt;strong&gt;Event Handlers&lt;/strong&gt; : Gestion des événements de domaine- &lt;strong&gt;Command Bus&lt;/strong&gt; : Orchestration des commandes- &lt;strong&gt;Write Sources&lt;/strong&gt; : Sources optimisées pour les écritures- &lt;strong&gt;Command Models&lt;/strong&gt; : Modèles optimisés pour les écritures#### &lt;strong&gt;Côté Requête (Read) avec Multi-sources&lt;/strong&gt;- &lt;strong&gt;Query Workflows&lt;/strong&gt; : Orchestration des processus de lecture- &lt;strong&gt;Query Activities&lt;/strong&gt; : Exécution des activités de lecture- &lt;strong&gt;Search Services&lt;/strong&gt; : Services de recherche spécialisés- &lt;strong&gt;Query Bus&lt;/strong&gt; : Orchestration des requêtes- &lt;strong&gt;Read Sources&lt;/strong&gt; : Sources optimisées pour les lectures- &lt;strong&gt;Query Models&lt;/strong&gt; : Modèles optimisés pour les lectures### &lt;strong&gt;Flux de Données&lt;/strong&gt;&lt;code&gt;mermaidgraph TD A[Command] --&amp;gt; B[Command Bus] B --&amp;gt; C[Command Workflow] C --&amp;gt; D[Command Activities] D --&amp;gt; E[Write Sources] E --&amp;gt; F[SQL Database] E --&amp;gt; G[Redis Cache] E --&amp;gt; H[File System] I[Query] --&amp;gt; J[Query Bus] J --&amp;gt; K[Query Workflow] K --&amp;gt; L[Query Activities] L --&amp;gt; M[Read Sources] M --&amp;gt; N[ElasticSearch] M --&amp;gt; O[Redis Cache] M --&amp;gt; P[SQL Database] Q[Event] --&amp;gt; R[Event Handler] R --&amp;gt; C S[Projection] --&amp;gt; T[Read Model Update] T --&amp;gt; M&lt;/code&gt;## 💻 &lt;strong&gt;Implémentation Pratique&lt;/strong&gt;### &lt;strong&gt;1. Command Side avec Multi-sources&lt;/strong&gt;#### &lt;strong&gt;Command Bus avec Multi-sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\CommandBus\MultiSource;use App\Domain\Command\CommandInterface;use App\Domain\Command\CommandHandlerInterface;use App\Infrastructure\MultiSource\SourceRouter;use Psr\Log\LoggerInterface;class MultiSourceCommandBus{ private array $handlers = []; private array $middleware = []; private SourceRouter $sourceRouter; private LoggerInterface $logger; public function __construct( SourceRouter $sourceRouter, LoggerInterface $logger ) { $this-&amp;gt;sourceRouter = $sourceRouter; $this-&amp;gt;logger = $logger; } public function registerHandler(string $commandClass, CommandHandlerInterface $handler): void { $this-&amp;gt;handlers[$commandClass] = $handler; } public function addMiddleware(callable $middleware): void { $this-&amp;gt;middleware[] = $middleware; } public function handle(CommandInterface $command): void { $commandClass = get_class($command); if (!isset($this-&amp;gt;handlers[$commandClass])) { throw new \InvalidArgumentException(&amp;quot;No handler registered for command: $commandClass&amp;quot;); } $handler = $this-&amp;gt;handlers[$commandClass]; // Exécuter les middleware $this-&amp;gt;executeMiddleware($command, function() use ($handler, $command) { $this-&amp;gt;logger-&amp;gt;info('Executing command via Multi-source CQS', [ 'command' =&amp;gt; get_class($command), 'data' =&amp;gt; $command-&amp;gt;toArray() ]); $handler-&amp;gt;handle($command); }); } private function executeMiddleware(CommandInterface $command, callable $next): void { $middleware = array_reverse($this-&amp;gt;middleware); foreach ($middleware as $mw) { $next = function() use ($mw, $command, $next) { return $mw($command, $next); }; } $next(); }}&lt;/code&gt;#### &lt;strong&gt;Command Workflow avec Multi-sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Workflow\Command\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Infrastructure\MultiSource\SourceRouter;#[WorkflowInterface]interface PaymentMultiSourceCommandWorkflowInterface{ #[WorkflowMethod] public function processPaymentCommandWithMultiSource(PaymentCommandRequest $request): PaymentCommandResult; #[WorkflowMethod] public function updatePaymentCommandWithMultiSource(PaymentUpdateCommandRequest $request): PaymentCommandResult; #[WorkflowMethod] public function deletePaymentCommandWithMultiSource(PaymentDeleteCommandRequest $request): PaymentCommandResult;}#[ActivityInterface]interface PaymentMultiSourceCommandActivityInterface{ #[ActivityMethod] public function validatePaymentCommand(PaymentCommandRequest $request): ValidationResult; #[ActivityMethod] public function executePaymentCommand(PaymentCommandRequest $request): CommandExecutionResult; #[ActivityMethod] public function persistToWriteSources(Payment $payment, array $sources): void; #[ActivityMethod] public function updateCommandModels(Payment $payment): void;}class PaymentMultiSourceCommandWorkflow implements PaymentMultiSourceCommandWorkflowInterface{ private PaymentMultiSourceCommandActivityInterface $commandActivity; private SourceRouter $sourceRouter; public function __construct() { $this-&amp;gt;commandActivity = Workflow::newActivityStub(PaymentMultiSourceCommandActivityInterface::class); $this-&amp;gt;sourceRouter = Workflow::newActivityStub(SourceRouter::class); } public function processPaymentCommandWithMultiSource(PaymentCommandRequest $request): PaymentCommandResult { try { // Validation de la commande $validation = yield $this-&amp;gt;commandActivity-&amp;gt;validatePaymentCommand($request); if (!$validation-&amp;gt;isValid()) { return new PaymentCommandResult(false, $validation-&amp;gt;getError()); } // Exécution de la commande $execution = yield $this-&amp;gt;commandActivity-&amp;gt;executePaymentCommand($request); if (!$execution-&amp;gt;isSuccess()) { return new PaymentCommandResult(false, $execution-&amp;gt;getError()); } // Déterminer les sources d'écriture optimales $writeSources = yield $this-&amp;gt;sourceRouter-&amp;gt;routeWrite('save', $execution-&amp;gt;getPayment()); // Persister dans les sources d'écriture yield $this-&amp;gt;commandActivity-&amp;gt;persistToWriteSources($execution-&amp;gt;getPayment(), $writeSources); // Mettre à jour les modèles de commande yield $this-&amp;gt;commandActivity-&amp;gt;updateCommandModels($execution-&amp;gt;getPayment()); return new PaymentCommandResult(true, 'Payment command processed with Multi-source CQS'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e-&amp;gt;getMessage()); } } public function updatePaymentCommandWithMultiSource(PaymentUpdateCommandRequest $request): PaymentCommandResult { try { // Validation de la commande de mise à jour $validation = yield $this-&amp;gt;commandActivity-&amp;gt;validatePaymentCommand($request); if (!$validation-&amp;gt;isValid()) { return new PaymentCommandResult(false, $validation-&amp;gt;getError()); } // Exécution de la mise à jour $execution = yield $this-&amp;gt;commandActivity-&amp;gt;executePaymentCommand($request); if (!$execution-&amp;gt;isSuccess()) { return new PaymentCommandResult(false, $execution-&amp;gt;getError()); } // Déterminer les sources d'écriture optimales $writeSources = yield $this-&amp;gt;sourceRouter-&amp;gt;routeWrite('update', $execution-&amp;gt;getPayment()); // Persister dans les sources d'écriture yield $this-&amp;gt;commandActivity-&amp;gt;persistToWriteSources($execution-&amp;gt;getPayment(), $writeSources); // Mettre à jour les modèles de commande yield $this-&amp;gt;commandActivity-&amp;gt;updateCommandModels($execution-&amp;gt;getPayment()); return new PaymentCommandResult(true, 'Payment update command processed with Multi-source CQS'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e-&amp;gt;getMessage()); } } public function deletePaymentCommandWithMultiSource(PaymentDeleteCommandRequest $request): PaymentCommandResult { try { // Validation de la commande de suppression $validation = yield $this-&amp;gt;commandActivity-&amp;gt;validatePaymentCommand($request); if (!$validation-&amp;gt;isValid()) { return new PaymentCommandResult(false, $validation-&amp;gt;getError()); } // Exécution de la suppression $execution = yield $this-&amp;gt;commandActivity-&amp;gt;executePaymentCommand($request); if (!$execution-&amp;gt;isSuccess()) { return new PaymentCommandResult(false, $execution-&amp;gt;getError()); } // Déterminer les sources d'écriture optimales $writeSources = yield $this-&amp;gt;sourceRouter-&amp;gt;routeWrite('delete', $execution-&amp;gt;getPayment()); // Persister dans les sources d'écriture yield $this-&amp;gt;commandActivity-&amp;gt;persistToWriteSources($execution-&amp;gt;getPayment(), $writeSources); // Mettre à jour les modèles de commande yield $this-&amp;gt;commandActivity-&amp;gt;updateCommandModels($execution-&amp;gt;getPayment()); return new PaymentCommandResult(true, 'Payment delete command processed with Multi-source CQS'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e-&amp;gt;getMessage()); } }}&lt;/code&gt;### &lt;strong&gt;2. Query Side avec Multi-sources&lt;/strong&gt;#### &lt;strong&gt;Query Bus avec Cache et Multi-sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\QueryBus\MultiSource;use App\Domain\Query\QueryInterface;use App\Domain\Query\QueryHandlerInterface;use App\Infrastructure\MultiSource\SourceRouter;use App\Infrastructure\MultiSource\MultiSourceCacheManager;use Psr\Log\LoggerInterface;class MultiSourceQueryBus{ private array $handlers = []; private SourceRouter $sourceRouter; private MultiSourceCacheManager $cacheManager; private LoggerInterface $logger; public function __construct( SourceRouter $sourceRouter, MultiSourceCacheManager $cacheManager, LoggerInterface $logger ) { $this-&amp;gt;sourceRouter = $sourceRouter; $this-&amp;gt;cacheManager = $cacheManager; $this-&amp;gt;logger = $logger; } public function registerHandler(string $queryClass, QueryHandlerInterface $handler): void { $this-&amp;gt;handlers[$queryClass] = $handler; } public function handle(QueryInterface $query): mixed { $queryClass = get_class($query); if (!isset($this-&amp;gt;handlers[$queryClass])) { throw new \InvalidArgumentException(&amp;quot;No handler registered for query: $queryClass&amp;quot;); } // Vérifier le cache $cacheKey = $this-&amp;gt;generateCacheKey($query); $cachedResult = $this-&amp;gt;cacheManager-&amp;gt;get($cacheKey); if ($cachedResult !== null) { $this-&amp;gt;logger-&amp;gt;debug('Query result served from cache', [ 'query' =&amp;gt; $queryClass, 'cacheKey' =&amp;gt; $cacheKey ]); return $cachedResult; } // Déterminer la source de lecture optimale $readSource = $this-&amp;gt;sourceRouter-&amp;gt;routeRead($queryClass, $query-&amp;gt;toArray()); // Exécuter la requête via la source optimale $handler = $this-&amp;gt;handlers[$queryClass]; $result = $handler-&amp;gt;handle($query, $readSource); // Mettre en cache $this-&amp;gt;cacheManager-&amp;gt;set($cacheKey, $result, 300); $this-&amp;gt;logger-&amp;gt;info('Query executed and cached via Multi-source CQS', [ 'query' =&amp;gt; $queryClass, 'source' =&amp;gt; $readSource, 'cacheKey' =&amp;gt; $cacheKey ]); return $result; } private function generateCacheKey(QueryInterface $query): string { return 'multi_source_query_' . md5(serialize($query)); }}&lt;/code&gt;#### &lt;strong&gt;Query Workflow avec Multi-sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Workflow\Query\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Infrastructure\MultiSource\SourceRouter;#[WorkflowInterface]interface PaymentMultiSourceQueryWorkflowInterface{ #[WorkflowMethod] public function searchPaymentsWithMultiSource(PaymentSearchQuery $query): PaymentSearchResult; #[WorkflowMethod] public function getPaymentByIdWithMultiSource(PaymentByIdQuery $query): ?Payment; #[WorkflowMethod] public function getPaymentStatisticsWithMultiSource(PaymentStatisticsQuery $query): array; #[WorkflowMethod] public function getPaymentAnalyticsWithMultiSource(PaymentAnalyticsQuery $query): array;}#[ActivityInterface]interface PaymentMultiSourceQueryActivityInterface{ #[ActivityMethod] public function searchPaymentsInSource(PaymentSearchQuery $query, string $source): array; #[ActivityMethod] public function getPaymentFromSource(string $paymentId, string $source): ?Payment; #[ActivityMethod] public function calculatePaymentStatisticsInSource(PaymentStatisticsQuery $query, string $source): array; #[ActivityMethod] public function generatePaymentAnalyticsInSource(PaymentAnalyticsQuery $query, string $source): array;}class PaymentMultiSourceQueryWorkflow implements PaymentMultiSourceQueryWorkflowInterface{ private PaymentMultiSourceQueryActivityInterface $queryActivity; private SourceRouter $sourceRouter; public function __construct() { $this-&amp;gt;queryActivity = Workflow::newActivityStub(PaymentMultiSourceQueryActivityInterface::class); $this-&amp;gt;sourceRouter = Workflow::newActivityStub(SourceRouter::class); } public function searchPaymentsWithMultiSource(PaymentSearchQuery $query): PaymentSearchResult { try { // Déterminer la source de lecture optimale $readSource = yield $this-&amp;gt;sourceRouter-&amp;gt;routeRead('search', $query-&amp;gt;toArray()); // Recherche dans la source optimale $payments = yield $this-&amp;gt;queryActivity-&amp;gt;searchPaymentsInSource($query, $readSource); // Filtrage et tri $filteredPayments = $this-&amp;gt;filterPayments($payments, $query); $sortedPayments = $this-&amp;gt;sortPayments($filteredPayments, $query); // Pagination $paginatedPayments = $this-&amp;gt;paginatePayments($sortedPayments, $query); return new PaymentSearchResult( $paginatedPayments, count($filteredPayments), $query-&amp;gt;getPage(), $query-&amp;gt;getSize() ); } catch (\Exception $e) { return new PaymentSearchResult([], 0, $query-&amp;gt;getPage(), $query-&amp;gt;getSize()); } } public function getPaymentByIdWithMultiSource(PaymentByIdQuery $query): ?Payment { try { // Déterminer la source de lecture optimale $readSource = yield $this-&amp;gt;sourceRouter-&amp;gt;routeRead('findById', ['id' =&amp;gt; $query-&amp;gt;getPaymentId()]); return yield $this-&amp;gt;queryActivity-&amp;gt;getPaymentFromSource($query-&amp;gt;getPaymentId(), $readSource); } catch (\Exception $e) { return null; } } public function getPaymentStatisticsWithMultiSource(PaymentStatisticsQuery $query): array { try { // Déterminer la source de lecture optimale $readSource = yield $this-&amp;gt;sourceRouter-&amp;gt;routeRead('statistics', $query-&amp;gt;toArray()); return yield $this-&amp;gt;queryActivity-&amp;gt;calculatePaymentStatisticsInSource($query, $readSource); } catch (\Exception $e) { return []; } } public function getPaymentAnalyticsWithMultiSource(PaymentAnalyticsQuery $query): array { try { // Déterminer la source de lecture optimale $readSource = yield $this-&amp;gt;sourceRouter-&amp;gt;routeRead('analytics', $query-&amp;gt;toArray()); return yield $this-&amp;gt;queryActivity-&amp;gt;generatePaymentAnalyticsInSource($query, $readSource); } catch (\Exception $e) { return []; } } private function filterPayments(array $payments, PaymentSearchQuery $query): array { return array_filter($payments, function($payment) use ($query) { if ($query-&amp;gt;getOrganizationId() &amp;amp;&amp;amp; $payment-&amp;gt;getOrganizationId() !== $query-&amp;gt;getOrganizationId()) { return false; } if ($query-&amp;gt;getStatus() &amp;amp;&amp;amp; $payment-&amp;gt;getStatus() !== $query-&amp;gt;getStatus()) { return false; } if ($query-&amp;gt;getMinAmount() &amp;amp;&amp;amp; $payment-&amp;gt;getAmount() &amp;lt; $query-&amp;gt;getMinAmount()) { return false; } if ($query-&amp;gt;getMaxAmount() &amp;amp;&amp;amp; $payment-&amp;gt;getAmount() &amp;gt; $query-&amp;gt;getMaxAmount()) { return false; } return true; }); } private function sortPayments(array $payments, PaymentSearchQuery $query): array { $sortField = $query-&amp;gt;getSortField() ?? 'createdAt'; $sortDirection = $query-&amp;gt;getSortDirection() ?? 'desc'; usort($payments, function($a, $b) use ($sortField, $sortDirection) { $valueA = $this-&amp;gt;getFieldValue($a, $sortField); $valueB = $this-&amp;gt;getFieldValue($b, $sortField); if ($sortDirection === 'asc') { return $valueA &amp;lt;=&amp;gt; $valueB; } else { return $valueB &amp;lt;=&amp;gt; $valueA; } }); return $payments; } private function paginatePayments(array $payments, PaymentSearchQuery $query): array { $page = $query-&amp;gt;getPage() ?? 1; $size = $query-&amp;gt;getSize() ?? 10; $offset = ($page - 1) * $size; return array_slice($payments, $offset, $size); } private function getFieldValue(Payment $payment, string $field): mixed { switch ($field) { case 'amount': return $payment-&amp;gt;getAmount(); case 'createdAt': return $payment-&amp;gt;getCreatedAt(); case 'status': return $payment-&amp;gt;getStatus(); default: return $payment-&amp;gt;getCreatedAt(); } }}&lt;/code&gt;### &lt;strong&gt;3. Service de Synchronisation Multi-Sources&lt;/strong&gt;#### &lt;strong&gt;Service de Synchronisation CQS&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Service\MultiSource;use App\Domain\Event\DomainEvent;use App\Infrastructure\MultiSource\SourceRouter;use App\Infrastructure\MultiSource\MultiSourceCacheManager;use Psr\Log\LoggerInterface;class MultiSourceCqsSynchronizationService{ private SourceRouter $sourceRouter; private MultiSourceCacheManager $cacheManager; private LoggerInterface $logger; public function __construct( SourceRouter $sourceRouter, MultiSourceCacheManager $cacheManager, LoggerInterface $logger ) { $this-&amp;gt;sourceRouter = $sourceRouter; $this-&amp;gt;cacheManager = $cacheManager; $this-&amp;gt;logger = $logger; } public function handleEvent(DomainEvent $event): void { try { $this-&amp;gt;logger-&amp;gt;info('Handling event via Multi-source CQS', [ 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'eventId' =&amp;gt; $event-&amp;gt;getId() ]); // Déterminer les sources affectées $affectedSources = $this-&amp;gt;determineAffectedSources($event); // Mettre à jour chaque source foreach ($affectedSources as $source) { $this-&amp;gt;updateSource($source, $event); } // Invalider le cache si nécessaire if ($this-&amp;gt;shouldInvalidateCache($event)) { $this-&amp;gt;invalidateCache($event); } } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to handle event via Multi-source CQS', [ 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } public function synchronizeSources(): void { try { $this-&amp;gt;logger-&amp;gt;info('Synchronizing sources via Multi-source CQS'); // Synchroniser les sources de lecture avec les sources d'écriture $this-&amp;gt;synchronizeReadSources(); // Nettoyer les caches expirés $this-&amp;gt;cleanExpiredCaches(); $this-&amp;gt;logger-&amp;gt;info('Sources synchronized successfully via Multi-source CQS'); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to synchronize sources via Multi-source CQS', [ 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } private function determineAffectedSources(DomainEvent $event): array { $sources = []; // Toujours affecter la base de données pour les événements critiques if ($this-&amp;gt;isCriticalEvent($event)) { $sources[] = 'database'; } // Affecter le cache pour les événements de lecture if ($this-&amp;gt;isReadEvent($event)) { $sources[] = 'cache'; } // Affecter ElasticSearch pour les événements de recherche if ($this-&amp;gt;isSearchEvent($event)) { $sources[] = 'elasticsearch'; } return $sources; } private function updateSource(string $source, DomainEvent $event): void { $this-&amp;gt;logger-&amp;gt;debug('Updating source', [ 'source' =&amp;gt; $source, 'eventType' =&amp;gt; $event-&amp;gt;getEventType() ]); // Implémentation spécifique à chaque source switch ($source) { case 'database': $this-&amp;gt;updateDatabase($event); break; case 'cache': $this-&amp;gt;updateCache($event); break; case 'elasticsearch': $this-&amp;gt;updateElasticSearch($event); break; } } private function shouldInvalidateCache(DomainEvent $event): bool { return in_array($event-&amp;gt;getEventType(), [ 'PaymentUpdated', 'PaymentDeleted', 'PaymentStatusChanged' ]); } private function invalidateCache(DomainEvent $event): void { $this-&amp;gt;logger-&amp;gt;debug('Invalidating cache', [ 'eventType' =&amp;gt; $event-&amp;gt;getEventType() ]); // Invalider les caches pertinents if (isset($event-&amp;gt;getData()['paymentId'])) { $this-&amp;gt;cacheManager-&amp;gt;deletePayment($event-&amp;gt;getData()['paymentId']); } } private function isCriticalEvent(DomainEvent $event): bool { return in_array($event-&amp;gt;getEventType(), [ 'PaymentCreated', 'PaymentUpdated', 'PaymentDeleted' ]); } private function isReadEvent(DomainEvent $event): bool { return in_array($event-&amp;gt;getEventType(), [ 'PaymentViewed', 'PaymentSearched' ]); } private function isSearchEvent(DomainEvent $event): bool { return in_array($event-&amp;gt;getEventType(), [ 'PaymentCreated', 'PaymentUpdated', 'PaymentDeleted' ]); } private function updateDatabase(DomainEvent $event): void { // Implémentation de la mise à jour de la base de données } private function updateCache(DomainEvent $event): void { // Implémentation de la mise à jour du cache } private function updateElasticSearch(DomainEvent $event): void { // Implémentation de la mise à jour d'ElasticSearch } private function synchronizeReadSources(): void { // Implémentation de la synchronisation des sources de lecture } private function cleanExpiredCaches(): void { // Implémentation du nettoyage des caches expirés }}&lt;/code&gt;## 🧪 &lt;strong&gt;Tests et Validation&lt;/strong&gt;### &lt;strong&gt;Tests d&amp;rsquo;Intégration CQS Multi-Sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Tests\Integration\MultiSource;use App\Workflow\Command\Payment\PaymentCommandRequest;use App\Workflow\Query\Payment\PaymentSearchQuery;use App\Application\CommandBus\MultiSource\MultiSourceCommandBus;use App\Application\QueryBus\MultiSource\MultiSourceQueryBus;use App\Infrastructure\MultiSource\SourceRouter;class MultiSourceCqsTest extends TestCase{ private MultiSourceCommandBus $commandBus; private MultiSourceQueryBus $queryBus; private SourceRouter $sourceRouter; protected function setUp(): void { $this-&amp;gt;sourceRouter = $this-&amp;gt;createMock(SourceRouter::class); $this-&amp;gt;commandBus = new MultiSourceCommandBus( $this-&amp;gt;sourceRouter, $this-&amp;gt;createMock(LoggerInterface::class) ); $this-&amp;gt;queryBus = new MultiSourceQueryBus( $this-&amp;gt;sourceRouter, $this-&amp;gt;createMock(MultiSourceCacheManager::class), $this-&amp;gt;createMock(LoggerInterface::class) ); } public function testCqsSeparationWithMultiSource(): void { // Exécuter une commande avec Multi-source CQS $command = new PaymentCommandRequest( 'CREATE', 'payment-123', 'org-456', 'user-789', 100.00, 'EUR', 'Test payment' ); $this-&amp;gt;commandBus-&amp;gt;handle($command); // Vérifier avec une requête $query = new PaymentSearchQuery('org-456', 0, 10); $result = $this-&amp;gt;queryBus-&amp;gt;handle($query); $this-&amp;gt;assertGreaterThan(0, $result-&amp;gt;getTotal()); } public function testQueryCachingWithMultiSource(): void { $query = new PaymentSearchQuery('org-456', 0, 10); // Première recherche $result1 = $this-&amp;gt;queryBus-&amp;gt;handle($query); // Deuxième recherche (devrait utiliser le cache) $result2 = $this-&amp;gt;queryBus-&amp;gt;handle($query); $this-&amp;gt;assertEquals($result1-&amp;gt;getTotal(), $result2-&amp;gt;getTotal()); }}&lt;/code&gt;## 📊 &lt;strong&gt;Performance et Optimisation&lt;/strong&gt;### &lt;strong&gt;Stratégies d&amp;rsquo;Optimisation CQS Multi-Sources&lt;/strong&gt;#### &lt;strong&gt;1. Cache Stratégique Multi-Sources&lt;/strong&gt;&lt;code&gt;phppublic function searchPaymentsWithCache(PaymentSearchQuery $query): PaymentSearchResult{ $cacheKey = 'multi_source_payment_search_' . md5(serialize($query)); if ($cached = $this-&amp;gt;cacheManager-&amp;gt;get($cacheKey)) { return $cached; } $result = $this-&amp;gt;searchPaymentsWithMultiSource($query); $this-&amp;gt;cacheManager-&amp;gt;set($cacheKey, $result, 300); return $result;}&lt;/code&gt;#### &lt;strong&gt;2. Load Balancing Multi-Sources&lt;/strong&gt;&lt;code&gt;phppublic function getOptimalSourceForOperation(string $operation, array $criteria = []): string{ $sourceLoads = $this-&amp;gt;getSourceLoads(); $optimalSource = array_keys($sourceLoads, min($sourceLoads))[0]; $this-&amp;gt;logger-&amp;gt;debug('Selected optimal source for operation', [ 'operation' =&amp;gt; $operation, 'source' =&amp;gt; $optimalSource, 'loads' =&amp;gt; $sourceLoads ]); return $optimalSource;}&lt;/code&gt;#### &lt;strong&gt;3. Monitoring des Sources Multi-Sources&lt;/strong&gt;&lt;code&gt;phppublic function getMultiSourceMetrics(): array{ return [ 'commandSources' =&amp;gt; $this-&amp;gt;getCommandSourceMetrics(), 'querySources' =&amp;gt; $this-&amp;gt;getQuerySourceMetrics(), 'cacheHitRate' =&amp;gt; $this-&amp;gt;getCacheHitRate(), 'sourceHealth' =&amp;gt; $this-&amp;gt;getSourceHealth(), 'averageExecutionTime' =&amp;gt; $this-&amp;gt;getAverageExecutionTime() ];}&lt;/code&gt;## 🎯 &lt;strong&gt;Critères d&amp;rsquo;Adoption&lt;/strong&gt;### &lt;strong&gt;Quand Utiliser CQS avec Multi-sources&lt;/strong&gt;#### &lt;strong&gt;✅ Avantages&lt;/strong&gt;- &lt;strong&gt;Performance optimisée&lt;/strong&gt; : Séparation claire entre écriture et lecture- &lt;strong&gt;Flexibilité maximale&lt;/strong&gt; : Choix du meilleur stockage pour chaque opération- &lt;strong&gt;Scalabilité&lt;/strong&gt; : Possibilité de scaler indépendamment chaque côté- &lt;strong&gt;Résilience&lt;/strong&gt; : Redondance et failover entre sources- &lt;strong&gt;Maintenabilité&lt;/strong&gt; : Code plus clair et organisé#### &lt;strong&gt;❌ Inconvénients&lt;/strong&gt;- &lt;strong&gt;Complexité élevée&lt;/strong&gt; : Gestion de plusieurs sources de données- &lt;strong&gt;Cohérence&lt;/strong&gt; : Risque d&amp;rsquo;incohérence entre sources- &lt;strong&gt;Maintenance&lt;/strong&gt; : Plus de sources à maintenir- &lt;strong&gt;Expertise&lt;/strong&gt; : Équipe expérimentée requise#### &lt;strong&gt;🎯 Critères d&amp;rsquo;Adoption&lt;/strong&gt;- &lt;strong&gt;Système complexe&lt;/strong&gt; : Besoins de performance différents par type d&amp;rsquo;opération- &lt;strong&gt;Données hétérogènes&lt;/strong&gt; : Types de données différents nécessitant différents stockages- &lt;strong&gt;Performance critique&lt;/strong&gt; : Besoins de performance optimale- &lt;strong&gt;Séparation des responsabilités&lt;/strong&gt; : Besoin de séparer clairement les commandes et requêtes- &lt;strong&gt;Équipe expérimentée&lt;/strong&gt; : Maîtrise de plusieurs technologies de stockage et CQS- &lt;strong&gt;Budget suffisant&lt;/strong&gt; : Investissement en infrastructure multiple- &lt;strong&gt;Temps de développement&lt;/strong&gt; : Suffisant pour implémenter cette complexité## 🚀 &lt;strong&gt;Votre Prochaine Étape&lt;/strong&gt;

&lt;div class="chapter-navigation"&gt;
 &lt;h2 class="chapter-nav-title"&gt;🎯 Votre Prochaine Étape&lt;/h2&gt;
 &lt;p class="chapter-nav-subtitle"&gt;Maintenant que vous comprenez les concepts de base et que j'ai partagé mon expérience avec Gyroscops, quel est votre contexte ?&lt;/p&gt;</description></item><item><title>Stockage Multi-sources - CQRS</title><link>http://localhost:1313/chapitres/stockage/multi-sources/chapitre-54-stockage-multi-sources-cqrs/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/multi-sources/chapitre-54-stockage-multi-sources-cqrs/</guid><description>&lt;h2 id="-contexte-et-objectifs-lnous-arrivons-maintenant-à-lapproche-la-plus-sophistiquée-pour-multi-sources--cqrs-complet-cette-combinaison-offre-une-architecture-hautement-scalable-et-flexible-parfaite-pour-les-systèmes-nécessitant-séparation-maximale-des-responsabilités-et-optimisation-des-performances-pourquoi-cqrs-avec-multi-sources---séparation-totale--commandes-et-requêtes-complètement-découplées--flexibilité-maximale--choix-du-meilleur-stockage-pour-chaque-opération--scalabilité-maximale--possibilité-de-scaler-indépendamment-chaque-côté--performance-optimale--chaque-côté-optimisé-pour-son-usage--résilience--redondance-et-failover-entre-sources--maintenabilité--code-plus-clair-et-organisé-contexte-gyroscopsdans-notre-écosystème-user--organization--workflow--cloud-resources--billing-cqrs-avec-multi-sources-est-la-solution-ultime-pour---workflows-de-commande--orchestration-des-processus-de-modification-avec-sources-optimisées--workflows-de-requête--optimisation-des-lectures-avec-sources-spécialisées--processus-de-facturation--séparation-complète-des-écritures-et-lectures-de-facturation--intégrations-complexes--orchestration-des-intégrations-avec-sources-multiples--architecture-cqrs-avec-multi-sources-séparation-complète-des-responsabilités-command-side-write-avec-multi-sources--command-workflows--orchestration-des-processus-de-modification--command-activities--exécution-des-activités-de-modification--event-handlers--gestion-des-événements-de-domaine--command-bus--orchestration-des-commandes--write-sources--sources-optimisées-pour-les-écritures--command-models--modèles-optimisés-pour-les-écritures--projections--mise-à-jour-des-vues-matérialisées-query-side-read-avec-multi-sources--query-workflows--orchestration-des-processus-de-lecture--query-activities--exécution-des-activités-de-lecture--search-services--services-de-recherche-spécialisés--query-bus--orchestration-des-requêtes--read-sources--sources-optimisées-pour-les-lectures--query-models--modèles-optimisés-pour-les-lectures--caches--optimisation-des-performances-flux-de-données-completmermaidgraph-td----acommand----bcommand-bus----b----ccommand-workflow----c----dcommand-activities----d----ewrite-sources----e----fsql-database----e----gredis-cache----e----hfile-system----e----ievent-store--------jquery----kquery-bus----k----lquery-workflow----l----mquery-activities----m----nread-sources----n----oelasticsearch----n----predis-cache----n----qsql-database----n----rread-models--------sevent----tevent-handler----t----c--------uprojection----vread-model-update----v----r--------wcommand-model----xwrite-optimization----x----e--------yquery-model----zread-optimization----z----n--implémentation-complète-1-command-side-avec-multi-sources-command-bus-avec-multi-sourcesphpphpnamespace-appapplicationcommandbusmultisourceuse-appdomaincommandcommandinterfaceuse-appdomaincommandcommandhandlerinterfaceuse-appinfrastructuremultisourcesourcerouteruse-psrlogloggerinterfaceclass-multisourcecqrscommandbus----private-array-handlers------private-array-middleware------private-sourcerouter-sourcerouter----private-loggerinterface-logger----public-function-__construct--------sourcerouter-sourcerouter--------loggerinterface-logger-------------this-sourcerouter--sourcerouter--------this-logger--logger--------public-function-registerhandlerstring-commandclass-commandhandlerinterface-handler-void------------this-handlerscommandclass--handler--------public-function-addmiddlewarecallable-middleware-void------------this-middleware--middleware--------public-function-handlecommandinterface-command-void------------commandclass--get_classcommand----------------if-issetthis-handlerscommandclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-command-commandclass----------------handler--this-handlerscommandclass-----------------exécuter-les-middleware--------this-executemiddlewarecommand-function-use-handler-command-------------this-logger-infoexecuting-command-via-multi-source-cqrs-----------------command--get_classcommand----------------data--command-toarray------------------------------------handler-handlecommand----------------private-function-executemiddlewarecommandinterface-command-callable-next-void------------middleware--array_reversethis-middleware----------------foreach-middleware-as-mw-------------next--function-use-mw-command-next-----------------return-mwcommand-next------------------------------------next-----command-workflow-avec-multi-sourcesphpphpnamespace-appworkflowcommandpaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowuse-appinfrastructuremultisourcesourcerouterworkflowinterfaceinterface-paymentmultisourcecqrscommandworkflowinterface----workflowmethod----public-function-processpaymentcommandwithmultisourcecqrspaymentcommandrequest-request-paymentcommandresult--------workflowmethod----public-function-updatepaymentcommandwithmultisourcecqrspaymentupdatecommandrequest-request-paymentcommandresult--------workflowmethod----public-function-deletepaymentcommandwithmultisourcecqrspaymentdeletecommandrequest-request-paymentcommandresultactivityinterfaceinterface-paymentmultisourcecqrscommandactivityinterface----activitymethod----public-function-validatepaymentcommandpaymentcommandrequest-request-validationresult--------activitymethod----public-function-executepaymentcommandpaymentcommandrequest-request-commandexecutionresult--------activitymethod----public-function-persisttowritesourcespayment-payment-array-sources-void--------activitymethod----public-function-updateprojectionspayment-payment-void--------activitymethod----public-function-updatecommandmodelspayment-payment-voidclass-paymentmultisourcecqrscommandworkflow-implements-paymentmultisourcecqrscommandworkflowinterface----private-paymentmultisourcecqrscommandactivityinterface-commandactivity----private-sourcerouter-sourcerouter----public-function-__construct------------this-commandactivity--workflownewactivitystubpaymentmultisourcecqrscommandactivityinterfaceclass--------this-sourcerouter--workflownewactivitystubsourcerouterclass--------public-function-processpaymentcommandwithmultisourcecqrspaymentcommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------exécution-de-la-commande------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------déterminer-les-sources-décriture-optimales------------writesources--yield-this-sourcerouter-routewritesave-execution-getpayment-------------------------persister-dans-les-sources-décriture------------yield-this-commandactivity-persisttowritesourcesexecution-getpayment-writesources-------------------------mettre-à-jour-les-projections------------yield-this-commandactivity-updateprojectionsexecution-getpayment-------------------------mettre-à-jour-les-modèles-de-commande------------yield-this-commandactivity-updatecommandmodelsexecution-getpayment------------------------return-new-paymentcommandresulttrue-payment-command-processed-with-multi-source-cqrs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage----------------public-function-updatepaymentcommandwithmultisourcecqrspaymentupdatecommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande-de-mise-à-jour------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------exécution-de-la-mise-à-jour------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------déterminer-les-sources-décriture-optimales------------writesources--yield-this-sourcerouter-routewriteupdate-execution-getpayment-------------------------persister-dans-les-sources-décriture------------yield-this-commandactivity-persisttowritesourcesexecution-getpayment-writesources-------------------------mettre-à-jour-les-projections------------yield-this-commandactivity-updateprojectionsexecution-getpayment-------------------------mettre-à-jour-les-modèles-de-commande------------yield-this-commandactivity-updatecommandmodelsexecution-getpayment------------------------return-new-paymentcommandresulttrue-payment-update-command-processed-with-multi-source-cqrs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage----------------public-function-deletepaymentcommandwithmultisourcecqrspaymentdeletecommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande-de-suppression------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------exécution-de-la-suppression------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------déterminer-les-sources-décriture-optimales------------writesources--yield-this-sourcerouter-routewritedelete-execution-getpayment-------------------------persister-dans-les-sources-décriture------------yield-this-commandactivity-persisttowritesourcesexecution-getpayment-writesources-------------------------mettre-à-jour-les-projections------------yield-this-commandactivity-updateprojectionsexecution-getpayment-------------------------mettre-à-jour-les-modèles-de-commande------------yield-this-commandactivity-updatecommandmodelsexecution-getpayment------------------------return-new-paymentcommandresulttrue-payment-delete-command-processed-with-multi-source-cqrs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage-------------2-query-side-avec-multi-sources-query-bus-avec-cache-et-multi-sourcesphpphpnamespace-appapplicationquerybusmultisourceuse-appdomainqueryqueryinterfaceuse-appdomainqueryqueryhandlerinterfaceuse-appinfrastructuremultisourcesourcerouteruse-appinfrastructuremultisourcemultisourcecachemanageruse-psrlogloggerinterfaceclass-multisourcecqrsquerybus----private-array-handlers------private-sourcerouter-sourcerouter----private-multisourcecachemanager-cachemanager----private-loggerinterface-logger----public-function-__construct--------sourcerouter-sourcerouter--------multisourcecachemanager-cachemanager--------loggerinterface-logger-------------this-sourcerouter--sourcerouter--------this-cachemanager--cachemanager--------this-logger--logger--------public-function-registerhandlerstring-queryclass-queryhandlerinterface-handler-void------------this-handlersqueryclass--handler--------public-function-handlequeryinterface-query-mixed------------queryclass--get_classquery----------------if-issetthis-handlersqueryclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-query-queryclass-----------------vérifier-le-cache--------cachekey--this-generatecachekeyquery--------cachedresult--this-cachemanager-getcachekey----------------if-cachedresult--null-------------this-logger-debugquery-result-served-from-cache-----------------query--queryclass----------------cachekey--cachekey------------------------------------return-cachedresult-----------------déterminer-la-source-de-lecture-optimale--------readsource--this-sourcerouter-routereadqueryclass-query-toarray-----------------exécuter-la-requête-via-la-source-optimale--------handler--this-handlersqueryclass--------result--handler-handlequery-readsource-----------------mettre-en-cache--------this-cachemanager-setcachekey-result-300----------------this-logger-infoquery-executed-and-cached-via-multi-source-cqrs-------------query--queryclass------------source--readsource------------cachekey--cachekey------------------------return-result--------private-function-generatecachekeyqueryinterface-query-string------------return-multi_source_cqrs_query_--md5serializequery-----query-workflow-avec-multi-sourcesphpphpnamespace-appworkflowquerypaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowuse-appinfrastructuremultisourcesourcerouterworkflowinterfaceinterface-paymentmultisourcecqrsqueryworkflowinterface----workflowmethod----public-function-searchpaymentswithmultisourcecqrspaymentsearchquery-query-paymentsearchresult--------workflowmethod----public-function-getpaymentbyidwithmultisourcecqrspaymentbyidquery-query-payment--------workflowmethod----public-function-getpaymentstatisticswithmultisourcecqrspaymentstatisticsquery-query-array--------workflowmethod----public-function-getpaymentanalyticswithmultisourcecqrspaymentanalyticsquery-query-array--------workflowmethod----public-function-getpaymenttimelinewithmultisourcecqrspaymenttimelinequery-query-arrayactivityinterfaceinterface-paymentmultisourcecqrsqueryactivityinterface----activitymethod----public-function-searchpaymentsinsourcepaymentsearchquery-query-string-source-array--------activitymethod----public-function-getpaymentfromsourcestring-paymentid-string-source-payment--------activitymethod----public-function-calculatepaymentstatisticsinsourcepaymentstatisticsquery-query-string-source-array--------activitymethod----public-function-generatepaymentanalyticsinsourcepaymentanalyticsquery-query-string-source-array--------activitymethod----public-function-geteventsbycorrelationidstring-correlationid-string-source-array--------activitymethod----public-function-updatequerymodelsarray-events-voidclass-paymentmultisourcecqrsqueryworkflow-implements-paymentmultisourcecqrsqueryworkflowinterface----private-paymentmultisourcecqrsqueryactivityinterface-queryactivity----private-sourcerouter-sourcerouter----public-function-__construct------------this-queryactivity--workflownewactivitystubpaymentmultisourcecqrsqueryactivityinterfaceclass--------this-sourcerouter--workflownewactivitystubsourcerouterclass--------public-function-searchpaymentswithmultisourcecqrspaymentsearchquery-query-paymentsearchresult------------try--------------déterminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadsearch-query-toarray-------------------------recherche-dans-la-source-optimale------------payments--yield-this-queryactivity-searchpaymentsinsourcequery-readsource-------------------------filtrage-et-tri------------filteredpayments--this-filterpaymentspayments-query------------sortedpayments--this-sortpaymentsfilteredpayments-query-------------------------pagination------------paginatedpayments--this-paginatepaymentssortedpayments-query------------------------return-new-paymentsearchresult----------------paginatedpayments----------------countfilteredpayments----------------query-getpage----------------query-getsize---------------------------------catch-exception-e-------------return-new-paymentsearchresult-0-query-getpage-query-getsize----------------public-function-getpaymentbyidwithmultisourcecqrspaymentbyidquery-query-payment------------try--------------déterminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadfindbyid-id--query-getpaymentid------------------------return-yield-this-queryactivity-getpaymentfromsourcequery-getpaymentid-readsource---------catch-exception-e-------------return-null----------------public-function-getpaymentstatisticswithmultisourcecqrspaymentstatisticsquery-query-array------------try--------------déterminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadstatistics-query-toarray------------------------return-yield-this-queryactivity-calculatepaymentstatisticsinsourcequery-readsource---------catch-exception-e-------------return-----------------public-function-getpaymentanalyticswithmultisourcecqrspaymentanalyticsquery-query-array------------try--------------déterminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadanalytics-query-toarray------------------------return-yield-this-queryactivity-generatepaymentanalyticsinsourcequery-readsource---------catch-exception-e-------------return-----------------public-function-getpaymenttimelinewithmultisourcecqrspaymenttimelinequery-query-array------------try--------------déterminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadtimeline-query-toarray------------------------events--yield-this-queryactivity-geteventsbycorrelationidquery-getcorrelationid-readsource------------------------timeline--------------foreach-events-as-event-----------------timeline----------------------eventid--event-getid--------------------aggregateid--event-getaggregateid--------------------eventtype--event-geteventtype--------------------timestamp--event-gettimestamp--------------------data--event-toarray--------------------metadata--event-getmetadata----------------------------------------------------return-timeline---------------------catch-exception-e-------------return-----------------private-function-filterpaymentsarray-payments-paymentsearchquery-query-array------------return-array_filterpayments-functionpayment-use-query-------------if-query-getorganizationid--payment-getorganizationid--query-getorganizationid-----------------return-false------------------------------------if-query-getstatus--payment-getstatus--query-getstatus-----------------return-false------------------------------------if-query-getminamount--payment-getamount--query-getminamount-----------------return-false------------------------------------if-query-getmaxamount--payment-getamount--query-getmaxamount-----------------return-false------------------------------------return-true----------------private-function-sortpaymentsarray-payments-paymentsearchquery-query-array------------sortfield--query-getsortfield--createdat--------sortdirection--query-getsortdirection--desc----------------usortpayments-functiona-b-use-sortfield-sortdirection-------------valuea--this-getfieldvaluea-sortfield------------valueb--this-getfieldvalueb-sortfield------------------------if-sortdirection--asc-----------------return-valuea--valueb-------------else-----------------return-valueb--valuea------------------------------------return-payments--------private-function-paginatepaymentsarray-payments-paymentsearchquery-query-array------------page--query-getpage--1--------size--query-getsize--10--------offset--page---1--size----------------return-array_slicepayments-offset-size--------private-function-getfieldvaluepayment-payment-string-field-mixed------------switch-field-------------case-amount----------------return-payment-getamount------------case-createdat----------------return-payment-getcreatedat------------case-status----------------return-payment-getstatus------------default----------------return-payment-getcreatedat-------------3-service-de-projection-avancé-avec-multi-sources-service-de-projection-avec-multi-sourcesphpphpnamespace-appapplicationservicemultisourceuse-appdomaineventdomaineventuse-appinfrastructuremultisourcesourcerouteruse-appinfrastructuremultisourcemultisourcecachemanageruse-psrlogloggerinterfaceclass-multisourcecqrsprojectionservice----private-sourcerouter-sourcerouter----private-multisourcecachemanager-cachemanager----private-loggerinterface-logger----public-function-__construct--------sourcerouter-sourcerouter--------multisourcecachemanager-cachemanager--------loggerinterface-logger-------------this-sourcerouter--sourcerouter--------this-cachemanager--cachemanager--------this-logger--logger--------public-function-handleeventdomainevent-event-void------------try-------------this-logger-infohandling-event-via-multi-source-cqrs-----------------eventtype--event-geteventtype----------------eventid--event-getid-------------------------déterminer-les-sources-affectées------------affectedsources--this-determineaffectedsourcesevent-------------------------mettre-à-jour-chaque-source------------foreach-affectedsources-as-source-----------------this-updatesourcesource-event-------------------------------------invalider-le-cache-si-nécessaire------------if-this-shouldinvalidatecacheevent-----------------this-invalidatecacheevent---------------------------------catch-exception-e-------------this-logger-errorfailed-to-handle-event-via-multi-source-cqrs-----------------eventtype--event-geteventtype----------------error--e-getmessage------------------------------------throw-e----------------public-function-rebuildprojectionstring-projectiontype-void------------try-------------this-logger-inforebuilding-projection-via-multi-source-cqrs-----------------projectiontype--projectiontype-------------------------------------reconstruire-la-projection-dans-toutes-les-sources-pertinentes------------sources--this-getprojectionsourcesprojectiontype------------------------foreach-sources-as-source-----------------this-rebuildprojectioninsourceprojectiontype-source------------------------------------this-logger-infoprojection-rebuilt-successfully-via-multi-source-cqrs-----------------projectiontype--projectiontype---------------------------------catch-exception-e-------------this-logger-errorfailed-to-rebuild-projection-via-multi-source-cqrs-----------------projectiontype--projectiontype----------------error--e-getmessage------------------------------------throw-e----------------private-function-determineaffectedsourcesdomainevent-event-array------------sources-------------------toujours-affecter-la-base-de-données-pour-les-événements-critiques--------if-this-iscriticaleventevent-------------sources--database-------------------------affecter-le-cache-pour-les-événements-de-lecture--------if-this-isreadeventevent-------------sources--cache-------------------------affecter-elasticsearch-pour-les-événements-de-recherche--------if-this-issearcheventevent-------------sources--elasticsearch-------------------------affecter-les-read-models-pour-les-projections--------if-this-isprojectioneventevent-------------sources--read_models------------------------return-sources--------private-function-updatesourcestring-source-domainevent-event-void------------this-logger-debugupdating-source-------------source--source------------eventtype--event-geteventtype-------------------------implémentation-spécifique-à-chaque-source--------switch-source-------------case-database----------------this-updatedatabaseevent----------------break------------case-cache----------------this-updatecacheevent----------------break------------case-elasticsearch----------------this-updateelasticsearchevent----------------break------------case-read_models----------------this-updatereadmodelsevent----------------break----------------private-function-shouldinvalidatecachedomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentupdated------------paymentdeleted------------paymentstatuschanged----------------private-function-invalidatecachedomainevent-event-void------------this-logger-debuginvalidating-cache-------------eventtype--event-geteventtype-------------------------invalider-les-caches-pertinents--------if-issetevent-getdatapaymentid-------------this-cachemanager-deletepaymentevent-getdatapaymentid----------------private-function-iscriticaleventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentcreated------------paymentupdated------------paymentdeleted----------------private-function-isreadeventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentviewed------------paymentsearched----------------private-function-issearcheventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentcreated------------paymentupdated------------paymentdeleted----------------private-function-isprojectioneventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentcreated------------paymentupdated------------paymentdeleted------------paymentstatuschanged----------------private-function-getprojectionsourcesstring-projectiontype-array------------switch-projectiontype-------------case-payment_summary----------------return-database-cache-elasticsearch------------case-payment_analytics----------------return-elasticsearch-read_models------------case-payment_timeline----------------return-read_models-cache------------default----------------return-database----------------private-function-rebuildprojectioninsourcestring-projectiontype-string-source-void------------this-logger-debugrebuilding-projection-in-source-------------projectiontype--projectiontype------------source--source-------------------------implémentation-spécifique-à-chaque-source--------switch-source-------------case-database----------------this-rebuilddatabaseprojectionprojectiontype----------------break------------case-cache----------------this-rebuildcacheprojectionprojectiontype----------------break------------case-elasticsearch----------------this-rebuildelasticsearchprojectionprojectiontype----------------break------------case-read_models----------------this-rebuildreadmodelsprojectionprojectiontype----------------break----------------private-function-updatedatabasedomainevent-event-void-------------implémentation-de-la-mise-à-jour-de-la-base-de-données--------private-function-updatecachedomainevent-event-void-------------implémentation-de-la-mise-à-jour-du-cache--------private-function-updateelasticsearchdomainevent-event-void-------------implémentation-de-la-mise-à-jour-delasticsearch--------private-function-updatereadmodelsdomainevent-event-void-------------implémentation-de-la-mise-à-jour-des-read-models--------private-function-rebuilddatabaseprojectionstring-projectiontype-void-------------implémentation-de-la-reconstruction-de-la-projection-en-base-de-données--------private-function-rebuildcacheprojectionstring-projectiontype-void-------------implémentation-de-la-reconstruction-de-la-projection-en-cache--------private-function-rebuildelasticsearchprojectionstring-projectiontype-void-------------implémentation-de-la-reconstruction-de-la-projection-en-elasticsearch--------private-function-rebuildreadmodelsprojectionstring-projectiontype-void-------------implémentation-de-la-reconstruction-de-la-projection-dans-les-read-models------tests-et-validation-tests-dphpphpnamespace-apptestsintegrationmultisourceuse-appworkflowcommandpaymentpaymentcommandrequestuse-appworkflowquerypaymentpaymentsearchqueryuse-appapplicationcommandbusmultisourcemultisourcecqrscommandbususe-appapplicationquerybusmultisourcemultisourcecqrsquerybususe-appinfrastructuremultisourcesourcerouterclass-multisourcecqrstest-extends-testcase----private-multisourcecqrscommandbus-commandbus----private-multisourcecqrsquerybus-querybus----private-sourcerouter-sourcerouter----protected-function-setup-void------------this-sourcerouter--this-createmocksourcerouterclass--------this-commandbus--new-multisourcecqrscommandbus------------this-sourcerouter------------this-createmockloggerinterfaceclass----------------this-querybus--new-multisourcecqrsquerybus------------this-sourcerouter------------this-createmockmultisourcecachemanagerclass------------this-createmockloggerinterfaceclass----------------public-function-testcqrsseparationwithmultisource-void-------------exécuter-une-commande-avec-multi-source-cqrs--------command--new-paymentcommandrequest------------create------------payment-123------------org-456------------user-789------------10000------------eur------------test-payment------------------------this-commandbus-handlecommand-----------------vérifier-avec-une-requête--------query--new-paymentsearchqueryorg-456-0-10--------result--this-querybus-handlequery----------------this-assertgreaterthan0-result-gettotal--------public-function-testquerycachingwithmultisource-void------------query--new-paymentsearchqueryorg-456-0-10-----------------première-recherche--------result1--this-querybus-handlequery-----------------deuxième-recherche-devrait-utiliser-le-cache--------result2--this-querybus-handlequery----------------this-assertequalsresult1-gettotal-result2-gettotal------performance-et-optimisation-stratégies-d-1-cache-multi-niveaux-avec-multi-sourcesphppublic-function-searchpaymentswithcachepaymentsearchquery-query-paymentsearchresult-----cache-l1-mémoire----if-issetthis-memorycachequery-getcachekey---------return-this-memorycachequery-getcachekey-------------cache-l2-redis----if-cached--this-redis-getpayment_search_ms_cqrsquery-getcachekey---------result--paymentsearchresultfromarrayjson_decodecached-true--------this-memorycachequery-getcachekey--result--------return-result-------------multi-source-cqrs----result--this-searchpaymentswithmultisourcecqrsquery---------mettre-en-cache----this-memorycachequery-getcachekey--result----this-redis-setexpayment_search_ms_cqrsquery-getcachekey-300-json_encoderesult-toarray--------return-result-2-projections-asynchrones-avec-multi-sourcesphppublic-function-handleeventasyncdomainevent-event-void-----mettre-en-queue-pour-traitement-asynchrone----this-messagebus-dispatchnew-processmultisourcecqrsprojectioncommandevent-3-monitoring-des-sources-multi-sourcesphppublic-function-getmultisourcecqrsmetrics-array----return---------commandsources--this-getcommandsourcemetrics--------querysources--this-getquerysourcemetrics--------projections--this-getprojectionmetrics--------cachehitrate--this-getcachehitrate--------sourcehealth--this-getsourcehealth--------averageexecutiontime--this-getaverageexecutiontime------critères-d-quand-utiliser-cqrs-avec-multi-sources--avantages--séparation-totale--commandes-et-requêtes-complètement-découplées--flexibilité-maximale--choix-du-meilleur-stockage-pour-chaque-opération--scalabilité-maximale--possibilité-de-scaler-indépendamment--performance-optimale--chaque-côté-optimisé-pour-son-usage--résilience--redondance-et-failover-entre-sources--maintenabilité--code-plus-clair-et-organisé--inconvénients--complexité-maximale--gestion-de-plusieurs-sources-de-données--cohérence--risque-dincohérence-entre-sources--maintenance--plus-de-sources-à-maintenir--expertise--équipe-très-expérimentée-requise--coût--infrastructure-très-coûteuse--critères-d--système-très-complexe--besoins-de-scalabilité-maximale--données-hétérogènes--types-de-données-différents-nécessitant-différents-stockages--performance-critique--besoins-de-performance-maximale--séparation-des-responsabilités--besoin-de-séparer-clairement-les-commandes-et-requêtes--équipe-très-expérimentée--maîtrise-de-plusieurs-technologies-de-stockage-et-cqrs--budget-important--investissement-en-infrastructure-multiple--temps-de-développement--suffisant-pour-implémenter-cette-complexité--maintenance--équipe-capable-de-maintenir-cette-complexité--votre-prochaine-étapehahahugoshortcode60s0hbhbcqrs-avec-multi-sources-représente-l"&gt;🎯 &lt;strong&gt;Contexte et Objectifs&lt;/strong&gt;### &lt;strong&gt;L&amp;rsquo;Architecture Maximale : CQRS avec Multi-sources&lt;/strong&gt;Nous arrivons maintenant à l&amp;rsquo;approche la plus sophistiquée pour Multi-sources : &lt;strong&gt;CQRS complet&lt;/strong&gt;. Cette combinaison offre une architecture hautement scalable et flexible, parfaite pour les systèmes nécessitant séparation maximale des responsabilités et optimisation des performances.#### &lt;strong&gt;Pourquoi CQRS avec Multi-sources ?&lt;/strong&gt;- &lt;strong&gt;Séparation totale&lt;/strong&gt; : Commandes et requêtes complètement découplées- &lt;strong&gt;Flexibilité maximale&lt;/strong&gt; : Choix du meilleur stockage pour chaque opération- &lt;strong&gt;Scalabilité maximale&lt;/strong&gt; : Possibilité de scaler indépendamment chaque côté- &lt;strong&gt;Performance optimale&lt;/strong&gt; : Chaque côté optimisé pour son usage- &lt;strong&gt;Résilience&lt;/strong&gt; : Redondance et failover entre sources- &lt;strong&gt;Maintenabilité&lt;/strong&gt; : Code plus clair et organisé### &lt;strong&gt;Contexte Gyroscops&lt;/strong&gt;Dans notre écosystème &lt;strong&gt;User → Organization → Workflow → Cloud Resources → Billing&lt;/strong&gt;, CQRS avec Multi-sources est la solution ultime pour :- &lt;strong&gt;Workflows de commande&lt;/strong&gt; : Orchestration des processus de modification avec sources optimisées- &lt;strong&gt;Workflows de requête&lt;/strong&gt; : Optimisation des lectures avec sources spécialisées- &lt;strong&gt;Processus de facturation&lt;/strong&gt; : Séparation complète des écritures et lectures de facturation- &lt;strong&gt;Intégrations complexes&lt;/strong&gt; : Orchestration des intégrations avec sources multiples## 🏗️ &lt;strong&gt;Architecture CQRS avec Multi-sources&lt;/strong&gt;### &lt;strong&gt;Séparation Complète des Responsabilités&lt;/strong&gt;#### &lt;strong&gt;Command Side (Write) avec Multi-sources&lt;/strong&gt;- &lt;strong&gt;Command Workflows&lt;/strong&gt; : Orchestration des processus de modification- &lt;strong&gt;Command Activities&lt;/strong&gt; : Exécution des activités de modification- &lt;strong&gt;Event Handlers&lt;/strong&gt; : Gestion des événements de domaine- &lt;strong&gt;Command Bus&lt;/strong&gt; : Orchestration des commandes- &lt;strong&gt;Write Sources&lt;/strong&gt; : Sources optimisées pour les écritures- &lt;strong&gt;Command Models&lt;/strong&gt; : Modèles optimisés pour les écritures- &lt;strong&gt;Projections&lt;/strong&gt; : Mise à jour des vues matérialisées#### &lt;strong&gt;Query Side (Read) avec Multi-sources&lt;/strong&gt;- &lt;strong&gt;Query Workflows&lt;/strong&gt; : Orchestration des processus de lecture- &lt;strong&gt;Query Activities&lt;/strong&gt; : Exécution des activités de lecture- &lt;strong&gt;Search Services&lt;/strong&gt; : Services de recherche spécialisés- &lt;strong&gt;Query Bus&lt;/strong&gt; : Orchestration des requêtes- &lt;strong&gt;Read Sources&lt;/strong&gt; : Sources optimisées pour les lectures- &lt;strong&gt;Query Models&lt;/strong&gt; : Modèles optimisés pour les lectures- &lt;strong&gt;Caches&lt;/strong&gt; : Optimisation des performances### &lt;strong&gt;Flux de Données Complet&lt;/strong&gt;&lt;code&gt;mermaidgraph TD A[Command] --&amp;gt; B[Command Bus] B --&amp;gt; C[Command Workflow] C --&amp;gt; D[Command Activities] D --&amp;gt; E[Write Sources] E --&amp;gt; F[SQL Database] E --&amp;gt; G[Redis Cache] E --&amp;gt; H[File System] E --&amp;gt; I[Event Store] J[Query] --&amp;gt; K[Query Bus] K --&amp;gt; L[Query Workflow] L --&amp;gt; M[Query Activities] M --&amp;gt; N[Read Sources] N --&amp;gt; O[ElasticSearch] N --&amp;gt; P[Redis Cache] N --&amp;gt; Q[SQL Database] N --&amp;gt; R[Read Models] S[Event] --&amp;gt; T[Event Handler] T --&amp;gt; C U[Projection] --&amp;gt; V[Read Model Update] V --&amp;gt; R W[Command Model] --&amp;gt; X[Write Optimization] X --&amp;gt; E Y[Query Model] --&amp;gt; Z[Read Optimization] Z --&amp;gt; N&lt;/code&gt;## 💻 &lt;strong&gt;Implémentation Complète&lt;/strong&gt;### &lt;strong&gt;1. Command Side avec Multi-sources&lt;/strong&gt;#### &lt;strong&gt;Command Bus avec Multi-sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\CommandBus\MultiSource;use App\Domain\Command\CommandInterface;use App\Domain\Command\CommandHandlerInterface;use App\Infrastructure\MultiSource\SourceRouter;use Psr\Log\LoggerInterface;class MultiSourceCqrsCommandBus{ private array $handlers = []; private array $middleware = []; private SourceRouter $sourceRouter; private LoggerInterface $logger; public function __construct( SourceRouter $sourceRouter, LoggerInterface $logger ) { $this-&amp;gt;sourceRouter = $sourceRouter; $this-&amp;gt;logger = $logger; } public function registerHandler(string $commandClass, CommandHandlerInterface $handler): void { $this-&amp;gt;handlers[$commandClass] = $handler; } public function addMiddleware(callable $middleware): void { $this-&amp;gt;middleware[] = $middleware; } public function handle(CommandInterface $command): void { $commandClass = get_class($command); if (!isset($this-&amp;gt;handlers[$commandClass])) { throw new \InvalidArgumentException(&amp;quot;No handler registered for command: $commandClass&amp;quot;); } $handler = $this-&amp;gt;handlers[$commandClass]; // Exécuter les middleware $this-&amp;gt;executeMiddleware($command, function() use ($handler, $command) { $this-&amp;gt;logger-&amp;gt;info('Executing command via Multi-source CQRS', [ 'command' =&amp;gt; get_class($command), 'data' =&amp;gt; $command-&amp;gt;toArray() ]); $handler-&amp;gt;handle($command); }); } private function executeMiddleware(CommandInterface $command, callable $next): void { $middleware = array_reverse($this-&amp;gt;middleware); foreach ($middleware as $mw) { $next = function() use ($mw, $command, $next) { return $mw($command, $next); }; } $next(); }}&lt;/code&gt;#### &lt;strong&gt;Command Workflow avec Multi-sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Workflow\Command\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Infrastructure\MultiSource\SourceRouter;#[WorkflowInterface]interface PaymentMultiSourceCqrsCommandWorkflowInterface{ #[WorkflowMethod] public function processPaymentCommandWithMultiSourceCqrs(PaymentCommandRequest $request): PaymentCommandResult; #[WorkflowMethod] public function updatePaymentCommandWithMultiSourceCqrs(PaymentUpdateCommandRequest $request): PaymentCommandResult; #[WorkflowMethod] public function deletePaymentCommandWithMultiSourceCqrs(PaymentDeleteCommandRequest $request): PaymentCommandResult;}#[ActivityInterface]interface PaymentMultiSourceCqrsCommandActivityInterface{ #[ActivityMethod] public function validatePaymentCommand(PaymentCommandRequest $request): ValidationResult; #[ActivityMethod] public function executePaymentCommand(PaymentCommandRequest $request): CommandExecutionResult; #[ActivityMethod] public function persistToWriteSources(Payment $payment, array $sources): void; #[ActivityMethod] public function updateProjections(Payment $payment): void; #[ActivityMethod] public function updateCommandModels(Payment $payment): void;}class PaymentMultiSourceCqrsCommandWorkflow implements PaymentMultiSourceCqrsCommandWorkflowInterface{ private PaymentMultiSourceCqrsCommandActivityInterface $commandActivity; private SourceRouter $sourceRouter; public function __construct() { $this-&amp;gt;commandActivity = Workflow::newActivityStub(PaymentMultiSourceCqrsCommandActivityInterface::class); $this-&amp;gt;sourceRouter = Workflow::newActivityStub(SourceRouter::class); } public function processPaymentCommandWithMultiSourceCqrs(PaymentCommandRequest $request): PaymentCommandResult { try { // Validation de la commande $validation = yield $this-&amp;gt;commandActivity-&amp;gt;validatePaymentCommand($request); if (!$validation-&amp;gt;isValid()) { return new PaymentCommandResult(false, $validation-&amp;gt;getError()); } // Exécution de la commande $execution = yield $this-&amp;gt;commandActivity-&amp;gt;executePaymentCommand($request); if (!$execution-&amp;gt;isSuccess()) { return new PaymentCommandResult(false, $execution-&amp;gt;getError()); } // Déterminer les sources d'écriture optimales $writeSources = yield $this-&amp;gt;sourceRouter-&amp;gt;routeWrite('save', $execution-&amp;gt;getPayment()); // Persister dans les sources d'écriture yield $this-&amp;gt;commandActivity-&amp;gt;persistToWriteSources($execution-&amp;gt;getPayment(), $writeSources); // Mettre à jour les projections yield $this-&amp;gt;commandActivity-&amp;gt;updateProjections($execution-&amp;gt;getPayment()); // Mettre à jour les modèles de commande yield $this-&amp;gt;commandActivity-&amp;gt;updateCommandModels($execution-&amp;gt;getPayment()); return new PaymentCommandResult(true, 'Payment command processed with Multi-source CQRS'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e-&amp;gt;getMessage()); } } public function updatePaymentCommandWithMultiSourceCqrs(PaymentUpdateCommandRequest $request): PaymentCommandResult { try { // Validation de la commande de mise à jour $validation = yield $this-&amp;gt;commandActivity-&amp;gt;validatePaymentCommand($request); if (!$validation-&amp;gt;isValid()) { return new PaymentCommandResult(false, $validation-&amp;gt;getError()); } // Exécution de la mise à jour $execution = yield $this-&amp;gt;commandActivity-&amp;gt;executePaymentCommand($request); if (!$execution-&amp;gt;isSuccess()) { return new PaymentCommandResult(false, $execution-&amp;gt;getError()); } // Déterminer les sources d'écriture optimales $writeSources = yield $this-&amp;gt;sourceRouter-&amp;gt;routeWrite('update', $execution-&amp;gt;getPayment()); // Persister dans les sources d'écriture yield $this-&amp;gt;commandActivity-&amp;gt;persistToWriteSources($execution-&amp;gt;getPayment(), $writeSources); // Mettre à jour les projections yield $this-&amp;gt;commandActivity-&amp;gt;updateProjections($execution-&amp;gt;getPayment()); // Mettre à jour les modèles de commande yield $this-&amp;gt;commandActivity-&amp;gt;updateCommandModels($execution-&amp;gt;getPayment()); return new PaymentCommandResult(true, 'Payment update command processed with Multi-source CQRS'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e-&amp;gt;getMessage()); } } public function deletePaymentCommandWithMultiSourceCqrs(PaymentDeleteCommandRequest $request): PaymentCommandResult { try { // Validation de la commande de suppression $validation = yield $this-&amp;gt;commandActivity-&amp;gt;validatePaymentCommand($request); if (!$validation-&amp;gt;isValid()) { return new PaymentCommandResult(false, $validation-&amp;gt;getError()); } // Exécution de la suppression $execution = yield $this-&amp;gt;commandActivity-&amp;gt;executePaymentCommand($request); if (!$execution-&amp;gt;isSuccess()) { return new PaymentCommandResult(false, $execution-&amp;gt;getError()); } // Déterminer les sources d'écriture optimales $writeSources = yield $this-&amp;gt;sourceRouter-&amp;gt;routeWrite('delete', $execution-&amp;gt;getPayment()); // Persister dans les sources d'écriture yield $this-&amp;gt;commandActivity-&amp;gt;persistToWriteSources($execution-&amp;gt;getPayment(), $writeSources); // Mettre à jour les projections yield $this-&amp;gt;commandActivity-&amp;gt;updateProjections($execution-&amp;gt;getPayment()); // Mettre à jour les modèles de commande yield $this-&amp;gt;commandActivity-&amp;gt;updateCommandModels($execution-&amp;gt;getPayment()); return new PaymentCommandResult(true, 'Payment delete command processed with Multi-source CQRS'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e-&amp;gt;getMessage()); } }}&lt;/code&gt;### &lt;strong&gt;2. Query Side avec Multi-sources&lt;/strong&gt;#### &lt;strong&gt;Query Bus avec Cache et Multi-sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\QueryBus\MultiSource;use App\Domain\Query\QueryInterface;use App\Domain\Query\QueryHandlerInterface;use App\Infrastructure\MultiSource\SourceRouter;use App\Infrastructure\MultiSource\MultiSourceCacheManager;use Psr\Log\LoggerInterface;class MultiSourceCqrsQueryBus{ private array $handlers = []; private SourceRouter $sourceRouter; private MultiSourceCacheManager $cacheManager; private LoggerInterface $logger; public function __construct( SourceRouter $sourceRouter, MultiSourceCacheManager $cacheManager, LoggerInterface $logger ) { $this-&amp;gt;sourceRouter = $sourceRouter; $this-&amp;gt;cacheManager = $cacheManager; $this-&amp;gt;logger = $logger; } public function registerHandler(string $queryClass, QueryHandlerInterface $handler): void { $this-&amp;gt;handlers[$queryClass] = $handler; } public function handle(QueryInterface $query): mixed { $queryClass = get_class($query); if (!isset($this-&amp;gt;handlers[$queryClass])) { throw new \InvalidArgumentException(&amp;quot;No handler registered for query: $queryClass&amp;quot;); } // Vérifier le cache $cacheKey = $this-&amp;gt;generateCacheKey($query); $cachedResult = $this-&amp;gt;cacheManager-&amp;gt;get($cacheKey); if ($cachedResult !== null) { $this-&amp;gt;logger-&amp;gt;debug('Query result served from cache', [ 'query' =&amp;gt; $queryClass, 'cacheKey' =&amp;gt; $cacheKey ]); return $cachedResult; } // Déterminer la source de lecture optimale $readSource = $this-&amp;gt;sourceRouter-&amp;gt;routeRead($queryClass, $query-&amp;gt;toArray()); // Exécuter la requête via la source optimale $handler = $this-&amp;gt;handlers[$queryClass]; $result = $handler-&amp;gt;handle($query, $readSource); // Mettre en cache $this-&amp;gt;cacheManager-&amp;gt;set($cacheKey, $result, 300); $this-&amp;gt;logger-&amp;gt;info('Query executed and cached via Multi-source CQRS', [ 'query' =&amp;gt; $queryClass, 'source' =&amp;gt; $readSource, 'cacheKey' =&amp;gt; $cacheKey ]); return $result; } private function generateCacheKey(QueryInterface $query): string { return 'multi_source_cqrs_query_' . md5(serialize($query)); }}&lt;/code&gt;#### &lt;strong&gt;Query Workflow avec Multi-sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Workflow\Query\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Infrastructure\MultiSource\SourceRouter;#[WorkflowInterface]interface PaymentMultiSourceCqrsQueryWorkflowInterface{ #[WorkflowMethod] public function searchPaymentsWithMultiSourceCqrs(PaymentSearchQuery $query): PaymentSearchResult; #[WorkflowMethod] public function getPaymentByIdWithMultiSourceCqrs(PaymentByIdQuery $query): ?Payment; #[WorkflowMethod] public function getPaymentStatisticsWithMultiSourceCqrs(PaymentStatisticsQuery $query): array; #[WorkflowMethod] public function getPaymentAnalyticsWithMultiSourceCqrs(PaymentAnalyticsQuery $query): array; #[WorkflowMethod] public function getPaymentTimelineWithMultiSourceCqrs(PaymentTimelineQuery $query): array;}#[ActivityInterface]interface PaymentMultiSourceCqrsQueryActivityInterface{ #[ActivityMethod] public function searchPaymentsInSource(PaymentSearchQuery $query, string $source): array; #[ActivityMethod] public function getPaymentFromSource(string $paymentId, string $source): ?Payment; #[ActivityMethod] public function calculatePaymentStatisticsInSource(PaymentStatisticsQuery $query, string $source): array; #[ActivityMethod] public function generatePaymentAnalyticsInSource(PaymentAnalyticsQuery $query, string $source): array; #[ActivityMethod] public function getEventsByCorrelationId(string $correlationId, string $source): array; #[ActivityMethod] public function updateQueryModels(array $events): void;}class PaymentMultiSourceCqrsQueryWorkflow implements PaymentMultiSourceCqrsQueryWorkflowInterface{ private PaymentMultiSourceCqrsQueryActivityInterface $queryActivity; private SourceRouter $sourceRouter; public function __construct() { $this-&amp;gt;queryActivity = Workflow::newActivityStub(PaymentMultiSourceCqrsQueryActivityInterface::class); $this-&amp;gt;sourceRouter = Workflow::newActivityStub(SourceRouter::class); } public function searchPaymentsWithMultiSourceCqrs(PaymentSearchQuery $query): PaymentSearchResult { try { // Déterminer la source de lecture optimale $readSource = yield $this-&amp;gt;sourceRouter-&amp;gt;routeRead('search', $query-&amp;gt;toArray()); // Recherche dans la source optimale $payments = yield $this-&amp;gt;queryActivity-&amp;gt;searchPaymentsInSource($query, $readSource); // Filtrage et tri $filteredPayments = $this-&amp;gt;filterPayments($payments, $query); $sortedPayments = $this-&amp;gt;sortPayments($filteredPayments, $query); // Pagination $paginatedPayments = $this-&amp;gt;paginatePayments($sortedPayments, $query); return new PaymentSearchResult( $paginatedPayments, count($filteredPayments), $query-&amp;gt;getPage(), $query-&amp;gt;getSize() ); } catch (\Exception $e) { return new PaymentSearchResult([], 0, $query-&amp;gt;getPage(), $query-&amp;gt;getSize()); } } public function getPaymentByIdWithMultiSourceCqrs(PaymentByIdQuery $query): ?Payment { try { // Déterminer la source de lecture optimale $readSource = yield $this-&amp;gt;sourceRouter-&amp;gt;routeRead('findById', ['id' =&amp;gt; $query-&amp;gt;getPaymentId()]); return yield $this-&amp;gt;queryActivity-&amp;gt;getPaymentFromSource($query-&amp;gt;getPaymentId(), $readSource); } catch (\Exception $e) { return null; } } public function getPaymentStatisticsWithMultiSourceCqrs(PaymentStatisticsQuery $query): array { try { // Déterminer la source de lecture optimale $readSource = yield $this-&amp;gt;sourceRouter-&amp;gt;routeRead('statistics', $query-&amp;gt;toArray()); return yield $this-&amp;gt;queryActivity-&amp;gt;calculatePaymentStatisticsInSource($query, $readSource); } catch (\Exception $e) { return []; } } public function getPaymentAnalyticsWithMultiSourceCqrs(PaymentAnalyticsQuery $query): array { try { // Déterminer la source de lecture optimale $readSource = yield $this-&amp;gt;sourceRouter-&amp;gt;routeRead('analytics', $query-&amp;gt;toArray()); return yield $this-&amp;gt;queryActivity-&amp;gt;generatePaymentAnalyticsInSource($query, $readSource); } catch (\Exception $e) { return []; } } public function getPaymentTimelineWithMultiSourceCqrs(PaymentTimelineQuery $query): array { try { // Déterminer la source de lecture optimale $readSource = yield $this-&amp;gt;sourceRouter-&amp;gt;routeRead('timeline', $query-&amp;gt;toArray()); $events = yield $this-&amp;gt;queryActivity-&amp;gt;getEventsByCorrelationId($query-&amp;gt;getCorrelationId(), $readSource); $timeline = []; foreach ($events as $event) { $timeline[] = [ 'eventId' =&amp;gt; $event-&amp;gt;getId(), 'aggregateId' =&amp;gt; $event-&amp;gt;getAggregateId(), 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'timestamp' =&amp;gt; $event-&amp;gt;getTimestamp(), 'data' =&amp;gt; $event-&amp;gt;toArray(), 'metadata' =&amp;gt; $event-&amp;gt;getMetadata() ]; } return $timeline; } catch (\Exception $e) { return []; } } private function filterPayments(array $payments, PaymentSearchQuery $query): array { return array_filter($payments, function($payment) use ($query) { if ($query-&amp;gt;getOrganizationId() &amp;amp;&amp;amp; $payment-&amp;gt;getOrganizationId() !== $query-&amp;gt;getOrganizationId()) { return false; } if ($query-&amp;gt;getStatus() &amp;amp;&amp;amp; $payment-&amp;gt;getStatus() !== $query-&amp;gt;getStatus()) { return false; } if ($query-&amp;gt;getMinAmount() &amp;amp;&amp;amp; $payment-&amp;gt;getAmount() &amp;lt; $query-&amp;gt;getMinAmount()) { return false; } if ($query-&amp;gt;getMaxAmount() &amp;amp;&amp;amp; $payment-&amp;gt;getAmount() &amp;gt; $query-&amp;gt;getMaxAmount()) { return false; } return true; }); } private function sortPayments(array $payments, PaymentSearchQuery $query): array { $sortField = $query-&amp;gt;getSortField() ?? 'createdAt'; $sortDirection = $query-&amp;gt;getSortDirection() ?? 'desc'; usort($payments, function($a, $b) use ($sortField, $sortDirection) { $valueA = $this-&amp;gt;getFieldValue($a, $sortField); $valueB = $this-&amp;gt;getFieldValue($b, $sortField); if ($sortDirection === 'asc') { return $valueA &amp;lt;=&amp;gt; $valueB; } else { return $valueB &amp;lt;=&amp;gt; $valueA; } }); return $payments; } private function paginatePayments(array $payments, PaymentSearchQuery $query): array { $page = $query-&amp;gt;getPage() ?? 1; $size = $query-&amp;gt;getSize() ?? 10; $offset = ($page - 1) * $size; return array_slice($payments, $offset, $size); } private function getFieldValue(Payment $payment, string $field): mixed { switch ($field) { case 'amount': return $payment-&amp;gt;getAmount(); case 'createdAt': return $payment-&amp;gt;getCreatedAt(); case 'status': return $payment-&amp;gt;getStatus(); default: return $payment-&amp;gt;getCreatedAt(); } }}&lt;/code&gt;### &lt;strong&gt;3. Service de Projection Avancé avec Multi-sources&lt;/strong&gt;#### &lt;strong&gt;Service de Projection avec Multi-sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Service\MultiSource;use App\Domain\Event\DomainEvent;use App\Infrastructure\MultiSource\SourceRouter;use App\Infrastructure\MultiSource\MultiSourceCacheManager;use Psr\Log\LoggerInterface;class MultiSourceCqrsProjectionService{ private SourceRouter $sourceRouter; private MultiSourceCacheManager $cacheManager; private LoggerInterface $logger; public function __construct( SourceRouter $sourceRouter, MultiSourceCacheManager $cacheManager, LoggerInterface $logger ) { $this-&amp;gt;sourceRouter = $sourceRouter; $this-&amp;gt;cacheManager = $cacheManager; $this-&amp;gt;logger = $logger; } public function handleEvent(DomainEvent $event): void { try { $this-&amp;gt;logger-&amp;gt;info('Handling event via Multi-source CQRS', [ 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'eventId' =&amp;gt; $event-&amp;gt;getId() ]); // Déterminer les sources affectées $affectedSources = $this-&amp;gt;determineAffectedSources($event); // Mettre à jour chaque source foreach ($affectedSources as $source) { $this-&amp;gt;updateSource($source, $event); } // Invalider le cache si nécessaire if ($this-&amp;gt;shouldInvalidateCache($event)) { $this-&amp;gt;invalidateCache($event); } } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to handle event via Multi-source CQRS', [ 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } public function rebuildProjection(string $projectionType): void { try { $this-&amp;gt;logger-&amp;gt;info('Rebuilding projection via Multi-source CQRS', [ 'projectionType' =&amp;gt; $projectionType ]); // Reconstruire la projection dans toutes les sources pertinentes $sources = $this-&amp;gt;getProjectionSources($projectionType); foreach ($sources as $source) { $this-&amp;gt;rebuildProjectionInSource($projectionType, $source); } $this-&amp;gt;logger-&amp;gt;info('Projection rebuilt successfully via Multi-source CQRS', [ 'projectionType' =&amp;gt; $projectionType ]); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to rebuild projection via Multi-source CQRS', [ 'projectionType' =&amp;gt; $projectionType, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } private function determineAffectedSources(DomainEvent $event): array { $sources = []; // Toujours affecter la base de données pour les événements critiques if ($this-&amp;gt;isCriticalEvent($event)) { $sources[] = 'database'; } // Affecter le cache pour les événements de lecture if ($this-&amp;gt;isReadEvent($event)) { $sources[] = 'cache'; } // Affecter ElasticSearch pour les événements de recherche if ($this-&amp;gt;isSearchEvent($event)) { $sources[] = 'elasticsearch'; } // Affecter les Read Models pour les projections if ($this-&amp;gt;isProjectionEvent($event)) { $sources[] = 'read_models'; } return $sources; } private function updateSource(string $source, DomainEvent $event): void { $this-&amp;gt;logger-&amp;gt;debug('Updating source', [ 'source' =&amp;gt; $source, 'eventType' =&amp;gt; $event-&amp;gt;getEventType() ]); // Implémentation spécifique à chaque source switch ($source) { case 'database': $this-&amp;gt;updateDatabase($event); break; case 'cache': $this-&amp;gt;updateCache($event); break; case 'elasticsearch': $this-&amp;gt;updateElasticSearch($event); break; case 'read_models': $this-&amp;gt;updateReadModels($event); break; } } private function shouldInvalidateCache(DomainEvent $event): bool { return in_array($event-&amp;gt;getEventType(), [ 'PaymentUpdated', 'PaymentDeleted', 'PaymentStatusChanged' ]); } private function invalidateCache(DomainEvent $event): void { $this-&amp;gt;logger-&amp;gt;debug('Invalidating cache', [ 'eventType' =&amp;gt; $event-&amp;gt;getEventType() ]); // Invalider les caches pertinents if (isset($event-&amp;gt;getData()['paymentId'])) { $this-&amp;gt;cacheManager-&amp;gt;deletePayment($event-&amp;gt;getData()['paymentId']); } } private function isCriticalEvent(DomainEvent $event): bool { return in_array($event-&amp;gt;getEventType(), [ 'PaymentCreated', 'PaymentUpdated', 'PaymentDeleted' ]); } private function isReadEvent(DomainEvent $event): bool { return in_array($event-&amp;gt;getEventType(), [ 'PaymentViewed', 'PaymentSearched' ]); } private function isSearchEvent(DomainEvent $event): bool { return in_array($event-&amp;gt;getEventType(), [ 'PaymentCreated', 'PaymentUpdated', 'PaymentDeleted' ]); } private function isProjectionEvent(DomainEvent $event): bool { return in_array($event-&amp;gt;getEventType(), [ 'PaymentCreated', 'PaymentUpdated', 'PaymentDeleted', 'PaymentStatusChanged' ]); } private function getProjectionSources(string $projectionType): array { switch ($projectionType) { case 'payment_summary': return ['database', 'cache', 'elasticsearch']; case 'payment_analytics': return ['elasticsearch', 'read_models']; case 'payment_timeline': return ['read_models', 'cache']; default: return ['database']; } } private function rebuildProjectionInSource(string $projectionType, string $source): void { $this-&amp;gt;logger-&amp;gt;debug('Rebuilding projection in source', [ 'projectionType' =&amp;gt; $projectionType, 'source' =&amp;gt; $source ]); // Implémentation spécifique à chaque source switch ($source) { case 'database': $this-&amp;gt;rebuildDatabaseProjection($projectionType); break; case 'cache': $this-&amp;gt;rebuildCacheProjection($projectionType); break; case 'elasticsearch': $this-&amp;gt;rebuildElasticSearchProjection($projectionType); break; case 'read_models': $this-&amp;gt;rebuildReadModelsProjection($projectionType); break; } } private function updateDatabase(DomainEvent $event): void { // Implémentation de la mise à jour de la base de données } private function updateCache(DomainEvent $event): void { // Implémentation de la mise à jour du cache } private function updateElasticSearch(DomainEvent $event): void { // Implémentation de la mise à jour d'ElasticSearch } private function updateReadModels(DomainEvent $event): void { // Implémentation de la mise à jour des Read Models } private function rebuildDatabaseProjection(string $projectionType): void { // Implémentation de la reconstruction de la projection en base de données } private function rebuildCacheProjection(string $projectionType): void { // Implémentation de la reconstruction de la projection en cache } private function rebuildElasticSearchProjection(string $projectionType): void { // Implémentation de la reconstruction de la projection en ElasticSearch } private function rebuildReadModelsProjection(string $projectionType): void { // Implémentation de la reconstruction de la projection dans les Read Models }}&lt;/code&gt;## 🧪 &lt;strong&gt;Tests et Validation&lt;/strong&gt;### &lt;strong&gt;Tests d&amp;rsquo;Intégration CQRS Multi-Sources&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Tests\Integration\MultiSource;use App\Workflow\Command\Payment\PaymentCommandRequest;use App\Workflow\Query\Payment\PaymentSearchQuery;use App\Application\CommandBus\MultiSource\MultiSourceCqrsCommandBus;use App\Application\QueryBus\MultiSource\MultiSourceCqrsQueryBus;use App\Infrastructure\MultiSource\SourceRouter;class MultiSourceCqrsTest extends TestCase{ private MultiSourceCqrsCommandBus $commandBus; private MultiSourceCqrsQueryBus $queryBus; private SourceRouter $sourceRouter; protected function setUp(): void { $this-&amp;gt;sourceRouter = $this-&amp;gt;createMock(SourceRouter::class); $this-&amp;gt;commandBus = new MultiSourceCqrsCommandBus( $this-&amp;gt;sourceRouter, $this-&amp;gt;createMock(LoggerInterface::class) ); $this-&amp;gt;queryBus = new MultiSourceCqrsQueryBus( $this-&amp;gt;sourceRouter, $this-&amp;gt;createMock(MultiSourceCacheManager::class), $this-&amp;gt;createMock(LoggerInterface::class) ); } public function testCqrsSeparationWithMultiSource(): void { // Exécuter une commande avec Multi-source CQRS $command = new PaymentCommandRequest( 'CREATE', 'payment-123', 'org-456', 'user-789', 100.00, 'EUR', 'Test payment' ); $this-&amp;gt;commandBus-&amp;gt;handle($command); // Vérifier avec une requête $query = new PaymentSearchQuery('org-456', 0, 10); $result = $this-&amp;gt;queryBus-&amp;gt;handle($query); $this-&amp;gt;assertGreaterThan(0, $result-&amp;gt;getTotal()); } public function testQueryCachingWithMultiSource(): void { $query = new PaymentSearchQuery('org-456', 0, 10); // Première recherche $result1 = $this-&amp;gt;queryBus-&amp;gt;handle($query); // Deuxième recherche (devrait utiliser le cache) $result2 = $this-&amp;gt;queryBus-&amp;gt;handle($query); $this-&amp;gt;assertEquals($result1-&amp;gt;getTotal(), $result2-&amp;gt;getTotal()); }}&lt;/code&gt;## 📊 &lt;strong&gt;Performance et Optimisation&lt;/strong&gt;### &lt;strong&gt;Stratégies d&amp;rsquo;Optimisation CQRS Multi-Sources&lt;/strong&gt;#### &lt;strong&gt;1. Cache Multi-Niveaux avec Multi-sources&lt;/strong&gt;&lt;code&gt;phppublic function searchPaymentsWithCache(PaymentSearchQuery $query): PaymentSearchResult{ // Cache L1: Mémoire if (isset($this-&amp;gt;memoryCache[$query-&amp;gt;getCacheKey()])) { return $this-&amp;gt;memoryCache[$query-&amp;gt;getCacheKey()]; } // Cache L2: Redis if ($cached = $this-&amp;gt;redis-&amp;gt;get(&amp;quot;payment_search_ms_cqrs:{$query-&amp;gt;getCacheKey()}&amp;quot;)) { $result = PaymentSearchResult::fromArray(json_decode($cached, true)); $this-&amp;gt;memoryCache[$query-&amp;gt;getCacheKey()] = $result; return $result; } // Multi-source CQRS $result = $this-&amp;gt;searchPaymentsWithMultiSourceCqrs($query); // Mettre en cache $this-&amp;gt;memoryCache[$query-&amp;gt;getCacheKey()] = $result; $this-&amp;gt;redis-&amp;gt;setex(&amp;quot;payment_search_ms_cqrs:{$query-&amp;gt;getCacheKey()}&amp;quot;, 300, json_encode($result-&amp;gt;toArray())); return $result;}&lt;/code&gt;#### &lt;strong&gt;2. Projections Asynchrones avec Multi-sources&lt;/strong&gt;&lt;code&gt;phppublic function handleEventAsync(DomainEvent $event): void{ // Mettre en queue pour traitement asynchrone $this-&amp;gt;messageBus-&amp;gt;dispatch(new ProcessMultiSourceCqrsProjectionCommand($event));}&lt;/code&gt;#### &lt;strong&gt;3. Monitoring des Sources Multi-sources&lt;/strong&gt;&lt;code&gt;phppublic function getMultiSourceCqrsMetrics(): array{ return [ 'commandSources' =&amp;gt; $this-&amp;gt;getCommandSourceMetrics(), 'querySources' =&amp;gt; $this-&amp;gt;getQuerySourceMetrics(), 'projections' =&amp;gt; $this-&amp;gt;getProjectionMetrics(), 'cacheHitRate' =&amp;gt; $this-&amp;gt;getCacheHitRate(), 'sourceHealth' =&amp;gt; $this-&amp;gt;getSourceHealth(), 'averageExecutionTime' =&amp;gt; $this-&amp;gt;getAverageExecutionTime() ];}&lt;/code&gt;## 🎯 &lt;strong&gt;Critères d&amp;rsquo;Adoption&lt;/strong&gt;### &lt;strong&gt;Quand Utiliser CQRS avec Multi-sources&lt;/strong&gt;#### &lt;strong&gt;✅ Avantages&lt;/strong&gt;- &lt;strong&gt;Séparation totale&lt;/strong&gt; : Commandes et requêtes complètement découplées- &lt;strong&gt;Flexibilité maximale&lt;/strong&gt; : Choix du meilleur stockage pour chaque opération- &lt;strong&gt;Scalabilité maximale&lt;/strong&gt; : Possibilité de scaler indépendamment- &lt;strong&gt;Performance optimale&lt;/strong&gt; : Chaque côté optimisé pour son usage- &lt;strong&gt;Résilience&lt;/strong&gt; : Redondance et failover entre sources- &lt;strong&gt;Maintenabilité&lt;/strong&gt; : Code plus clair et organisé#### &lt;strong&gt;❌ Inconvénients&lt;/strong&gt;- &lt;strong&gt;Complexité maximale&lt;/strong&gt; : Gestion de plusieurs sources de données- &lt;strong&gt;Cohérence&lt;/strong&gt; : Risque d&amp;rsquo;incohérence entre sources- &lt;strong&gt;Maintenance&lt;/strong&gt; : Plus de sources à maintenir- &lt;strong&gt;Expertise&lt;/strong&gt; : Équipe très expérimentée requise- &lt;strong&gt;Coût&lt;/strong&gt; : Infrastructure très coûteuse#### &lt;strong&gt;🎯 Critères d&amp;rsquo;Adoption&lt;/strong&gt;- &lt;strong&gt;Système très complexe&lt;/strong&gt; : Besoins de scalabilité maximale- &lt;strong&gt;Données hétérogènes&lt;/strong&gt; : Types de données différents nécessitant différents stockages- &lt;strong&gt;Performance critique&lt;/strong&gt; : Besoins de performance maximale- &lt;strong&gt;Séparation des responsabilités&lt;/strong&gt; : Besoin de séparer clairement les commandes et requêtes- &lt;strong&gt;Équipe très expérimentée&lt;/strong&gt; : Maîtrise de plusieurs technologies de stockage et CQRS- &lt;strong&gt;Budget important&lt;/strong&gt; : Investissement en infrastructure multiple- &lt;strong&gt;Temps de développement&lt;/strong&gt; : Suffisant pour implémenter cette complexité- &lt;strong&gt;Maintenance&lt;/strong&gt; : Équipe capable de maintenir cette complexité## 🚀 &lt;strong&gt;Votre Prochaine Étape&lt;/strong&gt;

&lt;div class="chapter-navigation"&gt;
 &lt;h2 class="chapter-nav-title"&gt;🎯 Votre Prochaine Étape&lt;/h2&gt;
 &lt;p class="chapter-nav-subtitle"&gt;Maintenant que vous comprenez les concepts de base et que j'ai partagé mon expérience avec Gyroscops, quel est votre contexte ?&lt;/p&gt;</description></item><item><title>Stockage Multi-sources avec Event Sourcing</title><link>http://localhost:1313/chapitres/stockage/multi-sources/chapitre-55-stockage-multi-sources-event-sourcing/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/multi-sources/chapitre-55-stockage-multi-sources-event-sourcing/</guid><description/></item><item><title>Stratégies Avancées de Réplication Multi-sources</title><link>http://localhost:1313/chapitres/stockage/multi-sources/chapitre-56-stockage-multi-sources-strategies-avancees/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/multi-sources/chapitre-56-stockage-multi-sources-strategies-avancees/</guid><description>&lt;h2 id="-objectif-du-chapitrece-chapitre-explore-les-stratégies-avancées-de-réplication-pour-les-systèmes-multi-sources-couvrant-les-patterns-sophistiqués-de-synchronisation-de-cohérence-et-doptimisation-des-performances--concepts-clés-réplication-avancéela-réplication-avancée-va-au-delà-de-la-simple-duplication-de-données---réplication-intelligente--sélection-dynamique-des-sources--synchronisation-bidirectionnelle--mise-à-jour-dans-les-deux-sens--réplication-conditionnelle--basée-sur-des-critères-métier--optimisation-des-performances--réplication-asynchrone-et-parallèle-architecture-de-réplication-avancéemermaidgraph-tb----aevent-source----breplication-manager----b----cstrategy-selector--------c----dimmediate-replication----c----ebatch-replication----c----fconditional-replication--------d----gprimary-store----d----hsecondary-store--------e----ibatch-processor----i----jmultiple-stores--------f----krule-engine----k----ltarget-stores--------mconflict-resolver----nconsistency-checker----n----osync-status--patterns-de-réplication-1-réplication-en-cascadeles-données-sont-répliquées-de-manière-séquentielle-phpphpnamespace-gyroscopscloudinfrastructurereplicationclass-cascadereplicationstrategy-implements-replicationstrategyinterface----private-array-storechain----private-int-maxretries----public-function-replicateeventstream-stream-void------------currentstream--stream----------------foreach-this-storechain-as-store-------------try-----------------store-appendcurrentstream----------------currentstream--this-transformstreamcurrentstream-store-------------catch-exception-e-----------------this-handlereplicationfailurestore-e----------------break--arrêter-la-cascade-en-cas-déchec----------------------------private-function-transformstreameventstream-stream-eventstoreinterface-store-eventstream-------------transformation-des-événements-selon-le-type-de-store--------transformedevents------------------foreach-stream-getevents-as-event-------------transformedevents--this-transformeventevent-store------------------------return-new-eventstreamtransformedevents-----2-réplication-en-étoiletoutes-les-sources-sont-mises-à-jour-simultanément-phpphpnamespace-gyroscopscloudinfrastructurereplicationclass-starreplicationstrategy-implements-replicationstrategyinterface----private-array-stores----private-replicationcoordinator-coordinator----public-function-replicateeventstream-stream-void------------replicationtasks------------------foreach-this-stores-as-storeid--store-------------replicationtasks--this-createreplicationtaskstore-stream------------------------this-coordinator-executeparallelreplicationtasks--------private-function-createreplicationtaskeventstoreinterface-store-eventstream-stream-replicationtask------------return-new-replicationtaskfunction-use-store-stream-------------try-----------------store-appendstream----------------return-replicationresultsuccess-------------catch-exception-e-----------------return-replicationresultfailuree-------------------------3-réplication-conditionnellela-réplication-dépend-de-critères-métier-phpphpnamespace-gyroscopscloudinfrastructurereplicationclass-conditionalreplicationstrategy-implements-replicationstrategyinterface----private-array-replicationrules----private-ruleengine-ruleengine----public-function-replicateeventstream-stream-void------------foreach-stream-getevents-as-event-------------targetstores--this-ruleengine-evaluateevent-this-replicationrules------------------------foreach-targetstores-as-store-----------------this-replicatetostorestore-event----------------------------private-function-replicatetostoreeventstoreinterface-store-domainevent-event-void------------try-------------store-appendnew-eventstreamevent---------catch-exception-e-------------this-handlereplicationerrorstore-event-e--------------stratégies-de-cohérence-1-cohérence-éventuelle-avec-compensationphpphpnamespace-gyroscopscloudinfrastructureconsistencyclass-eventualconsistencywithcompensation-implements-consistencystrategyinterface----private-consistencychecker-checker----private-compensationmanager-compensation----public-function-ensureconsistencyarray-stores-void------------inconsistencies--this-checker-detectinconsistenciesstores----------------foreach-inconsistencies-as-inconsistency-------------this-compensation-applycompensationinconsistency-------------2-cohérence-forte-avec-quorumphpphpnamespace-gyroscopscloudinfrastructureconsistencyclass-strongconsistencywithquorum-implements-consistencystrategyinterface----private-int-quorumsize----private-array-stores----public-function-writeeventstream-stream-void------------successcount--0--------errors------------------foreach-this-stores-as-store-------------try-----------------store-appendstream----------------successcount-------------catch-exception-e-----------------errors--e------------------------------------if-successcount--this-quorumsize-------------throw-new-quorumnotreachedexceptionerrors--------------optimisations-de-performance-1-réplication-asynchrone-avec-queuephpphpnamespace-gyroscopscloudinfrastructurereplicationclass-asyncreplicationwithqueue-implements-replicationstrategyinterface----private-messagequeue-queue----private-replicationworker-worker----public-function-replicateeventstream-stream-void-------------écriture-immédiate-dans-la-source-principale--------this-primarystore-appendstream-----------------mise-en-queue-pour-réplication-asynchrone--------this-queue-publishnew-replicationmessagestream--------public-function-processreplicationqueue-void------------while-message--this-queue-consume-------------this-worker-processmessage-------------2-réplication-par-batchphpphpnamespace-gyroscopscloudinfrastructurereplicationclass-batchreplicationstrategy-implements-replicationstrategyinterface----private-batchprocessor-batchprocessor----private-int-batchsize----private-int-batchtimeout----public-function-replicateeventstream-stream-void------------this-batchprocessor-addtobatchstream----------------if-this-shouldprocessbatch-------------this-processbatch----------------private-function-shouldprocessbatch-bool------------return-this-batchprocessor-getbatchsize--this-batchsize----------------this-batchprocessor-getbatchage--this-batchtimeout------monitoring-et-observabilité-1-métriques-de-réplicationphpphpnamespace-gyroscopscloudinfrastructuremonitoringclass-replicationmetrics----private-metricscollector-collector----public-function-recordreplicationlatencystring-storeid-float-latency-void------------this-collector-histogramreplicationlatency-latency-------------store--storeid----------------public-function-recordreplicationsuccessstring-storeid-void------------this-collector-incrementreplicationsuccess-------------store--storeid----------------public-function-recordreplicationfailurestring-storeid-string-error-void------------this-collector-incrementreplicationfailure-------------store--storeid------------error--error-------------2-health-checksphpphpnamespace-gyroscopscloudinfrastructurehealthclass-replicationhealthcheck-implements-healthcheckinterface----private-array-stores----private-consistencychecker-checker----public-function-check-healthstatus------------status--new-healthstatus----------------foreach-this-stores-as-storeid--store-------------try-----------------this-checkstorehealthstore----------------status-addstorestatusstoreid-healthy-------------catch-exception-e-----------------status-addstorestatusstoreid-unhealthy-e-getmessage------------------------------------return-status------patterns-avancés-1-réplication-géographiquephpphpnamespace-gyroscopscloudinfrastructurereplicationclass-geographicreplicationstrategy-implements-replicationstrategyinterface----private-array-regions----private-latencyoptimizer-optimizer----public-function-replicateeventstream-stream-void------------userregion--this-getuserregion--------targetregions--this-optimizer-selectoptimalregionsuserregion----------------foreach-targetregions-as-region-------------this-replicatetoregionregion-stream-------------2-réplication-adaptativephpphpnamespace-gyroscopscloudinfrastructurereplicationclass-adaptivereplicationstrategy-implements-replicationstrategyinterface----private-performancemonitor-monitor----private-strategyselector-selector----public-function-replicateeventstream-stream-void------------currentperformance--this-monitor-getcurrentperformance--------strategy--this-selector-selectstrategycurrentperformance----------------strategy-replicatestream------cas-d-systèmes-multi-région--latence-optimisée--réplication-basée-sur-la-proximité-géographique--disaster-recovery--réplication-cross-region-pour-la-continuité--compliance--respect-des-réglementations-par-région-systèmes-de-trading--latence-ultra-faible--réplication-immédiate-pour-les-données-critiques--cohérence-forte--garantie-de-cohérence-pour-les-transactions-financières--audit-trail--traçabilité-complète-des-modifications--métriques-et-kpis-métriques-de-performance--latence-de-réplication--temps-moyen-de-réplication--throughput--nombre-dévénements-répliqués-par-seconde--taux-de-succès--pourcentage-de-réplications-réussies--délai-de-synchronisation--temps-de-convergence-entre-stores-métriques-de-qualité--cohérence--pourcentage-de-données-cohérentes--intégrité--absence-de-corruption-des-données--disponibilité--temps-de-fonctionnement-des-stores--récupération--temps-de-récupération-après-panne--prochaines-étapesaprès-avoir-maîtrisé-les-stratégies-avancées-de-réplication-vous-pouvez---explorer-la-résolution-de-conflits-dans-les-environnements-multi-sources--découvrir-les-techniques-de-monitoring-et-dobservabilité-avancées--apprendre-les-patterns-de-migration-et-de-maintenance--implémenter-des-solutions-de-disaster-recovery-sophistiquéeshahahugoshortcode62s0hbhb"&gt;🎯 &lt;strong&gt;Objectif du Chapitre&lt;/strong&gt;Ce chapitre explore les &lt;strong&gt;stratégies avancées de réplication&lt;/strong&gt; pour les systèmes multi-sources, couvrant les patterns sophistiqués de synchronisation, de cohérence et d&amp;rsquo;optimisation des performances.## 🌟 &lt;strong&gt;Concepts Clés&lt;/strong&gt;### &lt;strong&gt;Réplication Avancée&lt;/strong&gt;La réplication avancée va au-delà de la simple duplication de données :- &lt;strong&gt;Réplication intelligente&lt;/strong&gt; : Sélection dynamique des sources- &lt;strong&gt;Synchronisation bidirectionnelle&lt;/strong&gt; : Mise à jour dans les deux sens- &lt;strong&gt;Réplication conditionnelle&lt;/strong&gt; : Basée sur des critères métier- &lt;strong&gt;Optimisation des performances&lt;/strong&gt; : Réplication asynchrone et parallèle### &lt;strong&gt;Architecture de Réplication Avancée&lt;/strong&gt;&lt;code&gt;mermaidgraph TB A[Event Source] --&amp;gt; B[Replication Manager] B --&amp;gt; C[Strategy Selector] C --&amp;gt; D[Immediate Replication] C --&amp;gt; E[Batch Replication] C --&amp;gt; F[Conditional Replication] D --&amp;gt; G[Primary Store] D --&amp;gt; H[Secondary Store] E --&amp;gt; I[Batch Processor] I --&amp;gt; J[Multiple Stores] F --&amp;gt; K[Rule Engine] K --&amp;gt; L[Target Stores] M[Conflict Resolver] --&amp;gt; N[Consistency Checker] N --&amp;gt; O[Sync Status]&lt;/code&gt;## 🏗️ &lt;strong&gt;Patterns de Réplication&lt;/strong&gt;### &lt;strong&gt;1. Réplication en Cascade&lt;/strong&gt;Les données sont répliquées de manière séquentielle :&lt;code&gt;php&amp;lt;?phpnamespace Gyroscops\Cloud\Infrastructure\Replication;class CascadeReplicationStrategy implements ReplicationStrategyInterface{ private array $storeChain; private int $maxRetries; public function replicate(EventStream $stream): void { $currentStream = $stream; foreach ($this-&amp;gt;storeChain as $store) { try { $store-&amp;gt;append($currentStream); $currentStream = $this-&amp;gt;transformStream($currentStream, $store); } catch (Exception $e) { $this-&amp;gt;handleReplicationFailure($store, $e); break; // Arrêter la cascade en cas d'échec } } } private function transformStream(EventStream $stream, EventStoreInterface $store): EventStream { // Transformation des événements selon le type de store $transformedEvents = []; foreach ($stream-&amp;gt;getEvents() as $event) { $transformedEvents[] = $this-&amp;gt;transformEvent($event, $store); } return new EventStream($transformedEvents); }}&lt;/code&gt;### &lt;strong&gt;2. Réplication en Étoile&lt;/strong&gt;Toutes les sources sont mises à jour simultanément :&lt;code&gt;php&amp;lt;?phpnamespace Gyroscops\Cloud\Infrastructure\Replication;class StarReplicationStrategy implements ReplicationStrategyInterface{ private array $stores; private ReplicationCoordinator $coordinator; public function replicate(EventStream $stream): void { $replicationTasks = []; foreach ($this-&amp;gt;stores as $storeId =&amp;gt; $store) { $replicationTasks[] = $this-&amp;gt;createReplicationTask($store, $stream); } $this-&amp;gt;coordinator-&amp;gt;executeParallel($replicationTasks); } private function createReplicationTask(EventStoreInterface $store, EventStream $stream): ReplicationTask { return new ReplicationTask(function() use ($store, $stream) { try { $store-&amp;gt;append($stream); return ReplicationResult::success(); } catch (Exception $e) { return ReplicationResult::failure($e); } }); }}&lt;/code&gt;### &lt;strong&gt;3. Réplication Conditionnelle&lt;/strong&gt;La réplication dépend de critères métier :&lt;code&gt;php&amp;lt;?phpnamespace Gyroscops\Cloud\Infrastructure\Replication;class ConditionalReplicationStrategy implements ReplicationStrategyInterface{ private array $replicationRules; private RuleEngine $ruleEngine; public function replicate(EventStream $stream): void { foreach ($stream-&amp;gt;getEvents() as $event) { $targetStores = $this-&amp;gt;ruleEngine-&amp;gt;evaluate($event, $this-&amp;gt;replicationRules); foreach ($targetStores as $store) { $this-&amp;gt;replicateToStore($store, $event); } } } private function replicateToStore(EventStoreInterface $store, DomainEvent $event): void { try { $store-&amp;gt;append(new EventStream([$event])); } catch (Exception $e) { $this-&amp;gt;handleReplicationError($store, $event, $e); } }}&lt;/code&gt;## 🔄 &lt;strong&gt;Stratégies de Cohérence&lt;/strong&gt;### &lt;strong&gt;1. Cohérence Éventuelle avec Compensation&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace Gyroscops\Cloud\Infrastructure\Consistency;class EventualConsistencyWithCompensation implements ConsistencyStrategyInterface{ private ConsistencyChecker $checker; private CompensationManager $compensation; public function ensureConsistency(array $stores): void { $inconsistencies = $this-&amp;gt;checker-&amp;gt;detectInconsistencies($stores); foreach ($inconsistencies as $inconsistency) { $this-&amp;gt;compensation-&amp;gt;applyCompensation($inconsistency); } }}&lt;/code&gt;### &lt;strong&gt;2. Cohérence Forte avec Quorum&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace Gyroscops\Cloud\Infrastructure\Consistency;class StrongConsistencyWithQuorum implements ConsistencyStrategyInterface{ private int $quorumSize; private array $stores; public function write(EventStream $stream): void { $successCount = 0; $errors = []; foreach ($this-&amp;gt;stores as $store) { try { $store-&amp;gt;append($stream); $successCount++; } catch (Exception $e) { $errors[] = $e; } } if ($successCount &amp;lt; $this-&amp;gt;quorumSize) { throw new QuorumNotReachedException($errors); } }}&lt;/code&gt;## ⚡ &lt;strong&gt;Optimisations de Performance&lt;/strong&gt;### &lt;strong&gt;1. Réplication Asynchrone avec Queue&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace Gyroscops\Cloud\Infrastructure\Replication;class AsyncReplicationWithQueue implements ReplicationStrategyInterface{ private MessageQueue $queue; private ReplicationWorker $worker; public function replicate(EventStream $stream): void { // Écriture immédiate dans la source principale $this-&amp;gt;primaryStore-&amp;gt;append($stream); // Mise en queue pour réplication asynchrone $this-&amp;gt;queue-&amp;gt;publish(new ReplicationMessage($stream)); } public function processReplicationQueue(): void { while ($message = $this-&amp;gt;queue-&amp;gt;consume()) { $this-&amp;gt;worker-&amp;gt;process($message); } }}&lt;/code&gt;### &lt;strong&gt;2. Réplication par Batch&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace Gyroscops\Cloud\Infrastructure\Replication;class BatchReplicationStrategy implements ReplicationStrategyInterface{ private BatchProcessor $batchProcessor; private int $batchSize; private int $batchTimeout; public function replicate(EventStream $stream): void { $this-&amp;gt;batchProcessor-&amp;gt;addToBatch($stream); if ($this-&amp;gt;shouldProcessBatch()) { $this-&amp;gt;processBatch(); } } private function shouldProcessBatch(): bool { return $this-&amp;gt;batchProcessor-&amp;gt;getBatchSize() &amp;gt;= $this-&amp;gt;batchSize || $this-&amp;gt;batchProcessor-&amp;gt;getBatchAge() &amp;gt;= $this-&amp;gt;batchTimeout; }}&lt;/code&gt;## 🔍 &lt;strong&gt;Monitoring et Observabilité&lt;/strong&gt;### &lt;strong&gt;1. Métriques de Réplication&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace Gyroscops\Cloud\Infrastructure\Monitoring;class ReplicationMetrics{ private MetricsCollector $collector; public function recordReplicationLatency(string $storeId, float $latency): void { $this-&amp;gt;collector-&amp;gt;histogram('replication.latency', $latency, [ 'store' =&amp;gt; $storeId ]); } public function recordReplicationSuccess(string $storeId): void { $this-&amp;gt;collector-&amp;gt;increment('replication.success', [ 'store' =&amp;gt; $storeId ]); } public function recordReplicationFailure(string $storeId, string $error): void { $this-&amp;gt;collector-&amp;gt;increment('replication.failure', [ 'store' =&amp;gt; $storeId, 'error' =&amp;gt; $error ]); }}&lt;/code&gt;### &lt;strong&gt;2. Health Checks&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace Gyroscops\Cloud\Infrastructure\Health;class ReplicationHealthCheck implements HealthCheckInterface{ private array $stores; private ConsistencyChecker $checker; public function check(): HealthStatus { $status = new HealthStatus(); foreach ($this-&amp;gt;stores as $storeId =&amp;gt; $store) { try { $this-&amp;gt;checkStoreHealth($store); $status-&amp;gt;addStoreStatus($storeId, 'healthy'); } catch (Exception $e) { $status-&amp;gt;addStoreStatus($storeId, 'unhealthy', $e-&amp;gt;getMessage()); } } return $status; }}&lt;/code&gt;## 🎯 &lt;strong&gt;Patterns Avancés&lt;/strong&gt;### &lt;strong&gt;1. Réplication Géographique&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace Gyroscops\Cloud\Infrastructure\Replication;class GeographicReplicationStrategy implements ReplicationStrategyInterface{ private array $regions; private LatencyOptimizer $optimizer; public function replicate(EventStream $stream): void { $userRegion = $this-&amp;gt;getUserRegion(); $targetRegions = $this-&amp;gt;optimizer-&amp;gt;selectOptimalRegions($userRegion); foreach ($targetRegions as $region) { $this-&amp;gt;replicateToRegion($region, $stream); } }}&lt;/code&gt;### &lt;strong&gt;2. Réplication Adaptative&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace Gyroscops\Cloud\Infrastructure\Replication;class AdaptiveReplicationStrategy implements ReplicationStrategyInterface{ private PerformanceMonitor $monitor; private StrategySelector $selector; public function replicate(EventStream $stream): void { $currentPerformance = $this-&amp;gt;monitor-&amp;gt;getCurrentPerformance(); $strategy = $this-&amp;gt;selector-&amp;gt;selectStrategy($currentPerformance); $strategy-&amp;gt;replicate($stream); }}&lt;/code&gt;## 🚀 &lt;strong&gt;Cas d&amp;rsquo;Usage Avancés&lt;/strong&gt;### &lt;strong&gt;Systèmes Multi-région&lt;/strong&gt;- &lt;strong&gt;Latence optimisée&lt;/strong&gt; : Réplication basée sur la proximité géographique- &lt;strong&gt;Disaster recovery&lt;/strong&gt; : Réplication cross-region pour la continuité- &lt;strong&gt;Compliance&lt;/strong&gt; : Respect des réglementations par région### &lt;strong&gt;Systèmes de Trading&lt;/strong&gt;- &lt;strong&gt;Latence ultra-faible&lt;/strong&gt; : Réplication immédiate pour les données critiques- &lt;strong&gt;Cohérence forte&lt;/strong&gt; : Garantie de cohérence pour les transactions financières- &lt;strong&gt;Audit trail&lt;/strong&gt; : Traçabilité complète des modifications## 📊 &lt;strong&gt;Métriques et KPIs&lt;/strong&gt;### &lt;strong&gt;Métriques de Performance&lt;/strong&gt;- &lt;strong&gt;Latence de réplication&lt;/strong&gt; : Temps moyen de réplication- &lt;strong&gt;Throughput&lt;/strong&gt; : Nombre d&amp;rsquo;événements répliqués par seconde- &lt;strong&gt;Taux de succès&lt;/strong&gt; : Pourcentage de réplications réussies- &lt;strong&gt;Délai de synchronisation&lt;/strong&gt; : Temps de convergence entre stores### &lt;strong&gt;Métriques de Qualité&lt;/strong&gt;- &lt;strong&gt;Cohérence&lt;/strong&gt; : Pourcentage de données cohérentes- &lt;strong&gt;Intégrité&lt;/strong&gt; : Absence de corruption des données- &lt;strong&gt;Disponibilité&lt;/strong&gt; : Temps de fonctionnement des stores- &lt;strong&gt;Récupération&lt;/strong&gt; : Temps de récupération après panne## 🎯 &lt;strong&gt;Prochaines Étapes&lt;/strong&gt;Après avoir maîtrisé les stratégies avancées de réplication, vous pouvez :- &lt;strong&gt;Explorer la résolution de conflits&lt;/strong&gt; dans les environnements multi-sources- &lt;strong&gt;Découvrir les techniques de monitoring&lt;/strong&gt; et d&amp;rsquo;observabilité avancées- &lt;strong&gt;Apprendre les patterns de migration&lt;/strong&gt; et de maintenance- &lt;strong&gt;Implémenter des solutions de disaster recovery&lt;/strong&gt; sophistiquées&amp;mdash;

&lt;div class="chapter-navigation"&gt;
 &lt;h2 class="chapter-nav-title"&gt;🎯 Votre Prochaine Étape&lt;/h2&gt;
 &lt;p class="chapter-nav-subtitle"&gt;Maintenant que vous comprenez les concepts de base et que j'ai partagé mon expérience avec Gyroscops, quel est votre contexte ?&lt;/p&gt;</description></item><item><title>Résolution de Conflits Multi-sources</title><link>http://localhost:1313/chapitres/stockage/multi-sources/chapitre-57-stockage-multi-sources-resolution-conflits/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/multi-sources/chapitre-57-stockage-multi-sources-resolution-conflits/</guid><description/></item></channel></rss>