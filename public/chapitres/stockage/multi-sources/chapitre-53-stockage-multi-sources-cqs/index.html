<!doctype html><html lang=fr-fr><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><title>Stockage Multi-sources - CQS | DDD Adventure</title><meta name=robots content="noindex"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Implémentation Command Query Separation avec Multi-sources pour optimiser les performances"><meta name=keywords content="Documentation,Hugo,Hugo Theme,Bootstrap"><meta name=author content="Colin Wilson - Lotus Labs"><meta name=email content="support@aigis.uk"><meta name=website content="https://lotusdocs.dev"><meta name=Version content="v0.1.0"><link rel=icon href=http://localhost:1313/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=http://localhost:1313/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=http://localhost:1313/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=http://localhost:1313/site.webmanifest><meta property="og:title" content="Stockage Multi-sources - CQS"><meta property="og:description" content="Implémentation Command Query Separation avec Multi-sources pour optimiser les performances"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/chapitres/stockage/multi-sources/chapitre-53-stockage-multi-sources-cqs/"><meta property="og:image" content="http://localhost:1313/opengraph/card-base-2_hu_e726d22c1606abfc.png"><meta property="article:section" content="chapitres"><meta property="article:published_time" content="2024-12-19T00:00:00+00:00"><meta property="article:modified_time" content="2024-12-19T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/opengraph/card-base-2_hu_e726d22c1606abfc.png"><meta name=twitter:title content="Stockage Multi-sources - CQS"><meta name=twitter:description content="Implémentation Command Query Separation avec Multi-sources pour optimiser les performances"><link rel=alternate type=application/atom+xml title="Atom feed for DDD Adventure" href=/index.xml><script type=text/javascript src=http://localhost:1313/docs/js/flexsearch.bundle.js></script><link rel=stylesheet href=/docs/scss/style.css crossorigin=anonymous></head><body><div class=content><div class="page-wrapper toggled"><nav id=sidebar class=sidebar-wrapper><div class=sidebar-brand><a href=/ aria-label=HomePage alt=HomePage><svg id="Layer_1" viewBox="0 0 250 250"><path d="m143 39.5c-18 0-18 18-18 18s0-18-18-18H22c-2.76.0-5 2.24-5 5v143c0 2.76 2.24 5 5 5h76c7.2.0 8.64 11.52 8.93 16.13.07 1.05.95 1.87 2 1.87h32.14c1.06.0 1.94-.82 2-1.87.29-4.61 1.73-16.13 8.93-16.13h76c2.76.0 5-2.24 5-5V44.5c0-2.76-2.24-5-5-5h-85zM206 163c0 1.38-1.12 2.5-2.5 2.5H143c-18 0-18 18-18 18s0-18-18-18H46.5c-1.38.0-2.5-1.12-2.5-2.5V69c0-1.38 1.12-2.5 2.5-2.5H98c7.2.0 8.64 11.52 8.93 16.13.07 1.05.95 1.87 2 1.87h32.14c1.06.0 1.94-.82 2-1.87.29-4.61 1.73-16.13 8.93-16.13h51.5c1.38.0 2.5 1.12 2.5 2.5v94z" style="fill:#06f"/></svg></a></div><div class=sidebar-content style="height:calc(100% - 131px)"><ul class=sidebar-menu><li class="sidebar-dropdown no-icon"><button class=btn>
Chapitres Fondamentaux</button><div class=sidebar-submenu><ul><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/fondamentaux/chapitre-01-introduction-event-storming-ddd/>Chapitre 1 : Introduction au Domain-Driven Design et Event Storming</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/fondamentaux/chapitre-02-impact-mapping/>Chapitre 2 : L'Impact Mapping - Aligner le Produit sur les Objectifs Business</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/fondamentaux/chapitre-03-atelier-event-storming/>Chapitre 3 : L'Atelier Event Storming - Guide Pratique</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/fondamentaux/chapitre-04-example-mapping/>Chapitre 4 : L'Example Mapping - Détailer les Règles Métier</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/fondamentaux/chapitre-05-complexite-accidentelle-essentielle/>Chapitre 5 : Complexité Accidentelle vs Essentielle - Le Choix Architectural</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/fondamentaux/chapitre-06-granularite-choix-architecturaux/>Chapitre 6 : Granularité des Choix Architecturaux</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/fondamentaux/chapitre-07-modeles-riches-vs-anemiques/>Chapitre 7 : Modèles Riches vs Modèles Anémiques</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/fondamentaux/chapitre-08-architecture-evenementielle/>Chapitre 8 : Architecture Événementielle</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/fondamentaux/chapitre-09-repositories-persistance/>Chapitre 9 : Repositories et Persistance</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/fondamentaux/chapitre-10-choix-type-stockage/>Chapitre 15 : Choix du Type de Stockage</a></li></ul></div></li><li class="sidebar-dropdown no-icon"><button class=btn>
Chapitres Optionnels</button><div class=sidebar-submenu><ul><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/optionnels/chapitre-13-architecture-cqrs/>Chapitre 15 : Architecture CQRS avec API Platform</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/optionnels/chapitre-12-architecture-cqs/>Chapitre 15 : Architecture CQS - Command Query Separation</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/optionnels/chapitre-11-event-sourcing/>Chapitre 15 : Event Sourcing - La Source de Vérité</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/optionnels/chapitre-14-cqrs-event-sourcing-combines/>Chapitre 15 : CQRS + Event Sourcing Combinés</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/optionnels/chapitre-15-projections-event-sourcing/>Chapitre 15 : Projections Event Sourcing</a></li></ul></div></li><li class="sidebar-dropdown no-icon current active"><button class=btn>
Chapitres de Stockage</button><div class="sidebar-submenu d-block"><ul><li class="sidebar-dropdown nested no-icon"><button class=btn>
Stockage SQL</button><div class=sidebar-submenu><ul><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/sql/chapitre-16-stockage-sql-classique/>Chapitre 16 : Stockage SQL - Approche Classique</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/sql/chapitre-17-stockage-sql-cqs/>Chapitre 17 : Stockage SQL - Approche CQS</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/sql/chapitre-18-stockage-sql-cqrs/>Chapitre 18 : Stockage SQL - Approche CQRS</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/sql/chapitre-19-stockage-sql-event-sourcing/>Chapitre 19 : Stockage SQL - Event Sourcing Seul</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/sql/chapitre-20-stockage-sql-event-sourcing-cqs/>Chapitre 58 : Stockage SQL - Event Sourcing + CQS</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/sql/chapitre-21-stockage-sql-event-sourcing-cqrs/>Chapitre 59 : Stockage SQL - Event Sourcing + CQRS</a></li></ul></div></li><li class="sidebar-dropdown nested no-icon"><button class=btn>
Stockage API</button><div class=sidebar-submenu><ul><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/api/chapitre-26-stockage-api-event-sourcing-cqs/>Chapitre 26 : Stockage API - Event Sourcing + CQS</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/api/chapitre-27-stockage-api-event-sourcing-cqrs/>Chapitre 27 : Stockage API - Event Sourcing + CQRS</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/api/chapitre-22-stockage-api-classique/>Chapitre 60 : Stockage API - Approche Classique</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/api/chapitre-23-stockage-api-cqs/>Chapitre 61 : Stockage API - Approche CQS</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/api/chapitre-24-stockage-api-cqrs/>Chapitre 62 : Stockage API - Approche CQRS</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/api/chapitre-25-stockage-api-event-sourcing/>Chapitre 63 : Stockage API - Event Sourcing Seul</a></li></ul></div></li><li class="sidebar-dropdown nested no-icon"><button class=btn>
Stockage MongoDB</button><div class=sidebar-submenu><ul><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/mongodb/chapitre-28-stockage-mongodb-classique/>Chapitre 28 : Stockage MongoDB - Approche Classique</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/mongodb/chapitre-29-stockage-mongodb-cqs/>Chapitre 29 : Stockage MongoDB - Approche CQS</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/mongodb/chapitre-30-stockage-mongodb-cqrs/>Chapitre 30 : Stockage MongoDB - Approche CQRS</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/mongodb/chapitre-31-stockage-mongodb-event-sourcing/>Chapitre 31 : Stockage MongoDB - Event Sourcing</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/mongodb/chapitre-32-stockage-mongodb-event-sourcing-cqs/>Stockage MongoDB - Event Sourcing + CQS</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/mongodb/chapitre-33-stockage-mongodb-event-sourcing-cqrs/>Stockage MongoDB - Event Sourcing + CQRS</a></li></ul></div></li><li class="sidebar-dropdown nested no-icon"><button class=btn>
Stockage ElasticSearch</button><div class=sidebar-submenu><ul><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/elasticsearch/chapitre-34-stockage-elasticsearch-classique/>Stockage ElasticSearch - Approche Classique</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/elasticsearch/chapitre-35-stockage-elasticsearch-cqs/>Stockage ElasticSearch - CQS</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/elasticsearch/chapitre-36-stockage-elasticsearch-cqrs/>Stockage ElasticSearch - CQRS</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/elasticsearch/chapitre-37-stockage-elasticsearch-event-sourcing/>Stockage ElasticSearch - Event Sourcing</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/elasticsearch/chapitre-38-stockage-elasticsearch-event-sourcing-cqs/>Stockage ElasticSearch - Event Sourcing + CQS</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/elasticsearch/chapitre-39-stockage-elasticsearch-event-sourcing-cqrs/>Stockage ElasticSearch - Event Sourcing + CQRS</a></li></ul></div></li><li class="sidebar-dropdown nested no-icon"><button class=btn>
Stockage In-Memory</button><div class=sidebar-submenu><ul><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/in-memory/chapitre-40-stockage-in-memory-classique/>Stockage In-Memory - Approche Classique</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/in-memory/chapitre-41-stockage-in-memory-cqs/>Stockage In-Memory - CQS</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/in-memory/chapitre-42-stockage-in-memory-cqrs/>Stockage In-Memory - CQRS</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/in-memory/chapitre-43-stockage-in-memory-event-sourcing/>Stockage In-Memory - Event Sourcing</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/in-memory/chapitre-44-stockage-in-memory-event-sourcing-cqs/>Stockage In-Memory - Event Sourcing + CQS</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/in-memory/chapitre-45-stockage-in-memory-event-sourcing-cqrs/>Stockage In-Memory - Event Sourcing + CQRS</a></li></ul></div></li><li class="sidebar-dropdown nested no-icon"><button class=btn>
Stockage Composite piloté par Temporal</button><div class=sidebar-submenu><ul><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/temporal/chapitre-46-stockage-temporal-classique/>Stockage Temporal - Approche Classique</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/temporal/chapitre-47-stockage-temporal-cqs/>Stockage Temporal - CQS</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/temporal/chapitre-48-stockage-temporal-cqrs/>Stockage Temporal - CQRS</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/temporal/chapitre-49-stockage-temporal-event-sourcing/>Stockage Temporal - Event Sourcing</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/temporal/chapitre-50-stockage-temporal-event-sourcing-cqs/>Stockage Temporal - Event Sourcing + CQS</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/temporal/chapitre-51-stockage-temporal-event-sourcing-cqrs/>Stockage Temporal - Event Sourcing + CQRS</a></li></ul></div></li><li class="sidebar-dropdown nested no-icon current active"><button class=btn>
Stockage Multi-sources</button><div class="sidebar-submenu d-block"><ul><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/multi-sources/chapitre-52-stockage-multi-sources-classique/>Stockage Multi-sources - Approche Classique</a></li><li class="current no-icon"><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/multi-sources/chapitre-53-stockage-multi-sources-cqs/>Stockage Multi-sources - CQS</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/multi-sources/chapitre-54-stockage-multi-sources-cqrs/>Stockage Multi-sources - CQRS</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/multi-sources/chapitre-55-stockage-multi-sources-event-sourcing/>Stockage Multi-sources avec Event Sourcing</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/multi-sources/chapitre-56-stockage-multi-sources-strategies-avancees/>Stratégies Avancées de Réplication Multi-sources</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/stockage/multi-sources/chapitre-57-stockage-multi-sources-resolution-conflits/>Résolution de Conflits Multi-sources</a></li></ul></div></li></ul></div></li><li class="sidebar-dropdown no-icon"><button class=btn>
Chapitres Techniques</button><div class=sidebar-submenu><ul><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/techniques/chapitre-58-gestion-donnees-validation/>Chapitre 58 : Gestion des Données et Validation</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/techniques/chapitre-59-pagination-performance/>Chapitre 59 : Pagination et Performance</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/techniques/chapitre-60-gestion-erreurs-observabilite/>Chapitre 60 : Gestion d'Erreurs et Observabilité</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/techniques/chapitre-61-tests-qualite/>Chapitre 61 : Tests et Qualité</a></li></ul></div></li><li class="sidebar-dropdown no-icon"><button class=btn>
Chapitres Avancés</button><div class=sidebar-submenu><ul><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/avances/chapitre-62-securite-autorisation/>Chapitre 62 : Sécurité et Autorisation - Protéger votre API Platform</a></li><li class=no-icon><a class=sidebar-nested-link href=http://localhost:1313/chapitres/avances/chapitre-63-frontend-integration/>Chapitre 63 : Frontend et Intégration - Connecter votre Interface Utilisateur</a></li></ul></div></li></ul></div><ul class="sidebar-footer list-unstyled mb-0"></ul></nav><main class="page-content bg-transparent"><div id=top-header class="top-header d-print-none"><div class="header-bar d-flex justify-content-between"><div class="d-flex align-items-center"><a href=/ class="logo-icon me-3" aria-label=HomePage alt=HomePage><div class=small><svg id="Layer_1" viewBox="0 0 250 250"><path d="m143 39.5c-18 0-18 18-18 18s0-18-18-18H22c-2.76.0-5 2.24-5 5v143c0 2.76 2.24 5 5 5h76c7.2.0 8.64 11.52 8.93 16.13.07 1.05.95 1.87 2 1.87h32.14c1.06.0 1.94-.82 2-1.87.29-4.61 1.73-16.13 8.93-16.13h76c2.76.0 5-2.24 5-5V44.5c0-2.76-2.24-5-5-5h-85zM206 163c0 1.38-1.12 2.5-2.5 2.5H143c-18 0-18 18-18 18s0-18-18-18H46.5c-1.38.0-2.5-1.12-2.5-2.5V69c0-1.38 1.12-2.5 2.5-2.5H98c7.2.0 8.64 11.52 8.93 16.13.07 1.05.95 1.87 2 1.87h32.14c1.06.0 1.94-.82 2-1.87.29-4.61 1.73-16.13 8.93-16.13h51.5c1.38.0 2.5 1.12 2.5 2.5v94z" style="fill:#06f"/></svg></div><div class=big><svg id="Layer_1" viewBox="0 0 250 250"><path d="m143 39.5c-18 0-18 18-18 18s0-18-18-18H22c-2.76.0-5 2.24-5 5v143c0 2.76 2.24 5 5 5h76c7.2.0 8.64 11.52 8.93 16.13.07 1.05.95 1.87 2 1.87h32.14c1.06.0 1.94-.82 2-1.87.29-4.61 1.73-16.13 8.93-16.13h76c2.76.0 5-2.24 5-5V44.5c0-2.76-2.24-5-5-5h-85zM206 163c0 1.38-1.12 2.5-2.5 2.5H143c-18 0-18 18-18 18s0-18-18-18H46.5c-1.38.0-2.5-1.12-2.5-2.5V69c0-1.38 1.12-2.5 2.5-2.5H98c7.2.0 8.64 11.52 8.93 16.13.07 1.05.95 1.87 2 1.87h32.14c1.06.0 1.94-.82 2-1.87.29-4.61 1.73-16.13 8.93-16.13h51.5c1.38.0 2.5 1.12 2.5 2.5v94z" style="fill:#06f"/></svg></div></a><button id=close-sidebar class="btn btn-icon btn-soft">
<span class="material-icons size-20 menu-icon align-middle">menu</span>
</button>
<button id=flexsearch-button class="ms-3 btn btn-soft" data-bs-toggle=collapse data-bs-target=#FlexSearchCollapse aria-expanded=false aria-controls=FlexSearchCollapse>
<span class="material-icons size-20 menu-icon align-middle">search</span>
<span class="flexsearch-button-placeholder ms-1 me-2 d-none d-sm-block">Search</span><div class="d-none d-sm-block"><span class=flexsearch-button-keys><kbd class=flexsearch-button-cmd-key><svg width="44" height="15"><path d="M2.118 11.5A1.519 1.519.0 011 11.042 1.583 1.583.0 011 8.815a1.519 1.519.0 011.113-.458h.715V6.643h-.71A1.519 1.519.0 011 6.185 1.519 1.519.0 01.547 5.071 1.519 1.519.0 011 3.958 1.519 1.519.0 012.118 3.5a1.519 1.519.0 011.114.458A1.519 1.519.0 013.69 5.071v.715H5.4V5.071A1.564 1.564.0 016.976 3.5 1.564 1.564.0 018.547 5.071 1.564 1.564.0 016.976 6.643H6.261V8.357h.715a1.575 1.575.0 011.113 2.685 1.583 1.583.0 01-2.227.0A1.519 1.519.0 015.4 9.929V9.214H3.69v.715a1.519 1.519.0 01-.458 1.113A1.519 1.519.0 012.118 11.5zm0-.857a.714.714.0 00.715-.714V9.214H2.118a.715.715.0 100 1.429zm4.858.0a.715.715.0 100-1.429H6.261v.715a.714.714.0 00.715.714zM3.69 8.357H5.4V6.643H3.69zM2.118 5.786h.715V5.071a.714.714.0 00-.715-.714.715.715.0 00-.5 1.22A.686.686.0 002.118 5.786zm4.143.0h.715a.715.715.0 00.5-1.22.715.715.0 00-1.22.5z" fill="currentColor"/><path d="M12.4 11.475H11.344l3.879-7.95h1.056z" fill="currentColor"/><path d="M25.073 5.384l-.864.576a2.121 2.121.0 00-1.786-.923 2.207 2.207.0 00-2.266 2.326 2.206 2.206.0 002.266 2.325 2.1 2.1.0 001.782-.918l.84.617a3.108 3.108.0 01-2.622 1.293 3.217 3.217.0 01-3.349-3.317 3.217 3.217.0 013.349-3.317A3.046 3.046.0 0125.073 5.384z" fill="currentColor"/><path d="M30.993 5.142h-2.07v5.419H27.891V5.142h-2.07V4.164h5.172z" fill="currentColor"/><path d="M34.67 4.164c1.471.0 2.266.658 2.266 1.851.0 1.087-.832 1.809-2.134 1.855l2.107 2.691h-1.28L33.591 7.87H33.07v2.691H32.038v-6.4zm-1.6.969v1.8h1.572c.832.0 1.22-.3 1.22-.918s-.411-.882-1.22-.882z" fill="currentColor"/><path d="M42.883 10.561H38.31v-6.4h1.033V9.583h3.54z" fill="currentColor"/></svg>
</kbd><kbd class=flexsearch-button-key><svg width="15" height="15"><path d="M5.926 12.279H4.41L9.073 2.721H10.59z" fill="currentColor"/></svg></kbd></span></div></button></div><div class="d-flex align-items-center"><ul class="list-unstyled mb-0"><li class="list-inline-item mb-0"><a href=https://twitter.com/gplanchat alt=twitter rel="noopener noreferrer" target=_blank><div class="btn btn-icon btn-default border-0"><svg width="24" height="24" viewBox="0 0 24 24"><title>Twitter / X</title><path d="M.088.768l9.266 12.39L.029 23.231h2.1l8.163-8.819 6.6 8.819h7.142L14.242 10.145 22.921.768h-2.1L13.3 8.891 7.229.768zM3.174 2.314H6.455L20.942 21.685h-3.28z" fill="currentColor"/></svg></div></a></li></ul></div></div><div class=collapse id=FlexSearchCollapse><div class=flexsearch-container><div class=flexsearch-keymap><li><kbd class=flexsearch-button-cmd-key><svg width="15" height="15" aria-label="Arrow down" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 3.5v8m3-3-3 3-3-3"/></g></svg></kbd>
<kbd class=flexsearch-button-cmd-key><svg width="15" height="15" aria-label="Arrow up" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 11.5v-8m3 3-3-3-3 3"/></g></svg></kbd>
<span class=flexsearch-key-label>to navigate</span></li><li><kbd class=flexsearch-button-cmd-key><svg width="15" height="15" aria-label="Enter key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M12 3.53088v3c0 1-1 2-2 2H4m3 3-3-3 3-3"/></g></svg></kbd>
<span class=flexsearch-key-label>to select</span></li><li><kbd class=flexsearch-button-cmd-key><svg width="15" height="15" aria-label="Escape key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M13.6167 8.936c-.1065.3583-.6883.962-1.4875.962-.7993.0-1.653-.9165-1.653-2.1258v-.5678c0-1.2548.7896-2.1016 1.653-2.1016s1.3601.4778 1.4875 1.0724M9 6c-.1352-.4735-.7506-.9219-1.46-.8972-.7092.0246-1.344.57-1.344 1.2166s.4198.8812 1.3445.9805C8.465 7.3992 8.968 7.9337 9 8.5s-.454 1.398-1.4595 1.398C6.6593 9.898 6 9 5.963 8.4851m-1.4748.5368c-.2635.5941-.8099.876-1.5443.876s-1.7073-.6248-1.7073-2.204v-.4603c0-1.0416.721-2.131 1.7073-2.131.9864.0 1.6425 1.031 1.5443 2.2492h-2.956"/></g></svg></kbd>
<span class=flexsearch-key-label>to close</span></li></div><form class="flexsearch position-relative flex-grow-1 ms-2 me-2"><div class="d-flex flex-row"><input id=flexsearch class=form-control type=search placeholder=Search aria-label=Search autocomplete=off>
<button id=hideFlexsearch type=button class="ms-2 btn btn-soft">
cancel</button></div><div id=suggestions class="shadow rounded-1 d-none"></div></form></div></div></div><div class=container-fluid><div class=layout-spacing><div class="d-md-flex justify-content-between align-items-center"><nav aria-label=breadcrumb class="d-inline-block pb-2 mt-1 mt-sm-0"><ul id=breadcrumbs class="breadcrumb bg-transparent mb-0" itemscope itemtype=https://schema.org/BreadcrumbList><li class="breadcrumb-item text-capitalize active" aria-current=page itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=/chapitres/><i class="material-icons size-20 align-text-bottom" itemprop=name>Home</i>
</a><meta itemprop=position content='1'></li><li class="breadcrumb-item text-capitalize" itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=/chapitres/stockage/><span itemprop=name>Chapitres de Stockage</span>
</a><meta itemprop=position content='2'></li><li class="breadcrumb-item text-capitalize" itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=/chapitres/stockage/multi-sources/><span itemprop=name>Stockage Multi-sources</span>
</a><meta itemprop=position content='3'></li><li class="breadcrumb-item text-capitalize active" itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><span itemprop=name>Stockage Multi-sources - CQS</span>
<meta itemprop=position content='4'></li></ul></nav></div><div class="row flex-xl-nowrap"><div class="docs-toc col-xl-3 d-xl-block"><toc><div class="fw-bold text-uppercase mb-2">On this page</div><nav id=TableOfContents><ul><li><a href=#-contexte-et-objectifs-pourquoi-cqs-avec-multi-sources-la-combinaison-cqs-avec-multi-sources-offre-une-architecture-optimisée-qui-sépare-clairement-les-responsabilités-tout-en-exploitant-les-avantages-de-différents-types-de-stockage-cette-approche-permet-doptimiser-chaque-côté-commandes-et-requêtes-avec-les-sources-les-plus-appropriées-avantages-de-cqs-avec-multi-sources--performance-optimisée--séparation-claire-entre-écriture-et-lecture--flexibilité-maximale--choix-du-meilleur-stockage-pour-chaque-opération--scalabilité--possibilité-de-scaler-indépendamment-chaque-côté--résilience--redondance-et-failover-entre-sources--maintenabilité--code-plus-clair-et-organisé-contexte-gyroscopsdans-notre-écosystème-user--organization--workflow--cloud-resources--billing-cqs-avec-multi-sources-est-particulièrement-pertinent-pour---workflows-de-commande--orchestration-des-processus-de-modification-avec-sources-optimisées--workflows-de-requête--optimisation-des-lectures-avec-sources-spécialisées--processus-de-facturation--séparation-des-écritures-et-lectures-de-facturation--intégrations-complexes--orchestration-des-intégrations-avec-sources-multiples--architecture-cqs-avec-multi-sources-séparation-des-responsabilités-côté-commande-write-avec-multi-sources--command-workflows--orchestration-des-processus-de-modification--command-activities--exécution-des-activités-de-modification--event-handlers--gestion-des-événements-de-domaine--command-bus--orchestration-des-commandes--write-sources--sources-optimisées-pour-les-écritures--command-models--modèles-optimisés-pour-les-écritures-côté-requête-read-avec-multi-sources--query-workflows--orchestration-des-processus-de-lecture--query-activities--exécution-des-activités-de-lecture--search-services--services-de-recherche-spécialisés--query-bus--orchestration-des-requêtes--read-sources--sources-optimisées-pour-les-lectures--query-models--modèles-optimisés-pour-les-lectures-flux-de-donnéesmermaidgraph-td----acommand----bcommand-bus----b----ccommand-workflow----c----dcommand-activities----d----ewrite-sources----e----fsql-database----e----gredis-cache----e----hfile-system--------iquery----jquery-bus----j----kquery-workflow----k----lquery-activities----l----mread-sources----m----nelasticsearch----m----oredis-cache----m----psql-database--------qevent----revent-handler----r----c--------sprojection----tread-model-update----t----m--implémentation-pratique-1-command-side-avec-multi-sources-command-bus-avec-multi-sourcesphpphpnamespace-appapplicationcommandbusmultisourceuse-appdomaincommandcommandinterfaceuse-appdomaincommandcommandhandlerinterfaceuse-appinfrastructuremultisourcesourcerouteruse-psrlogloggerinterfaceclass-multisourcecommandbus----private-array-handlers------private-array-middleware------private-sourcerouter-sourcerouter----private-loggerinterface-logger----public-function-__construct--------sourcerouter-sourcerouter--------loggerinterface-logger-------------this-sourcerouter--sourcerouter--------this-logger--logger--------public-function-registerhandlerstring-commandclass-commandhandlerinterface-handler-void------------this-handlerscommandclass--handler--------public-function-addmiddlewarecallable-middleware-void------------this-middleware--middleware--------public-function-handlecommandinterface-command-void------------commandclass--get_classcommand----------------if-issetthis-handlerscommandclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-command-commandclass----------------handler--this-handlerscommandclass-----------------exécuter-les-middleware--------this-executemiddlewarecommand-function-use-handler-command-------------this-logger-infoexecuting-command-via-multi-source-cqs-----------------command--get_classcommand----------------data--command-toarray------------------------------------handler-handlecommand----------------private-function-executemiddlewarecommandinterface-command-callable-next-void------------middleware--array_reversethis-middleware----------------foreach-middleware-as-mw-------------next--function-use-mw-command-next-----------------return-mwcommand-next------------------------------------next-----command-workflow-avec-multi-sourcesphpphpnamespace-appworkflowcommandpaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowuse-appinfrastructuremultisourcesourcerouterworkflowinterfaceinterface-paymentmultisourcecommandworkflowinterface----workflowmethod----public-function-processpaymentcommandwithmultisourcepaymentcommandrequest-request-paymentcommandresult--------workflowmethod----public-function-updatepaymentcommandwithmultisourcepaymentupdatecommandrequest-request-paymentcommandresult--------workflowmethod----public-function-deletepaymentcommandwithmultisourcepaymentdeletecommandrequest-request-paymentcommandresultactivityinterfaceinterface-paymentmultisourcecommandactivityinterface----activitymethod----public-function-validatepaymentcommandpaymentcommandrequest-request-validationresult--------activitymethod----public-function-executepaymentcommandpaymentcommandrequest-request-commandexecutionresult--------activitymethod----public-function-persisttowritesourcespayment-payment-array-sources-void--------activitymethod----public-function-updatecommandmodelspayment-payment-voidclass-paymentmultisourcecommandworkflow-implements-paymentmultisourcecommandworkflowinterface----private-paymentmultisourcecommandactivityinterface-commandactivity----private-sourcerouter-sourcerouter----public-function-__construct------------this-commandactivity--workflownewactivitystubpaymentmultisourcecommandactivityinterfaceclass--------this-sourcerouter--workflownewactivitystubsourcerouterclass--------public-function-processpaymentcommandwithmultisourcepaymentcommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------exécution-de-la-commande------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------déterminer-les-sources-décriture-optimales------------writesources--yield-this-sourcerouter-routewritesave-execution-getpayment-------------------------persister-dans-les-sources-décriture------------yield-this-commandactivity-persisttowritesourcesexecution-getpayment-writesources-------------------------mettre-à-jour-les-modèles-de-commande------------yield-this-commandactivity-updatecommandmodelsexecution-getpayment------------------------return-new-paymentcommandresulttrue-payment-command-processed-with-multi-source-cqs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage----------------public-function-updatepaymentcommandwithmultisourcepaymentupdatecommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande-de-mise-à-jour------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------exécution-de-la-mise-à-jour------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------déterminer-les-sources-décriture-optimales------------writesources--yield-this-sourcerouter-routewriteupdate-execution-getpayment-------------------------persister-dans-les-sources-décriture------------yield-this-commandactivity-persisttowritesourcesexecution-getpayment-writesources-------------------------mettre-à-jour-les-modèles-de-commande------------yield-this-commandactivity-updatecommandmodelsexecution-getpayment------------------------return-new-paymentcommandresulttrue-payment-update-command-processed-with-multi-source-cqs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage----------------public-function-deletepaymentcommandwithmultisourcepaymentdeletecommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande-de-suppression------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------exécution-de-la-suppression------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------déterminer-les-sources-décriture-optimales------------writesources--yield-this-sourcerouter-routewritedelete-execution-getpayment-------------------------persister-dans-les-sources-décriture------------yield-this-commandactivity-persisttowritesourcesexecution-getpayment-writesources-------------------------mettre-à-jour-les-modèles-de-commande------------yield-this-commandactivity-updatecommandmodelsexecution-getpayment------------------------return-new-paymentcommandresulttrue-payment-delete-command-processed-with-multi-source-cqs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage-------------2-query-side-avec-multi-sources-query-bus-avec-cache-et-multi-sourcesphpphpnamespace-appapplicationquerybusmultisourceuse-appdomainqueryqueryinterfaceuse-appdomainqueryqueryhandlerinterfaceuse-appinfrastructuremultisourcesourcerouteruse-appinfrastructuremultisourcemultisourcecachemanageruse-psrlogloggerinterfaceclass-multisourcequerybus----private-array-handlers------private-sourcerouter-sourcerouter----private-multisourcecachemanager-cachemanager----private-loggerinterface-logger----public-function-__construct--------sourcerouter-sourcerouter--------multisourcecachemanager-cachemanager--------loggerinterface-logger-------------this-sourcerouter--sourcerouter--------this-cachemanager--cachemanager--------this-logger--logger--------public-function-registerhandlerstring-queryclass-queryhandlerinterface-handler-void------------this-handlersqueryclass--handler--------public-function-handlequeryinterface-query-mixed------------queryclass--get_classquery----------------if-issetthis-handlersqueryclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-query-queryclass-----------------vérifier-le-cache--------cachekey--this-generatecachekeyquery--------cachedresult--this-cachemanager-getcachekey----------------if-cachedresult--null-------------this-logger-debugquery-result-served-from-cache-----------------query--queryclass----------------cachekey--cachekey------------------------------------return-cachedresult-----------------déterminer-la-source-de-lecture-optimale--------readsource--this-sourcerouter-routereadqueryclass-query-toarray-----------------exécuter-la-requête-via-la-source-optimale--------handler--this-handlersqueryclass--------result--handler-handlequery-readsource-----------------mettre-en-cache--------this-cachemanager-setcachekey-result-300----------------this-logger-infoquery-executed-and-cached-via-multi-source-cqs-------------query--queryclass------------source--readsource------------cachekey--cachekey------------------------return-result--------private-function-generatecachekeyqueryinterface-query-string------------return-multi_source_query_--md5serializequery-----query-workflow-avec-multi-sourcesphpphpnamespace-appworkflowquerypaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowuse-appinfrastructuremultisourcesourcerouterworkflowinterfaceinterface-paymentmultisourcequeryworkflowinterface----workflowmethod----public-function-searchpaymentswithmultisourcepaymentsearchquery-query-paymentsearchresult--------workflowmethod----public-function-getpaymentbyidwithmultisourcepaymentbyidquery-query-payment--------workflowmethod----public-function-getpaymentstatisticswithmultisourcepaymentstatisticsquery-query-array--------workflowmethod----public-function-getpaymentanalyticswithmultisourcepaymentanalyticsquery-query-arrayactivityinterfaceinterface-paymentmultisourcequeryactivityinterface----activitymethod----public-function-searchpaymentsinsourcepaymentsearchquery-query-string-source-array--------activitymethod----public-function-getpaymentfromsourcestring-paymentid-string-source-payment--------activitymethod----public-function-calculatepaymentstatisticsinsourcepaymentstatisticsquery-query-string-source-array--------activitymethod----public-function-generatepaymentanalyticsinsourcepaymentanalyticsquery-query-string-source-arrayclass-paymentmultisourcequeryworkflow-implements-paymentmultisourcequeryworkflowinterface----private-paymentmultisourcequeryactivityinterface-queryactivity----private-sourcerouter-sourcerouter----public-function-__construct------------this-queryactivity--workflownewactivitystubpaymentmultisourcequeryactivityinterfaceclass--------this-sourcerouter--workflownewactivitystubsourcerouterclass--------public-function-searchpaymentswithmultisourcepaymentsearchquery-query-paymentsearchresult------------try--------------déterminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadsearch-query-toarray-------------------------recherche-dans-la-source-optimale------------payments--yield-this-queryactivity-searchpaymentsinsourcequery-readsource-------------------------filtrage-et-tri------------filteredpayments--this-filterpaymentspayments-query------------sortedpayments--this-sortpaymentsfilteredpayments-query-------------------------pagination------------paginatedpayments--this-paginatepaymentssortedpayments-query------------------------return-new-paymentsearchresult----------------paginatedpayments----------------countfilteredpayments----------------query-getpage----------------query-getsize---------------------------------catch-exception-e-------------return-new-paymentsearchresult-0-query-getpage-query-getsize----------------public-function-getpaymentbyidwithmultisourcepaymentbyidquery-query-payment------------try--------------déterminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadfindbyid-id--query-getpaymentid------------------------return-yield-this-queryactivity-getpaymentfromsourcequery-getpaymentid-readsource---------catch-exception-e-------------return-null----------------public-function-getpaymentstatisticswithmultisourcepaymentstatisticsquery-query-array------------try--------------déterminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadstatistics-query-toarray------------------------return-yield-this-queryactivity-calculatepaymentstatisticsinsourcequery-readsource---------catch-exception-e-------------return-----------------public-function-getpaymentanalyticswithmultisourcepaymentanalyticsquery-query-array------------try--------------déterminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadanalytics-query-toarray------------------------return-yield-this-queryactivity-generatepaymentanalyticsinsourcequery-readsource---------catch-exception-e-------------return-----------------private-function-filterpaymentsarray-payments-paymentsearchquery-query-array------------return-array_filterpayments-functionpayment-use-query-------------if-query-getorganizationid--payment-getorganizationid--query-getorganizationid-----------------return-false------------------------------------if-query-getstatus--payment-getstatus--query-getstatus-----------------return-false------------------------------------if-query-getminamount--payment-getamount--query-getminamount-----------------return-false------------------------------------if-query-getmaxamount--payment-getamount--query-getmaxamount-----------------return-false------------------------------------return-true----------------private-function-sortpaymentsarray-payments-paymentsearchquery-query-array------------sortfield--query-getsortfield--createdat--------sortdirection--query-getsortdirection--desc----------------usortpayments-functiona-b-use-sortfield-sortdirection-------------valuea--this-getfieldvaluea-sortfield------------valueb--this-getfieldvalueb-sortfield------------------------if-sortdirection--asc-----------------return-valuea--valueb-------------else-----------------return-valueb--valuea------------------------------------return-payments--------private-function-paginatepaymentsarray-payments-paymentsearchquery-query-array------------page--query-getpage--1--------size--query-getsize--10--------offset--page---1--size----------------return-array_slicepayments-offset-size--------private-function-getfieldvaluepayment-payment-string-field-mixed------------switch-field-------------case-amount----------------return-payment-getamount------------case-createdat----------------return-payment-getcreatedat------------case-status----------------return-payment-getstatus------------default----------------return-payment-getcreatedat-------------3-service-de-synchronisation-multi-sources-service-de-synchronisation-cqsphpphpnamespace-appapplicationservicemultisourceuse-appdomaineventdomaineventuse-appinfrastructuremultisourcesourcerouteruse-appinfrastructuremultisourcemultisourcecachemanageruse-psrlogloggerinterfaceclass-multisourcecqssynchronizationservice----private-sourcerouter-sourcerouter----private-multisourcecachemanager-cachemanager----private-loggerinterface-logger----public-function-__construct--------sourcerouter-sourcerouter--------multisourcecachemanager-cachemanager--------loggerinterface-logger-------------this-sourcerouter--sourcerouter--------this-cachemanager--cachemanager--------this-logger--logger--------public-function-handleeventdomainevent-event-void------------try-------------this-logger-infohandling-event-via-multi-source-cqs-----------------eventtype--event-geteventtype----------------eventid--event-getid-------------------------déterminer-les-sources-affectées------------affectedsources--this-determineaffectedsourcesevent-------------------------mettre-à-jour-chaque-source------------foreach-affectedsources-as-source-----------------this-updatesourcesource-event-------------------------------------invalider-le-cache-si-nécessaire------------if-this-shouldinvalidatecacheevent-----------------this-invalidatecacheevent---------------------------------catch-exception-e-------------this-logger-errorfailed-to-handle-event-via-multi-source-cqs-----------------eventtype--event-geteventtype----------------error--e-getmessage------------------------------------throw-e----------------public-function-synchronizesources-void------------try-------------this-logger-infosynchronizing-sources-via-multi-source-cqs-------------------------synchroniser-les-sources-de-lecture-avec-les-sources-décriture------------this-synchronizereadsources-------------------------nettoyer-les-caches-expirés------------this-cleanexpiredcaches------------------------this-logger-infosources-synchronized-successfully-via-multi-source-cqs---------------------catch-exception-e-------------this-logger-errorfailed-to-synchronize-sources-via-multi-source-cqs-----------------error--e-getmessage------------------------------------throw-e----------------private-function-determineaffectedsourcesdomainevent-event-array------------sources-------------------toujours-affecter-la-base-de-données-pour-les-événements-critiques--------if-this-iscriticaleventevent-------------sources--database-------------------------affecter-le-cache-pour-les-événements-de-lecture--------if-this-isreadeventevent-------------sources--cache-------------------------affecter-elasticsearch-pour-les-événements-de-recherche--------if-this-issearcheventevent-------------sources--elasticsearch------------------------return-sources--------private-function-updatesourcestring-source-domainevent-event-void------------this-logger-debugupdating-source-------------source--source------------eventtype--event-geteventtype-------------------------implémentation-spécifique-à-chaque-source--------switch-source-------------case-database----------------this-updatedatabaseevent----------------break------------case-cache----------------this-updatecacheevent----------------break------------case-elasticsearch----------------this-updateelasticsearchevent----------------break----------------private-function-shouldinvalidatecachedomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentupdated------------paymentdeleted------------paymentstatuschanged----------------private-function-invalidatecachedomainevent-event-void------------this-logger-debuginvalidating-cache-------------eventtype--event-geteventtype-------------------------invalider-les-caches-pertinents--------if-issetevent-getdatapaymentid-------------this-cachemanager-deletepaymentevent-getdatapaymentid----------------private-function-iscriticaleventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentcreated------------paymentupdated------------paymentdeleted----------------private-function-isreadeventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentviewed------------paymentsearched----------------private-function-issearcheventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentcreated------------paymentupdated------------paymentdeleted----------------private-function-updatedatabasedomainevent-event-void-------------implémentation-de-la-mise-à-jour-de-la-base-de-données--------private-function-updatecachedomainevent-event-void-------------implémentation-de-la-mise-à-jour-du-cache--------private-function-updateelasticsearchdomainevent-event-void-------------implémentation-de-la-mise-à-jour-delasticsearch--------private-function-synchronizereadsources-void-------------implémentation-de-la-synchronisation-des-sources-de-lecture--------private-function-cleanexpiredcaches-void-------------implémentation-du-nettoyage-des-caches-expirés------tests-et-validation-tests-dphpphpnamespace-apptestsintegrationmultisourceuse-appworkflowcommandpaymentpaymentcommandrequestuse-appworkflowquerypaymentpaymentsearchqueryuse-appapplicationcommandbusmultisourcemultisourcecommandbususe-appapplicationquerybusmultisourcemultisourcequerybususe-appinfrastructuremultisourcesourcerouterclass-multisourcecqstest-extends-testcase----private-multisourcecommandbus-commandbus----private-multisourcequerybus-querybus----private-sourcerouter-sourcerouter----protected-function-setup-void------------this-sourcerouter--this-createmocksourcerouterclass--------this-commandbus--new-multisourcecommandbus------------this-sourcerouter------------this-createmockloggerinterfaceclass----------------this-querybus--new-multisourcequerybus------------this-sourcerouter------------this-createmockmultisourcecachemanagerclass------------this-createmockloggerinterfaceclass----------------public-function-testcqsseparationwithmultisource-void-------------exécuter-une-commande-avec-multi-source-cqs--------command--new-paymentcommandrequest------------create------------payment-123------------org-456------------user-789------------10000------------eur------------test-payment------------------------this-commandbus-handlecommand-----------------vérifier-avec-une-requête--------query--new-paymentsearchqueryorg-456-0-10--------result--this-querybus-handlequery----------------this-assertgreaterthan0-result-gettotal--------public-function-testquerycachingwithmultisource-void------------query--new-paymentsearchqueryorg-456-0-10-----------------première-recherche--------result1--this-querybus-handlequery-----------------deuxième-recherche-devrait-utiliser-le-cache--------result2--this-querybus-handlequery----------------this-assertequalsresult1-gettotal-result2-gettotal------performance-et-optimisation-stratégies-d-1-cache-stratégique-multi-sourcesphppublic-function-searchpaymentswithcachepaymentsearchquery-query-paymentsearchresult----cachekey--multi_source_payment_search_--md5serializequery--------if-cached--this-cachemanager-getcachekey---------return-cached------------result--this-searchpaymentswithmultisourcequery----this-cachemanager-setcachekey-result-300--------return-result-2-load-balancing-multi-sourcesphppublic-function-getoptimalsourceforoperationstring-operation-array-criteria---string----sourceloads--this-getsourceloads----optimalsource--array_keyssourceloads-minsourceloads0--------this-logger-debugselected-optimal-source-for-operation---------operation--operation--------source--optimalsource--------loads--sourceloads------------return-optimalsource-3-monitoring-des-sources-multi-sourcesphppublic-function-getmultisourcemetrics-array----return---------commandsources--this-getcommandsourcemetrics--------querysources--this-getquerysourcemetrics--------cachehitrate--this-getcachehitrate--------sourcehealth--this-getsourcehealth--------averageexecutiontime--this-getaverageexecutiontime------critères-d-quand-utiliser-cqs-avec-multi-sources--avantages--performance-optimisée--séparation-claire-entre-écriture-et-lecture--flexibilité-maximale--choix-du-meilleur-stockage-pour-chaque-opération--scalabilité--possibilité-de-scaler-indépendamment-chaque-côté--résilience--redondance-et-failover-entre-sources--maintenabilité--code-plus-clair-et-organisé--inconvénients--complexité-élevée--gestion-de-plusieurs-sources-de-données--cohérence--risque-dincohérence-entre-sources--maintenance--plus-de-sources-à-maintenir--expertise--équipe-expérimentée-requise--critères-d--système-complexe--besoins-de-performance-différents-par-type-dopération--données-hétérogènes--types-de-données-différents-nécessitant-différents-stockages--performance-critique--besoins-de-performance-optimale--séparation-des-responsabilités--besoin-de-séparer-clairement-les-commandes-et-requêtes--équipe-expérimentée--maîtrise-de-plusieurs-technologies-de-stockage-et-cqs--budget-suffisant--investissement-en-infrastructure-multiple--temps-de-développement--suffisant-pour-implémenter-cette-complexité--votre-prochaine-étapehahahugoshortcode59s0hbhbcqs-avec-multi-sources-offre-un-équilibre-optimal-entre-performance-et-flexibilité-parfaitement-adapté-aux-besoins-complexes-de-gyroscops>🎯 <strong>Contexte et Objectifs</strong>### **Pourquoi CQS avec Multi-sources ?**La combinaison CQS avec Multi-sources offre une architecture optimisée qui sépare clairement les responsabilités tout en exploitant les avantages de différents types de stockage. Cette approche permet d’optimiser chaque côté (commandes et requêtes) avec les sources les plus appropriées.#### <strong>Avantages de CQS avec Multi-sources</strong>- <strong>Performance optimisée</strong> : Séparation claire entre écriture et lecture- <strong>Flexibilité maximale</strong> : Choix du meilleur stockage pour chaque opération- <strong>Scalabilité</strong> : Possibilité de scaler indépendamment chaque côté- <strong>Résilience</strong> : Redondance et failover entre sources- <strong>Maintenabilité</strong> : Code plus clair et organisé### <strong>Contexte Gyroscops</strong>Dans notre écosystème <strong>User → Organization → Workflow → Cloud Resources → Billing</strong>, CQS avec Multi-sources est particulièrement pertinent pour :- <strong>Workflows de commande</strong> : Orchestration des processus de modification avec sources optimisées- <strong>Workflows de requête</strong> : Optimisation des lectures avec sources spécialisées- <strong>Processus de facturation</strong> : Séparation des écritures et lectures de facturation- <strong>Intégrations complexes</strong> : Orchestration des intégrations avec sources multiples## 🏗️ <strong>Architecture CQS avec Multi-sources</strong>### <strong>Séparation des Responsabilités</strong>#### <strong>Côté Commande (Write) avec Multi-sources</strong>- <strong>Command Workflows</strong> : Orchestration des processus de modification- <strong>Command Activities</strong> : Exécution des activités de modification- <strong>Event Handlers</strong> : Gestion des événements de domaine- <strong>Command Bus</strong> : Orchestration des commandes- <strong>Write Sources</strong> : Sources optimisées pour les écritures- <strong>Command Models</strong> : Modèles optimisés pour les écritures#### <strong>Côté Requête (Read) avec Multi-sources</strong>- <strong>Query Workflows</strong> : Orchestration des processus de lecture- <strong>Query Activities</strong> : Exécution des activités de lecture- <strong>Search Services</strong> : Services de recherche spécialisés- <strong>Query Bus</strong> : Orchestration des requêtes- <strong>Read Sources</strong> : Sources optimisées pour les lectures- <strong>Query Models</strong> : Modèles optimisés pour les lectures### <strong>Flux de Données</strong><code>mermaidgraph TD A[Command] --> B[Command Bus] B --> C[Command Workflow] C --> D[Command Activities] D --> E[Write Sources] E --> F[SQL Database] E --> G[Redis Cache] E --> H[File System] I[Query] --> J[Query Bus] J --> K[Query Workflow] K --> L[Query Activities] L --> M[Read Sources] M --> N[ElasticSearch] M --> O[Redis Cache] M --> P[SQL Database] Q[Event] --> R[Event Handler] R --> C S[Projection] --> T[Read Model Update] T --> M</code>## 💻 <strong>Implémentation Pratique</strong>### <strong>1. Command Side avec Multi-sources</strong>#### <strong>Command Bus avec Multi-sources</strong><code>php&lt;?phpnamespace App\Application\CommandBus\MultiSource;use App\Domain\Command\CommandInterface;use App\Domain\Command\CommandHandlerInterface;use App\Infrastructure\MultiSource\SourceRouter;use Psr\Log\LoggerInterface;class MultiSourceCommandBus{ private array $handlers = []; private array $middleware = []; private SourceRouter $sourceRouter; private LoggerInterface $logger; public function __construct( SourceRouter $sourceRouter, LoggerInterface $logger ) { $this->sourceRouter = $sourceRouter; $this->logger = $logger; } public function registerHandler(string $commandClass, CommandHandlerInterface $handler): void { $this->handlers[$commandClass] = $handler; } public function addMiddleware(callable $middleware): void { $this->middleware[] = $middleware; } public function handle(CommandInterface $command): void { $commandClass = get_class($command); if (!isset($this->handlers[$commandClass])) { throw new \InvalidArgumentException("No handler registered for command: $commandClass"); } $handler = $this->handlers[$commandClass]; // Exécuter les middleware $this->executeMiddleware($command, function() use ($handler, $command) { $this->logger->info('Executing command via Multi-source CQS', [ 'command' => get_class($command), 'data' => $command->toArray() ]); $handler->handle($command); }); } private function executeMiddleware(CommandInterface $command, callable $next): void { $middleware = array_reverse($this->middleware); foreach ($middleware as $mw) { $next = function() use ($mw, $command, $next) { return $mw($command, $next); }; } $next(); }}</code>#### <strong>Command Workflow avec Multi-sources</strong><code>php&lt;?phpnamespace App\Workflow\Command\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Infrastructure\MultiSource\SourceRouter;#[WorkflowInterface]interface PaymentMultiSourceCommandWorkflowInterface{ #[WorkflowMethod] public function processPaymentCommandWithMultiSource(PaymentCommandRequest $request): PaymentCommandResult; #[WorkflowMethod] public function updatePaymentCommandWithMultiSource(PaymentUpdateCommandRequest $request): PaymentCommandResult; #[WorkflowMethod] public function deletePaymentCommandWithMultiSource(PaymentDeleteCommandRequest $request): PaymentCommandResult;}#[ActivityInterface]interface PaymentMultiSourceCommandActivityInterface{ #[ActivityMethod] public function validatePaymentCommand(PaymentCommandRequest $request): ValidationResult; #[ActivityMethod] public function executePaymentCommand(PaymentCommandRequest $request): CommandExecutionResult; #[ActivityMethod] public function persistToWriteSources(Payment $payment, array $sources): void; #[ActivityMethod] public function updateCommandModels(Payment $payment): void;}class PaymentMultiSourceCommandWorkflow implements PaymentMultiSourceCommandWorkflowInterface{ private PaymentMultiSourceCommandActivityInterface $commandActivity; private SourceRouter $sourceRouter; public function __construct() { $this->commandActivity = Workflow::newActivityStub(PaymentMultiSourceCommandActivityInterface::class); $this->sourceRouter = Workflow::newActivityStub(SourceRouter::class); } public function processPaymentCommandWithMultiSource(PaymentCommandRequest $request): PaymentCommandResult { try { // Validation de la commande $validation = yield $this->commandActivity->validatePaymentCommand($request); if (!$validation->isValid()) { return new PaymentCommandResult(false, $validation->getError()); } // Exécution de la commande $execution = yield $this->commandActivity->executePaymentCommand($request); if (!$execution->isSuccess()) { return new PaymentCommandResult(false, $execution->getError()); } // Déterminer les sources d'écriture optimales $writeSources = yield $this->sourceRouter->routeWrite('save', $execution->getPayment()); // Persister dans les sources d'écriture yield $this->commandActivity->persistToWriteSources($execution->getPayment(), $writeSources); // Mettre à jour les modèles de commande yield $this->commandActivity->updateCommandModels($execution->getPayment()); return new PaymentCommandResult(true, 'Payment command processed with Multi-source CQS'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e->getMessage()); } } public function updatePaymentCommandWithMultiSource(PaymentUpdateCommandRequest $request): PaymentCommandResult { try { // Validation de la commande de mise à jour $validation = yield $this->commandActivity->validatePaymentCommand($request); if (!$validation->isValid()) { return new PaymentCommandResult(false, $validation->getError()); } // Exécution de la mise à jour $execution = yield $this->commandActivity->executePaymentCommand($request); if (!$execution->isSuccess()) { return new PaymentCommandResult(false, $execution->getError()); } // Déterminer les sources d'écriture optimales $writeSources = yield $this->sourceRouter->routeWrite('update', $execution->getPayment()); // Persister dans les sources d'écriture yield $this->commandActivity->persistToWriteSources($execution->getPayment(), $writeSources); // Mettre à jour les modèles de commande yield $this->commandActivity->updateCommandModels($execution->getPayment()); return new PaymentCommandResult(true, 'Payment update command processed with Multi-source CQS'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e->getMessage()); } } public function deletePaymentCommandWithMultiSource(PaymentDeleteCommandRequest $request): PaymentCommandResult { try { // Validation de la commande de suppression $validation = yield $this->commandActivity->validatePaymentCommand($request); if (!$validation->isValid()) { return new PaymentCommandResult(false, $validation->getError()); } // Exécution de la suppression $execution = yield $this->commandActivity->executePaymentCommand($request); if (!$execution->isSuccess()) { return new PaymentCommandResult(false, $execution->getError()); } // Déterminer les sources d'écriture optimales $writeSources = yield $this->sourceRouter->routeWrite('delete', $execution->getPayment()); // Persister dans les sources d'écriture yield $this->commandActivity->persistToWriteSources($execution->getPayment(), $writeSources); // Mettre à jour les modèles de commande yield $this->commandActivity->updateCommandModels($execution->getPayment()); return new PaymentCommandResult(true, 'Payment delete command processed with Multi-source CQS'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e->getMessage()); } }}</code>### <strong>2. Query Side avec Multi-sources</strong>#### <strong>Query Bus avec Cache et Multi-sources</strong><code>php&lt;?phpnamespace App\Application\QueryBus\MultiSource;use App\Domain\Query\QueryInterface;use App\Domain\Query\QueryHandlerInterface;use App\Infrastructure\MultiSource\SourceRouter;use App\Infrastructure\MultiSource\MultiSourceCacheManager;use Psr\Log\LoggerInterface;class MultiSourceQueryBus{ private array $handlers = []; private SourceRouter $sourceRouter; private MultiSourceCacheManager $cacheManager; private LoggerInterface $logger; public function __construct( SourceRouter $sourceRouter, MultiSourceCacheManager $cacheManager, LoggerInterface $logger ) { $this->sourceRouter = $sourceRouter; $this->cacheManager = $cacheManager; $this->logger = $logger; } public function registerHandler(string $queryClass, QueryHandlerInterface $handler): void { $this->handlers[$queryClass] = $handler; } public function handle(QueryInterface $query): mixed { $queryClass = get_class($query); if (!isset($this->handlers[$queryClass])) { throw new \InvalidArgumentException("No handler registered for query: $queryClass"); } // Vérifier le cache $cacheKey = $this->generateCacheKey($query); $cachedResult = $this->cacheManager->get($cacheKey); if ($cachedResult !== null) { $this->logger->debug('Query result served from cache', [ 'query' => $queryClass, 'cacheKey' => $cacheKey ]); return $cachedResult; } // Déterminer la source de lecture optimale $readSource = $this->sourceRouter->routeRead($queryClass, $query->toArray()); // Exécuter la requête via la source optimale $handler = $this->handlers[$queryClass]; $result = $handler->handle($query, $readSource); // Mettre en cache $this->cacheManager->set($cacheKey, $result, 300); $this->logger->info('Query executed and cached via Multi-source CQS', [ 'query' => $queryClass, 'source' => $readSource, 'cacheKey' => $cacheKey ]); return $result; } private function generateCacheKey(QueryInterface $query): string { return 'multi_source_query_' . md5(serialize($query)); }}</code>#### <strong>Query Workflow avec Multi-sources</strong><code>php&lt;?phpnamespace App\Workflow\Query\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Infrastructure\MultiSource\SourceRouter;#[WorkflowInterface]interface PaymentMultiSourceQueryWorkflowInterface{ #[WorkflowMethod] public function searchPaymentsWithMultiSource(PaymentSearchQuery $query): PaymentSearchResult; #[WorkflowMethod] public function getPaymentByIdWithMultiSource(PaymentByIdQuery $query): ?Payment; #[WorkflowMethod] public function getPaymentStatisticsWithMultiSource(PaymentStatisticsQuery $query): array; #[WorkflowMethod] public function getPaymentAnalyticsWithMultiSource(PaymentAnalyticsQuery $query): array;}#[ActivityInterface]interface PaymentMultiSourceQueryActivityInterface{ #[ActivityMethod] public function searchPaymentsInSource(PaymentSearchQuery $query, string $source): array; #[ActivityMethod] public function getPaymentFromSource(string $paymentId, string $source): ?Payment; #[ActivityMethod] public function calculatePaymentStatisticsInSource(PaymentStatisticsQuery $query, string $source): array; #[ActivityMethod] public function generatePaymentAnalyticsInSource(PaymentAnalyticsQuery $query, string $source): array;}class PaymentMultiSourceQueryWorkflow implements PaymentMultiSourceQueryWorkflowInterface{ private PaymentMultiSourceQueryActivityInterface $queryActivity; private SourceRouter $sourceRouter; public function __construct() { $this->queryActivity = Workflow::newActivityStub(PaymentMultiSourceQueryActivityInterface::class); $this->sourceRouter = Workflow::newActivityStub(SourceRouter::class); } public function searchPaymentsWithMultiSource(PaymentSearchQuery $query): PaymentSearchResult { try { // Déterminer la source de lecture optimale $readSource = yield $this->sourceRouter->routeRead('search', $query->toArray()); // Recherche dans la source optimale $payments = yield $this->queryActivity->searchPaymentsInSource($query, $readSource); // Filtrage et tri $filteredPayments = $this->filterPayments($payments, $query); $sortedPayments = $this->sortPayments($filteredPayments, $query); // Pagination $paginatedPayments = $this->paginatePayments($sortedPayments, $query); return new PaymentSearchResult( $paginatedPayments, count($filteredPayments), $query->getPage(), $query->getSize() ); } catch (\Exception $e) { return new PaymentSearchResult([], 0, $query->getPage(), $query->getSize()); } } public function getPaymentByIdWithMultiSource(PaymentByIdQuery $query): ?Payment { try { // Déterminer la source de lecture optimale $readSource = yield $this->sourceRouter->routeRead('findById', ['id' => $query->getPaymentId()]); return yield $this->queryActivity->getPaymentFromSource($query->getPaymentId(), $readSource); } catch (\Exception $e) { return null; } } public function getPaymentStatisticsWithMultiSource(PaymentStatisticsQuery $query): array { try { // Déterminer la source de lecture optimale $readSource = yield $this->sourceRouter->routeRead('statistics', $query->toArray()); return yield $this->queryActivity->calculatePaymentStatisticsInSource($query, $readSource); } catch (\Exception $e) { return []; } } public function getPaymentAnalyticsWithMultiSource(PaymentAnalyticsQuery $query): array { try { // Déterminer la source de lecture optimale $readSource = yield $this->sourceRouter->routeRead('analytics', $query->toArray()); return yield $this->queryActivity->generatePaymentAnalyticsInSource($query, $readSource); } catch (\Exception $e) { return []; } } private function filterPayments(array $payments, PaymentSearchQuery $query): array { return array_filter($payments, function($payment) use ($query) { if ($query->getOrganizationId() && $payment->getOrganizationId() !== $query->getOrganizationId()) { return false; } if ($query->getStatus() && $payment->getStatus() !== $query->getStatus()) { return false; } if ($query->getMinAmount() && $payment->getAmount() &lt; $query->getMinAmount()) { return false; } if ($query->getMaxAmount() && $payment->getAmount() > $query->getMaxAmount()) { return false; } return true; }); } private function sortPayments(array $payments, PaymentSearchQuery $query): array { $sortField = $query->getSortField() ?? 'createdAt'; $sortDirection = $query->getSortDirection() ?? 'desc'; usort($payments, function($a, $b) use ($sortField, $sortDirection) { $valueA = $this->getFieldValue($a, $sortField); $valueB = $this->getFieldValue($b, $sortField); if ($sortDirection === 'asc') { return $valueA &lt;=> $valueB; } else { return $valueB &lt;=> $valueA; } }); return $payments; } private function paginatePayments(array $payments, PaymentSearchQuery $query): array { $page = $query->getPage() ?? 1; $size = $query->getSize() ?? 10; $offset = ($page - 1) * $size; return array_slice($payments, $offset, $size); } private function getFieldValue(Payment $payment, string $field): mixed { switch ($field) { case 'amount': return $payment->getAmount(); case 'createdAt': return $payment->getCreatedAt(); case 'status': return $payment->getStatus(); default: return $payment->getCreatedAt(); } }}</code>### <strong>3. Service de Synchronisation Multi-Sources</strong>#### <strong>Service de Synchronisation CQS</strong><code>php&lt;?phpnamespace App\Application\Service\MultiSource;use App\Domain\Event\DomainEvent;use App\Infrastructure\MultiSource\SourceRouter;use App\Infrastructure\MultiSource\MultiSourceCacheManager;use Psr\Log\LoggerInterface;class MultiSourceCqsSynchronizationService{ private SourceRouter $sourceRouter; private MultiSourceCacheManager $cacheManager; private LoggerInterface $logger; public function __construct( SourceRouter $sourceRouter, MultiSourceCacheManager $cacheManager, LoggerInterface $logger ) { $this->sourceRouter = $sourceRouter; $this->cacheManager = $cacheManager; $this->logger = $logger; } public function handleEvent(DomainEvent $event): void { try { $this->logger->info('Handling event via Multi-source CQS', [ 'eventType' => $event->getEventType(), 'eventId' => $event->getId() ]); // Déterminer les sources affectées $affectedSources = $this->determineAffectedSources($event); // Mettre à jour chaque source foreach ($affectedSources as $source) { $this->updateSource($source, $event); } // Invalider le cache si nécessaire if ($this->shouldInvalidateCache($event)) { $this->invalidateCache($event); } } catch (\Exception $e) { $this->logger->error('Failed to handle event via Multi-source CQS', [ 'eventType' => $event->getEventType(), 'error' => $e->getMessage() ]); throw $e; } } public function synchronizeSources(): void { try { $this->logger->info('Synchronizing sources via Multi-source CQS'); // Synchroniser les sources de lecture avec les sources d'écriture $this->synchronizeReadSources(); // Nettoyer les caches expirés $this->cleanExpiredCaches(); $this->logger->info('Sources synchronized successfully via Multi-source CQS'); } catch (\Exception $e) { $this->logger->error('Failed to synchronize sources via Multi-source CQS', [ 'error' => $e->getMessage() ]); throw $e; } } private function determineAffectedSources(DomainEvent $event): array { $sources = []; // Toujours affecter la base de données pour les événements critiques if ($this->isCriticalEvent($event)) { $sources[] = 'database'; } // Affecter le cache pour les événements de lecture if ($this->isReadEvent($event)) { $sources[] = 'cache'; } // Affecter ElasticSearch pour les événements de recherche if ($this->isSearchEvent($event)) { $sources[] = 'elasticsearch'; } return $sources; } private function updateSource(string $source, DomainEvent $event): void { $this->logger->debug('Updating source', [ 'source' => $source, 'eventType' => $event->getEventType() ]); // Implémentation spécifique à chaque source switch ($source) { case 'database': $this->updateDatabase($event); break; case 'cache': $this->updateCache($event); break; case 'elasticsearch': $this->updateElasticSearch($event); break; } } private function shouldInvalidateCache(DomainEvent $event): bool { return in_array($event->getEventType(), [ 'PaymentUpdated', 'PaymentDeleted', 'PaymentStatusChanged' ]); } private function invalidateCache(DomainEvent $event): void { $this->logger->debug('Invalidating cache', [ 'eventType' => $event->getEventType() ]); // Invalider les caches pertinents if (isset($event->getData()['paymentId'])) { $this->cacheManager->deletePayment($event->getData()['paymentId']); } } private function isCriticalEvent(DomainEvent $event): bool { return in_array($event->getEventType(), [ 'PaymentCreated', 'PaymentUpdated', 'PaymentDeleted' ]); } private function isReadEvent(DomainEvent $event): bool { return in_array($event->getEventType(), [ 'PaymentViewed', 'PaymentSearched' ]); } private function isSearchEvent(DomainEvent $event): bool { return in_array($event->getEventType(), [ 'PaymentCreated', 'PaymentUpdated', 'PaymentDeleted' ]); } private function updateDatabase(DomainEvent $event): void { // Implémentation de la mise à jour de la base de données } private function updateCache(DomainEvent $event): void { // Implémentation de la mise à jour du cache } private function updateElasticSearch(DomainEvent $event): void { // Implémentation de la mise à jour d'ElasticSearch } private function synchronizeReadSources(): void { // Implémentation de la synchronisation des sources de lecture } private function cleanExpiredCaches(): void { // Implémentation du nettoyage des caches expirés }}</code>## 🧪 <strong>Tests et Validation</strong>### <strong>Tests d’Intégration CQS Multi-Sources</strong><code>php&lt;?phpnamespace App\Tests\Integration\MultiSource;use App\Workflow\Command\Payment\PaymentCommandRequest;use App\Workflow\Query\Payment\PaymentSearchQuery;use App\Application\CommandBus\MultiSource\MultiSourceCommandBus;use App\Application\QueryBus\MultiSource\MultiSourceQueryBus;use App\Infrastructure\MultiSource\SourceRouter;class MultiSourceCqsTest extends TestCase{ private MultiSourceCommandBus $commandBus; private MultiSourceQueryBus $queryBus; private SourceRouter $sourceRouter; protected function setUp(): void { $this->sourceRouter = $this->createMock(SourceRouter::class); $this->commandBus = new MultiSourceCommandBus( $this->sourceRouter, $this->createMock(LoggerInterface::class) ); $this->queryBus = new MultiSourceQueryBus( $this->sourceRouter, $this->createMock(MultiSourceCacheManager::class), $this->createMock(LoggerInterface::class) ); } public function testCqsSeparationWithMultiSource(): void { // Exécuter une commande avec Multi-source CQS $command = new PaymentCommandRequest( 'CREATE', 'payment-123', 'org-456', 'user-789', 100.00, 'EUR', 'Test payment' ); $this->commandBus->handle($command); // Vérifier avec une requête $query = new PaymentSearchQuery('org-456', 0, 10); $result = $this->queryBus->handle($query); $this->assertGreaterThan(0, $result->getTotal()); } public function testQueryCachingWithMultiSource(): void { $query = new PaymentSearchQuery('org-456', 0, 10); // Première recherche $result1 = $this->queryBus->handle($query); // Deuxième recherche (devrait utiliser le cache) $result2 = $this->queryBus->handle($query); $this->assertEquals($result1->getTotal(), $result2->getTotal()); }}</code>## 📊 <strong>Performance et Optimisation</strong>### <strong>Stratégies d’Optimisation CQS Multi-Sources</strong>#### <strong>1. Cache Stratégique Multi-Sources</strong><code>phppublic function searchPaymentsWithCache(PaymentSearchQuery $query): PaymentSearchResult{ $cacheKey = 'multi_source_payment_search_' . md5(serialize($query)); if ($cached = $this->cacheManager->get($cacheKey)) { return $cached; } $result = $this->searchPaymentsWithMultiSource($query); $this->cacheManager->set($cacheKey, $result, 300); return $result;}</code>#### <strong>2. Load Balancing Multi-Sources</strong><code>phppublic function getOptimalSourceForOperation(string $operation, array $criteria = []): string{ $sourceLoads = $this->getSourceLoads(); $optimalSource = array_keys($sourceLoads, min($sourceLoads))[0]; $this->logger->debug('Selected optimal source for operation', [ 'operation' => $operation, 'source' => $optimalSource, 'loads' => $sourceLoads ]); return $optimalSource;}</code>#### <strong>3. Monitoring des Sources Multi-Sources</strong><code>phppublic function getMultiSourceMetrics(): array{ return [ 'commandSources' => $this->getCommandSourceMetrics(), 'querySources' => $this->getQuerySourceMetrics(), 'cacheHitRate' => $this->getCacheHitRate(), 'sourceHealth' => $this->getSourceHealth(), 'averageExecutionTime' => $this->getAverageExecutionTime() ];}</code>## 🎯 <strong>Critères d’Adoption</strong>### <strong>Quand Utiliser CQS avec Multi-sources</strong>#### <strong>✅ Avantages</strong>- <strong>Performance optimisée</strong> : Séparation claire entre écriture et lecture- <strong>Flexibilité maximale</strong> : Choix du meilleur stockage pour chaque opération- <strong>Scalabilité</strong> : Possibilité de scaler indépendamment chaque côté- <strong>Résilience</strong> : Redondance et failover entre sources- <strong>Maintenabilité</strong> : Code plus clair et organisé#### <strong>❌ Inconvénients</strong>- <strong>Complexité élevée</strong> : Gestion de plusieurs sources de données- <strong>Cohérence</strong> : Risque d’incohérence entre sources- <strong>Maintenance</strong> : Plus de sources à maintenir- <strong>Expertise</strong> : Équipe expérimentée requise#### <strong>🎯 Critères d’Adoption</strong>- <strong>Système complexe</strong> : Besoins de performance différents par type d’opération- <strong>Données hétérogènes</strong> : Types de données différents nécessitant différents stockages- <strong>Performance critique</strong> : Besoins de performance optimale- <strong>Séparation des responsabilités</strong> : Besoin de séparer clairement les commandes et requêtes- <strong>Équipe expérimentée</strong> : Maîtrise de plusieurs technologies de stockage et CQS- <strong>Budget suffisant</strong> : Investissement en infrastructure multiple- <strong>Temps de développement</strong> : Suffisant pour implémenter cette complexité## 🚀 <strong>Votre Prochaine Étape</strong>HAHAHUGOSHORTCODE59s0HBHB—<em>CQS avec Multi-sources offre un équilibre optimal entre performance et flexibilité, parfaitement adapté aux besoins complexes de Gyroscops.</em></a></li></ul></nav></toc></div><div class="docs-toc-mobile d-print-none d-xl-none"><button id=toc-dropdown-btn class="btn-secondary dropdown-toggle" type=button data-bs-toggle=dropdown data-bs-offset=0,0 aria-expanded=false>
Table of Contents</button><nav id=toc-mobile><ul class=dropdown-menu><li><a href=#-contexte-et-objectifs-pourquoi-cqs-avec-multi-sources-la-combinaison-cqs-avec-multi-sources-offre-une-architecture-optimisée-qui-sépare-clairement-les-responsabilités-tout-en-exploitant-les-avantages-de-différents-types-de-stockage-cette-approche-permet-doptimiser-chaque-côté-commandes-et-requêtes-avec-les-sources-les-plus-appropriées-avantages-de-cqs-avec-multi-sources--performance-optimisée--séparation-claire-entre-écriture-et-lecture--flexibilité-maximale--choix-du-meilleur-stockage-pour-chaque-opération--scalabilité--possibilité-de-scaler-indépendamment-chaque-côté--résilience--redondance-et-failover-entre-sources--maintenabilité--code-plus-clair-et-organisé-contexte-gyroscopsdans-notre-écosystème-user--organization--workflow--cloud-resources--billing-cqs-avec-multi-sources-est-particulièrement-pertinent-pour---workflows-de-commande--orchestration-des-processus-de-modification-avec-sources-optimisées--workflows-de-requête--optimisation-des-lectures-avec-sources-spécialisées--processus-de-facturation--séparation-des-écritures-et-lectures-de-facturation--intégrations-complexes--orchestration-des-intégrations-avec-sources-multiples--architecture-cqs-avec-multi-sources-séparation-des-responsabilités-côté-commande-write-avec-multi-sources--command-workflows--orchestration-des-processus-de-modification--command-activities--exécution-des-activités-de-modification--event-handlers--gestion-des-événements-de-domaine--command-bus--orchestration-des-commandes--write-sources--sources-optimisées-pour-les-écritures--command-models--modèles-optimisés-pour-les-écritures-côté-requête-read-avec-multi-sources--query-workflows--orchestration-des-processus-de-lecture--query-activities--exécution-des-activités-de-lecture--search-services--services-de-recherche-spécialisés--query-bus--orchestration-des-requêtes--read-sources--sources-optimisées-pour-les-lectures--query-models--modèles-optimisés-pour-les-lectures-flux-de-donnéesmermaidgraph-td----acommand----bcommand-bus----b----ccommand-workflow----c----dcommand-activities----d----ewrite-sources----e----fsql-database----e----gredis-cache----e----hfile-system--------iquery----jquery-bus----j----kquery-workflow----k----lquery-activities----l----mread-sources----m----nelasticsearch----m----oredis-cache----m----psql-database--------qevent----revent-handler----r----c--------sprojection----tread-model-update----t----m--implémentation-pratique-1-command-side-avec-multi-sources-command-bus-avec-multi-sourcesphpphpnamespace-appapplicationcommandbusmultisourceuse-appdomaincommandcommandinterfaceuse-appdomaincommandcommandhandlerinterfaceuse-appinfrastructuremultisourcesourcerouteruse-psrlogloggerinterfaceclass-multisourcecommandbus----private-array-handlers------private-array-middleware------private-sourcerouter-sourcerouter----private-loggerinterface-logger----public-function-__construct--------sourcerouter-sourcerouter--------loggerinterface-logger-------------this-sourcerouter--sourcerouter--------this-logger--logger--------public-function-registerhandlerstring-commandclass-commandhandlerinterface-handler-void------------this-handlerscommandclass--handler--------public-function-addmiddlewarecallable-middleware-void------------this-middleware--middleware--------public-function-handlecommandinterface-command-void------------commandclass--get_classcommand----------------if-issetthis-handlerscommandclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-command-commandclass----------------handler--this-handlerscommandclass-----------------exécuter-les-middleware--------this-executemiddlewarecommand-function-use-handler-command-------------this-logger-infoexecuting-command-via-multi-source-cqs-----------------command--get_classcommand----------------data--command-toarray------------------------------------handler-handlecommand----------------private-function-executemiddlewarecommandinterface-command-callable-next-void------------middleware--array_reversethis-middleware----------------foreach-middleware-as-mw-------------next--function-use-mw-command-next-----------------return-mwcommand-next------------------------------------next-----command-workflow-avec-multi-sourcesphpphpnamespace-appworkflowcommandpaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowuse-appinfrastructuremultisourcesourcerouterworkflowinterfaceinterface-paymentmultisourcecommandworkflowinterface----workflowmethod----public-function-processpaymentcommandwithmultisourcepaymentcommandrequest-request-paymentcommandresult--------workflowmethod----public-function-updatepaymentcommandwithmultisourcepaymentupdatecommandrequest-request-paymentcommandresult--------workflowmethod----public-function-deletepaymentcommandwithmultisourcepaymentdeletecommandrequest-request-paymentcommandresultactivityinterfaceinterface-paymentmultisourcecommandactivityinterface----activitymethod----public-function-validatepaymentcommandpaymentcommandrequest-request-validationresult--------activitymethod----public-function-executepaymentcommandpaymentcommandrequest-request-commandexecutionresult--------activitymethod----public-function-persisttowritesourcespayment-payment-array-sources-void--------activitymethod----public-function-updatecommandmodelspayment-payment-voidclass-paymentmultisourcecommandworkflow-implements-paymentmultisourcecommandworkflowinterface----private-paymentmultisourcecommandactivityinterface-commandactivity----private-sourcerouter-sourcerouter----public-function-__construct------------this-commandactivity--workflownewactivitystubpaymentmultisourcecommandactivityinterfaceclass--------this-sourcerouter--workflownewactivitystubsourcerouterclass--------public-function-processpaymentcommandwithmultisourcepaymentcommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------exécution-de-la-commande------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------déterminer-les-sources-décriture-optimales------------writesources--yield-this-sourcerouter-routewritesave-execution-getpayment-------------------------persister-dans-les-sources-décriture------------yield-this-commandactivity-persisttowritesourcesexecution-getpayment-writesources-------------------------mettre-à-jour-les-modèles-de-commande------------yield-this-commandactivity-updatecommandmodelsexecution-getpayment------------------------return-new-paymentcommandresulttrue-payment-command-processed-with-multi-source-cqs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage----------------public-function-updatepaymentcommandwithmultisourcepaymentupdatecommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande-de-mise-à-jour------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------exécution-de-la-mise-à-jour------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------déterminer-les-sources-décriture-optimales------------writesources--yield-this-sourcerouter-routewriteupdate-execution-getpayment-------------------------persister-dans-les-sources-décriture------------yield-this-commandactivity-persisttowritesourcesexecution-getpayment-writesources-------------------------mettre-à-jour-les-modèles-de-commande------------yield-this-commandactivity-updatecommandmodelsexecution-getpayment------------------------return-new-paymentcommandresulttrue-payment-update-command-processed-with-multi-source-cqs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage----------------public-function-deletepaymentcommandwithmultisourcepaymentdeletecommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande-de-suppression------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------exécution-de-la-suppression------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------déterminer-les-sources-décriture-optimales------------writesources--yield-this-sourcerouter-routewritedelete-execution-getpayment-------------------------persister-dans-les-sources-décriture------------yield-this-commandactivity-persisttowritesourcesexecution-getpayment-writesources-------------------------mettre-à-jour-les-modèles-de-commande------------yield-this-commandactivity-updatecommandmodelsexecution-getpayment------------------------return-new-paymentcommandresulttrue-payment-delete-command-processed-with-multi-source-cqs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage-------------2-query-side-avec-multi-sources-query-bus-avec-cache-et-multi-sourcesphpphpnamespace-appapplicationquerybusmultisourceuse-appdomainqueryqueryinterfaceuse-appdomainqueryqueryhandlerinterfaceuse-appinfrastructuremultisourcesourcerouteruse-appinfrastructuremultisourcemultisourcecachemanageruse-psrlogloggerinterfaceclass-multisourcequerybus----private-array-handlers------private-sourcerouter-sourcerouter----private-multisourcecachemanager-cachemanager----private-loggerinterface-logger----public-function-__construct--------sourcerouter-sourcerouter--------multisourcecachemanager-cachemanager--------loggerinterface-logger-------------this-sourcerouter--sourcerouter--------this-cachemanager--cachemanager--------this-logger--logger--------public-function-registerhandlerstring-queryclass-queryhandlerinterface-handler-void------------this-handlersqueryclass--handler--------public-function-handlequeryinterface-query-mixed------------queryclass--get_classquery----------------if-issetthis-handlersqueryclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-query-queryclass-----------------vérifier-le-cache--------cachekey--this-generatecachekeyquery--------cachedresult--this-cachemanager-getcachekey----------------if-cachedresult--null-------------this-logger-debugquery-result-served-from-cache-----------------query--queryclass----------------cachekey--cachekey------------------------------------return-cachedresult-----------------déterminer-la-source-de-lecture-optimale--------readsource--this-sourcerouter-routereadqueryclass-query-toarray-----------------exécuter-la-requête-via-la-source-optimale--------handler--this-handlersqueryclass--------result--handler-handlequery-readsource-----------------mettre-en-cache--------this-cachemanager-setcachekey-result-300----------------this-logger-infoquery-executed-and-cached-via-multi-source-cqs-------------query--queryclass------------source--readsource------------cachekey--cachekey------------------------return-result--------private-function-generatecachekeyqueryinterface-query-string------------return-multi_source_query_--md5serializequery-----query-workflow-avec-multi-sourcesphpphpnamespace-appworkflowquerypaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowuse-appinfrastructuremultisourcesourcerouterworkflowinterfaceinterface-paymentmultisourcequeryworkflowinterface----workflowmethod----public-function-searchpaymentswithmultisourcepaymentsearchquery-query-paymentsearchresult--------workflowmethod----public-function-getpaymentbyidwithmultisourcepaymentbyidquery-query-payment--------workflowmethod----public-function-getpaymentstatisticswithmultisourcepaymentstatisticsquery-query-array--------workflowmethod----public-function-getpaymentanalyticswithmultisourcepaymentanalyticsquery-query-arrayactivityinterfaceinterface-paymentmultisourcequeryactivityinterface----activitymethod----public-function-searchpaymentsinsourcepaymentsearchquery-query-string-source-array--------activitymethod----public-function-getpaymentfromsourcestring-paymentid-string-source-payment--------activitymethod----public-function-calculatepaymentstatisticsinsourcepaymentstatisticsquery-query-string-source-array--------activitymethod----public-function-generatepaymentanalyticsinsourcepaymentanalyticsquery-query-string-source-arrayclass-paymentmultisourcequeryworkflow-implements-paymentmultisourcequeryworkflowinterface----private-paymentmultisourcequeryactivityinterface-queryactivity----private-sourcerouter-sourcerouter----public-function-__construct------------this-queryactivity--workflownewactivitystubpaymentmultisourcequeryactivityinterfaceclass--------this-sourcerouter--workflownewactivitystubsourcerouterclass--------public-function-searchpaymentswithmultisourcepaymentsearchquery-query-paymentsearchresult------------try--------------déterminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadsearch-query-toarray-------------------------recherche-dans-la-source-optimale------------payments--yield-this-queryactivity-searchpaymentsinsourcequery-readsource-------------------------filtrage-et-tri------------filteredpayments--this-filterpaymentspayments-query------------sortedpayments--this-sortpaymentsfilteredpayments-query-------------------------pagination------------paginatedpayments--this-paginatepaymentssortedpayments-query------------------------return-new-paymentsearchresult----------------paginatedpayments----------------countfilteredpayments----------------query-getpage----------------query-getsize---------------------------------catch-exception-e-------------return-new-paymentsearchresult-0-query-getpage-query-getsize----------------public-function-getpaymentbyidwithmultisourcepaymentbyidquery-query-payment------------try--------------déterminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadfindbyid-id--query-getpaymentid------------------------return-yield-this-queryactivity-getpaymentfromsourcequery-getpaymentid-readsource---------catch-exception-e-------------return-null----------------public-function-getpaymentstatisticswithmultisourcepaymentstatisticsquery-query-array------------try--------------déterminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadstatistics-query-toarray------------------------return-yield-this-queryactivity-calculatepaymentstatisticsinsourcequery-readsource---------catch-exception-e-------------return-----------------public-function-getpaymentanalyticswithmultisourcepaymentanalyticsquery-query-array------------try--------------déterminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadanalytics-query-toarray------------------------return-yield-this-queryactivity-generatepaymentanalyticsinsourcequery-readsource---------catch-exception-e-------------return-----------------private-function-filterpaymentsarray-payments-paymentsearchquery-query-array------------return-array_filterpayments-functionpayment-use-query-------------if-query-getorganizationid--payment-getorganizationid--query-getorganizationid-----------------return-false------------------------------------if-query-getstatus--payment-getstatus--query-getstatus-----------------return-false------------------------------------if-query-getminamount--payment-getamount--query-getminamount-----------------return-false------------------------------------if-query-getmaxamount--payment-getamount--query-getmaxamount-----------------return-false------------------------------------return-true----------------private-function-sortpaymentsarray-payments-paymentsearchquery-query-array------------sortfield--query-getsortfield--createdat--------sortdirection--query-getsortdirection--desc----------------usortpayments-functiona-b-use-sortfield-sortdirection-------------valuea--this-getfieldvaluea-sortfield------------valueb--this-getfieldvalueb-sortfield------------------------if-sortdirection--asc-----------------return-valuea--valueb-------------else-----------------return-valueb--valuea------------------------------------return-payments--------private-function-paginatepaymentsarray-payments-paymentsearchquery-query-array------------page--query-getpage--1--------size--query-getsize--10--------offset--page---1--size----------------return-array_slicepayments-offset-size--------private-function-getfieldvaluepayment-payment-string-field-mixed------------switch-field-------------case-amount----------------return-payment-getamount------------case-createdat----------------return-payment-getcreatedat------------case-status----------------return-payment-getstatus------------default----------------return-payment-getcreatedat-------------3-service-de-synchronisation-multi-sources-service-de-synchronisation-cqsphpphpnamespace-appapplicationservicemultisourceuse-appdomaineventdomaineventuse-appinfrastructuremultisourcesourcerouteruse-appinfrastructuremultisourcemultisourcecachemanageruse-psrlogloggerinterfaceclass-multisourcecqssynchronizationservice----private-sourcerouter-sourcerouter----private-multisourcecachemanager-cachemanager----private-loggerinterface-logger----public-function-__construct--------sourcerouter-sourcerouter--------multisourcecachemanager-cachemanager--------loggerinterface-logger-------------this-sourcerouter--sourcerouter--------this-cachemanager--cachemanager--------this-logger--logger--------public-function-handleeventdomainevent-event-void------------try-------------this-logger-infohandling-event-via-multi-source-cqs-----------------eventtype--event-geteventtype----------------eventid--event-getid-------------------------déterminer-les-sources-affectées------------affectedsources--this-determineaffectedsourcesevent-------------------------mettre-à-jour-chaque-source------------foreach-affectedsources-as-source-----------------this-updatesourcesource-event-------------------------------------invalider-le-cache-si-nécessaire------------if-this-shouldinvalidatecacheevent-----------------this-invalidatecacheevent---------------------------------catch-exception-e-------------this-logger-errorfailed-to-handle-event-via-multi-source-cqs-----------------eventtype--event-geteventtype----------------error--e-getmessage------------------------------------throw-e----------------public-function-synchronizesources-void------------try-------------this-logger-infosynchronizing-sources-via-multi-source-cqs-------------------------synchroniser-les-sources-de-lecture-avec-les-sources-décriture------------this-synchronizereadsources-------------------------nettoyer-les-caches-expirés------------this-cleanexpiredcaches------------------------this-logger-infosources-synchronized-successfully-via-multi-source-cqs---------------------catch-exception-e-------------this-logger-errorfailed-to-synchronize-sources-via-multi-source-cqs-----------------error--e-getmessage------------------------------------throw-e----------------private-function-determineaffectedsourcesdomainevent-event-array------------sources-------------------toujours-affecter-la-base-de-données-pour-les-événements-critiques--------if-this-iscriticaleventevent-------------sources--database-------------------------affecter-le-cache-pour-les-événements-de-lecture--------if-this-isreadeventevent-------------sources--cache-------------------------affecter-elasticsearch-pour-les-événements-de-recherche--------if-this-issearcheventevent-------------sources--elasticsearch------------------------return-sources--------private-function-updatesourcestring-source-domainevent-event-void------------this-logger-debugupdating-source-------------source--source------------eventtype--event-geteventtype-------------------------implémentation-spécifique-à-chaque-source--------switch-source-------------case-database----------------this-updatedatabaseevent----------------break------------case-cache----------------this-updatecacheevent----------------break------------case-elasticsearch----------------this-updateelasticsearchevent----------------break----------------private-function-shouldinvalidatecachedomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentupdated------------paymentdeleted------------paymentstatuschanged----------------private-function-invalidatecachedomainevent-event-void------------this-logger-debuginvalidating-cache-------------eventtype--event-geteventtype-------------------------invalider-les-caches-pertinents--------if-issetevent-getdatapaymentid-------------this-cachemanager-deletepaymentevent-getdatapaymentid----------------private-function-iscriticaleventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentcreated------------paymentupdated------------paymentdeleted----------------private-function-isreadeventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentviewed------------paymentsearched----------------private-function-issearcheventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentcreated------------paymentupdated------------paymentdeleted----------------private-function-updatedatabasedomainevent-event-void-------------implémentation-de-la-mise-à-jour-de-la-base-de-données--------private-function-updatecachedomainevent-event-void-------------implémentation-de-la-mise-à-jour-du-cache--------private-function-updateelasticsearchdomainevent-event-void-------------implémentation-de-la-mise-à-jour-delasticsearch--------private-function-synchronizereadsources-void-------------implémentation-de-la-synchronisation-des-sources-de-lecture--------private-function-cleanexpiredcaches-void-------------implémentation-du-nettoyage-des-caches-expirés------tests-et-validation-tests-dphpphpnamespace-apptestsintegrationmultisourceuse-appworkflowcommandpaymentpaymentcommandrequestuse-appworkflowquerypaymentpaymentsearchqueryuse-appapplicationcommandbusmultisourcemultisourcecommandbususe-appapplicationquerybusmultisourcemultisourcequerybususe-appinfrastructuremultisourcesourcerouterclass-multisourcecqstest-extends-testcase----private-multisourcecommandbus-commandbus----private-multisourcequerybus-querybus----private-sourcerouter-sourcerouter----protected-function-setup-void------------this-sourcerouter--this-createmocksourcerouterclass--------this-commandbus--new-multisourcecommandbus------------this-sourcerouter------------this-createmockloggerinterfaceclass----------------this-querybus--new-multisourcequerybus------------this-sourcerouter------------this-createmockmultisourcecachemanagerclass------------this-createmockloggerinterfaceclass----------------public-function-testcqsseparationwithmultisource-void-------------exécuter-une-commande-avec-multi-source-cqs--------command--new-paymentcommandrequest------------create------------payment-123------------org-456------------user-789------------10000------------eur------------test-payment------------------------this-commandbus-handlecommand-----------------vérifier-avec-une-requête--------query--new-paymentsearchqueryorg-456-0-10--------result--this-querybus-handlequery----------------this-assertgreaterthan0-result-gettotal--------public-function-testquerycachingwithmultisource-void------------query--new-paymentsearchqueryorg-456-0-10-----------------première-recherche--------result1--this-querybus-handlequery-----------------deuxième-recherche-devrait-utiliser-le-cache--------result2--this-querybus-handlequery----------------this-assertequalsresult1-gettotal-result2-gettotal------performance-et-optimisation-stratégies-d-1-cache-stratégique-multi-sourcesphppublic-function-searchpaymentswithcachepaymentsearchquery-query-paymentsearchresult----cachekey--multi_source_payment_search_--md5serializequery--------if-cached--this-cachemanager-getcachekey---------return-cached------------result--this-searchpaymentswithmultisourcequery----this-cachemanager-setcachekey-result-300--------return-result-2-load-balancing-multi-sourcesphppublic-function-getoptimalsourceforoperationstring-operation-array-criteria---string----sourceloads--this-getsourceloads----optimalsource--array_keyssourceloads-minsourceloads0--------this-logger-debugselected-optimal-source-for-operation---------operation--operation--------source--optimalsource--------loads--sourceloads------------return-optimalsource-3-monitoring-des-sources-multi-sourcesphppublic-function-getmultisourcemetrics-array----return---------commandsources--this-getcommandsourcemetrics--------querysources--this-getquerysourcemetrics--------cachehitrate--this-getcachehitrate--------sourcehealth--this-getsourcehealth--------averageexecutiontime--this-getaverageexecutiontime------critères-d-quand-utiliser-cqs-avec-multi-sources--avantages--performance-optimisée--séparation-claire-entre-écriture-et-lecture--flexibilité-maximale--choix-du-meilleur-stockage-pour-chaque-opération--scalabilité--possibilité-de-scaler-indépendamment-chaque-côté--résilience--redondance-et-failover-entre-sources--maintenabilité--code-plus-clair-et-organisé--inconvénients--complexité-élevée--gestion-de-plusieurs-sources-de-données--cohérence--risque-dincohérence-entre-sources--maintenance--plus-de-sources-à-maintenir--expertise--équipe-expérimentée-requise--critères-d--système-complexe--besoins-de-performance-différents-par-type-dopération--données-hétérogènes--types-de-données-différents-nécessitant-différents-stockages--performance-critique--besoins-de-performance-optimale--séparation-des-responsabilités--besoin-de-séparer-clairement-les-commandes-et-requêtes--équipe-expérimentée--maîtrise-de-plusieurs-technologies-de-stockage-et-cqs--budget-suffisant--investissement-en-infrastructure-multiple--temps-de-développement--suffisant-pour-implémenter-cette-complexité--votre-prochaine-étapehahahugoshortcode59s0hbhbcqs-avec-multi-sources-offre-un-équilibre-optimal-entre-performance-et-flexibilité-parfaitement-adapté-aux-besoins-complexes-de-gyroscops>🎯 <strong>Contexte et Objectifs</strong>### **Pourquoi CQS avec Multi-sources ?**La combinaison CQS avec Multi-sources offre une architecture optimisée qui sépare clairement les responsabilités tout en exploitant les avantages de différents types de stockage. Cette approche permet d’optimiser chaque côté (commandes et requêtes) avec les sources les plus appropriées.#### <strong>Avantages de CQS avec Multi-sources</strong>- <strong>Performance optimisée</strong> : Séparation claire entre écriture et lecture- <strong>Flexibilité maximale</strong> : Choix du meilleur stockage pour chaque opération- <strong>Scalabilité</strong> : Possibilité de scaler indépendamment chaque côté- <strong>Résilience</strong> : Redondance et failover entre sources- <strong>Maintenabilité</strong> : Code plus clair et organisé### <strong>Contexte Gyroscops</strong>Dans notre écosystème <strong>User → Organization → Workflow → Cloud Resources → Billing</strong>, CQS avec Multi-sources est particulièrement pertinent pour :- <strong>Workflows de commande</strong> : Orchestration des processus de modification avec sources optimisées- <strong>Workflows de requête</strong> : Optimisation des lectures avec sources spécialisées- <strong>Processus de facturation</strong> : Séparation des écritures et lectures de facturation- <strong>Intégrations complexes</strong> : Orchestration des intégrations avec sources multiples## 🏗️ <strong>Architecture CQS avec Multi-sources</strong>### <strong>Séparation des Responsabilités</strong>#### <strong>Côté Commande (Write) avec Multi-sources</strong>- <strong>Command Workflows</strong> : Orchestration des processus de modification- <strong>Command Activities</strong> : Exécution des activités de modification- <strong>Event Handlers</strong> : Gestion des événements de domaine- <strong>Command Bus</strong> : Orchestration des commandes- <strong>Write Sources</strong> : Sources optimisées pour les écritures- <strong>Command Models</strong> : Modèles optimisés pour les écritures#### <strong>Côté Requête (Read) avec Multi-sources</strong>- <strong>Query Workflows</strong> : Orchestration des processus de lecture- <strong>Query Activities</strong> : Exécution des activités de lecture- <strong>Search Services</strong> : Services de recherche spécialisés- <strong>Query Bus</strong> : Orchestration des requêtes- <strong>Read Sources</strong> : Sources optimisées pour les lectures- <strong>Query Models</strong> : Modèles optimisés pour les lectures### <strong>Flux de Données</strong><code>mermaidgraph TD A[Command] --> B[Command Bus] B --> C[Command Workflow] C --> D[Command Activities] D --> E[Write Sources] E --> F[SQL Database] E --> G[Redis Cache] E --> H[File System] I[Query] --> J[Query Bus] J --> K[Query Workflow] K --> L[Query Activities] L --> M[Read Sources] M --> N[ElasticSearch] M --> O[Redis Cache] M --> P[SQL Database] Q[Event] --> R[Event Handler] R --> C S[Projection] --> T[Read Model Update] T --> M</code>## 💻 <strong>Implémentation Pratique</strong>### <strong>1. Command Side avec Multi-sources</strong>#### <strong>Command Bus avec Multi-sources</strong><code>php&lt;?phpnamespace App\Application\CommandBus\MultiSource;use App\Domain\Command\CommandInterface;use App\Domain\Command\CommandHandlerInterface;use App\Infrastructure\MultiSource\SourceRouter;use Psr\Log\LoggerInterface;class MultiSourceCommandBus{ private array $handlers = []; private array $middleware = []; private SourceRouter $sourceRouter; private LoggerInterface $logger; public function __construct( SourceRouter $sourceRouter, LoggerInterface $logger ) { $this->sourceRouter = $sourceRouter; $this->logger = $logger; } public function registerHandler(string $commandClass, CommandHandlerInterface $handler): void { $this->handlers[$commandClass] = $handler; } public function addMiddleware(callable $middleware): void { $this->middleware[] = $middleware; } public function handle(CommandInterface $command): void { $commandClass = get_class($command); if (!isset($this->handlers[$commandClass])) { throw new \InvalidArgumentException("No handler registered for command: $commandClass"); } $handler = $this->handlers[$commandClass]; // Exécuter les middleware $this->executeMiddleware($command, function() use ($handler, $command) { $this->logger->info('Executing command via Multi-source CQS', [ 'command' => get_class($command), 'data' => $command->toArray() ]); $handler->handle($command); }); } private function executeMiddleware(CommandInterface $command, callable $next): void { $middleware = array_reverse($this->middleware); foreach ($middleware as $mw) { $next = function() use ($mw, $command, $next) { return $mw($command, $next); }; } $next(); }}</code>#### <strong>Command Workflow avec Multi-sources</strong><code>php&lt;?phpnamespace App\Workflow\Command\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Infrastructure\MultiSource\SourceRouter;#[WorkflowInterface]interface PaymentMultiSourceCommandWorkflowInterface{ #[WorkflowMethod] public function processPaymentCommandWithMultiSource(PaymentCommandRequest $request): PaymentCommandResult; #[WorkflowMethod] public function updatePaymentCommandWithMultiSource(PaymentUpdateCommandRequest $request): PaymentCommandResult; #[WorkflowMethod] public function deletePaymentCommandWithMultiSource(PaymentDeleteCommandRequest $request): PaymentCommandResult;}#[ActivityInterface]interface PaymentMultiSourceCommandActivityInterface{ #[ActivityMethod] public function validatePaymentCommand(PaymentCommandRequest $request): ValidationResult; #[ActivityMethod] public function executePaymentCommand(PaymentCommandRequest $request): CommandExecutionResult; #[ActivityMethod] public function persistToWriteSources(Payment $payment, array $sources): void; #[ActivityMethod] public function updateCommandModels(Payment $payment): void;}class PaymentMultiSourceCommandWorkflow implements PaymentMultiSourceCommandWorkflowInterface{ private PaymentMultiSourceCommandActivityInterface $commandActivity; private SourceRouter $sourceRouter; public function __construct() { $this->commandActivity = Workflow::newActivityStub(PaymentMultiSourceCommandActivityInterface::class); $this->sourceRouter = Workflow::newActivityStub(SourceRouter::class); } public function processPaymentCommandWithMultiSource(PaymentCommandRequest $request): PaymentCommandResult { try { // Validation de la commande $validation = yield $this->commandActivity->validatePaymentCommand($request); if (!$validation->isValid()) { return new PaymentCommandResult(false, $validation->getError()); } // Exécution de la commande $execution = yield $this->commandActivity->executePaymentCommand($request); if (!$execution->isSuccess()) { return new PaymentCommandResult(false, $execution->getError()); } // Déterminer les sources d'écriture optimales $writeSources = yield $this->sourceRouter->routeWrite('save', $execution->getPayment()); // Persister dans les sources d'écriture yield $this->commandActivity->persistToWriteSources($execution->getPayment(), $writeSources); // Mettre à jour les modèles de commande yield $this->commandActivity->updateCommandModels($execution->getPayment()); return new PaymentCommandResult(true, 'Payment command processed with Multi-source CQS'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e->getMessage()); } } public function updatePaymentCommandWithMultiSource(PaymentUpdateCommandRequest $request): PaymentCommandResult { try { // Validation de la commande de mise à jour $validation = yield $this->commandActivity->validatePaymentCommand($request); if (!$validation->isValid()) { return new PaymentCommandResult(false, $validation->getError()); } // Exécution de la mise à jour $execution = yield $this->commandActivity->executePaymentCommand($request); if (!$execution->isSuccess()) { return new PaymentCommandResult(false, $execution->getError()); } // Déterminer les sources d'écriture optimales $writeSources = yield $this->sourceRouter->routeWrite('update', $execution->getPayment()); // Persister dans les sources d'écriture yield $this->commandActivity->persistToWriteSources($execution->getPayment(), $writeSources); // Mettre à jour les modèles de commande yield $this->commandActivity->updateCommandModels($execution->getPayment()); return new PaymentCommandResult(true, 'Payment update command processed with Multi-source CQS'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e->getMessage()); } } public function deletePaymentCommandWithMultiSource(PaymentDeleteCommandRequest $request): PaymentCommandResult { try { // Validation de la commande de suppression $validation = yield $this->commandActivity->validatePaymentCommand($request); if (!$validation->isValid()) { return new PaymentCommandResult(false, $validation->getError()); } // Exécution de la suppression $execution = yield $this->commandActivity->executePaymentCommand($request); if (!$execution->isSuccess()) { return new PaymentCommandResult(false, $execution->getError()); } // Déterminer les sources d'écriture optimales $writeSources = yield $this->sourceRouter->routeWrite('delete', $execution->getPayment()); // Persister dans les sources d'écriture yield $this->commandActivity->persistToWriteSources($execution->getPayment(), $writeSources); // Mettre à jour les modèles de commande yield $this->commandActivity->updateCommandModels($execution->getPayment()); return new PaymentCommandResult(true, 'Payment delete command processed with Multi-source CQS'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e->getMessage()); } }}</code>### <strong>2. Query Side avec Multi-sources</strong>#### <strong>Query Bus avec Cache et Multi-sources</strong><code>php&lt;?phpnamespace App\Application\QueryBus\MultiSource;use App\Domain\Query\QueryInterface;use App\Domain\Query\QueryHandlerInterface;use App\Infrastructure\MultiSource\SourceRouter;use App\Infrastructure\MultiSource\MultiSourceCacheManager;use Psr\Log\LoggerInterface;class MultiSourceQueryBus{ private array $handlers = []; private SourceRouter $sourceRouter; private MultiSourceCacheManager $cacheManager; private LoggerInterface $logger; public function __construct( SourceRouter $sourceRouter, MultiSourceCacheManager $cacheManager, LoggerInterface $logger ) { $this->sourceRouter = $sourceRouter; $this->cacheManager = $cacheManager; $this->logger = $logger; } public function registerHandler(string $queryClass, QueryHandlerInterface $handler): void { $this->handlers[$queryClass] = $handler; } public function handle(QueryInterface $query): mixed { $queryClass = get_class($query); if (!isset($this->handlers[$queryClass])) { throw new \InvalidArgumentException("No handler registered for query: $queryClass"); } // Vérifier le cache $cacheKey = $this->generateCacheKey($query); $cachedResult = $this->cacheManager->get($cacheKey); if ($cachedResult !== null) { $this->logger->debug('Query result served from cache', [ 'query' => $queryClass, 'cacheKey' => $cacheKey ]); return $cachedResult; } // Déterminer la source de lecture optimale $readSource = $this->sourceRouter->routeRead($queryClass, $query->toArray()); // Exécuter la requête via la source optimale $handler = $this->handlers[$queryClass]; $result = $handler->handle($query, $readSource); // Mettre en cache $this->cacheManager->set($cacheKey, $result, 300); $this->logger->info('Query executed and cached via Multi-source CQS', [ 'query' => $queryClass, 'source' => $readSource, 'cacheKey' => $cacheKey ]); return $result; } private function generateCacheKey(QueryInterface $query): string { return 'multi_source_query_' . md5(serialize($query)); }}</code>#### <strong>Query Workflow avec Multi-sources</strong><code>php&lt;?phpnamespace App\Workflow\Query\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Infrastructure\MultiSource\SourceRouter;#[WorkflowInterface]interface PaymentMultiSourceQueryWorkflowInterface{ #[WorkflowMethod] public function searchPaymentsWithMultiSource(PaymentSearchQuery $query): PaymentSearchResult; #[WorkflowMethod] public function getPaymentByIdWithMultiSource(PaymentByIdQuery $query): ?Payment; #[WorkflowMethod] public function getPaymentStatisticsWithMultiSource(PaymentStatisticsQuery $query): array; #[WorkflowMethod] public function getPaymentAnalyticsWithMultiSource(PaymentAnalyticsQuery $query): array;}#[ActivityInterface]interface PaymentMultiSourceQueryActivityInterface{ #[ActivityMethod] public function searchPaymentsInSource(PaymentSearchQuery $query, string $source): array; #[ActivityMethod] public function getPaymentFromSource(string $paymentId, string $source): ?Payment; #[ActivityMethod] public function calculatePaymentStatisticsInSource(PaymentStatisticsQuery $query, string $source): array; #[ActivityMethod] public function generatePaymentAnalyticsInSource(PaymentAnalyticsQuery $query, string $source): array;}class PaymentMultiSourceQueryWorkflow implements PaymentMultiSourceQueryWorkflowInterface{ private PaymentMultiSourceQueryActivityInterface $queryActivity; private SourceRouter $sourceRouter; public function __construct() { $this->queryActivity = Workflow::newActivityStub(PaymentMultiSourceQueryActivityInterface::class); $this->sourceRouter = Workflow::newActivityStub(SourceRouter::class); } public function searchPaymentsWithMultiSource(PaymentSearchQuery $query): PaymentSearchResult { try { // Déterminer la source de lecture optimale $readSource = yield $this->sourceRouter->routeRead('search', $query->toArray()); // Recherche dans la source optimale $payments = yield $this->queryActivity->searchPaymentsInSource($query, $readSource); // Filtrage et tri $filteredPayments = $this->filterPayments($payments, $query); $sortedPayments = $this->sortPayments($filteredPayments, $query); // Pagination $paginatedPayments = $this->paginatePayments($sortedPayments, $query); return new PaymentSearchResult( $paginatedPayments, count($filteredPayments), $query->getPage(), $query->getSize() ); } catch (\Exception $e) { return new PaymentSearchResult([], 0, $query->getPage(), $query->getSize()); } } public function getPaymentByIdWithMultiSource(PaymentByIdQuery $query): ?Payment { try { // Déterminer la source de lecture optimale $readSource = yield $this->sourceRouter->routeRead('findById', ['id' => $query->getPaymentId()]); return yield $this->queryActivity->getPaymentFromSource($query->getPaymentId(), $readSource); } catch (\Exception $e) { return null; } } public function getPaymentStatisticsWithMultiSource(PaymentStatisticsQuery $query): array { try { // Déterminer la source de lecture optimale $readSource = yield $this->sourceRouter->routeRead('statistics', $query->toArray()); return yield $this->queryActivity->calculatePaymentStatisticsInSource($query, $readSource); } catch (\Exception $e) { return []; } } public function getPaymentAnalyticsWithMultiSource(PaymentAnalyticsQuery $query): array { try { // Déterminer la source de lecture optimale $readSource = yield $this->sourceRouter->routeRead('analytics', $query->toArray()); return yield $this->queryActivity->generatePaymentAnalyticsInSource($query, $readSource); } catch (\Exception $e) { return []; } } private function filterPayments(array $payments, PaymentSearchQuery $query): array { return array_filter($payments, function($payment) use ($query) { if ($query->getOrganizationId() && $payment->getOrganizationId() !== $query->getOrganizationId()) { return false; } if ($query->getStatus() && $payment->getStatus() !== $query->getStatus()) { return false; } if ($query->getMinAmount() && $payment->getAmount() &lt; $query->getMinAmount()) { return false; } if ($query->getMaxAmount() && $payment->getAmount() > $query->getMaxAmount()) { return false; } return true; }); } private function sortPayments(array $payments, PaymentSearchQuery $query): array { $sortField = $query->getSortField() ?? 'createdAt'; $sortDirection = $query->getSortDirection() ?? 'desc'; usort($payments, function($a, $b) use ($sortField, $sortDirection) { $valueA = $this->getFieldValue($a, $sortField); $valueB = $this->getFieldValue($b, $sortField); if ($sortDirection === 'asc') { return $valueA &lt;=> $valueB; } else { return $valueB &lt;=> $valueA; } }); return $payments; } private function paginatePayments(array $payments, PaymentSearchQuery $query): array { $page = $query->getPage() ?? 1; $size = $query->getSize() ?? 10; $offset = ($page - 1) * $size; return array_slice($payments, $offset, $size); } private function getFieldValue(Payment $payment, string $field): mixed { switch ($field) { case 'amount': return $payment->getAmount(); case 'createdAt': return $payment->getCreatedAt(); case 'status': return $payment->getStatus(); default: return $payment->getCreatedAt(); } }}</code>### <strong>3. Service de Synchronisation Multi-Sources</strong>#### <strong>Service de Synchronisation CQS</strong><code>php&lt;?phpnamespace App\Application\Service\MultiSource;use App\Domain\Event\DomainEvent;use App\Infrastructure\MultiSource\SourceRouter;use App\Infrastructure\MultiSource\MultiSourceCacheManager;use Psr\Log\LoggerInterface;class MultiSourceCqsSynchronizationService{ private SourceRouter $sourceRouter; private MultiSourceCacheManager $cacheManager; private LoggerInterface $logger; public function __construct( SourceRouter $sourceRouter, MultiSourceCacheManager $cacheManager, LoggerInterface $logger ) { $this->sourceRouter = $sourceRouter; $this->cacheManager = $cacheManager; $this->logger = $logger; } public function handleEvent(DomainEvent $event): void { try { $this->logger->info('Handling event via Multi-source CQS', [ 'eventType' => $event->getEventType(), 'eventId' => $event->getId() ]); // Déterminer les sources affectées $affectedSources = $this->determineAffectedSources($event); // Mettre à jour chaque source foreach ($affectedSources as $source) { $this->updateSource($source, $event); } // Invalider le cache si nécessaire if ($this->shouldInvalidateCache($event)) { $this->invalidateCache($event); } } catch (\Exception $e) { $this->logger->error('Failed to handle event via Multi-source CQS', [ 'eventType' => $event->getEventType(), 'error' => $e->getMessage() ]); throw $e; } } public function synchronizeSources(): void { try { $this->logger->info('Synchronizing sources via Multi-source CQS'); // Synchroniser les sources de lecture avec les sources d'écriture $this->synchronizeReadSources(); // Nettoyer les caches expirés $this->cleanExpiredCaches(); $this->logger->info('Sources synchronized successfully via Multi-source CQS'); } catch (\Exception $e) { $this->logger->error('Failed to synchronize sources via Multi-source CQS', [ 'error' => $e->getMessage() ]); throw $e; } } private function determineAffectedSources(DomainEvent $event): array { $sources = []; // Toujours affecter la base de données pour les événements critiques if ($this->isCriticalEvent($event)) { $sources[] = 'database'; } // Affecter le cache pour les événements de lecture if ($this->isReadEvent($event)) { $sources[] = 'cache'; } // Affecter ElasticSearch pour les événements de recherche if ($this->isSearchEvent($event)) { $sources[] = 'elasticsearch'; } return $sources; } private function updateSource(string $source, DomainEvent $event): void { $this->logger->debug('Updating source', [ 'source' => $source, 'eventType' => $event->getEventType() ]); // Implémentation spécifique à chaque source switch ($source) { case 'database': $this->updateDatabase($event); break; case 'cache': $this->updateCache($event); break; case 'elasticsearch': $this->updateElasticSearch($event); break; } } private function shouldInvalidateCache(DomainEvent $event): bool { return in_array($event->getEventType(), [ 'PaymentUpdated', 'PaymentDeleted', 'PaymentStatusChanged' ]); } private function invalidateCache(DomainEvent $event): void { $this->logger->debug('Invalidating cache', [ 'eventType' => $event->getEventType() ]); // Invalider les caches pertinents if (isset($event->getData()['paymentId'])) { $this->cacheManager->deletePayment($event->getData()['paymentId']); } } private function isCriticalEvent(DomainEvent $event): bool { return in_array($event->getEventType(), [ 'PaymentCreated', 'PaymentUpdated', 'PaymentDeleted' ]); } private function isReadEvent(DomainEvent $event): bool { return in_array($event->getEventType(), [ 'PaymentViewed', 'PaymentSearched' ]); } private function isSearchEvent(DomainEvent $event): bool { return in_array($event->getEventType(), [ 'PaymentCreated', 'PaymentUpdated', 'PaymentDeleted' ]); } private function updateDatabase(DomainEvent $event): void { // Implémentation de la mise à jour de la base de données } private function updateCache(DomainEvent $event): void { // Implémentation de la mise à jour du cache } private function updateElasticSearch(DomainEvent $event): void { // Implémentation de la mise à jour d'ElasticSearch } private function synchronizeReadSources(): void { // Implémentation de la synchronisation des sources de lecture } private function cleanExpiredCaches(): void { // Implémentation du nettoyage des caches expirés }}</code>## 🧪 <strong>Tests et Validation</strong>### <strong>Tests d’Intégration CQS Multi-Sources</strong><code>php&lt;?phpnamespace App\Tests\Integration\MultiSource;use App\Workflow\Command\Payment\PaymentCommandRequest;use App\Workflow\Query\Payment\PaymentSearchQuery;use App\Application\CommandBus\MultiSource\MultiSourceCommandBus;use App\Application\QueryBus\MultiSource\MultiSourceQueryBus;use App\Infrastructure\MultiSource\SourceRouter;class MultiSourceCqsTest extends TestCase{ private MultiSourceCommandBus $commandBus; private MultiSourceQueryBus $queryBus; private SourceRouter $sourceRouter; protected function setUp(): void { $this->sourceRouter = $this->createMock(SourceRouter::class); $this->commandBus = new MultiSourceCommandBus( $this->sourceRouter, $this->createMock(LoggerInterface::class) ); $this->queryBus = new MultiSourceQueryBus( $this->sourceRouter, $this->createMock(MultiSourceCacheManager::class), $this->createMock(LoggerInterface::class) ); } public function testCqsSeparationWithMultiSource(): void { // Exécuter une commande avec Multi-source CQS $command = new PaymentCommandRequest( 'CREATE', 'payment-123', 'org-456', 'user-789', 100.00, 'EUR', 'Test payment' ); $this->commandBus->handle($command); // Vérifier avec une requête $query = new PaymentSearchQuery('org-456', 0, 10); $result = $this->queryBus->handle($query); $this->assertGreaterThan(0, $result->getTotal()); } public function testQueryCachingWithMultiSource(): void { $query = new PaymentSearchQuery('org-456', 0, 10); // Première recherche $result1 = $this->queryBus->handle($query); // Deuxième recherche (devrait utiliser le cache) $result2 = $this->queryBus->handle($query); $this->assertEquals($result1->getTotal(), $result2->getTotal()); }}</code>## 📊 <strong>Performance et Optimisation</strong>### <strong>Stratégies d’Optimisation CQS Multi-Sources</strong>#### <strong>1. Cache Stratégique Multi-Sources</strong><code>phppublic function searchPaymentsWithCache(PaymentSearchQuery $query): PaymentSearchResult{ $cacheKey = 'multi_source_payment_search_' . md5(serialize($query)); if ($cached = $this->cacheManager->get($cacheKey)) { return $cached; } $result = $this->searchPaymentsWithMultiSource($query); $this->cacheManager->set($cacheKey, $result, 300); return $result;}</code>#### <strong>2. Load Balancing Multi-Sources</strong><code>phppublic function getOptimalSourceForOperation(string $operation, array $criteria = []): string{ $sourceLoads = $this->getSourceLoads(); $optimalSource = array_keys($sourceLoads, min($sourceLoads))[0]; $this->logger->debug('Selected optimal source for operation', [ 'operation' => $operation, 'source' => $optimalSource, 'loads' => $sourceLoads ]); return $optimalSource;}</code>#### <strong>3. Monitoring des Sources Multi-Sources</strong><code>phppublic function getMultiSourceMetrics(): array{ return [ 'commandSources' => $this->getCommandSourceMetrics(), 'querySources' => $this->getQuerySourceMetrics(), 'cacheHitRate' => $this->getCacheHitRate(), 'sourceHealth' => $this->getSourceHealth(), 'averageExecutionTime' => $this->getAverageExecutionTime() ];}</code>## 🎯 <strong>Critères d’Adoption</strong>### <strong>Quand Utiliser CQS avec Multi-sources</strong>#### <strong>✅ Avantages</strong>- <strong>Performance optimisée</strong> : Séparation claire entre écriture et lecture- <strong>Flexibilité maximale</strong> : Choix du meilleur stockage pour chaque opération- <strong>Scalabilité</strong> : Possibilité de scaler indépendamment chaque côté- <strong>Résilience</strong> : Redondance et failover entre sources- <strong>Maintenabilité</strong> : Code plus clair et organisé#### <strong>❌ Inconvénients</strong>- <strong>Complexité élevée</strong> : Gestion de plusieurs sources de données- <strong>Cohérence</strong> : Risque d’incohérence entre sources- <strong>Maintenance</strong> : Plus de sources à maintenir- <strong>Expertise</strong> : Équipe expérimentée requise#### <strong>🎯 Critères d’Adoption</strong>- <strong>Système complexe</strong> : Besoins de performance différents par type d’opération- <strong>Données hétérogènes</strong> : Types de données différents nécessitant différents stockages- <strong>Performance critique</strong> : Besoins de performance optimale- <strong>Séparation des responsabilités</strong> : Besoin de séparer clairement les commandes et requêtes- <strong>Équipe expérimentée</strong> : Maîtrise de plusieurs technologies de stockage et CQS- <strong>Budget suffisant</strong> : Investissement en infrastructure multiple- <strong>Temps de développement</strong> : Suffisant pour implémenter cette complexité## 🚀 <strong>Votre Prochaine Étape</strong>HAHAHUGOSHORTCODE59s0HBHB—<em>CQS avec Multi-sources offre un équilibre optimal entre performance et flexibilité, parfaitement adapté aux besoins complexes de Gyroscops.</em></a></li></ul></nav></div><div class="docs-content col-12 col-xl-9 mt-0"><div class="mb-0 d-flex"><h1 class="content-title mb-0">Stockage Multi-sources - CQS
<span class="badge bg-default fs-6 mb-1 align-middle">DRAFT</span></h1></div><div id=content class=main-content><div data-prismjs-copy data-prismjs-copy-success data-prismjs-copy-error><h2 id=-contexte-et-objectifs-pourquoi-cqs-avec-multi-sources-la-combinaison-cqs-avec-multi-sources-offre-une-architecture-optimisée-qui-sépare-clairement-les-responsabilités-tout-en-exploitant-les-avantages-de-différents-types-de-stockage-cette-approche-permet-doptimiser-chaque-côté-commandes-et-requêtes-avec-les-sources-les-plus-appropriées-avantages-de-cqs-avec-multi-sources--performance-optimisée--séparation-claire-entre-écriture-et-lecture--flexibilité-maximale--choix-du-meilleur-stockage-pour-chaque-opération--scalabilité--possibilité-de-scaler-indépendamment-chaque-côté--résilience--redondance-et-failover-entre-sources--maintenabilité--code-plus-clair-et-organisé-contexte-gyroscopsdans-notre-écosystème-user--organization--workflow--cloud-resources--billing-cqs-avec-multi-sources-est-particulièrement-pertinent-pour---workflows-de-commande--orchestration-des-processus-de-modification-avec-sources-optimisées--workflows-de-requête--optimisation-des-lectures-avec-sources-spécialisées--processus-de-facturation--séparation-des-écritures-et-lectures-de-facturation--intégrations-complexes--orchestration-des-intégrations-avec-sources-multiples--architecture-cqs-avec-multi-sources-séparation-des-responsabilités-côté-commande-write-avec-multi-sources--command-workflows--orchestration-des-processus-de-modification--command-activities--exécution-des-activités-de-modification--event-handlers--gestion-des-événements-de-domaine--command-bus--orchestration-des-commandes--write-sources--sources-optimisées-pour-les-écritures--command-models--modèles-optimisés-pour-les-écritures-côté-requête-read-avec-multi-sources--query-workflows--orchestration-des-processus-de-lecture--query-activities--exécution-des-activités-de-lecture--search-services--services-de-recherche-spécialisés--query-bus--orchestration-des-requêtes--read-sources--sources-optimisées-pour-les-lectures--query-models--modèles-optimisés-pour-les-lectures-flux-de-donnéesmermaidgraph-td----acommand----bcommand-bus----b----ccommand-workflow----c----dcommand-activities----d----ewrite-sources----e----fsql-database----e----gredis-cache----e----hfile-system--------iquery----jquery-bus----j----kquery-workflow----k----lquery-activities----l----mread-sources----m----nelasticsearch----m----oredis-cache----m----psql-database--------qevent----revent-handler----r----c--------sprojection----tread-model-update----t----m--implémentation-pratique-1-command-side-avec-multi-sources-command-bus-avec-multi-sourcesphpphpnamespace-appapplicationcommandbusmultisourceuse-appdomaincommandcommandinterfaceuse-appdomaincommandcommandhandlerinterfaceuse-appinfrastructuremultisourcesourcerouteruse-psrlogloggerinterfaceclass-multisourcecommandbus----private-array-handlers------private-array-middleware------private-sourcerouter-sourcerouter----private-loggerinterface-logger----public-function-__construct--------sourcerouter-sourcerouter--------loggerinterface-logger-------------this-sourcerouter--sourcerouter--------this-logger--logger--------public-function-registerhandlerstring-commandclass-commandhandlerinterface-handler-void------------this-handlerscommandclass--handler--------public-function-addmiddlewarecallable-middleware-void------------this-middleware--middleware--------public-function-handlecommandinterface-command-void------------commandclass--get_classcommand----------------if-issetthis-handlerscommandclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-command-commandclass----------------handler--this-handlerscommandclass-----------------exécuter-les-middleware--------this-executemiddlewarecommand-function-use-handler-command-------------this-logger-infoexecuting-command-via-multi-source-cqs-----------------command--get_classcommand----------------data--command-toarray------------------------------------handler-handlecommand----------------private-function-executemiddlewarecommandinterface-command-callable-next-void------------middleware--array_reversethis-middleware----------------foreach-middleware-as-mw-------------next--function-use-mw-command-next-----------------return-mwcommand-next------------------------------------next-----command-workflow-avec-multi-sourcesphpphpnamespace-appworkflowcommandpaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowuse-appinfrastructuremultisourcesourcerouterworkflowinterfaceinterface-paymentmultisourcecommandworkflowinterface----workflowmethod----public-function-processpaymentcommandwithmultisourcepaymentcommandrequest-request-paymentcommandresult--------workflowmethod----public-function-updatepaymentcommandwithmultisourcepaymentupdatecommandrequest-request-paymentcommandresult--------workflowmethod----public-function-deletepaymentcommandwithmultisourcepaymentdeletecommandrequest-request-paymentcommandresultactivityinterfaceinterface-paymentmultisourcecommandactivityinterface----activitymethod----public-function-validatepaymentcommandpaymentcommandrequest-request-validationresult--------activitymethod----public-function-executepaymentcommandpaymentcommandrequest-request-commandexecutionresult--------activitymethod----public-function-persisttowritesourcespayment-payment-array-sources-void--------activitymethod----public-function-updatecommandmodelspayment-payment-voidclass-paymentmultisourcecommandworkflow-implements-paymentmultisourcecommandworkflowinterface----private-paymentmultisourcecommandactivityinterface-commandactivity----private-sourcerouter-sourcerouter----public-function-__construct------------this-commandactivity--workflownewactivitystubpaymentmultisourcecommandactivityinterfaceclass--------this-sourcerouter--workflownewactivitystubsourcerouterclass--------public-function-processpaymentcommandwithmultisourcepaymentcommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------exécution-de-la-commande------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------déterminer-les-sources-décriture-optimales------------writesources--yield-this-sourcerouter-routewritesave-execution-getpayment-------------------------persister-dans-les-sources-décriture------------yield-this-commandactivity-persisttowritesourcesexecution-getpayment-writesources-------------------------mettre-à-jour-les-modèles-de-commande------------yield-this-commandactivity-updatecommandmodelsexecution-getpayment------------------------return-new-paymentcommandresulttrue-payment-command-processed-with-multi-source-cqs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage----------------public-function-updatepaymentcommandwithmultisourcepaymentupdatecommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande-de-mise-à-jour------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------exécution-de-la-mise-à-jour------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------déterminer-les-sources-décriture-optimales------------writesources--yield-this-sourcerouter-routewriteupdate-execution-getpayment-------------------------persister-dans-les-sources-décriture------------yield-this-commandactivity-persisttowritesourcesexecution-getpayment-writesources-------------------------mettre-à-jour-les-modèles-de-commande------------yield-this-commandactivity-updatecommandmodelsexecution-getpayment------------------------return-new-paymentcommandresulttrue-payment-update-command-processed-with-multi-source-cqs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage----------------public-function-deletepaymentcommandwithmultisourcepaymentdeletecommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande-de-suppression------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------exécution-de-la-suppression------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------déterminer-les-sources-décriture-optimales------------writesources--yield-this-sourcerouter-routewritedelete-execution-getpayment-------------------------persister-dans-les-sources-décriture------------yield-this-commandactivity-persisttowritesourcesexecution-getpayment-writesources-------------------------mettre-à-jour-les-modèles-de-commande------------yield-this-commandactivity-updatecommandmodelsexecution-getpayment------------------------return-new-paymentcommandresulttrue-payment-delete-command-processed-with-multi-source-cqs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage-------------2-query-side-avec-multi-sources-query-bus-avec-cache-et-multi-sourcesphpphpnamespace-appapplicationquerybusmultisourceuse-appdomainqueryqueryinterfaceuse-appdomainqueryqueryhandlerinterfaceuse-appinfrastructuremultisourcesourcerouteruse-appinfrastructuremultisourcemultisourcecachemanageruse-psrlogloggerinterfaceclass-multisourcequerybus----private-array-handlers------private-sourcerouter-sourcerouter----private-multisourcecachemanager-cachemanager----private-loggerinterface-logger----public-function-__construct--------sourcerouter-sourcerouter--------multisourcecachemanager-cachemanager--------loggerinterface-logger-------------this-sourcerouter--sourcerouter--------this-cachemanager--cachemanager--------this-logger--logger--------public-function-registerhandlerstring-queryclass-queryhandlerinterface-handler-void------------this-handlersqueryclass--handler--------public-function-handlequeryinterface-query-mixed------------queryclass--get_classquery----------------if-issetthis-handlersqueryclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-query-queryclass-----------------vérifier-le-cache--------cachekey--this-generatecachekeyquery--------cachedresult--this-cachemanager-getcachekey----------------if-cachedresult--null-------------this-logger-debugquery-result-served-from-cache-----------------query--queryclass----------------cachekey--cachekey------------------------------------return-cachedresult-----------------déterminer-la-source-de-lecture-optimale--------readsource--this-sourcerouter-routereadqueryclass-query-toarray-----------------exécuter-la-requête-via-la-source-optimale--------handler--this-handlersqueryclass--------result--handler-handlequery-readsource-----------------mettre-en-cache--------this-cachemanager-setcachekey-result-300----------------this-logger-infoquery-executed-and-cached-via-multi-source-cqs-------------query--queryclass------------source--readsource------------cachekey--cachekey------------------------return-result--------private-function-generatecachekeyqueryinterface-query-string------------return-multi_source_query_--md5serializequery-----query-workflow-avec-multi-sourcesphpphpnamespace-appworkflowquerypaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowuse-appinfrastructuremultisourcesourcerouterworkflowinterfaceinterface-paymentmultisourcequeryworkflowinterface----workflowmethod----public-function-searchpaymentswithmultisourcepaymentsearchquery-query-paymentsearchresult--------workflowmethod----public-function-getpaymentbyidwithmultisourcepaymentbyidquery-query-payment--------workflowmethod----public-function-getpaymentstatisticswithmultisourcepaymentstatisticsquery-query-array--------workflowmethod----public-function-getpaymentanalyticswithmultisourcepaymentanalyticsquery-query-arrayactivityinterfaceinterface-paymentmultisourcequeryactivityinterface----activitymethod----public-function-searchpaymentsinsourcepaymentsearchquery-query-string-source-array--------activitymethod----public-function-getpaymentfromsourcestring-paymentid-string-source-payment--------activitymethod----public-function-calculatepaymentstatisticsinsourcepaymentstatisticsquery-query-string-source-array--------activitymethod----public-function-generatepaymentanalyticsinsourcepaymentanalyticsquery-query-string-source-arrayclass-paymentmultisourcequeryworkflow-implements-paymentmultisourcequeryworkflowinterface----private-paymentmultisourcequeryactivityinterface-queryactivity----private-sourcerouter-sourcerouter----public-function-__construct------------this-queryactivity--workflownewactivitystubpaymentmultisourcequeryactivityinterfaceclass--------this-sourcerouter--workflownewactivitystubsourcerouterclass--------public-function-searchpaymentswithmultisourcepaymentsearchquery-query-paymentsearchresult------------try--------------déterminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadsearch-query-toarray-------------------------recherche-dans-la-source-optimale------------payments--yield-this-queryactivity-searchpaymentsinsourcequery-readsource-------------------------filtrage-et-tri------------filteredpayments--this-filterpaymentspayments-query------------sortedpayments--this-sortpaymentsfilteredpayments-query-------------------------pagination------------paginatedpayments--this-paginatepaymentssortedpayments-query------------------------return-new-paymentsearchresult----------------paginatedpayments----------------countfilteredpayments----------------query-getpage----------------query-getsize---------------------------------catch-exception-e-------------return-new-paymentsearchresult-0-query-getpage-query-getsize----------------public-function-getpaymentbyidwithmultisourcepaymentbyidquery-query-payment------------try--------------déterminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadfindbyid-id--query-getpaymentid------------------------return-yield-this-queryactivity-getpaymentfromsourcequery-getpaymentid-readsource---------catch-exception-e-------------return-null----------------public-function-getpaymentstatisticswithmultisourcepaymentstatisticsquery-query-array------------try--------------déterminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadstatistics-query-toarray------------------------return-yield-this-queryactivity-calculatepaymentstatisticsinsourcequery-readsource---------catch-exception-e-------------return-----------------public-function-getpaymentanalyticswithmultisourcepaymentanalyticsquery-query-array------------try--------------déterminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadanalytics-query-toarray------------------------return-yield-this-queryactivity-generatepaymentanalyticsinsourcequery-readsource---------catch-exception-e-------------return-----------------private-function-filterpaymentsarray-payments-paymentsearchquery-query-array------------return-array_filterpayments-functionpayment-use-query-------------if-query-getorganizationid--payment-getorganizationid--query-getorganizationid-----------------return-false------------------------------------if-query-getstatus--payment-getstatus--query-getstatus-----------------return-false------------------------------------if-query-getminamount--payment-getamount--query-getminamount-----------------return-false------------------------------------if-query-getmaxamount--payment-getamount--query-getmaxamount-----------------return-false------------------------------------return-true----------------private-function-sortpaymentsarray-payments-paymentsearchquery-query-array------------sortfield--query-getsortfield--createdat--------sortdirection--query-getsortdirection--desc----------------usortpayments-functiona-b-use-sortfield-sortdirection-------------valuea--this-getfieldvaluea-sortfield------------valueb--this-getfieldvalueb-sortfield------------------------if-sortdirection--asc-----------------return-valuea--valueb-------------else-----------------return-valueb--valuea------------------------------------return-payments--------private-function-paginatepaymentsarray-payments-paymentsearchquery-query-array------------page--query-getpage--1--------size--query-getsize--10--------offset--page---1--size----------------return-array_slicepayments-offset-size--------private-function-getfieldvaluepayment-payment-string-field-mixed------------switch-field-------------case-amount----------------return-payment-getamount------------case-createdat----------------return-payment-getcreatedat------------case-status----------------return-payment-getstatus------------default----------------return-payment-getcreatedat-------------3-service-de-synchronisation-multi-sources-service-de-synchronisation-cqsphpphpnamespace-appapplicationservicemultisourceuse-appdomaineventdomaineventuse-appinfrastructuremultisourcesourcerouteruse-appinfrastructuremultisourcemultisourcecachemanageruse-psrlogloggerinterfaceclass-multisourcecqssynchronizationservice----private-sourcerouter-sourcerouter----private-multisourcecachemanager-cachemanager----private-loggerinterface-logger----public-function-__construct--------sourcerouter-sourcerouter--------multisourcecachemanager-cachemanager--------loggerinterface-logger-------------this-sourcerouter--sourcerouter--------this-cachemanager--cachemanager--------this-logger--logger--------public-function-handleeventdomainevent-event-void------------try-------------this-logger-infohandling-event-via-multi-source-cqs-----------------eventtype--event-geteventtype----------------eventid--event-getid-------------------------déterminer-les-sources-affectées------------affectedsources--this-determineaffectedsourcesevent-------------------------mettre-à-jour-chaque-source------------foreach-affectedsources-as-source-----------------this-updatesourcesource-event-------------------------------------invalider-le-cache-si-nécessaire------------if-this-shouldinvalidatecacheevent-----------------this-invalidatecacheevent---------------------------------catch-exception-e-------------this-logger-errorfailed-to-handle-event-via-multi-source-cqs-----------------eventtype--event-geteventtype----------------error--e-getmessage------------------------------------throw-e----------------public-function-synchronizesources-void------------try-------------this-logger-infosynchronizing-sources-via-multi-source-cqs-------------------------synchroniser-les-sources-de-lecture-avec-les-sources-décriture------------this-synchronizereadsources-------------------------nettoyer-les-caches-expirés------------this-cleanexpiredcaches------------------------this-logger-infosources-synchronized-successfully-via-multi-source-cqs---------------------catch-exception-e-------------this-logger-errorfailed-to-synchronize-sources-via-multi-source-cqs-----------------error--e-getmessage------------------------------------throw-e----------------private-function-determineaffectedsourcesdomainevent-event-array------------sources-------------------toujours-affecter-la-base-de-données-pour-les-événements-critiques--------if-this-iscriticaleventevent-------------sources--database-------------------------affecter-le-cache-pour-les-événements-de-lecture--------if-this-isreadeventevent-------------sources--cache-------------------------affecter-elasticsearch-pour-les-événements-de-recherche--------if-this-issearcheventevent-------------sources--elasticsearch------------------------return-sources--------private-function-updatesourcestring-source-domainevent-event-void------------this-logger-debugupdating-source-------------source--source------------eventtype--event-geteventtype-------------------------implémentation-spécifique-à-chaque-source--------switch-source-------------case-database----------------this-updatedatabaseevent----------------break------------case-cache----------------this-updatecacheevent----------------break------------case-elasticsearch----------------this-updateelasticsearchevent----------------break----------------private-function-shouldinvalidatecachedomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentupdated------------paymentdeleted------------paymentstatuschanged----------------private-function-invalidatecachedomainevent-event-void------------this-logger-debuginvalidating-cache-------------eventtype--event-geteventtype-------------------------invalider-les-caches-pertinents--------if-issetevent-getdatapaymentid-------------this-cachemanager-deletepaymentevent-getdatapaymentid----------------private-function-iscriticaleventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentcreated------------paymentupdated------------paymentdeleted----------------private-function-isreadeventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentviewed------------paymentsearched----------------private-function-issearcheventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentcreated------------paymentupdated------------paymentdeleted----------------private-function-updatedatabasedomainevent-event-void-------------implémentation-de-la-mise-à-jour-de-la-base-de-données--------private-function-updatecachedomainevent-event-void-------------implémentation-de-la-mise-à-jour-du-cache--------private-function-updateelasticsearchdomainevent-event-void-------------implémentation-de-la-mise-à-jour-delasticsearch--------private-function-synchronizereadsources-void-------------implémentation-de-la-synchronisation-des-sources-de-lecture--------private-function-cleanexpiredcaches-void-------------implémentation-du-nettoyage-des-caches-expirés------tests-et-validation-tests-dphpphpnamespace-apptestsintegrationmultisourceuse-appworkflowcommandpaymentpaymentcommandrequestuse-appworkflowquerypaymentpaymentsearchqueryuse-appapplicationcommandbusmultisourcemultisourcecommandbususe-appapplicationquerybusmultisourcemultisourcequerybususe-appinfrastructuremultisourcesourcerouterclass-multisourcecqstest-extends-testcase----private-multisourcecommandbus-commandbus----private-multisourcequerybus-querybus----private-sourcerouter-sourcerouter----protected-function-setup-void------------this-sourcerouter--this-createmocksourcerouterclass--------this-commandbus--new-multisourcecommandbus------------this-sourcerouter------------this-createmockloggerinterfaceclass----------------this-querybus--new-multisourcequerybus------------this-sourcerouter------------this-createmockmultisourcecachemanagerclass------------this-createmockloggerinterfaceclass----------------public-function-testcqsseparationwithmultisource-void-------------exécuter-une-commande-avec-multi-source-cqs--------command--new-paymentcommandrequest------------create------------payment-123------------org-456------------user-789------------10000------------eur------------test-payment------------------------this-commandbus-handlecommand-----------------vérifier-avec-une-requête--------query--new-paymentsearchqueryorg-456-0-10--------result--this-querybus-handlequery----------------this-assertgreaterthan0-result-gettotal--------public-function-testquerycachingwithmultisource-void------------query--new-paymentsearchqueryorg-456-0-10-----------------première-recherche--------result1--this-querybus-handlequery-----------------deuxième-recherche-devrait-utiliser-le-cache--------result2--this-querybus-handlequery----------------this-assertequalsresult1-gettotal-result2-gettotal------performance-et-optimisation-stratégies-d-1-cache-stratégique-multi-sourcesphppublic-function-searchpaymentswithcachepaymentsearchquery-query-paymentsearchresult----cachekey--multi_source_payment_search_--md5serializequery--------if-cached--this-cachemanager-getcachekey---------return-cached------------result--this-searchpaymentswithmultisourcequery----this-cachemanager-setcachekey-result-300--------return-result-2-load-balancing-multi-sourcesphppublic-function-getoptimalsourceforoperationstring-operation-array-criteria---string----sourceloads--this-getsourceloads----optimalsource--array_keyssourceloads-minsourceloads0--------this-logger-debugselected-optimal-source-for-operation---------operation--operation--------source--optimalsource--------loads--sourceloads------------return-optimalsource-3-monitoring-des-sources-multi-sourcesphppublic-function-getmultisourcemetrics-array----return---------commandsources--this-getcommandsourcemetrics--------querysources--this-getquerysourcemetrics--------cachehitrate--this-getcachehitrate--------sourcehealth--this-getsourcehealth--------averageexecutiontime--this-getaverageexecutiontime------critères-d-quand-utiliser-cqs-avec-multi-sources--avantages--performance-optimisée--séparation-claire-entre-écriture-et-lecture--flexibilité-maximale--choix-du-meilleur-stockage-pour-chaque-opération--scalabilité--possibilité-de-scaler-indépendamment-chaque-côté--résilience--redondance-et-failover-entre-sources--maintenabilité--code-plus-clair-et-organisé--inconvénients--complexité-élevée--gestion-de-plusieurs-sources-de-données--cohérence--risque-dincohérence-entre-sources--maintenance--plus-de-sources-à-maintenir--expertise--équipe-expérimentée-requise--critères-d--système-complexe--besoins-de-performance-différents-par-type-dopération--données-hétérogènes--types-de-données-différents-nécessitant-différents-stockages--performance-critique--besoins-de-performance-optimale--séparation-des-responsabilités--besoin-de-séparer-clairement-les-commandes-et-requêtes--équipe-expérimentée--maîtrise-de-plusieurs-technologies-de-stockage-et-cqs--budget-suffisant--investissement-en-infrastructure-multiple--temps-de-développement--suffisant-pour-implémenter-cette-complexité--votre-prochaine-étapehahahugoshortcode59s0hbhbcqs-avec-multi-sources-offre-un-équilibre-optimal-entre-performance-et-flexibilité-parfaitement-adapté-aux-besoins-complexes-de-gyroscops>🎯 <strong>Contexte et Objectifs</strong>### **Pourquoi CQS avec Multi-sources ?**La combinaison CQS avec Multi-sources offre une architecture optimisée qui sépare clairement les responsabilités tout en exploitant les avantages de différents types de stockage. Cette approche permet d&rsquo;optimiser chaque côté (commandes et requêtes) avec les sources les plus appropriées.#### <strong>Avantages de CQS avec Multi-sources</strong>- <strong>Performance optimisée</strong> : Séparation claire entre écriture et lecture- <strong>Flexibilité maximale</strong> : Choix du meilleur stockage pour chaque opération- <strong>Scalabilité</strong> : Possibilité de scaler indépendamment chaque côté- <strong>Résilience</strong> : Redondance et failover entre sources- <strong>Maintenabilité</strong> : Code plus clair et organisé### <strong>Contexte Gyroscops</strong>Dans notre écosystème <strong>User → Organization → Workflow → Cloud Resources → Billing</strong>, CQS avec Multi-sources est particulièrement pertinent pour :- <strong>Workflows de commande</strong> : Orchestration des processus de modification avec sources optimisées- <strong>Workflows de requête</strong> : Optimisation des lectures avec sources spécialisées- <strong>Processus de facturation</strong> : Séparation des écritures et lectures de facturation- <strong>Intégrations complexes</strong> : Orchestration des intégrations avec sources multiples## 🏗️ <strong>Architecture CQS avec Multi-sources</strong>### <strong>Séparation des Responsabilités</strong>#### <strong>Côté Commande (Write) avec Multi-sources</strong>- <strong>Command Workflows</strong> : Orchestration des processus de modification- <strong>Command Activities</strong> : Exécution des activités de modification- <strong>Event Handlers</strong> : Gestion des événements de domaine- <strong>Command Bus</strong> : Orchestration des commandes- <strong>Write Sources</strong> : Sources optimisées pour les écritures- <strong>Command Models</strong> : Modèles optimisés pour les écritures#### <strong>Côté Requête (Read) avec Multi-sources</strong>- <strong>Query Workflows</strong> : Orchestration des processus de lecture- <strong>Query Activities</strong> : Exécution des activités de lecture- <strong>Search Services</strong> : Services de recherche spécialisés- <strong>Query Bus</strong> : Orchestration des requêtes- <strong>Read Sources</strong> : Sources optimisées pour les lectures- <strong>Query Models</strong> : Modèles optimisés pour les lectures### <strong>Flux de Données</strong><code>mermaidgraph TD A[Command] --> B[Command Bus] B --> C[Command Workflow] C --> D[Command Activities] D --> E[Write Sources] E --> F[SQL Database] E --> G[Redis Cache] E --> H[File System] I[Query] --> J[Query Bus] J --> K[Query Workflow] K --> L[Query Activities] L --> M[Read Sources] M --> N[ElasticSearch] M --> O[Redis Cache] M --> P[SQL Database] Q[Event] --> R[Event Handler] R --> C S[Projection] --> T[Read Model Update] T --> M</code>## 💻 <strong>Implémentation Pratique</strong>### <strong>1. Command Side avec Multi-sources</strong>#### <strong>Command Bus avec Multi-sources</strong><code>php&lt;?phpnamespace App\Application\CommandBus\MultiSource;use App\Domain\Command\CommandInterface;use App\Domain\Command\CommandHandlerInterface;use App\Infrastructure\MultiSource\SourceRouter;use Psr\Log\LoggerInterface;class MultiSourceCommandBus{ private array $handlers = []; private array $middleware = []; private SourceRouter $sourceRouter; private LoggerInterface $logger; public function __construct( SourceRouter $sourceRouter, LoggerInterface $logger ) { $this->sourceRouter = $sourceRouter; $this->logger = $logger; } public function registerHandler(string $commandClass, CommandHandlerInterface $handler): void { $this->handlers[$commandClass] = $handler; } public function addMiddleware(callable $middleware): void { $this->middleware[] = $middleware; } public function handle(CommandInterface $command): void { $commandClass = get_class($command); if (!isset($this->handlers[$commandClass])) { throw new \InvalidArgumentException("No handler registered for command: $commandClass"); } $handler = $this->handlers[$commandClass]; // Exécuter les middleware $this->executeMiddleware($command, function() use ($handler, $command) { $this->logger->info('Executing command via Multi-source CQS', [ 'command' => get_class($command), 'data' => $command->toArray() ]); $handler->handle($command); }); } private function executeMiddleware(CommandInterface $command, callable $next): void { $middleware = array_reverse($this->middleware); foreach ($middleware as $mw) { $next = function() use ($mw, $command, $next) { return $mw($command, $next); }; } $next(); }}</code>#### <strong>Command Workflow avec Multi-sources</strong><code>php&lt;?phpnamespace App\Workflow\Command\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Infrastructure\MultiSource\SourceRouter;#[WorkflowInterface]interface PaymentMultiSourceCommandWorkflowInterface{ #[WorkflowMethod] public function processPaymentCommandWithMultiSource(PaymentCommandRequest $request): PaymentCommandResult; #[WorkflowMethod] public function updatePaymentCommandWithMultiSource(PaymentUpdateCommandRequest $request): PaymentCommandResult; #[WorkflowMethod] public function deletePaymentCommandWithMultiSource(PaymentDeleteCommandRequest $request): PaymentCommandResult;}#[ActivityInterface]interface PaymentMultiSourceCommandActivityInterface{ #[ActivityMethod] public function validatePaymentCommand(PaymentCommandRequest $request): ValidationResult; #[ActivityMethod] public function executePaymentCommand(PaymentCommandRequest $request): CommandExecutionResult; #[ActivityMethod] public function persistToWriteSources(Payment $payment, array $sources): void; #[ActivityMethod] public function updateCommandModels(Payment $payment): void;}class PaymentMultiSourceCommandWorkflow implements PaymentMultiSourceCommandWorkflowInterface{ private PaymentMultiSourceCommandActivityInterface $commandActivity; private SourceRouter $sourceRouter; public function __construct() { $this->commandActivity = Workflow::newActivityStub(PaymentMultiSourceCommandActivityInterface::class); $this->sourceRouter = Workflow::newActivityStub(SourceRouter::class); } public function processPaymentCommandWithMultiSource(PaymentCommandRequest $request): PaymentCommandResult { try { // Validation de la commande $validation = yield $this->commandActivity->validatePaymentCommand($request); if (!$validation->isValid()) { return new PaymentCommandResult(false, $validation->getError()); } // Exécution de la commande $execution = yield $this->commandActivity->executePaymentCommand($request); if (!$execution->isSuccess()) { return new PaymentCommandResult(false, $execution->getError()); } // Déterminer les sources d'écriture optimales $writeSources = yield $this->sourceRouter->routeWrite('save', $execution->getPayment()); // Persister dans les sources d'écriture yield $this->commandActivity->persistToWriteSources($execution->getPayment(), $writeSources); // Mettre à jour les modèles de commande yield $this->commandActivity->updateCommandModels($execution->getPayment()); return new PaymentCommandResult(true, 'Payment command processed with Multi-source CQS'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e->getMessage()); } } public function updatePaymentCommandWithMultiSource(PaymentUpdateCommandRequest $request): PaymentCommandResult { try { // Validation de la commande de mise à jour $validation = yield $this->commandActivity->validatePaymentCommand($request); if (!$validation->isValid()) { return new PaymentCommandResult(false, $validation->getError()); } // Exécution de la mise à jour $execution = yield $this->commandActivity->executePaymentCommand($request); if (!$execution->isSuccess()) { return new PaymentCommandResult(false, $execution->getError()); } // Déterminer les sources d'écriture optimales $writeSources = yield $this->sourceRouter->routeWrite('update', $execution->getPayment()); // Persister dans les sources d'écriture yield $this->commandActivity->persistToWriteSources($execution->getPayment(), $writeSources); // Mettre à jour les modèles de commande yield $this->commandActivity->updateCommandModels($execution->getPayment()); return new PaymentCommandResult(true, 'Payment update command processed with Multi-source CQS'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e->getMessage()); } } public function deletePaymentCommandWithMultiSource(PaymentDeleteCommandRequest $request): PaymentCommandResult { try { // Validation de la commande de suppression $validation = yield $this->commandActivity->validatePaymentCommand($request); if (!$validation->isValid()) { return new PaymentCommandResult(false, $validation->getError()); } // Exécution de la suppression $execution = yield $this->commandActivity->executePaymentCommand($request); if (!$execution->isSuccess()) { return new PaymentCommandResult(false, $execution->getError()); } // Déterminer les sources d'écriture optimales $writeSources = yield $this->sourceRouter->routeWrite('delete', $execution->getPayment()); // Persister dans les sources d'écriture yield $this->commandActivity->persistToWriteSources($execution->getPayment(), $writeSources); // Mettre à jour les modèles de commande yield $this->commandActivity->updateCommandModels($execution->getPayment()); return new PaymentCommandResult(true, 'Payment delete command processed with Multi-source CQS'); } catch (\Exception $e) { return new PaymentCommandResult(false, $e->getMessage()); } }}</code>### <strong>2. Query Side avec Multi-sources</strong>#### <strong>Query Bus avec Cache et Multi-sources</strong><code>php&lt;?phpnamespace App\Application\QueryBus\MultiSource;use App\Domain\Query\QueryInterface;use App\Domain\Query\QueryHandlerInterface;use App\Infrastructure\MultiSource\SourceRouter;use App\Infrastructure\MultiSource\MultiSourceCacheManager;use Psr\Log\LoggerInterface;class MultiSourceQueryBus{ private array $handlers = []; private SourceRouter $sourceRouter; private MultiSourceCacheManager $cacheManager; private LoggerInterface $logger; public function __construct( SourceRouter $sourceRouter, MultiSourceCacheManager $cacheManager, LoggerInterface $logger ) { $this->sourceRouter = $sourceRouter; $this->cacheManager = $cacheManager; $this->logger = $logger; } public function registerHandler(string $queryClass, QueryHandlerInterface $handler): void { $this->handlers[$queryClass] = $handler; } public function handle(QueryInterface $query): mixed { $queryClass = get_class($query); if (!isset($this->handlers[$queryClass])) { throw new \InvalidArgumentException("No handler registered for query: $queryClass"); } // Vérifier le cache $cacheKey = $this->generateCacheKey($query); $cachedResult = $this->cacheManager->get($cacheKey); if ($cachedResult !== null) { $this->logger->debug('Query result served from cache', [ 'query' => $queryClass, 'cacheKey' => $cacheKey ]); return $cachedResult; } // Déterminer la source de lecture optimale $readSource = $this->sourceRouter->routeRead($queryClass, $query->toArray()); // Exécuter la requête via la source optimale $handler = $this->handlers[$queryClass]; $result = $handler->handle($query, $readSource); // Mettre en cache $this->cacheManager->set($cacheKey, $result, 300); $this->logger->info('Query executed and cached via Multi-source CQS', [ 'query' => $queryClass, 'source' => $readSource, 'cacheKey' => $cacheKey ]); return $result; } private function generateCacheKey(QueryInterface $query): string { return 'multi_source_query_' . md5(serialize($query)); }}</code>#### <strong>Query Workflow avec Multi-sources</strong><code>php&lt;?phpnamespace App\Workflow\Query\Payment;use Temporal\Workflow\WorkflowInterface;use Temporal\Workflow\WorkflowMethod;use Temporal\Workflow\ActivityInterface;use Temporal\Workflow\ActivityMethod;use Temporal\Workflow\Workflow;use App\Infrastructure\MultiSource\SourceRouter;#[WorkflowInterface]interface PaymentMultiSourceQueryWorkflowInterface{ #[WorkflowMethod] public function searchPaymentsWithMultiSource(PaymentSearchQuery $query): PaymentSearchResult; #[WorkflowMethod] public function getPaymentByIdWithMultiSource(PaymentByIdQuery $query): ?Payment; #[WorkflowMethod] public function getPaymentStatisticsWithMultiSource(PaymentStatisticsQuery $query): array; #[WorkflowMethod] public function getPaymentAnalyticsWithMultiSource(PaymentAnalyticsQuery $query): array;}#[ActivityInterface]interface PaymentMultiSourceQueryActivityInterface{ #[ActivityMethod] public function searchPaymentsInSource(PaymentSearchQuery $query, string $source): array; #[ActivityMethod] public function getPaymentFromSource(string $paymentId, string $source): ?Payment; #[ActivityMethod] public function calculatePaymentStatisticsInSource(PaymentStatisticsQuery $query, string $source): array; #[ActivityMethod] public function generatePaymentAnalyticsInSource(PaymentAnalyticsQuery $query, string $source): array;}class PaymentMultiSourceQueryWorkflow implements PaymentMultiSourceQueryWorkflowInterface{ private PaymentMultiSourceQueryActivityInterface $queryActivity; private SourceRouter $sourceRouter; public function __construct() { $this->queryActivity = Workflow::newActivityStub(PaymentMultiSourceQueryActivityInterface::class); $this->sourceRouter = Workflow::newActivityStub(SourceRouter::class); } public function searchPaymentsWithMultiSource(PaymentSearchQuery $query): PaymentSearchResult { try { // Déterminer la source de lecture optimale $readSource = yield $this->sourceRouter->routeRead('search', $query->toArray()); // Recherche dans la source optimale $payments = yield $this->queryActivity->searchPaymentsInSource($query, $readSource); // Filtrage et tri $filteredPayments = $this->filterPayments($payments, $query); $sortedPayments = $this->sortPayments($filteredPayments, $query); // Pagination $paginatedPayments = $this->paginatePayments($sortedPayments, $query); return new PaymentSearchResult( $paginatedPayments, count($filteredPayments), $query->getPage(), $query->getSize() ); } catch (\Exception $e) { return new PaymentSearchResult([], 0, $query->getPage(), $query->getSize()); } } public function getPaymentByIdWithMultiSource(PaymentByIdQuery $query): ?Payment { try { // Déterminer la source de lecture optimale $readSource = yield $this->sourceRouter->routeRead('findById', ['id' => $query->getPaymentId()]); return yield $this->queryActivity->getPaymentFromSource($query->getPaymentId(), $readSource); } catch (\Exception $e) { return null; } } public function getPaymentStatisticsWithMultiSource(PaymentStatisticsQuery $query): array { try { // Déterminer la source de lecture optimale $readSource = yield $this->sourceRouter->routeRead('statistics', $query->toArray()); return yield $this->queryActivity->calculatePaymentStatisticsInSource($query, $readSource); } catch (\Exception $e) { return []; } } public function getPaymentAnalyticsWithMultiSource(PaymentAnalyticsQuery $query): array { try { // Déterminer la source de lecture optimale $readSource = yield $this->sourceRouter->routeRead('analytics', $query->toArray()); return yield $this->queryActivity->generatePaymentAnalyticsInSource($query, $readSource); } catch (\Exception $e) { return []; } } private function filterPayments(array $payments, PaymentSearchQuery $query): array { return array_filter($payments, function($payment) use ($query) { if ($query->getOrganizationId() && $payment->getOrganizationId() !== $query->getOrganizationId()) { return false; } if ($query->getStatus() && $payment->getStatus() !== $query->getStatus()) { return false; } if ($query->getMinAmount() && $payment->getAmount() &lt; $query->getMinAmount()) { return false; } if ($query->getMaxAmount() && $payment->getAmount() > $query->getMaxAmount()) { return false; } return true; }); } private function sortPayments(array $payments, PaymentSearchQuery $query): array { $sortField = $query->getSortField() ?? 'createdAt'; $sortDirection = $query->getSortDirection() ?? 'desc'; usort($payments, function($a, $b) use ($sortField, $sortDirection) { $valueA = $this->getFieldValue($a, $sortField); $valueB = $this->getFieldValue($b, $sortField); if ($sortDirection === 'asc') { return $valueA &lt;=> $valueB; } else { return $valueB &lt;=> $valueA; } }); return $payments; } private function paginatePayments(array $payments, PaymentSearchQuery $query): array { $page = $query->getPage() ?? 1; $size = $query->getSize() ?? 10; $offset = ($page - 1) * $size; return array_slice($payments, $offset, $size); } private function getFieldValue(Payment $payment, string $field): mixed { switch ($field) { case 'amount': return $payment->getAmount(); case 'createdAt': return $payment->getCreatedAt(); case 'status': return $payment->getStatus(); default: return $payment->getCreatedAt(); } }}</code>### <strong>3. Service de Synchronisation Multi-Sources</strong>#### <strong>Service de Synchronisation CQS</strong><code>php&lt;?phpnamespace App\Application\Service\MultiSource;use App\Domain\Event\DomainEvent;use App\Infrastructure\MultiSource\SourceRouter;use App\Infrastructure\MultiSource\MultiSourceCacheManager;use Psr\Log\LoggerInterface;class MultiSourceCqsSynchronizationService{ private SourceRouter $sourceRouter; private MultiSourceCacheManager $cacheManager; private LoggerInterface $logger; public function __construct( SourceRouter $sourceRouter, MultiSourceCacheManager $cacheManager, LoggerInterface $logger ) { $this->sourceRouter = $sourceRouter; $this->cacheManager = $cacheManager; $this->logger = $logger; } public function handleEvent(DomainEvent $event): void { try { $this->logger->info('Handling event via Multi-source CQS', [ 'eventType' => $event->getEventType(), 'eventId' => $event->getId() ]); // Déterminer les sources affectées $affectedSources = $this->determineAffectedSources($event); // Mettre à jour chaque source foreach ($affectedSources as $source) { $this->updateSource($source, $event); } // Invalider le cache si nécessaire if ($this->shouldInvalidateCache($event)) { $this->invalidateCache($event); } } catch (\Exception $e) { $this->logger->error('Failed to handle event via Multi-source CQS', [ 'eventType' => $event->getEventType(), 'error' => $e->getMessage() ]); throw $e; } } public function synchronizeSources(): void { try { $this->logger->info('Synchronizing sources via Multi-source CQS'); // Synchroniser les sources de lecture avec les sources d'écriture $this->synchronizeReadSources(); // Nettoyer les caches expirés $this->cleanExpiredCaches(); $this->logger->info('Sources synchronized successfully via Multi-source CQS'); } catch (\Exception $e) { $this->logger->error('Failed to synchronize sources via Multi-source CQS', [ 'error' => $e->getMessage() ]); throw $e; } } private function determineAffectedSources(DomainEvent $event): array { $sources = []; // Toujours affecter la base de données pour les événements critiques if ($this->isCriticalEvent($event)) { $sources[] = 'database'; } // Affecter le cache pour les événements de lecture if ($this->isReadEvent($event)) { $sources[] = 'cache'; } // Affecter ElasticSearch pour les événements de recherche if ($this->isSearchEvent($event)) { $sources[] = 'elasticsearch'; } return $sources; } private function updateSource(string $source, DomainEvent $event): void { $this->logger->debug('Updating source', [ 'source' => $source, 'eventType' => $event->getEventType() ]); // Implémentation spécifique à chaque source switch ($source) { case 'database': $this->updateDatabase($event); break; case 'cache': $this->updateCache($event); break; case 'elasticsearch': $this->updateElasticSearch($event); break; } } private function shouldInvalidateCache(DomainEvent $event): bool { return in_array($event->getEventType(), [ 'PaymentUpdated', 'PaymentDeleted', 'PaymentStatusChanged' ]); } private function invalidateCache(DomainEvent $event): void { $this->logger->debug('Invalidating cache', [ 'eventType' => $event->getEventType() ]); // Invalider les caches pertinents if (isset($event->getData()['paymentId'])) { $this->cacheManager->deletePayment($event->getData()['paymentId']); } } private function isCriticalEvent(DomainEvent $event): bool { return in_array($event->getEventType(), [ 'PaymentCreated', 'PaymentUpdated', 'PaymentDeleted' ]); } private function isReadEvent(DomainEvent $event): bool { return in_array($event->getEventType(), [ 'PaymentViewed', 'PaymentSearched' ]); } private function isSearchEvent(DomainEvent $event): bool { return in_array($event->getEventType(), [ 'PaymentCreated', 'PaymentUpdated', 'PaymentDeleted' ]); } private function updateDatabase(DomainEvent $event): void { // Implémentation de la mise à jour de la base de données } private function updateCache(DomainEvent $event): void { // Implémentation de la mise à jour du cache } private function updateElasticSearch(DomainEvent $event): void { // Implémentation de la mise à jour d'ElasticSearch } private function synchronizeReadSources(): void { // Implémentation de la synchronisation des sources de lecture } private function cleanExpiredCaches(): void { // Implémentation du nettoyage des caches expirés }}</code>## 🧪 <strong>Tests et Validation</strong>### <strong>Tests d&rsquo;Intégration CQS Multi-Sources</strong><code>php&lt;?phpnamespace App\Tests\Integration\MultiSource;use App\Workflow\Command\Payment\PaymentCommandRequest;use App\Workflow\Query\Payment\PaymentSearchQuery;use App\Application\CommandBus\MultiSource\MultiSourceCommandBus;use App\Application\QueryBus\MultiSource\MultiSourceQueryBus;use App\Infrastructure\MultiSource\SourceRouter;class MultiSourceCqsTest extends TestCase{ private MultiSourceCommandBus $commandBus; private MultiSourceQueryBus $queryBus; private SourceRouter $sourceRouter; protected function setUp(): void { $this->sourceRouter = $this->createMock(SourceRouter::class); $this->commandBus = new MultiSourceCommandBus( $this->sourceRouter, $this->createMock(LoggerInterface::class) ); $this->queryBus = new MultiSourceQueryBus( $this->sourceRouter, $this->createMock(MultiSourceCacheManager::class), $this->createMock(LoggerInterface::class) ); } public function testCqsSeparationWithMultiSource(): void { // Exécuter une commande avec Multi-source CQS $command = new PaymentCommandRequest( 'CREATE', 'payment-123', 'org-456', 'user-789', 100.00, 'EUR', 'Test payment' ); $this->commandBus->handle($command); // Vérifier avec une requête $query = new PaymentSearchQuery('org-456', 0, 10); $result = $this->queryBus->handle($query); $this->assertGreaterThan(0, $result->getTotal()); } public function testQueryCachingWithMultiSource(): void { $query = new PaymentSearchQuery('org-456', 0, 10); // Première recherche $result1 = $this->queryBus->handle($query); // Deuxième recherche (devrait utiliser le cache) $result2 = $this->queryBus->handle($query); $this->assertEquals($result1->getTotal(), $result2->getTotal()); }}</code>## 📊 <strong>Performance et Optimisation</strong>### <strong>Stratégies d&rsquo;Optimisation CQS Multi-Sources</strong>#### <strong>1. Cache Stratégique Multi-Sources</strong><code>phppublic function searchPaymentsWithCache(PaymentSearchQuery $query): PaymentSearchResult{ $cacheKey = 'multi_source_payment_search_' . md5(serialize($query)); if ($cached = $this->cacheManager->get($cacheKey)) { return $cached; } $result = $this->searchPaymentsWithMultiSource($query); $this->cacheManager->set($cacheKey, $result, 300); return $result;}</code>#### <strong>2. Load Balancing Multi-Sources</strong><code>phppublic function getOptimalSourceForOperation(string $operation, array $criteria = []): string{ $sourceLoads = $this->getSourceLoads(); $optimalSource = array_keys($sourceLoads, min($sourceLoads))[0]; $this->logger->debug('Selected optimal source for operation', [ 'operation' => $operation, 'source' => $optimalSource, 'loads' => $sourceLoads ]); return $optimalSource;}</code>#### <strong>3. Monitoring des Sources Multi-Sources</strong><code>phppublic function getMultiSourceMetrics(): array{ return [ 'commandSources' => $this->getCommandSourceMetrics(), 'querySources' => $this->getQuerySourceMetrics(), 'cacheHitRate' => $this->getCacheHitRate(), 'sourceHealth' => $this->getSourceHealth(), 'averageExecutionTime' => $this->getAverageExecutionTime() ];}</code>## 🎯 <strong>Critères d&rsquo;Adoption</strong>### <strong>Quand Utiliser CQS avec Multi-sources</strong>#### <strong>✅ Avantages</strong>- <strong>Performance optimisée</strong> : Séparation claire entre écriture et lecture- <strong>Flexibilité maximale</strong> : Choix du meilleur stockage pour chaque opération- <strong>Scalabilité</strong> : Possibilité de scaler indépendamment chaque côté- <strong>Résilience</strong> : Redondance et failover entre sources- <strong>Maintenabilité</strong> : Code plus clair et organisé#### <strong>❌ Inconvénients</strong>- <strong>Complexité élevée</strong> : Gestion de plusieurs sources de données- <strong>Cohérence</strong> : Risque d&rsquo;incohérence entre sources- <strong>Maintenance</strong> : Plus de sources à maintenir- <strong>Expertise</strong> : Équipe expérimentée requise#### <strong>🎯 Critères d&rsquo;Adoption</strong>- <strong>Système complexe</strong> : Besoins de performance différents par type d&rsquo;opération- <strong>Données hétérogènes</strong> : Types de données différents nécessitant différents stockages- <strong>Performance critique</strong> : Besoins de performance optimale- <strong>Séparation des responsabilités</strong> : Besoin de séparer clairement les commandes et requêtes- <strong>Équipe expérimentée</strong> : Maîtrise de plusieurs technologies de stockage et CQS- <strong>Budget suffisant</strong> : Investissement en infrastructure multiple- <strong>Temps de développement</strong> : Suffisant pour implémenter cette complexité## 🚀 <strong>Votre Prochaine Étape</strong><div class=chapter-navigation><h2 class=chapter-nav-title>🎯 Votre Prochaine Étape</h2><p class=chapter-nav-subtitle>Maintenant que vous comprenez les concepts de base et que j'ai partagé mon expérience avec Gyroscops, quel est votre contexte ?</p><div class=chapter-options><div class=chapter-option data-color=green data-draft=true><div class=chapter-option-header><div class=chapter-option-letter>A</div><div><h3 class=chapter-option-title>Je veux voir l'approche CQRS avec Multi-sources</h3><p class=chapter-option-subtitle>Vous voulez comprendre la séparation complète des responsabilités</p></div></div><div class=chapter-option-content><div class=chapter-option-criteria><h4 class=chapter-option-criteria-title>Critères d'adoption :</h4><ul class=chapter-option-criteria-list><li>Architecture complexe</li><li>Équipe très expérimentée</li><li>Performance critique</li><li>Scalabilité maximale</li></ul></div><div class=chapter-option-footer><span class=chapter-option-time>⏱️ 45-60 minutes</span>
<span class="chapter-option-link chapter-option-link-disabled">Stockage Multi-sources - CQRS
<span class=draft-indicator>📝</span></span></div></div></div><style>.chapter-option-link-disabled{background:#9ca3af!important;color:#6b7280!important;cursor:not-allowed!important;opacity:.7}.chapter-option-link-disabled:hover{background:#9ca3af!important;color:#6b7280!important;transform:none!important;box-shadow:none!important}.chapter-option-link-disabled::after{display:none!important}.chapter-option[data-draft=true]{opacity:.8;border-style:dashed;border-color:#d1d5db}.chapter-option[data-draft=true] .chapter-option-letter{background:#9ca3af}.chapter-option[data-draft=true] .chapter-option-title{color:#6b7280}.chapter-option[data-draft=true] .chapter-option-subtitle{color:#9ca3af}.draft-indicator,.coming-soon-indicator{margin-left:.5rem;font-size:.875rem}.chapter-option[data-draft=true]{animation:draft-pulse 2s ease-in-out infinite}@keyframes draft-pulse{0%,100%{opacity:.8}50%{opacity:.6}}</style><div class=chapter-option data-color=yellow data-draft=true><div class=chapter-option-header><div class=chapter-option-letter>B</div><div><h3 class=chapter-option-title>Je veux explorer les autres types de stockage</h3><p class=chapter-option-subtitle>Vous voulez voir les alternatives à Multi-sources</p></div></div><div class=chapter-option-content><div class=chapter-option-criteria><h4 class=chapter-option-criteria-title>Critères d'adoption :</h4><ul class=chapter-option-criteria-list><li>Comparaison nécessaire</li><li>Choix de stockage</li><li>Architecture à définir</li><li>Performance à optimiser</li></ul></div><div class=chapter-option-footer><span class=chapter-option-time>⏱️ 30-40 minutes</span>
<span class="chapter-option-link chapter-option-link-disabled">Choix du Type de Stockage
<span class=draft-indicator>📝</span></span></div></div></div><style>.chapter-option-link-disabled{background:#9ca3af!important;color:#6b7280!important;cursor:not-allowed!important;opacity:.7}.chapter-option-link-disabled:hover{background:#9ca3af!important;color:#6b7280!important;transform:none!important;box-shadow:none!important}.chapter-option-link-disabled::after{display:none!important}.chapter-option[data-draft=true]{opacity:.8;border-style:dashed;border-color:#d1d5db}.chapter-option[data-draft=true] .chapter-option-letter{background:#9ca3af}.chapter-option[data-draft=true] .chapter-option-title{color:#6b7280}.chapter-option[data-draft=true] .chapter-option-subtitle{color:#9ca3af}.draft-indicator,.coming-soon-indicator{margin-left:.5rem;font-size:.875rem}.chapter-option[data-draft=true]{animation:draft-pulse 2s ease-in-out infinite}@keyframes draft-pulse{0%,100%{opacity:.8}50%{opacity:.6}}</style><div class=chapter-option data-color=blue><div class=chapter-option-header><div class=chapter-option-letter>C</div><div><h3 class=chapter-option-title>Je veux voir des exemples concrets</h3><p class=chapter-option-subtitle>Vous voulez comprendre les implémentations pratiques</p></div></div><div class=chapter-option-content><div class=chapter-option-criteria><h4 class=chapter-option-criteria-title>Critères d'adoption :</h4><ul class=chapter-option-criteria-list><li>Développeur expérimenté</li><li>Besoin d'exemples pratiques</li><li>Implémentation à faire</li><li>Code à écrire</li></ul></div><div class=chapter-option-footer><span class=chapter-option-time>⏱️ Variable</span>
<a href=/examples/ class=chapter-option-link>Exemples et Implémentations</a></div></div></div><style>.chapter-option-link-disabled{background:#9ca3af!important;color:#6b7280!important;cursor:not-allowed!important;opacity:.7}.chapter-option-link-disabled:hover{background:#9ca3af!important;color:#6b7280!important;transform:none!important;box-shadow:none!important}.chapter-option-link-disabled::after{display:none!important}.chapter-option[data-draft=true]{opacity:.8;border-style:dashed;border-color:#d1d5db}.chapter-option[data-draft=true] .chapter-option-letter{background:#9ca3af}.chapter-option[data-draft=true] .chapter-option-title{color:#6b7280}.chapter-option[data-draft=true] .chapter-option-subtitle{color:#9ca3af}.draft-indicator,.coming-soon-indicator{margin-left:.5rem;font-size:.875rem}.chapter-option[data-draft=true]{animation:draft-pulse 2s ease-in-out infinite}@keyframes draft-pulse{0%,100%{opacity:.8}50%{opacity:.6}}</style><div class=chapter-option data-color=purple><div class=chapter-option-header><div class=chapter-option-letter>D</div><div><h3 class=chapter-option-title>Je veux revenir aux fondamentaux</h3><p class=chapter-option-subtitle>Vous voulez comprendre les concepts de base</p></div></div><div class=chapter-option-content><div class=chapter-option-criteria><h4 class=chapter-option-criteria-title>Critères d'adoption :</h4><ul class=chapter-option-criteria-list><li>Développeur débutant</li><li>Besoin de comprendre les concepts</li><li>Projet à structurer</li><li>Équipe à former</li></ul></div><div class=chapter-option-footer><span class=chapter-option-time>⏱️ 45-60 minutes</span>
<a href=/chapitres/fondamentaux/chapitre-01-introduction-event-storming-ddd/ class=chapter-option-link>Introduction au Domain-Driven Design et Event Storming</a></div></div></div><style>.chapter-option-link-disabled{background:#9ca3af!important;color:#6b7280!important;cursor:not-allowed!important;opacity:.7}.chapter-option-link-disabled:hover{background:#9ca3af!important;color:#6b7280!important;transform:none!important;box-shadow:none!important}.chapter-option-link-disabled::after{display:none!important}.chapter-option[data-draft=true]{opacity:.8;border-style:dashed;border-color:#d1d5db}.chapter-option[data-draft=true] .chapter-option-letter{background:#9ca3af}.chapter-option[data-draft=true] .chapter-option-title{color:#6b7280}.chapter-option[data-draft=true] .chapter-option-subtitle{color:#9ca3af}.draft-indicator,.coming-soon-indicator{margin-left:.5rem;font-size:.875rem}.chapter-option[data-draft=true]{animation:draft-pulse 2s ease-in-out infinite}@keyframes draft-pulse{0%,100%{opacity:.8}50%{opacity:.6}}</style></div></div><style>.chapter-navigation{margin:2rem 0;padding:1.5rem;background:linear-gradient(135deg,#f8fafc 0%,#e2e8f0 100%);border-radius:12px;border-left:4px solid #3b82f6}.chapter-nav-title{margin:0 0 .5rem;font-size:1.5rem;font-weight:700;color:#1e293b}.chapter-nav-subtitle{margin:0 0 1.5rem;color:#64748b;font-size:1rem;line-height:1.6}.chapter-options{display:flex;flex-direction:column;gap:1rem}.chapter-option{background:#fff;border-radius:8px;padding:1.25rem;border:1px solid #e2e8f0;transition:all .2s ease;position:relative;overflow:hidden}.chapter-option:hover{transform:translateY(-2px);box-shadow:0 8px 25px rgba(0,0,0,.1);border-color:#3b82f6}.chapter-option::before{content:'';position:absolute;top:0;left:0;width:4px;height:100%;background:var(--option-color,#6b7280);border-radius:0 2px 2px 0}.chapter-option-header{display:flex;align-items:center;margin-bottom:.75rem}.chapter-option-letter{display:inline-flex;align-items:center;justify-content:center;width:2rem;height:2rem;border-radius:50%;background:var(--option-color,#6b7280);color:#fff;font-weight:700;font-size:.875rem;margin-right:.75rem;flex-shrink:0}.chapter-option-title{font-size:1.125rem;font-weight:600;color:#1e293b;margin:0;line-height:1.4}.chapter-option-subtitle{font-size:.875rem;color:#64748b;font-style:italic;margin:.25rem 0 0;line-height:1.4}.chapter-option-content{margin-left:2.75rem}.chapter-option-criteria{margin-bottom:.75rem}.chapter-option-criteria-title{font-size:.875rem;font-weight:600;color:#374151;margin:0 0 .5rem}.chapter-option-criteria-list{list-style:none;padding:0;margin:0}.chapter-option-criteria-list li{position:relative;padding-left:1.25rem;margin-bottom:.25rem;font-size:.875rem;color:#4b5563;line-height:1.4}.chapter-option-criteria-list li::before{content:'✓';position:absolute;left:0;color:#10b981;font-weight:600}.chapter-option-footer{display:flex;justify-content:space-between;align-items:center;margin-top:1rem;padding-top:.75rem;border-top:1px solid #e5e7eb}.chapter-option-time{font-size:.875rem;color:#6b7280;font-weight:500}.chapter-option-link{display:inline-flex;align-items:center;padding:.5rem 1rem;background:var(--option-color,#6b7280);color:#fff!important;text-decoration:none!important;border-radius:6px;font-weight:600;font-size:.875rem;transition:all .2s ease;border:none;cursor:pointer}.chapter-option-link:hover{background:var(--option-color-dark,#4b5563);color:#fff!important;text-decoration:none!important;transform:translateY(-1px);box-shadow:0 4px 12px rgba(0,0,0,.15)}.chapter-option-link:visited{color:#fff!important;text-decoration:none!important}.chapter-option-link:focus{color:#fff!important;text-decoration:none!important;outline:2px solid rgba(255,255,255,.5);outline-offset:2px}.chapter-option-link:active{color:#fff!important;text-decoration:none!important}.chapter-option-link::after{content:'→';margin-left:.5rem;transition:transform .2s ease;color:#fff!important}.chapter-option-link:hover::after{transform:translateX(2px);color:#fff!important}.chapter-navigation a{color:inherit;text-decoration:none}.chapter-navigation a:hover{color:inherit;text-decoration:none}.chapter-navigation a:visited{color:inherit;text-decoration:none}.chapter-navigation a:focus{color:inherit;text-decoration:none}.chapter-navigation a:active{color:inherit;text-decoration:none}.chapter-option[data-color=green]{--option-color:#10b981;--option-color-dark:#059669}.chapter-option[data-color=yellow]{--option-color:#f59e0b;--option-color-dark:#d97706}.chapter-option[data-color=red]{--option-color:#ef4444;--option-color-dark:#dc2626}.chapter-option[data-color=blue]{--option-color:#3b82f6;--option-color-dark:#2563eb}.chapter-option[data-color=purple]{--option-color:#8b5cf6;--option-color-dark:#7c3aed}.chapter-option[data-color=orange]{--option-color:#f97316;--option-color-dark:#ea580c}.chapter-option[data-color=teal]{--option-color:#14b8a6;--option-color-dark:#0d9488}.chapter-option[data-color=indigo]{--option-color:#6366f1;--option-color-dark:#4f46e5}.chapter-option[data-color=pink]{--option-color:#ec4899;--option-color-dark:#db2777}.chapter-option[data-color=cyan]{--option-color:#06b6d4;--option-color-dark:#0891b2}@media(max-width:768px){.chapter-navigation{padding:1rem}.chapter-option{padding:1rem}.chapter-option-content{margin-left:2.5rem}.chapter-option-footer{flex-direction:column;align-items:flex-start;gap:.75rem}.chapter-option-link{align-self:stretch;justify-content:center}}</style>&mdash;<em>CQS avec Multi-sources offre un équilibre optimal entre performance et flexibilité, parfaitement adapté aux besoins complexes de Gyroscops.</em> <a href=#-contexte-et-objectifs-pourquoi-cqs-avec-multi-sources-la-combinaison-cqs-avec-multi-sources-offre-une-architecture-optimis%c3%a9e-qui-s%c3%a9pare-clairement-les-responsabilit%c3%a9s-tout-en-exploitant-les-avantages-de-diff%c3%a9rents-types-de-stockage-cette-approche-permet-doptimiser-chaque-c%c3%b4t%c3%a9-commandes-et-requ%c3%aates-avec-les-sources-les-plus-appropri%c3%a9es-avantages-de-cqs-avec-multi-sources--performance-optimis%c3%a9e--s%c3%a9paration-claire-entre-%c3%a9criture-et-lecture--flexibilit%c3%a9-maximale--choix-du-meilleur-stockage-pour-chaque-op%c3%a9ration--scalabilit%c3%a9--possibilit%c3%a9-de-scaler-ind%c3%a9pendamment-chaque-c%c3%b4t%c3%a9--r%c3%a9silience--redondance-et-failover-entre-sources--maintenabilit%c3%a9--code-plus-clair-et-organis%c3%a9-contexte-gyroscopsdans-notre-%c3%a9cosyst%c3%a8me-user--organization--workflow--cloud-resources--billing-cqs-avec-multi-sources-est-particuli%c3%a8rement-pertinent-pour---workflows-de-commande--orchestration-des-processus-de-modification-avec-sources-optimis%c3%a9es--workflows-de-requ%c3%aate--optimisation-des-lectures-avec-sources-sp%c3%a9cialis%c3%a9es--processus-de-facturation--s%c3%a9paration-des-%c3%a9critures-et-lectures-de-facturation--int%c3%a9grations-complexes--orchestration-des-int%c3%a9grations-avec-sources-multiples--architecture-cqs-avec-multi-sources-s%c3%a9paration-des-responsabilit%c3%a9s-c%c3%b4t%c3%a9-commande-write-avec-multi-sources--command-workflows--orchestration-des-processus-de-modification--command-activities--ex%c3%a9cution-des-activit%c3%a9s-de-modification--event-handlers--gestion-des-%c3%a9v%c3%a9nements-de-domaine--command-bus--orchestration-des-commandes--write-sources--sources-optimis%c3%a9es-pour-les-%c3%a9critures--command-models--mod%c3%a8les-optimis%c3%a9s-pour-les-%c3%a9critures-c%c3%b4t%c3%a9-requ%c3%aate-read-avec-multi-sources--query-workflows--orchestration-des-processus-de-lecture--query-activities--ex%c3%a9cution-des-activit%c3%a9s-de-lecture--search-services--services-de-recherche-sp%c3%a9cialis%c3%a9s--query-bus--orchestration-des-requ%c3%aates--read-sources--sources-optimis%c3%a9es-pour-les-lectures--query-models--mod%c3%a8les-optimis%c3%a9s-pour-les-lectures-flux-de-donn%c3%a9esmermaidgraph-td----acommand----bcommand-bus----b----ccommand-workflow----c----dcommand-activities----d----ewrite-sources----e----fsql-database----e----gredis-cache----e----hfile-system--------iquery----jquery-bus----j----kquery-workflow----k----lquery-activities----l----mread-sources----m----nelasticsearch----m----oredis-cache----m----psql-database--------qevent----revent-handler----r----c--------sprojection----tread-model-update----t----m--impl%c3%a9mentation-pratique-1-command-side-avec-multi-sources-command-bus-avec-multi-sourcesphpphpnamespace-appapplicationcommandbusmultisourceuse-appdomaincommandcommandinterfaceuse-appdomaincommandcommandhandlerinterfaceuse-appinfrastructuremultisourcesourcerouteruse-psrlogloggerinterfaceclass-multisourcecommandbus----private-array-handlers------private-array-middleware------private-sourcerouter-sourcerouter----private-loggerinterface-logger----public-function-__construct--------sourcerouter-sourcerouter--------loggerinterface-logger-------------this-sourcerouter--sourcerouter--------this-logger--logger--------public-function-registerhandlerstring-commandclass-commandhandlerinterface-handler-void------------this-handlerscommandclass--handler--------public-function-addmiddlewarecallable-middleware-void------------this-middleware--middleware--------public-function-handlecommandinterface-command-void------------commandclass--get_classcommand----------------if-issetthis-handlerscommandclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-command-commandclass----------------handler--this-handlerscommandclass-----------------ex%c3%a9cuter-les-middleware--------this-executemiddlewarecommand-function-use-handler-command-------------this-logger-infoexecuting-command-via-multi-source-cqs-----------------command--get_classcommand----------------data--command-toarray------------------------------------handler-handlecommand----------------private-function-executemiddlewarecommandinterface-command-callable-next-void------------middleware--array_reversethis-middleware----------------foreach-middleware-as-mw-------------next--function-use-mw-command-next-----------------return-mwcommand-next------------------------------------next-----command-workflow-avec-multi-sourcesphpphpnamespace-appworkflowcommandpaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowuse-appinfrastructuremultisourcesourcerouterworkflowinterfaceinterface-paymentmultisourcecommandworkflowinterface----workflowmethod----public-function-processpaymentcommandwithmultisourcepaymentcommandrequest-request-paymentcommandresult--------workflowmethod----public-function-updatepaymentcommandwithmultisourcepaymentupdatecommandrequest-request-paymentcommandresult--------workflowmethod----public-function-deletepaymentcommandwithmultisourcepaymentdeletecommandrequest-request-paymentcommandresultactivityinterfaceinterface-paymentmultisourcecommandactivityinterface----activitymethod----public-function-validatepaymentcommandpaymentcommandrequest-request-validationresult--------activitymethod----public-function-executepaymentcommandpaymentcommandrequest-request-commandexecutionresult--------activitymethod----public-function-persisttowritesourcespayment-payment-array-sources-void--------activitymethod----public-function-updatecommandmodelspayment-payment-voidclass-paymentmultisourcecommandworkflow-implements-paymentmultisourcecommandworkflowinterface----private-paymentmultisourcecommandactivityinterface-commandactivity----private-sourcerouter-sourcerouter----public-function-__construct------------this-commandactivity--workflownewactivitystubpaymentmultisourcecommandactivityinterfaceclass--------this-sourcerouter--workflownewactivitystubsourcerouterclass--------public-function-processpaymentcommandwithmultisourcepaymentcommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------ex%c3%a9cution-de-la-commande------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------d%c3%a9terminer-les-sources-d%c3%a9criture-optimales------------writesources--yield-this-sourcerouter-routewritesave-execution-getpayment-------------------------persister-dans-les-sources-d%c3%a9criture------------yield-this-commandactivity-persisttowritesourcesexecution-getpayment-writesources-------------------------mettre-%c3%a0-jour-les-mod%c3%a8les-de-commande------------yield-this-commandactivity-updatecommandmodelsexecution-getpayment------------------------return-new-paymentcommandresulttrue-payment-command-processed-with-multi-source-cqs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage----------------public-function-updatepaymentcommandwithmultisourcepaymentupdatecommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande-de-mise-%c3%a0-jour------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------ex%c3%a9cution-de-la-mise-%c3%a0-jour------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------d%c3%a9terminer-les-sources-d%c3%a9criture-optimales------------writesources--yield-this-sourcerouter-routewriteupdate-execution-getpayment-------------------------persister-dans-les-sources-d%c3%a9criture------------yield-this-commandactivity-persisttowritesourcesexecution-getpayment-writesources-------------------------mettre-%c3%a0-jour-les-mod%c3%a8les-de-commande------------yield-this-commandactivity-updatecommandmodelsexecution-getpayment------------------------return-new-paymentcommandresulttrue-payment-update-command-processed-with-multi-source-cqs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage----------------public-function-deletepaymentcommandwithmultisourcepaymentdeletecommandrequest-request-paymentcommandresult------------try--------------validation-de-la-commande-de-suppression------------validation--yield-this-commandactivity-validatepaymentcommandrequest------------------------if-validation-isvalid-----------------return-new-paymentcommandresultfalse-validation-geterror-------------------------------------ex%c3%a9cution-de-la-suppression------------execution--yield-this-commandactivity-executepaymentcommandrequest------------------------if-execution-issuccess-----------------return-new-paymentcommandresultfalse-execution-geterror-------------------------------------d%c3%a9terminer-les-sources-d%c3%a9criture-optimales------------writesources--yield-this-sourcerouter-routewritedelete-execution-getpayment-------------------------persister-dans-les-sources-d%c3%a9criture------------yield-this-commandactivity-persisttowritesourcesexecution-getpayment-writesources-------------------------mettre-%c3%a0-jour-les-mod%c3%a8les-de-commande------------yield-this-commandactivity-updatecommandmodelsexecution-getpayment------------------------return-new-paymentcommandresulttrue-payment-delete-command-processed-with-multi-source-cqs---------------------catch-exception-e-------------return-new-paymentcommandresultfalse-e-getmessage-------------2-query-side-avec-multi-sources-query-bus-avec-cache-et-multi-sourcesphpphpnamespace-appapplicationquerybusmultisourceuse-appdomainqueryqueryinterfaceuse-appdomainqueryqueryhandlerinterfaceuse-appinfrastructuremultisourcesourcerouteruse-appinfrastructuremultisourcemultisourcecachemanageruse-psrlogloggerinterfaceclass-multisourcequerybus----private-array-handlers------private-sourcerouter-sourcerouter----private-multisourcecachemanager-cachemanager----private-loggerinterface-logger----public-function-__construct--------sourcerouter-sourcerouter--------multisourcecachemanager-cachemanager--------loggerinterface-logger-------------this-sourcerouter--sourcerouter--------this-cachemanager--cachemanager--------this-logger--logger--------public-function-registerhandlerstring-queryclass-queryhandlerinterface-handler-void------------this-handlersqueryclass--handler--------public-function-handlequeryinterface-query-mixed------------queryclass--get_classquery----------------if-issetthis-handlersqueryclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-query-queryclass-----------------v%c3%a9rifier-le-cache--------cachekey--this-generatecachekeyquery--------cachedresult--this-cachemanager-getcachekey----------------if-cachedresult--null-------------this-logger-debugquery-result-served-from-cache-----------------query--queryclass----------------cachekey--cachekey------------------------------------return-cachedresult-----------------d%c3%a9terminer-la-source-de-lecture-optimale--------readsource--this-sourcerouter-routereadqueryclass-query-toarray-----------------ex%c3%a9cuter-la-requ%c3%aate-via-la-source-optimale--------handler--this-handlersqueryclass--------result--handler-handlequery-readsource-----------------mettre-en-cache--------this-cachemanager-setcachekey-result-300----------------this-logger-infoquery-executed-and-cached-via-multi-source-cqs-------------query--queryclass------------source--readsource------------cachekey--cachekey------------------------return-result--------private-function-generatecachekeyqueryinterface-query-string------------return-multi_source_query_--md5serializequery-----query-workflow-avec-multi-sourcesphpphpnamespace-appworkflowquerypaymentuse-temporalworkflowworkflowinterfaceuse-temporalworkflowworkflowmethoduse-temporalworkflowactivityinterfaceuse-temporalworkflowactivitymethoduse-temporalworkflowworkflowuse-appinfrastructuremultisourcesourcerouterworkflowinterfaceinterface-paymentmultisourcequeryworkflowinterface----workflowmethod----public-function-searchpaymentswithmultisourcepaymentsearchquery-query-paymentsearchresult--------workflowmethod----public-function-getpaymentbyidwithmultisourcepaymentbyidquery-query-payment--------workflowmethod----public-function-getpaymentstatisticswithmultisourcepaymentstatisticsquery-query-array--------workflowmethod----public-function-getpaymentanalyticswithmultisourcepaymentanalyticsquery-query-arrayactivityinterfaceinterface-paymentmultisourcequeryactivityinterface----activitymethod----public-function-searchpaymentsinsourcepaymentsearchquery-query-string-source-array--------activitymethod----public-function-getpaymentfromsourcestring-paymentid-string-source-payment--------activitymethod----public-function-calculatepaymentstatisticsinsourcepaymentstatisticsquery-query-string-source-array--------activitymethod----public-function-generatepaymentanalyticsinsourcepaymentanalyticsquery-query-string-source-arrayclass-paymentmultisourcequeryworkflow-implements-paymentmultisourcequeryworkflowinterface----private-paymentmultisourcequeryactivityinterface-queryactivity----private-sourcerouter-sourcerouter----public-function-__construct------------this-queryactivity--workflownewactivitystubpaymentmultisourcequeryactivityinterfaceclass--------this-sourcerouter--workflownewactivitystubsourcerouterclass--------public-function-searchpaymentswithmultisourcepaymentsearchquery-query-paymentsearchresult------------try--------------d%c3%a9terminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadsearch-query-toarray-------------------------recherche-dans-la-source-optimale------------payments--yield-this-queryactivity-searchpaymentsinsourcequery-readsource-------------------------filtrage-et-tri------------filteredpayments--this-filterpaymentspayments-query------------sortedpayments--this-sortpaymentsfilteredpayments-query-------------------------pagination------------paginatedpayments--this-paginatepaymentssortedpayments-query------------------------return-new-paymentsearchresult----------------paginatedpayments----------------countfilteredpayments----------------query-getpage----------------query-getsize---------------------------------catch-exception-e-------------return-new-paymentsearchresult-0-query-getpage-query-getsize----------------public-function-getpaymentbyidwithmultisourcepaymentbyidquery-query-payment------------try--------------d%c3%a9terminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadfindbyid-id--query-getpaymentid------------------------return-yield-this-queryactivity-getpaymentfromsourcequery-getpaymentid-readsource---------catch-exception-e-------------return-null----------------public-function-getpaymentstatisticswithmultisourcepaymentstatisticsquery-query-array------------try--------------d%c3%a9terminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadstatistics-query-toarray------------------------return-yield-this-queryactivity-calculatepaymentstatisticsinsourcequery-readsource---------catch-exception-e-------------return-----------------public-function-getpaymentanalyticswithmultisourcepaymentanalyticsquery-query-array------------try--------------d%c3%a9terminer-la-source-de-lecture-optimale------------readsource--yield-this-sourcerouter-routereadanalytics-query-toarray------------------------return-yield-this-queryactivity-generatepaymentanalyticsinsourcequery-readsource---------catch-exception-e-------------return-----------------private-function-filterpaymentsarray-payments-paymentsearchquery-query-array------------return-array_filterpayments-functionpayment-use-query-------------if-query-getorganizationid--payment-getorganizationid--query-getorganizationid-----------------return-false------------------------------------if-query-getstatus--payment-getstatus--query-getstatus-----------------return-false------------------------------------if-query-getminamount--payment-getamount--query-getminamount-----------------return-false------------------------------------if-query-getmaxamount--payment-getamount--query-getmaxamount-----------------return-false------------------------------------return-true----------------private-function-sortpaymentsarray-payments-paymentsearchquery-query-array------------sortfield--query-getsortfield--createdat--------sortdirection--query-getsortdirection--desc----------------usortpayments-functiona-b-use-sortfield-sortdirection-------------valuea--this-getfieldvaluea-sortfield------------valueb--this-getfieldvalueb-sortfield------------------------if-sortdirection--asc-----------------return-valuea--valueb-------------else-----------------return-valueb--valuea------------------------------------return-payments--------private-function-paginatepaymentsarray-payments-paymentsearchquery-query-array------------page--query-getpage--1--------size--query-getsize--10--------offset--page---1--size----------------return-array_slicepayments-offset-size--------private-function-getfieldvaluepayment-payment-string-field-mixed------------switch-field-------------case-amount----------------return-payment-getamount------------case-createdat----------------return-payment-getcreatedat------------case-status----------------return-payment-getstatus------------default----------------return-payment-getcreatedat-------------3-service-de-synchronisation-multi-sources-service-de-synchronisation-cqsphpphpnamespace-appapplicationservicemultisourceuse-appdomaineventdomaineventuse-appinfrastructuremultisourcesourcerouteruse-appinfrastructuremultisourcemultisourcecachemanageruse-psrlogloggerinterfaceclass-multisourcecqssynchronizationservice----private-sourcerouter-sourcerouter----private-multisourcecachemanager-cachemanager----private-loggerinterface-logger----public-function-__construct--------sourcerouter-sourcerouter--------multisourcecachemanager-cachemanager--------loggerinterface-logger-------------this-sourcerouter--sourcerouter--------this-cachemanager--cachemanager--------this-logger--logger--------public-function-handleeventdomainevent-event-void------------try-------------this-logger-infohandling-event-via-multi-source-cqs-----------------eventtype--event-geteventtype----------------eventid--event-getid-------------------------d%c3%a9terminer-les-sources-affect%c3%a9es------------affectedsources--this-determineaffectedsourcesevent-------------------------mettre-%c3%a0-jour-chaque-source------------foreach-affectedsources-as-source-----------------this-updatesourcesource-event-------------------------------------invalider-le-cache-si-n%c3%a9cessaire------------if-this-shouldinvalidatecacheevent-----------------this-invalidatecacheevent---------------------------------catch-exception-e-------------this-logger-errorfailed-to-handle-event-via-multi-source-cqs-----------------eventtype--event-geteventtype----------------error--e-getmessage------------------------------------throw-e----------------public-function-synchronizesources-void------------try-------------this-logger-infosynchronizing-sources-via-multi-source-cqs-------------------------synchroniser-les-sources-de-lecture-avec-les-sources-d%c3%a9criture------------this-synchronizereadsources-------------------------nettoyer-les-caches-expir%c3%a9s------------this-cleanexpiredcaches------------------------this-logger-infosources-synchronized-successfully-via-multi-source-cqs---------------------catch-exception-e-------------this-logger-errorfailed-to-synchronize-sources-via-multi-source-cqs-----------------error--e-getmessage------------------------------------throw-e----------------private-function-determineaffectedsourcesdomainevent-event-array------------sources-------------------toujours-affecter-la-base-de-donn%c3%a9es-pour-les-%c3%a9v%c3%a9nements-critiques--------if-this-iscriticaleventevent-------------sources--database-------------------------affecter-le-cache-pour-les-%c3%a9v%c3%a9nements-de-lecture--------if-this-isreadeventevent-------------sources--cache-------------------------affecter-elasticsearch-pour-les-%c3%a9v%c3%a9nements-de-recherche--------if-this-issearcheventevent-------------sources--elasticsearch------------------------return-sources--------private-function-updatesourcestring-source-domainevent-event-void------------this-logger-debugupdating-source-------------source--source------------eventtype--event-geteventtype-------------------------impl%c3%a9mentation-sp%c3%a9cifique-%c3%a0-chaque-source--------switch-source-------------case-database----------------this-updatedatabaseevent----------------break------------case-cache----------------this-updatecacheevent----------------break------------case-elasticsearch----------------this-updateelasticsearchevent----------------break----------------private-function-shouldinvalidatecachedomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentupdated------------paymentdeleted------------paymentstatuschanged----------------private-function-invalidatecachedomainevent-event-void------------this-logger-debuginvalidating-cache-------------eventtype--event-geteventtype-------------------------invalider-les-caches-pertinents--------if-issetevent-getdatapaymentid-------------this-cachemanager-deletepaymentevent-getdatapaymentid----------------private-function-iscriticaleventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentcreated------------paymentupdated------------paymentdeleted----------------private-function-isreadeventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentviewed------------paymentsearched----------------private-function-issearcheventdomainevent-event-bool------------return-in_arrayevent-geteventtype-------------paymentcreated------------paymentupdated------------paymentdeleted----------------private-function-updatedatabasedomainevent-event-void-------------impl%c3%a9mentation-de-la-mise-%c3%a0-jour-de-la-base-de-donn%c3%a9es--------private-function-updatecachedomainevent-event-void-------------impl%c3%a9mentation-de-la-mise-%c3%a0-jour-du-cache--------private-function-updateelasticsearchdomainevent-event-void-------------impl%c3%a9mentation-de-la-mise-%c3%a0-jour-delasticsearch--------private-function-synchronizereadsources-void-------------impl%c3%a9mentation-de-la-synchronisation-des-sources-de-lecture--------private-function-cleanexpiredcaches-void-------------impl%c3%a9mentation-du-nettoyage-des-caches-expir%c3%a9s------tests-et-validation-tests-dphpphpnamespace-apptestsintegrationmultisourceuse-appworkflowcommandpaymentpaymentcommandrequestuse-appworkflowquerypaymentpaymentsearchqueryuse-appapplicationcommandbusmultisourcemultisourcecommandbususe-appapplicationquerybusmultisourcemultisourcequerybususe-appinfrastructuremultisourcesourcerouterclass-multisourcecqstest-extends-testcase----private-multisourcecommandbus-commandbus----private-multisourcequerybus-querybus----private-sourcerouter-sourcerouter----protected-function-setup-void------------this-sourcerouter--this-createmocksourcerouterclass--------this-commandbus--new-multisourcecommandbus------------this-sourcerouter------------this-createmockloggerinterfaceclass----------------this-querybus--new-multisourcequerybus------------this-sourcerouter------------this-createmockmultisourcecachemanagerclass------------this-createmockloggerinterfaceclass----------------public-function-testcqsseparationwithmultisource-void-------------ex%c3%a9cuter-une-commande-avec-multi-source-cqs--------command--new-paymentcommandrequest------------create------------payment-123------------org-456------------user-789------------10000------------eur------------test-payment------------------------this-commandbus-handlecommand-----------------v%c3%a9rifier-avec-une-requ%c3%aate--------query--new-paymentsearchqueryorg-456-0-10--------result--this-querybus-handlequery----------------this-assertgreaterthan0-result-gettotal--------public-function-testquerycachingwithmultisource-void------------query--new-paymentsearchqueryorg-456-0-10-----------------premi%c3%a8re-recherche--------result1--this-querybus-handlequery-----------------deuxi%c3%a8me-recherche-devrait-utiliser-le-cache--------result2--this-querybus-handlequery----------------this-assertequalsresult1-gettotal-result2-gettotal------performance-et-optimisation-strat%c3%a9gies-d-1-cache-strat%c3%a9gique-multi-sourcesphppublic-function-searchpaymentswithcachepaymentsearchquery-query-paymentsearchresult----cachekey--multi_source_payment_search_--md5serializequery--------if-cached--this-cachemanager-getcachekey---------return-cached------------result--this-searchpaymentswithmultisourcequery----this-cachemanager-setcachekey-result-300--------return-result-2-load-balancing-multi-sourcesphppublic-function-getoptimalsourceforoperationstring-operation-array-criteria---string----sourceloads--this-getsourceloads----optimalsource--array_keyssourceloads-minsourceloads0--------this-logger-debugselected-optimal-source-for-operation---------operation--operation--------source--optimalsource--------loads--sourceloads------------return-optimalsource-3-monitoring-des-sources-multi-sourcesphppublic-function-getmultisourcemetrics-array----return---------commandsources--this-getcommandsourcemetrics--------querysources--this-getquerysourcemetrics--------cachehitrate--this-getcachehitrate--------sourcehealth--this-getsourcehealth--------averageexecutiontime--this-getaverageexecutiontime------crit%c3%a8res-d-quand-utiliser-cqs-avec-multi-sources--avantages--performance-optimis%c3%a9e--s%c3%a9paration-claire-entre-%c3%a9criture-et-lecture--flexibilit%c3%a9-maximale--choix-du-meilleur-stockage-pour-chaque-op%c3%a9ration--scalabilit%c3%a9--possibilit%c3%a9-de-scaler-ind%c3%a9pendamment-chaque-c%c3%b4t%c3%a9--r%c3%a9silience--redondance-et-failover-entre-sources--maintenabilit%c3%a9--code-plus-clair-et-organis%c3%a9--inconv%c3%a9nients--complexit%c3%a9-%c3%a9lev%c3%a9e--gestion-de-plusieurs-sources-de-donn%c3%a9es--coh%c3%a9rence--risque-dincoh%c3%a9rence-entre-sources--maintenance--plus-de-sources-%c3%a0-maintenir--expertise--%c3%a9quipe-exp%c3%a9riment%c3%a9e-requise--crit%c3%a8res-d--syst%c3%a8me-complexe--besoins-de-performance-diff%c3%a9rents-par-type-dop%c3%a9ration--donn%c3%a9es-h%c3%a9t%c3%a9rog%c3%a8nes--types-de-donn%c3%a9es-diff%c3%a9rents-n%c3%a9cessitant-diff%c3%a9rents-stockages--performance-critique--besoins-de-performance-optimale--s%c3%a9paration-des-responsabilit%c3%a9s--besoin-de-s%c3%a9parer-clairement-les-commandes-et-requ%c3%aates--%c3%a9quipe-exp%c3%a9riment%c3%a9e--ma%c3%aetrise-de-plusieurs-technologies-de-stockage-et-cqs--budget-suffisant--investissement-en-infrastructure-multiple--temps-de-d%c3%a9veloppement--suffisant-pour-impl%c3%a9menter-cette-complexit%c3%a9--votre-prochaine-%c3%a9tapehahahugoshortcode59s0hbhbcqs-avec-multi-sources-offre-un-%c3%a9quilibre-optimal-entre-performance-et-flexibilit%c3%a9-parfaitement-adapt%c3%a9-aux-besoins-complexes-de-gyroscops class=anchor aria-hidden=true><i class="material-icons align-middle">link</i></a></h2></div></div><div><hr class=doc-hr><div id=doc-nav class=d-print-none><div class="row flex-xl-nowrap"><div class="col-sm-6 pt-2 doc-next"><a href=/chapitres/stockage/multi-sources/chapitre-52-stockage-multi-sources-classique/><div class="card h-100 my-1"><div class="card-body py-2"><p class="card-title fs-5 fw-semibold lh-base mb-0"><i class="material-icons align-middle">navigate_before</i> Stockage Multi-sources - Approche Classique</p></div></div></a></div><div class="col-sm-6 pt-2 doc-prev"><a class=ms-auto href=/chapitres/stockage/multi-sources/chapitre-54-stockage-multi-sources-cqrs/><div class="card h-100 my-1 text-end"><div class="card-body py-2"><p class="card-title fs-5 fw-semibold lh-base mb-0">Stockage Multi-sources - CQRS <i class="material-icons align-middle">navigate_next</i></p></div></div></a></div></div></div></div></div></div></div></div><footer class="shadow py-3 d-print-none"><div class=container-fluid><div class="row align-items-center"><div class=col><div class="text-sm-start text-center mx-md-2"><p class=mb-0>© 2025 Grégory Planchat. Tous droits réservés.</p></div></div></div><div class="row mt-3 pt-3 border-top"><div class=col-12><div class=text-center><h6 class="text-muted mb-2">Nos Sponsors</h6><p class="text-muted small mb-2">Merci à nos partenaires qui soutiennent cette initiative</p><div class="d-flex justify-content-center align-items-center flex-wrap gap-3"><div class=sponsor-item><a href=https://kiboko.fr target=_blank rel="noopener noreferrer" class="text-decoration-none d-inline-block"><img src=/logo-kiboko-fr.svg alt=Kiboko width=120 height=60 style=display:block;max-width:120px;height:auto></a></div><div class=sponsor-item><a href=https://gyroscops.com target=_blank rel="noopener noreferrer" class="text-decoration-none d-inline-block"><img src=/logo-gyroscops.svg alt=Gyroscops width=120 height=60 style=display:block;max-width:120px;height:auto></a></div></div></div></div></div></div></footer></main></div></div><button onclick=topFunction() id=back-to-top aria-label="Back to Top Button" class="back-to-top fs-5"><svg width="24" height="24"><path d="M12 10.224l-6.3 6.3-1.38-1.372L12 7.472l7.68 7.68-1.38 1.376z" style="fill:#fff"/></svg></button>
<script src=/docs/js/bootstrap.js defer></script><script type=text/javascript src=http://localhost:1313/docs/js/bundle.js defer></script><script type=module>
    var suggestions = document.getElementById('suggestions');
    var search = document.getElementById('flexsearch');

    const flexsearchContainer = document.getElementById('FlexSearchCollapse');

    const hideFlexsearchBtn = document.getElementById('hideFlexsearch');

    const configObject = { toggle: false }
    const flexsearchContainerCollapse = new Collapse(flexsearchContainer, configObject) 

    if (search !== null) {
        document.addEventListener('keydown', inputFocus);
        flexsearchContainer.addEventListener('shown.bs.collapse', function () {
            search.focus();
        });
        
        var topHeader = document.getElementById("top-header");
        document.addEventListener('click', function(elem) {
            if (!flexsearchContainer.contains(elem.target) && !topHeader.contains(elem.target))
                flexsearchContainerCollapse.hide();
        });
    }

    hideFlexsearchBtn.addEventListener('click', () =>{
        flexsearchContainerCollapse.hide()
    })

    function inputFocus(e) {
        if (e.ctrlKey && e.key === '/') {
            e.preventDefault();
            flexsearchContainerCollapse.toggle();
        }
        if (e.key === 'Escape' ) {
            search.blur();
            
            flexsearchContainerCollapse.hide();
        }
    };

    document.addEventListener('click', function(event) {

    var isClickInsideElement = suggestions.contains(event.target);

    if (!isClickInsideElement) {
        suggestions.classList.add('d-none');
    }

    });

    


    document.addEventListener('keydown',suggestionFocus);

    function suggestionFocus(e) {
    const suggestionsHidden = suggestions.classList.contains('d-none');
    if (suggestionsHidden) return;

    const focusableSuggestions= [...suggestions.querySelectorAll('a')];
    if (focusableSuggestions.length === 0) return;

    const index = focusableSuggestions.indexOf(document.activeElement);

    if (e.key === "ArrowUp") {
        e.preventDefault();
        const nextIndex = index > 0 ? index - 1 : 0;
        focusableSuggestions[nextIndex].focus();
    }
    else if (e.key === "ArrowDown") {
        e.preventDefault();
        const nextIndex= index + 1 < focusableSuggestions.length ? index + 1 : index;
        focusableSuggestions[nextIndex].focus();
    }

    }

    


    (function(){

    var index = new FlexSearch.Document({
        
        tokenize: "forward",
        minlength:  0 ,
        cache:  100 ,
        optimize:  true ,
        document: {
        id: 'id',
        store: [
            "href", "title", "description"
        ],
        index: ["title", "description", "content"]
        }
    });


    


    
    


    

    

    search.addEventListener('input', show_results, true);

    function show_results(){
        const maxResult =  5 ;
        const minlength =  0 ;
        var searchQuery = sanitizeHTML(this.value);
        var results = index.search(searchQuery, {limit: maxResult, enrich: true});

        
        const flatResults = new Map(); 
        for (const result of results.flatMap(r => r.result)) {
        if (flatResults.has(result.doc.href)) continue;
        flatResults.set(result.doc.href, result.doc);
        }

        suggestions.innerHTML = "";
        suggestions.classList.remove('d-none');

        
        if (searchQuery.length < minlength) {
            const minCharMessage = document.createElement('div')
            minCharMessage.innerHTML = `Please type at least <strong>${minlength}</strong> characters`
            minCharMessage.classList.add("suggestion__no-results");
            suggestions.appendChild(minCharMessage);
            return;
        } else {
            
            if (flatResults.size === 0 && searchQuery) {
                const noResultsMessage = document.createElement('div')
                noResultsMessage.innerHTML = "No results for" + ` "<strong>${searchQuery}</strong>"`
                noResultsMessage.classList.add("suggestion__no-results");
                suggestions.appendChild(noResultsMessage);
                return;
            }
        }

        
        for(const [href, doc] of flatResults) {
            const entry = document.createElement('div');
            suggestions.appendChild(entry);

            const a = document.createElement('a');
            a.href = href;
            entry.appendChild(a);

            const title = document.createElement('span');
            title.textContent = doc.title;
            title.classList.add("suggestion__title");
            a.appendChild(title);

            const description = document.createElement('span');
            description.textContent = doc.description;
            description.classList.add("suggestion__description");
            a.appendChild(description);

            suggestions.appendChild(entry);

            if(suggestions.childElementCount == maxResult) break;
        }
    }
    }());
</script></body></html>