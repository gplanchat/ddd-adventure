<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Stockage In-Memory on DDD Adventure</title><link>http://localhost:1313/chapitres/stockage/in-memory/</link><description>Recent content in Stockage In-Memory on DDD Adventure</description><generator>Hugo</generator><language>fr-fr</language><lastBuildDate>Thu, 19 Dec 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/chapitres/stockage/in-memory/index.xml" rel="self" type="application/rss+xml"/><item><title>Stockage In-Memory - Approche Classique</title><link>http://localhost:1313/chapitres/stockage/in-memory/chapitre-40-stockage-in-memory-classique/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/in-memory/chapitre-40-stockage-in-memory-classique/</guid><description>&lt;h2 id="-contexte-et-objectifs-pourquoi-in-memory-pour-le-stockage-le-stockage-in-memory-offre-des-performances-exceptionnelles-en-gardant-toutes-les-données-en-ram-éliminant-les-latences-de-disque-et-les-coûts-de-sérialisation-avantages-du-stockage-in-memory--performance-maximale--accès-ultra-rapide-aux-données--simplicité--pas-de-configuration-de-base-de-données--latence-minimale--pas-de-io-disque--développement-rapide--idéal-pour-les-prototypes-et-tests-contexte-gyroscopsdans-notre-écosystème-user--organization--workflow--cloud-resources--billing-le-stockage-in-memory-est-particulièrement-pertinent-pour---cache-haute-performance--mise-en-cache-des-données-fréquemment-accédées--sessions-utilisateur--stockage-temporaire-des-sessions--métriques-en-temps-réel--collecte-et-agrégation-des-métriques--tests-et-développement--environnements-de-test-rapides--architecture-in-memory-classique-structure-des-données-collections-en-mémoirephpphpnamespace-appinfrastructureinmemoryclass-inmemorystorage----private-array-data------private-array-indexes------private-array-locks------public-function-storestring-key-mixed-value-void------------this-datakey--value--------public-function-getstring-key-mixed------------return-this-datakey--null--------public-function-deletestring-key-void------------unsetthis-datakey--------public-function-existsstring-key-bool------------return-array_key_existskey-this-data--------public-function-getall-array------------return-this-data--------public-function-clear-void------------this-data----------this-indexes-------indexation-pour-la-recherchephpphpnamespace-appinfrastructureinmemoryclass-inmemoryindexer----private-array-indexes------public-function-addtoindexstring-indexname-string-key-mixed-value-array-searchfields-void------------if-issetthis-indexesindexname-------------this-indexesindexname------------------foreach-searchfields-as-field-------------fieldvalue--this-getfieldvaluevalue-field------------if-fieldvalue--null-----------------this-indexesindexnamefieldfieldvalue--key----------------------------public-function-searchstring-indexname-string-field-mixed-value-array------------return-this-indexesindexnamefieldvalue----------public-function-removefromindexstring-indexname-string-key-void------------if-issetthis-indexesindexname-------------return----------------foreach-this-indexesindexname-as-field--values-------------foreach-values-as-fieldvalue--keys-----------------this-indexesindexnamefieldfieldvalue--array_filter--------------------keys--------------------fnk--k--key--------------------------------------------private-function-getfieldvaluemixed-value-string-field-mixed------------if-is_arrayvalue-------------return-valuefield--null----------------if-is_objectvalue-------------return-value-field--null----------------return-null-----flux-de-donnéesmermaidgraph-td----acommand----bcommand-handler----b----cin-memory-storage----c----ddata-in-ram----d----eindex-update--------fquery----gquery-handler----g----hin-memory-search----h----c----c----isearch-results----i----jresponse--------kcache----lcache-manager----l----c----c----mcached-data----m----nfast-response--implémentation-pratique-1-repository-in-memory-repository-de-basephpphpnamespace-appinfrastructureinmemoryrepositoryuse-appdomainpaymentpaymentuse-appdomainpaymentpaymentrepositoryinterfaceuse-appinfrastructureinmemoryinmemorystorageuse-appinfrastructureinmemoryinmemoryindexerclass-inmemorypaymentrepository-implements-paymentrepositoryinterface----private-inmemorystorage-storage----private-inmemoryindexer-indexer----private-string-entitytype----public-function-__constructinmemorystorage-storage-inmemoryindexer-indexer------------this-storage--storage--------this-indexer--indexer--------this-entitytype--payment--------public-function-savepayment-payment-void------------key--this-generatekeypayment-getid-----------------sauvegarder-lentité--------this-storage-storekey-payment-----------------mettre-à-jour-les-index--------this-indexer-addtoindex------------this-entitytype------------key------------payment------------organizationid-userid-status-currency----------------public-function-findbyidstring-id-payment------------key--this-generatekeyid--------data--this-storage-getkey----------------return-data-instanceof-payment--data--null--------public-function-findbyorganizationstring-organizationid-array------------keys--this-indexer-searchthis-entitytype-organizationid-organizationid----------------payments----------foreach-keys-as-key-------------payment--this-storage-getkey------------if-payment-instanceof-payment-----------------payments--payment------------------------------------return-payments--------public-function-findbyuserstring-userid-array------------keys--this-indexer-searchthis-entitytype-userid-userid----------------payments----------foreach-keys-as-key-------------payment--this-storage-getkey------------if-payment-instanceof-payment-----------------payments--payment------------------------------------return-payments--------public-function-findbystatusstring-status-array------------keys--this-indexer-searchthis-entitytype-status-status----------------payments----------foreach-keys-as-key-------------payment--this-storage-getkey------------if-payment-instanceof-payment-----------------payments--payment------------------------------------return-payments--------public-function-findbycurrencystring-currency-array------------keys--this-indexer-searchthis-entitytype-currency-currency----------------payments----------foreach-keys-as-key-------------payment--this-storage-getkey------------if-payment-instanceof-payment-----------------payments--payment------------------------------------return-payments--------public-function-findall-array------------alldata--this-storage-getall----------------payments----------foreach-alldata-as-key--value-------------if-str_starts_withkey-payment--value-instanceof-payment-----------------payments--value------------------------------------return-payments--------public-function-deletestring-id-void------------key--this-generatekeyid-----------------supprimer-des-index--------this-indexer-removefromindexthis-entitytype-key-----------------supprimer-de-la-storage--------this-storage-deletekey--------public-function-count-int------------alldata--this-storage-getall--------count--0----------------foreach-alldata-as-key--value-------------if-str_starts_withkey-payment--value-instanceof-payment-----------------count------------------------------------return-count--------private-function-generatekeystring-id-string------------return-paymentid-----2-service-de-cache-cache-managerphpphpnamespace-appinfrastructureinmemorycacheuse-appinfrastructureinmemoryinmemorystorageuse-psrlogloggerinterfaceclass-cachemanager----private-inmemorystorage-storage----private-loggerinterface-logger----private-array-ttl------private-array-accesscount------private-int-maxsize----public-function-__constructinmemorystorage-storage-loggerinterface-logger-int-maxsize--10000------------this-storage--storage--------this-logger--logger--------this-maxsize--maxsize--------public-function-getstring-key-mixed------------if-this-storage-existskey-------------return-null-----------------vérifier-le-ttl--------if-issetthis-ttlkey--this-ttlkey--time-------------this-deletekey------------return-null-----------------incrémenter-le-compteur-daccès--------this-accesscountkey--this-accesscountkey--0--1--------this-logger-debugcache-hit-key--key--------return-this-storage-getkey--------public-function-setstring-key-mixed-value-int-ttl--3600-void-------------vérifier-la-taille-maximale--------if-this-storage-count--this-maxsize-------------this-evictleastused----------------this-storage-storekey-value--------this-ttlkey--time--ttl--------this-accesscountkey--0--------this-logger-debugcache-set-key--key-ttl--ttl--------public-function-deletestring-key-void------------this-storage-deletekey--------unsetthis-ttlkey--------unsetthis-accesscountkey--------this-logger-debugcache-delete-key--key--------public-function-clear-void------------this-storage-clear--------this-ttl----------this-accesscount----------this-logger-infocache-cleared--------public-function-existsstring-key-bool------------if-this-storage-existskey-------------return-false-----------------vérifier-le-ttl--------if-issetthis-ttlkey--this-ttlkey--time-------------this-deletekey------------return-false----------------return-true--------public-function-getstats-array------------return-------------size--this-storage-count------------maxsize--this-maxsize------------hitrate--this-calculatehitrate------------memoryusage--memory_get_usagetrue------------peakmemoryusage--memory_get_peak_usagetrue----------------private-function-evictleastused-void------------if-emptythis-accesscount-------------return-----------------trouver-la-clé-la-moins-utilisée--------leastusedkey--array_searchminthis-accesscount-this-accesscount----------------if-leastusedkey--false-------------this-deleteleastusedkey------------this-logger-debugcache-evicted-key--leastusedkey----------------private-function-calculatehitrate-float------------totalaccess--array_sumthis-accesscount--------totalkeys--countthis-accesscount----------------if-totalkeys--0-------------return-00----------------return-totalaccess--totalkeys-----3-service-de-recherche-search-servicephpphpnamespace-appinfrastructureinmemorysearchuse-appinfrastructureinmemoryinmemorystorageuse-appinfrastructureinmemoryinmemoryindexerclass-searchservice----private-inmemorystorage-storage----private-inmemoryindexer-indexer----public-function-__constructinmemorystorage-storage-inmemoryindexer-indexer------------this-storage--storage--------this-indexer--indexer--------public-function-searchstring-entitytype-array-criteria-array------------results----------alldata--this-storage-getall--------foreach-alldata-as-key--value-------------if-this-isentitytypekey-entitytype-----------------continue------------------------if-this-matchescriteriavalue-criteria-----------------results--value----------------------------return-results--------public-function-searchbyfieldstring-entitytype-string-field-mixed-value-array------------keys--this-indexer-searchentitytype-field-value----------------results----------foreach-keys-as-key-------------data--this-storage-getkey------------if-data--null-----------------results--data------------------------------------return-results--------public-function-searchbymultiplefieldsstring-entitytype-array-criteria-array------------results----------alldata--this-storage-getall--------foreach-alldata-as-key--value-------------if-this-isentitytypekey-entitytype-----------------continue------------------------matches--true------------foreach-criteria-as-field--expectedvalue-----------------if-this-fieldmatchesvalue-field-expectedvalue---------------------matches--false--------------------break----------------------------------------if-matches-----------------results--value----------------------------return-results--------public-function-searchbyrangestring-entitytype-string-field-mixed-min-mixed-max-array------------results----------alldata--this-storage-getall--------foreach-alldata-as-key--value-------------if-this-isentitytypekey-entitytype-----------------continue------------------------fieldvalue--this-getfieldvaluevalue-field------------if-fieldvalue--null--fieldvalue--min--fieldvalue--max-----------------results--value----------------------------return-results--------public-function-searchbytextstring-entitytype-string-field-string-text-array------------results----------alldata--this-storage-getall--------foreach-alldata-as-key--value-------------if-this-isentitytypekey-entitytype-----------------continue------------------------fieldvalue--this-getfieldvaluevalue-field------------if-fieldvalue--null--striposfieldvalue-text--false-----------------results--value----------------------------return-results--------private-function-isentitytypestring-key-string-entitytype-bool------------return-str_starts_withkey-entitytype--------private-function-matchescriteriamixed-value-array-criteria-bool------------foreach-criteria-as-field--expectedvalue-------------if-this-fieldmatchesvalue-field-expectedvalue-----------------return-false----------------------------return-true--------private-function-fieldmatchesmixed-value-string-field-mixed-expectedvalue-bool------------fieldvalue--this-getfieldvaluevalue-field----------------if-is_arrayexpectedvalue-------------return-in_arrayfieldvalue-expectedvalue----------------return-fieldvalue--expectedvalue--------private-function-getfieldvaluemixed-value-string-field-mixed------------if-is_arrayvalue-------------return-valuefield--null----------------if-is_objectvalue-------------return-value-field--null----------------return-null------tests-et-validation-tests-dphpphpnamespace-apptestsintegrationinmemoryuse-appdomainpaymentpaymentuse-appinfrastructureinmemoryrepositoryinmemorypaymentrepositoryuse-appinfrastructureinmemoryinmemorystorageuse-appinfrastructureinmemoryinmemoryindexerclass-inmemorypaymentrepositorytest-extends-testcase----private-inmemorypaymentrepository-repository----private-inmemorystorage-storage----private-inmemoryindexer-indexer----protected-function-setup-void------------this-storage--new-inmemorystorage--------this-indexer--new-inmemoryindexer--------this-repository--new-inmemorypaymentrepositorythis-storage-this-indexer--------public-function-testsaveandfindpayment-void------------payment--new-payment------------payment-123------------org-456------------user-789------------10000------------eur------------completed------------test-payment------------new-datetime----------------this-repository-savepayment--------found--this-repository-findbyidpayment-123--------this-assertnotnullfound--------this-assertequalspayment-getid-found-getid--------this-assertequalspayment-getamount-found-getamount--------public-function-testfindbyorganization-void------------payments--------------new-paymentpayment-1-org-456-user-1-10000-eur-completed-payment-1-new-datetime------------new-paymentpayment-2-org-456-user-2-20000-usd-completed-payment-2-new-datetime------------new-paymentpayment-3-org-789-user-3-30000-eur-completed-payment-3-new-datetime----------------foreach-payments-as-payment-------------this-repository-savepayment----------------orgpayments--this-repository-findbyorganizationorg-456--------this-assertcount2-orgpayments--------public-function-testfindbystatus-void------------payments--------------new-paymentpayment-1-org-456-user-1-10000-eur-completed-payment-1-new-datetime------------new-paymentpayment-2-org-456-user-2-20000-usd-pending-payment-2-new-datetime------------new-paymentpayment-3-org-789-user-3-30000-eur-completed-payment-3-new-datetime----------------foreach-payments-as-payment-------------this-repository-savepayment----------------completedpayments--this-repository-findbystatuscompleted--------this-assertcount2-completedpayments--------public-function-testdeletepayment-void------------payment--new-payment------------payment-123------------org-456------------user-789------------10000------------eur------------completed------------test-payment------------new-datetime----------------this-repository-savepayment--------this-assertnotnullthis-repository-findbyidpayment-123--------this-repository-deletepayment-123--------this-assertnullthis-repository-findbyidpayment-123------performance-et-optimisation-stratégies-d-1-gestion-de-la-mémoirephppublic-function-optimizememory-void-----nettoyer-les-données-expirées----this-cleanexpireddata---------compacter-les-index----this-compactindexes---------forcer-le-garbage-collection----gc_collect_cycles-2-cache-lru-least-recently-usedphppublic-function-evictleastrecentlyused-void----sortedbyaccess--this-accesscount----asortsortedbyaccess--------keystoevict--array_slicearray_keyssortedbyaccess-0-this-evictioncount--------foreach-keystoevict-as-key---------this-deletekey-----3-compression-des-donnéesphppublic-function-compressdatamixed-data-string----return-gzcompressserializedata-9public-function-decompressdatastring-compresseddata-mixed----return-unserializegzuncompresscompresseddata--critères-d-quand-utiliser-in-memory-classique--avantages--performance-maximale--accès-ultra-rapide-aux-données--simplicité--pas-de-configuration-de-base-de-données--latence-minimale--pas-de-io-disque--développement-rapide--idéal-pour-les-prototypes-et-tests--inconvénients--volatilité--données-perdues-au-redémarrage--limitation-mémoire--contraint-par-la-ram-disponible--pas-de-persistance--données-temporaires-uniquement--pas-de-partage--données-limitées-à-un-processus--critères-d--performance-critique--besoins-de-performance-maximale--données-temporaires--cache-sessions-métriques--tests-et-développement--environnements-de-test-rapides--prototypes--développement-rapide-et-itératif--données-volatiles--pas-de-besoin-de-persistance--mémoire-suffisante--ram-disponible-pour-toutes-les-données--votre-prochaine-étapehahahugoshortcode30s0hbhbin-memory-classique-offre-des-performances-exceptionnelles-pour-les-données-temporaires-et-les-caches-parfaitement-adapté-aux-besoins-de-performance-de-gyroscops"&gt;🎯 &lt;strong&gt;Contexte et Objectifs&lt;/strong&gt;### **Pourquoi In-Memory pour le Stockage ?**Le stockage In-Memory offre des performances exceptionnelles en gardant toutes les données en RAM, éliminant les latences de disque et les coûts de sérialisation.#### &lt;strong&gt;Avantages du Stockage In-Memory&lt;/strong&gt;- &lt;strong&gt;Performance maximale&lt;/strong&gt; : Accès ultra-rapide aux données- &lt;strong&gt;Simplicité&lt;/strong&gt; : Pas de configuration de base de données- &lt;strong&gt;Latence minimale&lt;/strong&gt; : Pas de I/O disque- &lt;strong&gt;Développement rapide&lt;/strong&gt; : Idéal pour les prototypes et tests### &lt;strong&gt;Contexte Gyroscops&lt;/strong&gt;Dans notre écosystème &lt;strong&gt;User → Organization → Workflow → Cloud Resources → Billing&lt;/strong&gt;, le stockage In-Memory est particulièrement pertinent pour :- &lt;strong&gt;Cache haute performance&lt;/strong&gt; : Mise en cache des données fréquemment accédées- &lt;strong&gt;Sessions utilisateur&lt;/strong&gt; : Stockage temporaire des sessions- &lt;strong&gt;Métriques en temps réel&lt;/strong&gt; : Collecte et agrégation des métriques- &lt;strong&gt;Tests et développement&lt;/strong&gt; : Environnements de test rapides## 🏗️ &lt;strong&gt;Architecture In-Memory Classique&lt;/strong&gt;### &lt;strong&gt;Structure des Données&lt;/strong&gt;#### &lt;strong&gt;Collections en Mémoire&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Infrastructure\InMemory;class InMemoryStorage{ private array $data = []; private array $indexes = []; private array $locks = []; public function store(string $key, mixed $value): void { $this-&amp;gt;data[$key] = $value; } public function get(string $key): mixed { return $this-&amp;gt;data[$key] ?? null; } public function delete(string $key): void { unset($this-&amp;gt;data[$key]); } public function exists(string $key): bool { return array_key_exists($key, $this-&amp;gt;data); } public function getAll(): array { return $this-&amp;gt;data; } public function clear(): void { $this-&amp;gt;data = []; $this-&amp;gt;indexes = []; }}&lt;/code&gt;#### &lt;strong&gt;Indexation pour la Recherche&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Infrastructure\InMemory;class InMemoryIndexer{ private array $indexes = []; public function addToIndex(string $indexName, string $key, mixed $value, array $searchFields): void { if (!isset($this-&amp;gt;indexes[$indexName])) { $this-&amp;gt;indexes[$indexName] = []; } foreach ($searchFields as $field) { $fieldValue = $this-&amp;gt;getFieldValue($value, $field); if ($fieldValue !== null) { $this-&amp;gt;indexes[$indexName][$field][$fieldValue][] = $key; } } } public function search(string $indexName, string $field, mixed $value): array { return $this-&amp;gt;indexes[$indexName][$field][$value] ?? []; } public function removeFromIndex(string $indexName, string $key): void { if (!isset($this-&amp;gt;indexes[$indexName])) { return; } foreach ($this-&amp;gt;indexes[$indexName] as $field =&amp;gt; $values) { foreach ($values as $fieldValue =&amp;gt; $keys) { $this-&amp;gt;indexes[$indexName][$field][$fieldValue] = array_filter( $keys, fn($k) =&amp;gt; $k !== $key ); } } } private function getFieldValue(mixed $value, string $field): mixed { if (is_array($value)) { return $value[$field] ?? null; } if (is_object($value)) { return $value-&amp;gt;$field ?? null; } return null; }}&lt;/code&gt;### &lt;strong&gt;Flux de Données&lt;/strong&gt;&lt;code&gt;mermaidgraph TD A[Command] --&amp;gt; B[Command Handler] B --&amp;gt; C[In-Memory Storage] C --&amp;gt; D[Data in RAM] D --&amp;gt; E[Index Update] F[Query] --&amp;gt; G[Query Handler] G --&amp;gt; H[In-Memory Search] H --&amp;gt; C C --&amp;gt; I[Search Results] I --&amp;gt; J[Response] K[Cache] --&amp;gt; L[Cache Manager] L --&amp;gt; C C --&amp;gt; M[Cached Data] M --&amp;gt; N[Fast Response]&lt;/code&gt;## 💻 &lt;strong&gt;Implémentation Pratique&lt;/strong&gt;### &lt;strong&gt;1. Repository In-Memory&lt;/strong&gt;#### &lt;strong&gt;Repository de Base&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Infrastructure\InMemory\Repository;use App\Domain\Payment\Payment;use App\Domain\Payment\PaymentRepositoryInterface;use App\Infrastructure\InMemory\InMemoryStorage;use App\Infrastructure\InMemory\InMemoryIndexer;class InMemoryPaymentRepository implements PaymentRepositoryInterface{ private InMemoryStorage $storage; private InMemoryIndexer $indexer; private string $entityType; public function __construct(InMemoryStorage $storage, InMemoryIndexer $indexer) { $this-&amp;gt;storage = $storage; $this-&amp;gt;indexer = $indexer; $this-&amp;gt;entityType = 'Payment'; } public function save(Payment $payment): void { $key = $this-&amp;gt;generateKey($payment-&amp;gt;getId()); // Sauvegarder l'entité $this-&amp;gt;storage-&amp;gt;store($key, $payment); // Mettre à jour les index $this-&amp;gt;indexer-&amp;gt;addToIndex( $this-&amp;gt;entityType, $key, $payment, ['organizationId', 'userId', 'status', 'currency'] ); } public function findById(string $id): ?Payment { $key = $this-&amp;gt;generateKey($id); $data = $this-&amp;gt;storage-&amp;gt;get($key); return $data instanceof Payment ? $data : null; } public function findByOrganization(string $organizationId): array { $keys = $this-&amp;gt;indexer-&amp;gt;search($this-&amp;gt;entityType, 'organizationId', $organizationId); $payments = []; foreach ($keys as $key) { $payment = $this-&amp;gt;storage-&amp;gt;get($key); if ($payment instanceof Payment) { $payments[] = $payment; } } return $payments; } public function findByUser(string $userId): array { $keys = $this-&amp;gt;indexer-&amp;gt;search($this-&amp;gt;entityType, 'userId', $userId); $payments = []; foreach ($keys as $key) { $payment = $this-&amp;gt;storage-&amp;gt;get($key); if ($payment instanceof Payment) { $payments[] = $payment; } } return $payments; } public function findByStatus(string $status): array { $keys = $this-&amp;gt;indexer-&amp;gt;search($this-&amp;gt;entityType, 'status', $status); $payments = []; foreach ($keys as $key) { $payment = $this-&amp;gt;storage-&amp;gt;get($key); if ($payment instanceof Payment) { $payments[] = $payment; } } return $payments; } public function findByCurrency(string $currency): array { $keys = $this-&amp;gt;indexer-&amp;gt;search($this-&amp;gt;entityType, 'currency', $currency); $payments = []; foreach ($keys as $key) { $payment = $this-&amp;gt;storage-&amp;gt;get($key); if ($payment instanceof Payment) { $payments[] = $payment; } } return $payments; } public function findAll(): array { $allData = $this-&amp;gt;storage-&amp;gt;getAll(); $payments = []; foreach ($allData as $key =&amp;gt; $value) { if (str_starts_with($key, 'Payment:') &amp;amp;&amp;amp; $value instanceof Payment) { $payments[] = $value; } } return $payments; } public function delete(string $id): void { $key = $this-&amp;gt;generateKey($id); // Supprimer des index $this-&amp;gt;indexer-&amp;gt;removeFromIndex($this-&amp;gt;entityType, $key); // Supprimer de la storage $this-&amp;gt;storage-&amp;gt;delete($key); } public function count(): int { $allData = $this-&amp;gt;storage-&amp;gt;getAll(); $count = 0; foreach ($allData as $key =&amp;gt; $value) { if (str_starts_with($key, 'Payment:') &amp;amp;&amp;amp; $value instanceof Payment) { $count++; } } return $count; } private function generateKey(string $id): string { return &amp;quot;Payment:{$id}&amp;quot;; }}&lt;/code&gt;### &lt;strong&gt;2. Service de Cache&lt;/strong&gt;#### &lt;strong&gt;Cache Manager&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Infrastructure\InMemory\Cache;use App\Infrastructure\InMemory\InMemoryStorage;use Psr\Log\LoggerInterface;class CacheManager{ private InMemoryStorage $storage; private LoggerInterface $logger; private array $ttl = []; private array $accessCount = []; private int $maxSize; public function __construct(InMemoryStorage $storage, LoggerInterface $logger, int $maxSize = 10000) { $this-&amp;gt;storage = $storage; $this-&amp;gt;logger = $logger; $this-&amp;gt;maxSize = $maxSize; } public function get(string $key): mixed { if (!$this-&amp;gt;storage-&amp;gt;exists($key)) { return null; } // Vérifier le TTL if (isset($this-&amp;gt;ttl[$key]) &amp;amp;&amp;amp; $this-&amp;gt;ttl[$key] &amp;lt; time()) { $this-&amp;gt;delete($key); return null; } // Incrémenter le compteur d'accès $this-&amp;gt;accessCount[$key] = ($this-&amp;gt;accessCount[$key] ?? 0) + 1; $this-&amp;gt;logger-&amp;gt;debug('Cache hit', ['key' =&amp;gt; $key]); return $this-&amp;gt;storage-&amp;gt;get($key); } public function set(string $key, mixed $value, int $ttl = 3600): void { // Vérifier la taille maximale if ($this-&amp;gt;storage-&amp;gt;count() &amp;gt;= $this-&amp;gt;maxSize) { $this-&amp;gt;evictLeastUsed(); } $this-&amp;gt;storage-&amp;gt;store($key, $value); $this-&amp;gt;ttl[$key] = time() + $ttl; $this-&amp;gt;accessCount[$key] = 0; $this-&amp;gt;logger-&amp;gt;debug('Cache set', ['key' =&amp;gt; $key, 'ttl' =&amp;gt; $ttl]); } public function delete(string $key): void { $this-&amp;gt;storage-&amp;gt;delete($key); unset($this-&amp;gt;ttl[$key]); unset($this-&amp;gt;accessCount[$key]); $this-&amp;gt;logger-&amp;gt;debug('Cache delete', ['key' =&amp;gt; $key]); } public function clear(): void { $this-&amp;gt;storage-&amp;gt;clear(); $this-&amp;gt;ttl = []; $this-&amp;gt;accessCount = []; $this-&amp;gt;logger-&amp;gt;info('Cache cleared'); } public function exists(string $key): bool { if (!$this-&amp;gt;storage-&amp;gt;exists($key)) { return false; } // Vérifier le TTL if (isset($this-&amp;gt;ttl[$key]) &amp;amp;&amp;amp; $this-&amp;gt;ttl[$key] &amp;lt; time()) { $this-&amp;gt;delete($key); return false; } return true; } public function getStats(): array { return [ 'size' =&amp;gt; $this-&amp;gt;storage-&amp;gt;count(), 'maxSize' =&amp;gt; $this-&amp;gt;maxSize, 'hitRate' =&amp;gt; $this-&amp;gt;calculateHitRate(), 'memoryUsage' =&amp;gt; memory_get_usage(true), 'peakMemoryUsage' =&amp;gt; memory_get_peak_usage(true) ]; } private function evictLeastUsed(): void { if (empty($this-&amp;gt;accessCount)) { return; } // Trouver la clé la moins utilisée $leastUsedKey = array_search(min($this-&amp;gt;accessCount), $this-&amp;gt;accessCount); if ($leastUsedKey !== false) { $this-&amp;gt;delete($leastUsedKey); $this-&amp;gt;logger-&amp;gt;debug('Cache evicted', ['key' =&amp;gt; $leastUsedKey]); } } private function calculateHitRate(): float { $totalAccess = array_sum($this-&amp;gt;accessCount); $totalKeys = count($this-&amp;gt;accessCount); if ($totalKeys === 0) { return 0.0; } return $totalAccess / $totalKeys; }}&lt;/code&gt;### &lt;strong&gt;3. Service de Recherche&lt;/strong&gt;#### &lt;strong&gt;Search Service&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Infrastructure\InMemory\Search;use App\Infrastructure\InMemory\InMemoryStorage;use App\Infrastructure\InMemory\InMemoryIndexer;class SearchService{ private InMemoryStorage $storage; private InMemoryIndexer $indexer; public function __construct(InMemoryStorage $storage, InMemoryIndexer $indexer) { $this-&amp;gt;storage = $storage; $this-&amp;gt;indexer = $indexer; } public function search(string $entityType, array $criteria): array { $results = []; $allData = $this-&amp;gt;storage-&amp;gt;getAll(); foreach ($allData as $key =&amp;gt; $value) { if (!$this-&amp;gt;isEntityType($key, $entityType)) { continue; } if ($this-&amp;gt;matchesCriteria($value, $criteria)) { $results[] = $value; } } return $results; } public function searchByField(string $entityType, string $field, mixed $value): array { $keys = $this-&amp;gt;indexer-&amp;gt;search($entityType, $field, $value); $results = []; foreach ($keys as $key) { $data = $this-&amp;gt;storage-&amp;gt;get($key); if ($data !== null) { $results[] = $data; } } return $results; } public function searchByMultipleFields(string $entityType, array $criteria): array { $results = []; $allData = $this-&amp;gt;storage-&amp;gt;getAll(); foreach ($allData as $key =&amp;gt; $value) { if (!$this-&amp;gt;isEntityType($key, $entityType)) { continue; } $matches = true; foreach ($criteria as $field =&amp;gt; $expectedValue) { if (!$this-&amp;gt;fieldMatches($value, $field, $expectedValue)) { $matches = false; break; } } if ($matches) { $results[] = $value; } } return $results; } public function searchByRange(string $entityType, string $field, mixed $min, mixed $max): array { $results = []; $allData = $this-&amp;gt;storage-&amp;gt;getAll(); foreach ($allData as $key =&amp;gt; $value) { if (!$this-&amp;gt;isEntityType($key, $entityType)) { continue; } $fieldValue = $this-&amp;gt;getFieldValue($value, $field); if ($fieldValue !== null &amp;amp;&amp;amp; $fieldValue &amp;gt;= $min &amp;amp;&amp;amp; $fieldValue &amp;lt;= $max) { $results[] = $value; } } return $results; } public function searchByText(string $entityType, string $field, string $text): array { $results = []; $allData = $this-&amp;gt;storage-&amp;gt;getAll(); foreach ($allData as $key =&amp;gt; $value) { if (!$this-&amp;gt;isEntityType($key, $entityType)) { continue; } $fieldValue = $this-&amp;gt;getFieldValue($value, $field); if ($fieldValue !== null &amp;amp;&amp;amp; stripos($fieldValue, $text) !== false) { $results[] = $value; } } return $results; } private function isEntityType(string $key, string $entityType): bool { return str_starts_with($key, &amp;quot;{$entityType}:&amp;quot;); } private function matchesCriteria(mixed $value, array $criteria): bool { foreach ($criteria as $field =&amp;gt; $expectedValue) { if (!$this-&amp;gt;fieldMatches($value, $field, $expectedValue)) { return false; } } return true; } private function fieldMatches(mixed $value, string $field, mixed $expectedValue): bool { $fieldValue = $this-&amp;gt;getFieldValue($value, $field); if (is_array($expectedValue)) { return in_array($fieldValue, $expectedValue); } return $fieldValue === $expectedValue; } private function getFieldValue(mixed $value, string $field): mixed { if (is_array($value)) { return $value[$field] ?? null; } if (is_object($value)) { return $value-&amp;gt;$field ?? null; } return null; }}&lt;/code&gt;## 🧪 &lt;strong&gt;Tests et Validation&lt;/strong&gt;### &lt;strong&gt;Tests d&amp;rsquo;Intégration In-Memory&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Tests\Integration\InMemory;use App\Domain\Payment\Payment;use App\Infrastructure\InMemory\Repository\InMemoryPaymentRepository;use App\Infrastructure\InMemory\InMemoryStorage;use App\Infrastructure\InMemory\InMemoryIndexer;class InMemoryPaymentRepositoryTest extends TestCase{ private InMemoryPaymentRepository $repository; private InMemoryStorage $storage; private InMemoryIndexer $indexer; protected function setUp(): void { $this-&amp;gt;storage = new InMemoryStorage(); $this-&amp;gt;indexer = new InMemoryIndexer(); $this-&amp;gt;repository = new InMemoryPaymentRepository($this-&amp;gt;storage, $this-&amp;gt;indexer); } public function testSaveAndFindPayment(): void { $payment = new Payment( 'payment-123', 'org-456', 'user-789', 100.00, 'EUR', 'completed', 'Test payment', new \DateTime() ); $this-&amp;gt;repository-&amp;gt;save($payment); $found = $this-&amp;gt;repository-&amp;gt;findById('payment-123'); $this-&amp;gt;assertNotNull($found); $this-&amp;gt;assertEquals($payment-&amp;gt;getId(), $found-&amp;gt;getId()); $this-&amp;gt;assertEquals($payment-&amp;gt;getAmount(), $found-&amp;gt;getAmount()); } public function testFindByOrganization(): void { $payments = [ new Payment('payment-1', 'org-456', 'user-1', 100.00, 'EUR', 'completed', 'Payment 1', new \DateTime()), new Payment('payment-2', 'org-456', 'user-2', 200.00, 'USD', 'completed', 'Payment 2', new \DateTime()), new Payment('payment-3', 'org-789', 'user-3', 300.00, 'EUR', 'completed', 'Payment 3', new \DateTime()) ]; foreach ($payments as $payment) { $this-&amp;gt;repository-&amp;gt;save($payment); } $orgPayments = $this-&amp;gt;repository-&amp;gt;findByOrganization('org-456'); $this-&amp;gt;assertCount(2, $orgPayments); } public function testFindByStatus(): void { $payments = [ new Payment('payment-1', 'org-456', 'user-1', 100.00, 'EUR', 'completed', 'Payment 1', new \DateTime()), new Payment('payment-2', 'org-456', 'user-2', 200.00, 'USD', 'pending', 'Payment 2', new \DateTime()), new Payment('payment-3', 'org-789', 'user-3', 300.00, 'EUR', 'completed', 'Payment 3', new \DateTime()) ]; foreach ($payments as $payment) { $this-&amp;gt;repository-&amp;gt;save($payment); } $completedPayments = $this-&amp;gt;repository-&amp;gt;findByStatus('completed'); $this-&amp;gt;assertCount(2, $completedPayments); } public function testDeletePayment(): void { $payment = new Payment( 'payment-123', 'org-456', 'user-789', 100.00, 'EUR', 'completed', 'Test payment', new \DateTime() ); $this-&amp;gt;repository-&amp;gt;save($payment); $this-&amp;gt;assertNotNull($this-&amp;gt;repository-&amp;gt;findById('payment-123')); $this-&amp;gt;repository-&amp;gt;delete('payment-123'); $this-&amp;gt;assertNull($this-&amp;gt;repository-&amp;gt;findById('payment-123')); }}&lt;/code&gt;## 📊 &lt;strong&gt;Performance et Optimisation&lt;/strong&gt;### &lt;strong&gt;Stratégies d&amp;rsquo;Optimisation In-Memory&lt;/strong&gt;#### &lt;strong&gt;1. Gestion de la Mémoire&lt;/strong&gt;&lt;code&gt;phppublic function optimizeMemory(): void{ // Nettoyer les données expirées $this-&amp;gt;cleanExpiredData(); // Compacter les index $this-&amp;gt;compactIndexes(); // Forcer le garbage collection gc_collect_cycles();}&lt;/code&gt;#### &lt;strong&gt;2. Cache LRU (Least Recently Used)&lt;/strong&gt;&lt;code&gt;phppublic function evictLeastRecentlyUsed(): void{ $sortedByAccess = $this-&amp;gt;accessCount; asort($sortedByAccess); $keysToEvict = array_slice(array_keys($sortedByAccess), 0, $this-&amp;gt;evictionCount); foreach ($keysToEvict as $key) { $this-&amp;gt;delete($key); }}&lt;/code&gt;#### &lt;strong&gt;3. Compression des Données&lt;/strong&gt;&lt;code&gt;phppublic function compressData(mixed $data): string{ return gzcompress(serialize($data), 9);}public function decompressData(string $compressedData): mixed{ return unserialize(gzuncompress($compressedData));}&lt;/code&gt;## 🎯 &lt;strong&gt;Critères d&amp;rsquo;Adoption&lt;/strong&gt;### &lt;strong&gt;Quand Utiliser In-Memory Classique&lt;/strong&gt;#### &lt;strong&gt;✅ Avantages&lt;/strong&gt;- &lt;strong&gt;Performance maximale&lt;/strong&gt; : Accès ultra-rapide aux données- &lt;strong&gt;Simplicité&lt;/strong&gt; : Pas de configuration de base de données- &lt;strong&gt;Latence minimale&lt;/strong&gt; : Pas de I/O disque- &lt;strong&gt;Développement rapide&lt;/strong&gt; : Idéal pour les prototypes et tests#### &lt;strong&gt;❌ Inconvénients&lt;/strong&gt;- &lt;strong&gt;Volatilité&lt;/strong&gt; : Données perdues au redémarrage- &lt;strong&gt;Limitation mémoire&lt;/strong&gt; : Contraint par la RAM disponible- &lt;strong&gt;Pas de persistance&lt;/strong&gt; : Données temporaires uniquement- &lt;strong&gt;Pas de partage&lt;/strong&gt; : Données limitées à un processus#### &lt;strong&gt;🎯 Critères d&amp;rsquo;Adoption&lt;/strong&gt;- &lt;strong&gt;Performance critique&lt;/strong&gt; : Besoins de performance maximale- &lt;strong&gt;Données temporaires&lt;/strong&gt; : Cache, sessions, métriques- &lt;strong&gt;Tests et développement&lt;/strong&gt; : Environnements de test rapides- &lt;strong&gt;Prototypes&lt;/strong&gt; : Développement rapide et itératif- &lt;strong&gt;Données volatiles&lt;/strong&gt; : Pas de besoin de persistance- &lt;strong&gt;Mémoire suffisante&lt;/strong&gt; : RAM disponible pour toutes les données## 🚀 &lt;strong&gt;Votre Prochaine Étape&lt;/strong&gt;

&lt;div class="chapter-navigation"&gt;
 &lt;h2 class="chapter-nav-title"&gt;🎯 Votre Prochaine Étape&lt;/h2&gt;
 &lt;p class="chapter-nav-subtitle"&gt;Maintenant que vous comprenez les concepts de base et que j'ai partagé mon expérience avec Gyroscops, quel est votre contexte ?&lt;/p&gt;</description></item><item><title>Stockage In-Memory - CQS</title><link>http://localhost:1313/chapitres/stockage/in-memory/chapitre-41-stockage-in-memory-cqs/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/in-memory/chapitre-41-stockage-in-memory-cqs/</guid><description>&lt;h2 id="-contexte-et-objectifs-pourquoi-cqs-avec-in-memory-la-combinaison-cqs-avec-in-memory-offre-une-architecture-optimisée-qui-sépare-clairement-les-responsabilités-tout-en-conservant-les-performances-exceptionnelles-du-stockage-en-mémoire-avantages-de-cqs-avec-in-memory--performance-optimisée--séparation-claire-entre-écriture-et-lecture--scalabilité--possibilité-de-scaler-indépendamment-les-commandes-et-requêtes--flexibilité--requêtes-optimisées-pour-chaque-usage--maintenabilité--code-plus-clair-et-organisé--cache-efficace--mise-en-cache-des-requêtes-contexte-gyroscopsdans-notre-écosystème-user--organization--workflow--cloud-resources--billing-cqs-avec-in-memory-est-particulièrement-pertinent-pour---cache-haute-performance--séparation-des-écritures-et-lectures-de-cache--sessions-utilisateur--gestion-optimisée-des-sessions--métriques-en-temps-réel--collecte-et-lecture-des-métriques--tests-et-développement--environnements-de-test-rapides-et-organisés--architecture-cqs-avec-in-memory-séparation-des-responsabilités-côté-commande-write--command-handlers--traitement-des-commandes-métier--in-memory-writer--écriture-optimisée-en-mémoire--event-handlers--gestion-des-événements-de-domaine--bulk-operations--optimisation-des-écritures-côté-requête-read--query-handlers--traitement-des-requêtes--in-memory-reader--requêtes-optimisées--search-services--services-de-recherche-spécialisés--caches--optimisation-des-performances-flux-de-donnéesmermaidgraph-td----acommand----bcommand-handler----b----cin-memory-writer----c----ddata-in-ram----d----eindex-update--------fquery----gquery-handler----g----hin-memory-reader----h----d----d----isearch-results----i----jresponse--------kevent----levent-handler----l----c--------mcache----ncache-manager----n----d----d----ocached-data----o----pfast-response--implémentation-pratique-1-command-side-implementation-in-memory-writerphpphpnamespace-appinfrastructureinmemorycommanduse-appinfrastructureinmemoryinmemorystorageuse-appinfrastructureinmemoryinmemoryindexeruse-psrlogloggerinterfaceclass-inmemorywriter----private-inmemorystorage-storage----private-inmemoryindexer-indexer----private-loggerinterface-logger----private-array-bulkbuffer------private-int-bulksize----public-function-__construct--------inmemorystorage-storage--------inmemoryindexer-indexer--------loggerinterface-logger--------int-bulksize--100-------------this-storage--storage--------this-indexer--indexer--------this-logger--logger--------this-bulksize--bulksize--------public-function-storestring-key-mixed-value-array-indexfields---void------------this-bulkbuffer--------------operation--store------------key--key------------value--value------------indexfields--indexfields----------------if-countthis-bulkbuffer--this-bulksize-------------this-flushbulk----------------public-function-updatestring-key-mixed-value-array-indexfields---void------------this-bulkbuffer--------------operation--update------------key--key------------value--value------------indexfields--indexfields----------------if-countthis-bulkbuffer--this-bulksize-------------this-flushbulk----------------public-function-deletestring-key-void------------this-bulkbuffer--------------operation--delete------------key--key----------------if-countthis-bulkbuffer--this-bulksize-------------this-flushbulk----------------public-function-flushbulk-void------------if-emptythis-bulkbuffer-------------return----------------try-------------foreach-this-bulkbuffer-as-operation-----------------switch-operationoperation---------------------case-store------------------------this-storage-storeoperationkey-operationvalue------------------------if-emptyoperationindexfields-----------------------------this-indexer-addtoindex--------------------------------this-getentitytypeoperationkey--------------------------------operationkey--------------------------------operationvalue--------------------------------operationindexfields----------------------------------------------------------------------------break--------------------case-update------------------------this-storage-storeoperationkey-operationvalue------------------------if-emptyoperationindexfields-----------------------------this-indexer-removefromindex--------------------------------this-getentitytypeoperationkey--------------------------------operationkey--------------------------------------------------------this-indexer-addtoindex--------------------------------this-getentitytypeoperationkey--------------------------------operationkey--------------------------------operationvalue--------------------------------operationindexfields----------------------------------------------------------------------------break--------------------case-delete------------------------this-indexer-removefromindex----------------------------this-getentitytypeoperationkey----------------------------operationkey------------------------------------------------this-storage-deleteoperationkey------------------------break----------------------------------------this-logger-infobulk-operations-completed-----------------operations--countthis-bulkbuffer------------------------this-bulkbuffer-----------catch-exception-e-------------this-logger-errorbulk-operations-failed-----------------error--e-getmessage----------------operations--countthis-bulkbuffer------------------------throw-e----------------private-function-getentitytypestring-key-string------------parts--explode-key--------return-parts0--unknown-----command-handler-pour-les-paiementsphpphpnamespace-appapplicationcommandpaymentuse-appdomainpaymentpaymentuse-appdomainpaymentpaymentrepositoryinterfaceuse-appinfrastructureinmemorycommandinmemorywriteruse-psrlogloggerinterfaceclass-createpaymentcommandhandler----public-function-__construct--------private-paymentrepositoryinterface-paymentrepository--------private-inmemorywriter-writer--------private-loggerinterface-logger---------public-function-handlecreatepaymentcommand-command-void------------try--------------créer-le-paiement------------payment--new-payment----------------command-getpaymentid----------------command-getorganizationid----------------command-getuserid----------------command-getamount----------------command-getcurrency----------------pending----------------command-getdescription----------------new-datetime----------------command-getmetadata-------------------------sauvegarder-dans-le-repository-principal------------this-paymentrepository-savepayment-------------indexer-dans-in-memory-pour-la-recherche------------this-indexpaymentforsearchpayment------------this-logger-infopayment-created-and-indexed-----------------paymentid--payment-getid----------------organizationid--payment-getorganizationid---------------------catch-exception-e-------------this-logger-errorfailed-to-create-payment-----------------paymentid--command-getpaymentid----------------error--e-getmessage------------------------throw-e----------------private-function-indexpaymentforsearchpayment-payment-void------------key--paymentpayment-getid--------document--------------paymentid--payment-getid------------organizationid--payment-getorganizationid------------userid--payment-getuserid------------amount--payment-getamount------------currency--payment-getcurrency------------status--payment-getstatus------------description--payment-getdescription------------processedat--payment-getprocessedat-formatc------------metadata--payment-getmetadata------------indexedat--new-datetime-formatc----------------this-writer-storekey-document-------------organizationid------------userid------------status------------currency-------------event-handler-pour-la-synchronisationphpphpnamespace-appapplicationeventhandlerpaymentuse-appdomaineventdomaineventuse-appinfrastructureinmemorycommandinmemorywriteruse-psrlogloggerinterfaceclass-paymenteventhandler----public-function-__construct--------private-inmemorywriter-writer--------private-loggerinterface-logger---------public-function-handledomainevent-event-void------------switch-event-geteventtype-------------case-paymentprocessed----------------this-handlepaymentprocessedevent----------------break------------case-paymentfailed----------------this-handlepaymentfailedevent----------------break------------case-paymentrefunded----------------this-handlepaymentrefundedevent----------------break----------------private-function-handlepaymentprocesseddomainevent-event-void------------key--paymentevent-getaggregateid--------update--------------status--completed------------processedat--event-gettimestamp-formatc------------updatedat--new-datetime-formatc----------------this-writer-updatekey-update-status--------this-logger-infopayment-processed-event-handled-------------paymentid--event-getaggregateid------------status--completed----------------private-function-handlepaymentfaileddomainevent-event-void------------key--paymentevent-getaggregateid--------update--------------status--failed------------error--event-getdataerror------------failedat--event-gettimestamp-formatc------------updatedat--new-datetime-formatc----------------this-writer-updatekey-update-status--------this-logger-infopayment-failed-event-handled-------------paymentid--event-getaggregateid------------status--failed----------------private-function-handlepaymentrefundeddomainevent-event-void------------key--paymentevent-getaggregateid--------update--------------status--refunded------------refundamount--event-getdatarefundamount------------refundedat--event-gettimestamp-formatc------------updatedat--new-datetime-formatc----------------this-writer-updatekey-update-status--------this-logger-infopayment-refunded-event-handled-------------paymentid--event-getaggregateid------------status--refunded-------------2-query-side-implementation-in-memory-readerphpphpnamespace-appinfrastructureinmemoryqueryuse-appinfrastructureinmemoryinmemorystorageuse-appinfrastructureinmemoryinmemoryindexeruse-psrlogloggerinterfaceuse-psrcachecacheitempoolinterfaceclass-inmemoryreader----private-inmemorystorage-storage----private-inmemoryindexer-indexer----private-loggerinterface-logger----private-cacheitempoolinterface-cache----public-function-__construct--------inmemorystorage-storage--------inmemoryindexer-indexer--------loggerinterface-logger--------cacheitempoolinterface-cache-------------this-storage--storage--------this-indexer--indexer--------this-logger--logger--------this-cache--cache--------public-function-getstring-key-string-cachekey--null-mixed-------------vérifier-le-cache--------if-cachekey-------------cacheditem--this-cache-getitemcachekey------------if-cacheditem-ishit-----------------this-logger-debugdata-served-from-cache---------------------key--key--------------------cachekey--cachekey--------------------------------return-cacheditem-get----------------------------data--this-storage-getkey---------mettre-en-cache--------if-cachekey--data--null-------------cacheditem-setdata------------cacheditem-expiresafter300--5-minutes------------this-cache-savecacheditem----------------return-data--------public-function-searcharray-criteria-string-cachekey--null-array-------------vérifier-le-cache--------if-cachekey-------------cacheditem--this-cache-getitemcachekey------------if-cacheditem-ishit-----------------this-logger-debugsearch-result-served-from-cache---------------------criteria--criteria--------------------cachekey--cachekey--------------------------------return-cacheditem-get----------------------------results--this-performsearchcriteria---------mettre-en-cache--------if-cachekey-------------cacheditem-setresults------------cacheditem-expiresafter300--5-minutes------------this-cache-savecacheditem----------------this-logger-infosearch-executed-------------criteria--criteria------------results--countresults----------------return-results--------public-function-searchbyfieldstring-entitytype-string-field-mixed-value-array------------keys--this-indexer-searchentitytype-field-value----------------results----------foreach-keys-as-key-------------data--this-storage-getkey------------if-data--null-----------------results--data------------------------------------return-results--------public-function-searchbymultiplefieldsstring-entitytype-array-criteria-array------------results----------alldata--this-storage-getall--------foreach-alldata-as-key--value-------------if-this-isentitytypekey-entitytype-----------------continue------------------------matches--true------------foreach-criteria-as-field--expectedvalue-----------------if-this-fieldmatchesvalue-field-expectedvalue---------------------matches--false--------------------break----------------------------------------if-matches-----------------results--value----------------------------return-results--------public-function-getstatisticsstring-entitytype-array------------alldata--this-storage-getall--------entitydata----------foreach-alldata-as-key--value-------------if-this-isentitytypekey-entitytype-----------------entitydata--value----------------------------return-------------total--countentitydata------------memoryusage--memory_get_usagetrue------------peakmemoryusage--memory_get_peak_usagetrue----------------private-function-performsearcharray-criteria-array------------results----------alldata--this-storage-getall--------foreach-alldata-as-key--value-------------if-this-matchescriteriavalue-criteria-----------------results--value----------------------------return-results--------private-function-isentitytypestring-key-string-entitytype-bool------------return-str_starts_withkey-entitytype--------private-function-matchescriteriamixed-value-array-criteria-bool------------foreach-criteria-as-field--expectedvalue-------------if-this-fieldmatchesvalue-field-expectedvalue-----------------return-false----------------------------return-true--------private-function-fieldmatchesmixed-value-string-field-mixed-expectedvalue-bool------------fieldvalue--this-getfieldvaluevalue-field----------------if-is_arrayexpectedvalue-------------return-in_arrayfieldvalue-expectedvalue----------------return-fieldvalue--expectedvalue--------private-function-getfieldvaluemixed-value-string-field-mixed------------if-is_arrayvalue-------------return-valuefield--null----------------if-is_objectvalue-------------return-value-field--null----------------return-null-----query-handler-pour-les-paiementsphpphpnamespace-appapplicationquerypaymentuse-appinfrastructureinmemoryqueryinmemoryreaderuse-appdomainpaymentpaymentuse-psrlogloggerinterfaceclass-paymentqueryhandler----private-inmemoryreader-reader----private-loggerinterface-logger----public-function-__constructinmemoryreader-reader-loggerinterface-logger------------this-reader--reader--------this-logger--logger--------public-function-handlegetpaymentbyidquery-query-payment------------key--paymentquery-getpaymentid--------cachekey--payment_query-getpaymentid----------------data--this-reader-getkey-cachekey----------------if-data-------------return-null------------------------return-this-datatopaymentdata--------public-function-handlesearchpaymentsquery-query-paymentsearchresult------------criteria--this-buildsearchcriteriaquery--------cachekey--this-generatecachekeyquery----------------results--this-reader-searchcriteria-cachekey----------------payments----------foreach-results-as-data-------------payments--this-datatopaymentdata------------------------return-new-paymentsearchresult------------payments------------countpayments------------query-getpage------------query-getsize----------------public-function-handlegetpaymentstatisticsquery-query-array------------criteria--------------organizationid--query-getorganizationid------------------------if-query-getfrom--query-getto-------------criteriaprocessedat------------------gte--query-getfrom-formatc----------------lte--query-getto-formatc------------------------------------results--this-reader-searchcriteria----------------statistics--------------total--countresults------------bystatus--------------bycurrency--------------totalamount--0------------------------foreach-results-as-data-------------status--datastatus--unknown------------currency--datacurrency--unknown------------amount--dataamount--0------------------------statisticsbystatusstatus--statisticsbystatusstatus--0--1------------statisticsbycurrencycurrency--statisticsbycurrencycurrency--0--1------------statisticstotalamount--amount------------------------return-statistics--------private-function-buildsearchcriteriasearchpaymentsquery-query-array------------criteria------------------if-query-getorganizationid-------------criteriaorganizationid--query-getorganizationid------------------------if-query-getstatuses-------------criteriastatus--query-getstatuses------------------------if-query-getcurrencies-------------criteriacurrency--query-getcurrencies------------------------if-query-getminamount--query-getmaxamount-------------criteriaamount--------------if-query-getminamount-----------------criteriaamountgte--query-getminamount------------------------if-query-getmaxamount-----------------criteriaamountlte--query-getmaxamount------------------------------------return-criteria--------private-function-generatecachekeysearchpaymentsquery-query-string------------return-payment_search_--md5serializequery--------private-function-datatopaymentarray-data-payment------------return-new-payment------------datapaymentid------------dataorganizationid------------datauserid------------dataamount------------datacurrency------------datastatus------------datadescription------------new-datetimedataprocessedat------------datametadata---------------3-service-de-synchronisation-service-de-synchronisation-bidirectionnellephpphpnamespace-appapplicationserviceinmemoryuse-appdomainpaymentpaymentrepositoryinterfaceuse-appinfrastructureinmemorycommandinmemorywriteruse-appinfrastructureinmemoryqueryinmemoryreaderuse-psrlogloggerinterfaceclass-paymentsynchronizationservice----public-function-__construct--------private-paymentrepositoryinterface-paymentrepository--------private-inmemorywriter-writer--------private-inmemoryreader-reader--------private-loggerinterface-logger---------public-function-synchronizepaymentstring-paymentid-void------------try--------------récupérer-le-paiement-depuis-le-repository-principal------------payment--this-paymentrepository-findbyidpaymentid------------------------if-payment-----------------this-logger-warningpayment-not-found-for-synchronization---------------------paymentid--paymentid--------------------------------return-------------------------indexer-dans-in-memory------------this-indexpaymentforsearchpayment------------this-logger-infopayment-synchronized-----------------paymentid--paymentid----------------status--payment-getstatus---------------------catch-exception-e-------------this-logger-errorpayment-synchronization-failed-----------------paymentid--paymentid----------------error--e-getmessage------------------------throw-e----------------public-function-synchronizeallpaymentsstring-organizationid--null-void------------try-------------payments--organizationid------------------this-paymentrepository-findbyorganizationorganizationid-----------------this-paymentrepository-findall------------count--0------------foreach-payments-as-payment-----------------this-synchronizepaymentpayment-getid----------------count------------------------this-logger-infoall-payments-synchronized-----------------count--count----------------organizationid--organizationid---------------------catch-exception-e-------------this-logger-errorbulk-synchronization-failed-----------------organizationid--organizationid----------------error--e-getmessage------------------------throw-e----------------public-function-verifysynchronizationstring-paymentid-bool------------try-------------payment--this-paymentrepository-findbyidpaymentid------------data--this-reader-getpaymentpaymentid------------if-payment--data-----------------return-false-------------------------vérifier-que-les-données-correspondent------------return-payment-getstatus--datastatus--------------------payment-getamount--dataamount--------------------payment-getcurrency--datacurrency---------catch-exception-e-------------this-logger-errorsynchronization-verification-failed-----------------paymentid--paymentid----------------error--e-getmessage------------------------return-false----------------private-function-indexpaymentforsearchpayment-payment-void------------key--paymentpayment-getid--------document--------------paymentid--payment-getid------------organizationid--payment-getorganizationid------------userid--payment-getuserid------------amount--payment-getamount------------currency--payment-getcurrency------------status--payment-getstatus------------description--payment-getdescription------------processedat--payment-getprocessedat-formatc------------metadata--payment-getmetadata------------synchronizedat--new-datetime-formatc----------------this-writer-storekey-document-------------organizationid------------userid------------status------------currency--------------tests-et-validation-tests-dphpphpnamespace-apptestsintegrationinmemoryuse-appapplicationcommandpaymentcreatepaymentcommanduse-appapplicationcommandpaymentcreatepaymentcommandhandleruse-appapplicationquerypaymentgetpaymentbyidqueryuse-appapplicationquerypaymentsearchpaymentsqueryuse-appapplicationquerypaymentpaymentqueryhandleruse-appinfrastructureinmemorycommandinmemorywriteruse-appinfrastructureinmemoryqueryinmemoryreaderuse-appinfrastructureinmemoryinmemorystorageuse-appinfrastructureinmemoryinmemoryindexerclass-inmemorycqstest-extends-testcase----private-inmemorywriter-writer----private-inmemoryreader-reader----private-createpaymentcommandhandler-commandhandler----private-paymentqueryhandler-queryhandler----protected-function-setup-void------------storage--new-inmemorystorage--------indexer--new-inmemoryindexer----------------this-writer--new-inmemorywriterstorage-indexer-this-createmockloggerinterfaceclass--------this-reader--new-inmemoryreaderstorage-indexer-this-createmockloggerinterfaceclass-this-createmockcacheitempoolinterfaceclass----------------this-commandhandler--new-createpaymentcommandhandler------------this-createmockpaymentrepositoryinterfaceclass------------this-writer------------this-createmockloggerinterfaceclass------------------------this-queryhandler--new-paymentqueryhandlerthis-reader-this-createmockloggerinterfaceclass--------public-function-testcommandqueryseparation-void-------------exécuter-une-commande--------command--new-createpaymentcommand------------payment-123------------org-456------------user-789------------10000------------eur------------test-payment------------source--test------------------------this-commandhandler-handlecommand-----------------vérifier-avec-une-requête--------query--new-getpaymentbyidquerypayment-123--------payment--this-queryhandler-handlequery----------------this-assertnotnullpayment--------this-assertequalspayment-123-payment-getid--------this-assertequals10000-payment-getamount--------public-function-testsearchfunctionality-void-------------créer-plusieurs-paiements--------payments--------------new-createpaymentcommandpayment-1-org-456-user-1-10000-eur-payment-1-------------new-createpaymentcommandpayment-2-org-456-user-2-20000-usd-payment-2-------------new-createpaymentcommandpayment-3-org-789-user-3-30000-eur-payment-3-------------------------foreach-payments-as-command-------------this-commandhandler-handlecommand-------------------------rechercher-par-organisation--------searchquery--new-searchpaymentsqueryorg-456-0-10--------result--this-queryhandler-handlesearchquery----------------this-assertcount2-result-getpayments--------this-assertequals2-result-gettotal------performance-et-optimisation-stratégies-d-1-bulk-operationsphppublic-function-bulkstorepaymentsarray-payments-void----foreach-payments-as-payment---------this-writer-store------------paymentpayment-getid------------this-paymenttodatapayment------------organizationid-userid-status-currency--------------------this-writer-flushbulk-2-cache-stratégiquephppublic-function-searchwithcachesearchpaymentsquery-query-paymentsearchresult----cachekey--payment_search_--md5serializequery--------if-cached--this-cache-getcachekey---------return-cached------------result--this-searchpaymentsquery----this-cache-setcachekey-result-300--------return-result-3-index-optimisésphppublic-function-optimizeindexes-void-----nettoyer-les-index-orphelins----this-cleanorphanedindexes---------compacter-les-index----this-compactindexes---------forcer-le-garbage-collection----gc_collect_cycles--critères-d-quand-utiliser-cqs-avec-in-memory--avantages--performance-optimisée--séparation-claire-entre-écriture-et-lecture--scalabilité--possibilité-de-scaler-indépendamment--flexibilité--requêtes-optimisées-pour-chaque-usage--maintenabilité--code-plus-clair-et-organisé--cache-efficace--mise-en-cache-des-requêtes--inconvénients--complexité--architecture-plus-complexe--volatilité--données-perdues-au-redémarrage--limitation-mémoire--contraint-par-la-ram-disponible--expertise--équipe-expérimentée-requise--critères-d--performance-importante--besoins-de-performance-élevée--données-temporaires--cache-sessions-métriques--équipe-expérimentée--maîtrise-din-memory-et-cqs--tests-et-développement--environnements-de-test-rapides--mémoire-suffisante--ram-disponible-pour-toutes-les-données--pas-de-persistance--données-temporaires-uniquement--votre-prochaine-étapehahahugoshortcode31s0hbhbcqs-avec-in-memory-offre-un-équilibre-optimal-entre-performance-et-organisation-parfaitement-adapté-aux-besoins-de-cache-et-de-données-temporaires-de-gyroscops"&gt;🎯 &lt;strong&gt;Contexte et Objectifs&lt;/strong&gt;### **Pourquoi CQS avec In-Memory ?**La combinaison CQS avec In-Memory offre une architecture optimisée qui sépare clairement les responsabilités tout en conservant les performances exceptionnelles du stockage en mémoire.#### &lt;strong&gt;Avantages de CQS avec In-Memory&lt;/strong&gt;- &lt;strong&gt;Performance optimisée&lt;/strong&gt; : Séparation claire entre écriture et lecture- &lt;strong&gt;Scalabilité&lt;/strong&gt; : Possibilité de scaler indépendamment les commandes et requêtes- &lt;strong&gt;Flexibilité&lt;/strong&gt; : Requêtes optimisées pour chaque usage- &lt;strong&gt;Maintenabilité&lt;/strong&gt; : Code plus clair et organisé- &lt;strong&gt;Cache efficace&lt;/strong&gt; : Mise en cache des requêtes### &lt;strong&gt;Contexte Gyroscops&lt;/strong&gt;Dans notre écosystème &lt;strong&gt;User → Organization → Workflow → Cloud Resources → Billing&lt;/strong&gt;, CQS avec In-Memory est particulièrement pertinent pour :- &lt;strong&gt;Cache haute performance&lt;/strong&gt; : Séparation des écritures et lectures de cache- &lt;strong&gt;Sessions utilisateur&lt;/strong&gt; : Gestion optimisée des sessions- &lt;strong&gt;Métriques en temps réel&lt;/strong&gt; : Collecte et lecture des métriques- &lt;strong&gt;Tests et développement&lt;/strong&gt; : Environnements de test rapides et organisés## 🏗️ &lt;strong&gt;Architecture CQS avec In-Memory&lt;/strong&gt;### &lt;strong&gt;Séparation des Responsabilités&lt;/strong&gt;#### &lt;strong&gt;Côté Commande (Write)&lt;/strong&gt;- &lt;strong&gt;Command Handlers&lt;/strong&gt; : Traitement des commandes métier- &lt;strong&gt;In-Memory Writer&lt;/strong&gt; : Écriture optimisée en mémoire- &lt;strong&gt;Event Handlers&lt;/strong&gt; : Gestion des événements de domaine- &lt;strong&gt;Bulk Operations&lt;/strong&gt; : Optimisation des écritures#### &lt;strong&gt;Côté Requête (Read)&lt;/strong&gt;- &lt;strong&gt;Query Handlers&lt;/strong&gt; : Traitement des requêtes- &lt;strong&gt;In-Memory Reader&lt;/strong&gt; : Requêtes optimisées- &lt;strong&gt;Search Services&lt;/strong&gt; : Services de recherche spécialisés- &lt;strong&gt;Caches&lt;/strong&gt; : Optimisation des performances### &lt;strong&gt;Flux de Données&lt;/strong&gt;&lt;code&gt;mermaidgraph TD A[Command] --&amp;gt; B[Command Handler] B --&amp;gt; C[In-Memory Writer] C --&amp;gt; D[Data in RAM] D --&amp;gt; E[Index Update] F[Query] --&amp;gt; G[Query Handler] G --&amp;gt; H[In-Memory Reader] H --&amp;gt; D D --&amp;gt; I[Search Results] I --&amp;gt; J[Response] K[Event] --&amp;gt; L[Event Handler] L --&amp;gt; C M[Cache] --&amp;gt; N[Cache Manager] N --&amp;gt; D D --&amp;gt; O[Cached Data] O --&amp;gt; P[Fast Response]&lt;/code&gt;## 💻 &lt;strong&gt;Implémentation Pratique&lt;/strong&gt;### &lt;strong&gt;1. Command Side Implementation&lt;/strong&gt;#### &lt;strong&gt;In-Memory Writer&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Infrastructure\InMemory\Command;use App\Infrastructure\InMemory\InMemoryStorage;use App\Infrastructure\InMemory\InMemoryIndexer;use Psr\Log\LoggerInterface;class InMemoryWriter{ private InMemoryStorage $storage; private InMemoryIndexer $indexer; private LoggerInterface $logger; private array $bulkBuffer = []; private int $bulkSize; public function __construct( InMemoryStorage $storage, InMemoryIndexer $indexer, LoggerInterface $logger, int $bulkSize = 100 ) { $this-&amp;gt;storage = $storage; $this-&amp;gt;indexer = $indexer; $this-&amp;gt;logger = $logger; $this-&amp;gt;bulkSize = $bulkSize; } public function store(string $key, mixed $value, array $indexFields = []): void { $this-&amp;gt;bulkBuffer[] = [ 'operation' =&amp;gt; 'store', 'key' =&amp;gt; $key, 'value' =&amp;gt; $value, 'indexFields' =&amp;gt; $indexFields ]; if (count($this-&amp;gt;bulkBuffer) &amp;gt;= $this-&amp;gt;bulkSize) { $this-&amp;gt;flushBulk(); } } public function update(string $key, mixed $value, array $indexFields = []): void { $this-&amp;gt;bulkBuffer[] = [ 'operation' =&amp;gt; 'update', 'key' =&amp;gt; $key, 'value' =&amp;gt; $value, 'indexFields' =&amp;gt; $indexFields ]; if (count($this-&amp;gt;bulkBuffer) &amp;gt;= $this-&amp;gt;bulkSize) { $this-&amp;gt;flushBulk(); } } public function delete(string $key): void { $this-&amp;gt;bulkBuffer[] = [ 'operation' =&amp;gt; 'delete', 'key' =&amp;gt; $key ]; if (count($this-&amp;gt;bulkBuffer) &amp;gt;= $this-&amp;gt;bulkSize) { $this-&amp;gt;flushBulk(); } } public function flushBulk(): void { if (empty($this-&amp;gt;bulkBuffer)) { return; } try { foreach ($this-&amp;gt;bulkBuffer as $operation) { switch ($operation['operation']) { case 'store': $this-&amp;gt;storage-&amp;gt;store($operation['key'], $operation['value']); if (!empty($operation['indexFields'])) { $this-&amp;gt;indexer-&amp;gt;addToIndex( $this-&amp;gt;getEntityType($operation['key']), $operation['key'], $operation['value'], $operation['indexFields'] ); } break; case 'update': $this-&amp;gt;storage-&amp;gt;store($operation['key'], $operation['value']); if (!empty($operation['indexFields'])) { $this-&amp;gt;indexer-&amp;gt;removeFromIndex( $this-&amp;gt;getEntityType($operation['key']), $operation['key'] ); $this-&amp;gt;indexer-&amp;gt;addToIndex( $this-&amp;gt;getEntityType($operation['key']), $operation['key'], $operation['value'], $operation['indexFields'] ); } break; case 'delete': $this-&amp;gt;indexer-&amp;gt;removeFromIndex( $this-&amp;gt;getEntityType($operation['key']), $operation['key'] ); $this-&amp;gt;storage-&amp;gt;delete($operation['key']); break; } } $this-&amp;gt;logger-&amp;gt;info('Bulk operations completed', [ 'operations' =&amp;gt; count($this-&amp;gt;bulkBuffer) ]); $this-&amp;gt;bulkBuffer = []; } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Bulk operations failed', [ 'error' =&amp;gt; $e-&amp;gt;getMessage(), 'operations' =&amp;gt; count($this-&amp;gt;bulkBuffer) ]); throw $e; } } private function getEntityType(string $key): string { $parts = explode(':', $key); return $parts[0] ?? 'Unknown'; }}&lt;/code&gt;#### &lt;strong&gt;Command Handler pour les Paiements&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Command\Payment;use App\Domain\Payment\Payment;use App\Domain\Payment\PaymentRepositoryInterface;use App\Infrastructure\InMemory\Command\InMemoryWriter;use Psr\Log\LoggerInterface;class CreatePaymentCommandHandler{ public function __construct( private PaymentRepositoryInterface $paymentRepository, private InMemoryWriter $writer, private LoggerInterface $logger ) {} public function handle(CreatePaymentCommand $command): void { try { // Créer le paiement $payment = new Payment( $command-&amp;gt;getPaymentId(), $command-&amp;gt;getOrganizationId(), $command-&amp;gt;getUserId(), $command-&amp;gt;getAmount(), $command-&amp;gt;getCurrency(), 'pending', $command-&amp;gt;getDescription(), new \DateTime(), $command-&amp;gt;getMetadata() ); // Sauvegarder dans le repository principal $this-&amp;gt;paymentRepository-&amp;gt;save($payment); // Indexer dans In-Memory pour la recherche $this-&amp;gt;indexPaymentForSearch($payment); $this-&amp;gt;logger-&amp;gt;info('Payment created and indexed', [ 'paymentId' =&amp;gt; $payment-&amp;gt;getId(), 'organizationId' =&amp;gt; $payment-&amp;gt;getOrganizationId() ]); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to create payment', [ 'paymentId' =&amp;gt; $command-&amp;gt;getPaymentId(), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } private function indexPaymentForSearch(Payment $payment): void { $key = &amp;quot;Payment:{$payment-&amp;gt;getId()}&amp;quot;; $document = [ 'paymentId' =&amp;gt; $payment-&amp;gt;getId(), 'organizationId' =&amp;gt; $payment-&amp;gt;getOrganizationId(), 'userId' =&amp;gt; $payment-&amp;gt;getUserId(), 'amount' =&amp;gt; $payment-&amp;gt;getAmount(), 'currency' =&amp;gt; $payment-&amp;gt;getCurrency(), 'status' =&amp;gt; $payment-&amp;gt;getStatus(), 'description' =&amp;gt; $payment-&amp;gt;getDescription(), 'processedAt' =&amp;gt; $payment-&amp;gt;getProcessedAt()-&amp;gt;format('c'), 'metadata' =&amp;gt; $payment-&amp;gt;getMetadata(), 'indexedAt' =&amp;gt; (new \DateTime())-&amp;gt;format('c') ]; $this-&amp;gt;writer-&amp;gt;store($key, $document, [ 'organizationId', 'userId', 'status', 'currency' ]); }}&lt;/code&gt;#### &lt;strong&gt;Event Handler pour la Synchronisation&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\EventHandler\Payment;use App\Domain\Event\DomainEvent;use App\Infrastructure\InMemory\Command\InMemoryWriter;use Psr\Log\LoggerInterface;class PaymentEventHandler{ public function __construct( private InMemoryWriter $writer, private LoggerInterface $logger ) {} public function handle(DomainEvent $event): void { switch ($event-&amp;gt;getEventType()) { case 'PaymentProcessed': $this-&amp;gt;handlePaymentProcessed($event); break; case 'PaymentFailed': $this-&amp;gt;handlePaymentFailed($event); break; case 'PaymentRefunded': $this-&amp;gt;handlePaymentRefunded($event); break; } } private function handlePaymentProcessed(DomainEvent $event): void { $key = &amp;quot;Payment:{$event-&amp;gt;getAggregateId()}&amp;quot;; $update = [ 'status' =&amp;gt; 'completed', 'processedAt' =&amp;gt; $event-&amp;gt;getTimestamp()-&amp;gt;format('c'), 'updatedAt' =&amp;gt; (new \DateTime())-&amp;gt;format('c') ]; $this-&amp;gt;writer-&amp;gt;update($key, $update, ['status']); $this-&amp;gt;logger-&amp;gt;info('Payment processed event handled', [ 'paymentId' =&amp;gt; $event-&amp;gt;getAggregateId(), 'status' =&amp;gt; 'completed' ]); } private function handlePaymentFailed(DomainEvent $event): void { $key = &amp;quot;Payment:{$event-&amp;gt;getAggregateId()}&amp;quot;; $update = [ 'status' =&amp;gt; 'failed', 'error' =&amp;gt; $event-&amp;gt;getData()['error'], 'failedAt' =&amp;gt; $event-&amp;gt;getTimestamp()-&amp;gt;format('c'), 'updatedAt' =&amp;gt; (new \DateTime())-&amp;gt;format('c') ]; $this-&amp;gt;writer-&amp;gt;update($key, $update, ['status']); $this-&amp;gt;logger-&amp;gt;info('Payment failed event handled', [ 'paymentId' =&amp;gt; $event-&amp;gt;getAggregateId(), 'status' =&amp;gt; 'failed' ]); } private function handlePaymentRefunded(DomainEvent $event): void { $key = &amp;quot;Payment:{$event-&amp;gt;getAggregateId()}&amp;quot;; $update = [ 'status' =&amp;gt; 'refunded', 'refundAmount' =&amp;gt; $event-&amp;gt;getData()['refundAmount'], 'refundedAt' =&amp;gt; $event-&amp;gt;getTimestamp()-&amp;gt;format('c'), 'updatedAt' =&amp;gt; (new \DateTime())-&amp;gt;format('c') ]; $this-&amp;gt;writer-&amp;gt;update($key, $update, ['status']); $this-&amp;gt;logger-&amp;gt;info('Payment refunded event handled', [ 'paymentId' =&amp;gt; $event-&amp;gt;getAggregateId(), 'status' =&amp;gt; 'refunded' ]); }}&lt;/code&gt;### &lt;strong&gt;2. Query Side Implementation&lt;/strong&gt;#### &lt;strong&gt;In-Memory Reader&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Infrastructure\InMemory\Query;use App\Infrastructure\InMemory\InMemoryStorage;use App\Infrastructure\InMemory\InMemoryIndexer;use Psr\Log\LoggerInterface;use Psr\Cache\CacheItemPoolInterface;class InMemoryReader{ private InMemoryStorage $storage; private InMemoryIndexer $indexer; private LoggerInterface $logger; private CacheItemPoolInterface $cache; public function __construct( InMemoryStorage $storage, InMemoryIndexer $indexer, LoggerInterface $logger, CacheItemPoolInterface $cache ) { $this-&amp;gt;storage = $storage; $this-&amp;gt;indexer = $indexer; $this-&amp;gt;logger = $logger; $this-&amp;gt;cache = $cache; } public function get(string $key, string $cacheKey = null): mixed { // Vérifier le cache if ($cacheKey) { $cachedItem = $this-&amp;gt;cache-&amp;gt;getItem($cacheKey); if ($cachedItem-&amp;gt;isHit()) { $this-&amp;gt;logger-&amp;gt;debug('Data served from cache', [ 'key' =&amp;gt; $key, 'cacheKey' =&amp;gt; $cacheKey ]); return $cachedItem-&amp;gt;get(); } } $data = $this-&amp;gt;storage-&amp;gt;get($key); // Mettre en cache if ($cacheKey &amp;amp;&amp;amp; $data !== null) { $cachedItem-&amp;gt;set($data); $cachedItem-&amp;gt;expiresAfter(300); // 5 minutes $this-&amp;gt;cache-&amp;gt;save($cachedItem); } return $data; } public function search(array $criteria, string $cacheKey = null): array { // Vérifier le cache if ($cacheKey) { $cachedItem = $this-&amp;gt;cache-&amp;gt;getItem($cacheKey); if ($cachedItem-&amp;gt;isHit()) { $this-&amp;gt;logger-&amp;gt;debug('Search result served from cache', [ 'criteria' =&amp;gt; $criteria, 'cacheKey' =&amp;gt; $cacheKey ]); return $cachedItem-&amp;gt;get(); } } $results = $this-&amp;gt;performSearch($criteria); // Mettre en cache if ($cacheKey) { $cachedItem-&amp;gt;set($results); $cachedItem-&amp;gt;expiresAfter(300); // 5 minutes $this-&amp;gt;cache-&amp;gt;save($cachedItem); } $this-&amp;gt;logger-&amp;gt;info('Search executed', [ 'criteria' =&amp;gt; $criteria, 'results' =&amp;gt; count($results) ]); return $results; } public function searchByField(string $entityType, string $field, mixed $value): array { $keys = $this-&amp;gt;indexer-&amp;gt;search($entityType, $field, $value); $results = []; foreach ($keys as $key) { $data = $this-&amp;gt;storage-&amp;gt;get($key); if ($data !== null) { $results[] = $data; } } return $results; } public function searchByMultipleFields(string $entityType, array $criteria): array { $results = []; $allData = $this-&amp;gt;storage-&amp;gt;getAll(); foreach ($allData as $key =&amp;gt; $value) { if (!$this-&amp;gt;isEntityType($key, $entityType)) { continue; } $matches = true; foreach ($criteria as $field =&amp;gt; $expectedValue) { if (!$this-&amp;gt;fieldMatches($value, $field, $expectedValue)) { $matches = false; break; } } if ($matches) { $results[] = $value; } } return $results; } public function getStatistics(string $entityType): array { $allData = $this-&amp;gt;storage-&amp;gt;getAll(); $entityData = []; foreach ($allData as $key =&amp;gt; $value) { if ($this-&amp;gt;isEntityType($key, $entityType)) { $entityData[] = $value; } } return [ 'total' =&amp;gt; count($entityData), 'memoryUsage' =&amp;gt; memory_get_usage(true), 'peakMemoryUsage' =&amp;gt; memory_get_peak_usage(true) ]; } private function performSearch(array $criteria): array { $results = []; $allData = $this-&amp;gt;storage-&amp;gt;getAll(); foreach ($allData as $key =&amp;gt; $value) { if ($this-&amp;gt;matchesCriteria($value, $criteria)) { $results[] = $value; } } return $results; } private function isEntityType(string $key, string $entityType): bool { return str_starts_with($key, &amp;quot;{$entityType}:&amp;quot;); } private function matchesCriteria(mixed $value, array $criteria): bool { foreach ($criteria as $field =&amp;gt; $expectedValue) { if (!$this-&amp;gt;fieldMatches($value, $field, $expectedValue)) { return false; } } return true; } private function fieldMatches(mixed $value, string $field, mixed $expectedValue): bool { $fieldValue = $this-&amp;gt;getFieldValue($value, $field); if (is_array($expectedValue)) { return in_array($fieldValue, $expectedValue); } return $fieldValue === $expectedValue; } private function getFieldValue(mixed $value, string $field): mixed { if (is_array($value)) { return $value[$field] ?? null; } if (is_object($value)) { return $value-&amp;gt;$field ?? null; } return null; }}&lt;/code&gt;#### &lt;strong&gt;Query Handler pour les Paiements&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Query\Payment;use App\Infrastructure\InMemory\Query\InMemoryReader;use App\Domain\Payment\Payment;use Psr\Log\LoggerInterface;class PaymentQueryHandler{ private InMemoryReader $reader; private LoggerInterface $logger; public function __construct(InMemoryReader $reader, LoggerInterface $logger) { $this-&amp;gt;reader = $reader; $this-&amp;gt;logger = $logger; } public function handle(GetPaymentByIdQuery $query): ?Payment { $key = &amp;quot;Payment:{$query-&amp;gt;getPaymentId()}&amp;quot;; $cacheKey = &amp;quot;payment_{$query-&amp;gt;getPaymentId()}&amp;quot;; $data = $this-&amp;gt;reader-&amp;gt;get($key, $cacheKey); if (!$data) { return null; } return $this-&amp;gt;dataToPayment($data); } public function handle(SearchPaymentsQuery $query): PaymentSearchResult { $criteria = $this-&amp;gt;buildSearchCriteria($query); $cacheKey = $this-&amp;gt;generateCacheKey($query); $results = $this-&amp;gt;reader-&amp;gt;search($criteria, $cacheKey); $payments = []; foreach ($results as $data) { $payments[] = $this-&amp;gt;dataToPayment($data); } return new PaymentSearchResult( $payments, count($payments), $query-&amp;gt;getPage(), $query-&amp;gt;getSize() ); } public function handle(GetPaymentStatisticsQuery $query): array { $criteria = [ 'organizationId' =&amp;gt; $query-&amp;gt;getOrganizationId() ]; if ($query-&amp;gt;getFrom() &amp;amp;&amp;amp; $query-&amp;gt;getTo()) { $criteria['processedAt'] = [ 'gte' =&amp;gt; $query-&amp;gt;getFrom()-&amp;gt;format('c'), 'lte' =&amp;gt; $query-&amp;gt;getTo()-&amp;gt;format('c') ]; } $results = $this-&amp;gt;reader-&amp;gt;search($criteria); $statistics = [ 'total' =&amp;gt; count($results), 'byStatus' =&amp;gt; [], 'byCurrency' =&amp;gt; [], 'totalAmount' =&amp;gt; 0 ]; foreach ($results as $data) { $status = $data['status'] ?? 'unknown'; $currency = $data['currency'] ?? 'unknown'; $amount = $data['amount'] ?? 0; $statistics['byStatus'][$status] = ($statistics['byStatus'][$status] ?? 0) + 1; $statistics['byCurrency'][$currency] = ($statistics['byCurrency'][$currency] ?? 0) + 1; $statistics['totalAmount'] += $amount; } return $statistics; } private function buildSearchCriteria(SearchPaymentsQuery $query): array { $criteria = []; if ($query-&amp;gt;getOrganizationId()) { $criteria['organizationId'] = $query-&amp;gt;getOrganizationId(); } if ($query-&amp;gt;getStatuses()) { $criteria['status'] = $query-&amp;gt;getStatuses(); } if ($query-&amp;gt;getCurrencies()) { $criteria['currency'] = $query-&amp;gt;getCurrencies(); } if ($query-&amp;gt;getMinAmount() || $query-&amp;gt;getMaxAmount()) { $criteria['amount'] = []; if ($query-&amp;gt;getMinAmount()) { $criteria['amount']['gte'] = $query-&amp;gt;getMinAmount(); } if ($query-&amp;gt;getMaxAmount()) { $criteria['amount']['lte'] = $query-&amp;gt;getMaxAmount(); } } return $criteria; } private function generateCacheKey(SearchPaymentsQuery $query): string { return 'payment_search_' . md5(serialize($query)); } private function dataToPayment(array $data): Payment { return new Payment( $data['paymentId'], $data['organizationId'], $data['userId'], $data['amount'], $data['currency'], $data['status'], $data['description'], new \DateTime($data['processedAt']), $data['metadata'] ?? [] ); }}&lt;/code&gt;### &lt;strong&gt;3. Service de Synchronisation&lt;/strong&gt;#### &lt;strong&gt;Service de Synchronisation Bidirectionnelle&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Service\InMemory;use App\Domain\Payment\PaymentRepositoryInterface;use App\Infrastructure\InMemory\Command\InMemoryWriter;use App\Infrastructure\InMemory\Query\InMemoryReader;use Psr\Log\LoggerInterface;class PaymentSynchronizationService{ public function __construct( private PaymentRepositoryInterface $paymentRepository, private InMemoryWriter $writer, private InMemoryReader $reader, private LoggerInterface $logger ) {} public function synchronizePayment(string $paymentId): void { try { // Récupérer le paiement depuis le repository principal $payment = $this-&amp;gt;paymentRepository-&amp;gt;findById($paymentId); if (!$payment) { $this-&amp;gt;logger-&amp;gt;warning('Payment not found for synchronization', [ 'paymentId' =&amp;gt; $paymentId ]); return; } // Indexer dans In-Memory $this-&amp;gt;indexPaymentForSearch($payment); $this-&amp;gt;logger-&amp;gt;info('Payment synchronized', [ 'paymentId' =&amp;gt; $paymentId, 'status' =&amp;gt; $payment-&amp;gt;getStatus() ]); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Payment synchronization failed', [ 'paymentId' =&amp;gt; $paymentId, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } public function synchronizeAllPayments(string $organizationId = null): void { try { $payments = $organizationId ? $this-&amp;gt;paymentRepository-&amp;gt;findByOrganization($organizationId) : $this-&amp;gt;paymentRepository-&amp;gt;findAll(); $count = 0; foreach ($payments as $payment) { $this-&amp;gt;synchronizePayment($payment-&amp;gt;getId()); $count++; } $this-&amp;gt;logger-&amp;gt;info('All payments synchronized', [ 'count' =&amp;gt; $count, 'organizationId' =&amp;gt; $organizationId ]); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Bulk synchronization failed', [ 'organizationId' =&amp;gt; $organizationId, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } public function verifySynchronization(string $paymentId): bool { try { $payment = $this-&amp;gt;paymentRepository-&amp;gt;findById($paymentId); $data = $this-&amp;gt;reader-&amp;gt;get(&amp;quot;Payment:{$paymentId}&amp;quot;); if (!$payment || !$data) { return false; } // Vérifier que les données correspondent return $payment-&amp;gt;getStatus() === $data['status'] &amp;amp;&amp;amp; $payment-&amp;gt;getAmount() === $data['amount'] &amp;amp;&amp;amp; $payment-&amp;gt;getCurrency() === $data['currency']; } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Synchronization verification failed', [ 'paymentId' =&amp;gt; $paymentId, 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); return false; } } private function indexPaymentForSearch(Payment $payment): void { $key = &amp;quot;Payment:{$payment-&amp;gt;getId()}&amp;quot;; $document = [ 'paymentId' =&amp;gt; $payment-&amp;gt;getId(), 'organizationId' =&amp;gt; $payment-&amp;gt;getOrganizationId(), 'userId' =&amp;gt; $payment-&amp;gt;getUserId(), 'amount' =&amp;gt; $payment-&amp;gt;getAmount(), 'currency' =&amp;gt; $payment-&amp;gt;getCurrency(), 'status' =&amp;gt; $payment-&amp;gt;getStatus(), 'description' =&amp;gt; $payment-&amp;gt;getDescription(), 'processedAt' =&amp;gt; $payment-&amp;gt;getProcessedAt()-&amp;gt;format('c'), 'metadata' =&amp;gt; $payment-&amp;gt;getMetadata(), 'synchronizedAt' =&amp;gt; (new \DateTime())-&amp;gt;format('c') ]; $this-&amp;gt;writer-&amp;gt;store($key, $document, [ 'organizationId', 'userId', 'status', 'currency' ]); }}&lt;/code&gt;## 🧪 &lt;strong&gt;Tests et Validation&lt;/strong&gt;### &lt;strong&gt;Tests d&amp;rsquo;Intégration CQS&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Tests\Integration\InMemory;use App\Application\Command\Payment\CreatePaymentCommand;use App\Application\Command\Payment\CreatePaymentCommandHandler;use App\Application\Query\Payment\GetPaymentByIdQuery;use App\Application\Query\Payment\SearchPaymentsQuery;use App\Application\Query\Payment\PaymentQueryHandler;use App\Infrastructure\InMemory\Command\InMemoryWriter;use App\Infrastructure\InMemory\Query\InMemoryReader;use App\Infrastructure\InMemory\InMemoryStorage;use App\Infrastructure\InMemory\InMemoryIndexer;class InMemoryCqsTest extends TestCase{ private InMemoryWriter $writer; private InMemoryReader $reader; private CreatePaymentCommandHandler $commandHandler; private PaymentQueryHandler $queryHandler; protected function setUp(): void { $storage = new InMemoryStorage(); $indexer = new InMemoryIndexer(); $this-&amp;gt;writer = new InMemoryWriter($storage, $indexer, $this-&amp;gt;createMock(LoggerInterface::class)); $this-&amp;gt;reader = new InMemoryReader($storage, $indexer, $this-&amp;gt;createMock(LoggerInterface::class), $this-&amp;gt;createMock(CacheItemPoolInterface::class)); $this-&amp;gt;commandHandler = new CreatePaymentCommandHandler( $this-&amp;gt;createMock(PaymentRepositoryInterface::class), $this-&amp;gt;writer, $this-&amp;gt;createMock(LoggerInterface::class) ); $this-&amp;gt;queryHandler = new PaymentQueryHandler($this-&amp;gt;reader, $this-&amp;gt;createMock(LoggerInterface::class)); } public function testCommandQuerySeparation(): void { // Exécuter une commande $command = new CreatePaymentCommand( 'payment-123', 'org-456', 'user-789', 100.00, 'EUR', 'Test payment', ['source' =&amp;gt; 'test'] ); $this-&amp;gt;commandHandler-&amp;gt;handle($command); // Vérifier avec une requête $query = new GetPaymentByIdQuery('payment-123'); $payment = $this-&amp;gt;queryHandler-&amp;gt;handle($query); $this-&amp;gt;assertNotNull($payment); $this-&amp;gt;assertEquals('payment-123', $payment-&amp;gt;getId()); $this-&amp;gt;assertEquals(100.00, $payment-&amp;gt;getAmount()); } public function testSearchFunctionality(): void { // Créer plusieurs paiements $payments = [ new CreatePaymentCommand('payment-1', 'org-456', 'user-1', 100.00, 'EUR', 'Payment 1', []), new CreatePaymentCommand('payment-2', 'org-456', 'user-2', 200.00, 'USD', 'Payment 2', []), new CreatePaymentCommand('payment-3', 'org-789', 'user-3', 300.00, 'EUR', 'Payment 3', []) ]; foreach ($payments as $command) { $this-&amp;gt;commandHandler-&amp;gt;handle($command); } // Rechercher par organisation $searchQuery = new SearchPaymentsQuery('org-456', 0, 10); $result = $this-&amp;gt;queryHandler-&amp;gt;handle($searchQuery); $this-&amp;gt;assertCount(2, $result-&amp;gt;getPayments()); $this-&amp;gt;assertEquals(2, $result-&amp;gt;getTotal()); }}&lt;/code&gt;## 📊 &lt;strong&gt;Performance et Optimisation&lt;/strong&gt;### &lt;strong&gt;Stratégies d&amp;rsquo;Optimisation CQS&lt;/strong&gt;#### &lt;strong&gt;1. Bulk Operations&lt;/strong&gt;&lt;code&gt;phppublic function bulkStorePayments(array $payments): void{ foreach ($payments as $payment) { $this-&amp;gt;writer-&amp;gt;store( &amp;quot;Payment:{$payment-&amp;gt;getId()}&amp;quot;, $this-&amp;gt;paymentToData($payment), ['organizationId', 'userId', 'status', 'currency'] ); } $this-&amp;gt;writer-&amp;gt;flushBulk();}&lt;/code&gt;#### &lt;strong&gt;2. Cache Stratégique&lt;/strong&gt;&lt;code&gt;phppublic function searchWithCache(SearchPaymentsQuery $query): PaymentSearchResult{ $cacheKey = 'payment_search_' . md5(serialize($query)); if ($cached = $this-&amp;gt;cache-&amp;gt;get($cacheKey)) { return $cached; } $result = $this-&amp;gt;searchPayments($query); $this-&amp;gt;cache-&amp;gt;set($cacheKey, $result, 300); return $result;}&lt;/code&gt;#### &lt;strong&gt;3. Index Optimisés&lt;/strong&gt;&lt;code&gt;phppublic function optimizeIndexes(): void{ // Nettoyer les index orphelins $this-&amp;gt;cleanOrphanedIndexes(); // Compacter les index $this-&amp;gt;compactIndexes(); // Forcer le garbage collection gc_collect_cycles();}&lt;/code&gt;## 🎯 &lt;strong&gt;Critères d&amp;rsquo;Adoption&lt;/strong&gt;### &lt;strong&gt;Quand Utiliser CQS avec In-Memory&lt;/strong&gt;#### &lt;strong&gt;✅ Avantages&lt;/strong&gt;- &lt;strong&gt;Performance optimisée&lt;/strong&gt; : Séparation claire entre écriture et lecture- &lt;strong&gt;Scalabilité&lt;/strong&gt; : Possibilité de scaler indépendamment- &lt;strong&gt;Flexibilité&lt;/strong&gt; : Requêtes optimisées pour chaque usage- &lt;strong&gt;Maintenabilité&lt;/strong&gt; : Code plus clair et organisé- &lt;strong&gt;Cache efficace&lt;/strong&gt; : Mise en cache des requêtes#### &lt;strong&gt;❌ Inconvénients&lt;/strong&gt;- &lt;strong&gt;Complexité&lt;/strong&gt; : Architecture plus complexe- &lt;strong&gt;Volatilité&lt;/strong&gt; : Données perdues au redémarrage- &lt;strong&gt;Limitation mémoire&lt;/strong&gt; : Contraint par la RAM disponible- &lt;strong&gt;Expertise&lt;/strong&gt; : Équipe expérimentée requise#### &lt;strong&gt;🎯 Critères d&amp;rsquo;Adoption&lt;/strong&gt;- &lt;strong&gt;Performance importante&lt;/strong&gt; : Besoins de performance élevée- &lt;strong&gt;Données temporaires&lt;/strong&gt; : Cache, sessions, métriques- &lt;strong&gt;Équipe expérimentée&lt;/strong&gt; : Maîtrise d&amp;rsquo;In-Memory et CQS- &lt;strong&gt;Tests et développement&lt;/strong&gt; : Environnements de test rapides- &lt;strong&gt;Mémoire suffisante&lt;/strong&gt; : RAM disponible pour toutes les données- &lt;strong&gt;Pas de persistance&lt;/strong&gt; : Données temporaires uniquement## 🚀 &lt;strong&gt;Votre Prochaine Étape&lt;/strong&gt;

&lt;div class="chapter-navigation"&gt;
 &lt;h2 class="chapter-nav-title"&gt;🎯 Votre Prochaine Étape&lt;/h2&gt;
 &lt;p class="chapter-nav-subtitle"&gt;Maintenant que vous comprenez les concepts de base et que j'ai partagé mon expérience avec Gyroscops, quel est votre contexte ?&lt;/p&gt;</description></item><item><title>Stockage In-Memory - CQRS</title><link>http://localhost:1313/chapitres/stockage/in-memory/chapitre-42-stockage-in-memory-cqrs/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/in-memory/chapitre-42-stockage-in-memory-cqrs/</guid><description>&lt;h2 id="-contexte-et-objectifs-lnous-arrivons-maintenant-à-lapproche-la-plus-sophistiquée-pour-in-memory--cqrs-complet-cette-combinaison-offre-une-architecture-hautement-scalable-et-flexible-parfaite-pour-les-systèmes-nécessitant-performance-maximale-et-séparation-claire-des-responsabilités-pourquoi-cqrs-avec-in-memory---séparation-totale--commandes-et-requêtes-complètement-découplées--scalabilité-maximale--possibilité-de-scaler-indépendamment-chaque-côté--performance-optimale--chaque-côté-optimisé-pour-son-usage--flexibilité--projections-multiples-pour-différents-besoins--cache-efficace--mise-en-cache-des-requêtes-contexte-gyroscopsdans-notre-écosystème-user--organization--workflow--cloud-resources--billing-cqrs-avec-in-memory-est-idéal-pour---cache-haute-performance--séparation-des-écritures-et-lectures-de-cache--sessions-utilisateur--gestion-optimisée-des-sessions-avec-projections--métriques-en-temps-réel--collecte-et-lecture-des-métriques-avec-analytics--tests-et-développement--environnements-de-test-rapides-et-organisés--architecture-cqrs-avec-in-memory-séparation-complète-des-responsabilités-command-side-write--command-handlers--traitement-des-commandes-métier--in-memory-writer--écriture-optimisée-en-mémoire--event-handlers--gestion-des-événements-de-domaine--command-bus--orchestration-des-commandes--bulk-operations--optimisation-des-écritures-query-side-read--query-handlers--traitement-des-requêtes--in-memory-reader--requêtes-optimisées--search-services--services-de-recherche-spécialisés--query-bus--orchestration-des-requêtes--caches--optimisation-des-performances-flux-de-données-completmermaidgraph-td----acommand----bcommand-bus----b----ccommand-handler----c----din-memory-writer----d----edata-in-ram----e----findex-update--------gquery----hquery-bus----h----iquery-handler----i----jin-memory-reader----j----e----e----ksearch-results----k----lresponse--------mevent----nevent-handler----n----d--------oprojection----pin-memory-writer----p----e--implémentation-complète-1-command-side-implementation-command-bus-avec-middlewarephpphpnamespace-appapplicationcommandbususe-appdomaincommandcommandinterfaceuse-appdomaincommandcommandhandlerinterfaceuse-psrlogloggerinterfaceclass-commandbus----private-array-handlers------private-array-middleware------private-loggerinterface-logger----public-function-__constructloggerinterface-logger------------this-logger--logger--------public-function-registerhandlerstring-commandclass-commandhandlerinterface-handler-void------------this-handlerscommandclass--handler--------public-function-addmiddlewarecallable-middleware-void------------this-middleware--middleware--------public-function-handlecommandinterface-command-void------------commandclass--get_classcommand----------------if-issetthis-handlerscommandclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-command-commandclass----------------handler--this-handlerscommandclass-----------------exécuter-les-middleware--------this-executemiddlewarecommand-function-use-handler-command-------------this-logger-infoexecuting-command-----------------command--get_classcommand----------------data--command-toarray------------------------------------handler-handlecommand----------------private-function-executemiddlewarecommandinterface-command-callable-next-void------------middleware--array_reversethis-middleware----------------foreach-middleware-as-mw-------------next--function-use-mw-command-next-----------------return-mwcommand-next------------------------------------next-----in-memory-writer-avancéphpphpnamespace-appinfrastructureinmemorycommanduse-appinfrastructureinmemoryinmemorystorageuse-appinfrastructureinmemoryinmemoryindexeruse-psrlogloggerinterfaceclass-inmemorywriter----private-inmemorystorage-storage----private-inmemoryindexer-indexer----private-loggerinterface-logger----private-array-bulkbuffer------private-int-bulksize----private-string-routingfield----public-function-__construct--------inmemorystorage-storage--------inmemoryindexer-indexer--------loggerinterface-logger--------int-bulksize--100--------string-routingfield--organizationid-------------this-storage--storage--------this-indexer--indexer--------this-logger--logger--------this-bulksize--bulksize--------this-routingfield--routingfield--------public-function-storestring-key-mixed-value-array-indexfields---string-routing--null-void------------this-bulkbuffer--------------operation--store------------key--key------------value--value------------indexfields--indexfields------------routing--routing----------------if-countthis-bulkbuffer--this-bulksize-------------this-flushbulk----------------public-function-updatestring-key-mixed-value-array-indexfields---string-routing--null-void------------this-bulkbuffer--------------operation--update------------key--key------------value--value------------indexfields--indexfields------------routing--routing----------------if-countthis-bulkbuffer--this-bulksize-------------this-flushbulk----------------public-function-deletestring-key-string-routing--null-void------------this-bulkbuffer--------------operation--delete------------key--key------------routing--routing----------------if-countthis-bulkbuffer--this-bulksize-------------this-flushbulk----------------public-function-flushbulk-void------------if-emptythis-bulkbuffer-------------return----------------try-------------foreach-this-bulkbuffer-as-operation-----------------switch-operationoperation---------------------case-store------------------------this-storage-storeoperationkey-operationvalue------------------------if-emptyoperationindexfields-----------------------------this-indexer-addtoindex--------------------------------this-getentitytypeoperationkey--------------------------------operationkey--------------------------------operationvalue--------------------------------operationindexfields----------------------------------------------------------------------------break--------------------case-update------------------------this-storage-storeoperationkey-operationvalue------------------------if-emptyoperationindexfields-----------------------------this-indexer-removefromindex--------------------------------this-getentitytypeoperationkey--------------------------------operationkey--------------------------------------------------------this-indexer-addtoindex--------------------------------this-getentitytypeoperationkey--------------------------------operationkey--------------------------------operationvalue--------------------------------operationindexfields----------------------------------------------------------------------------break--------------------case-delete------------------------this-indexer-removefromindex----------------------------this-getentitytypeoperationkey----------------------------operationkey------------------------------------------------this-storage-deleteoperationkey------------------------break----------------------------------------this-logger-infobulk-operations-completed-----------------operations--countthis-bulkbuffer------------------------this-bulkbuffer-----------catch-exception-e-------------this-logger-errorbulk-operations-failed-----------------error--e-getmessage----------------operations--countthis-bulkbuffer------------------------throw-e----------------private-function-getentitytypestring-key-string------------parts--explode-key--------return-parts0--unknown-----command-handler-pour-les-paiementsphpphpnamespace-appapplicationcommandpaymentuse-appdomainpaymentpaymentuse-appdomainpaymentpaymentrepositoryinterfaceuse-appinfrastructureinmemorycommandinmemorywriteruse-appdomaineventeventbusinterfaceuse-psrlogloggerinterfaceclass-processpaymentcommandhandler-implements-commandhandlerinterface----public-function-__construct--------private-paymentrepositoryinterface-paymentrepository--------private-inmemorywriter-writer--------private-eventbusinterface-eventbus--------private-loggerinterface-logger---------public-function-handleprocesspaymentcommand-command-void------------try--------------charger-le-paiement------------payment--this-paymentrepository-findbyidcommand-getpaymentid------------------------if-payment-----------------throw-new-invalidargumentexceptionpayment-not-found-command-getpaymentid-------------------------traiter-le-paiement------------payment-processpaymentcommand-getamount-command-getcurrency-------------------------sauvegarder-dans-le-repository-principal------------this-paymentrepository-savepayment-------------indexer-dans-in-memory-pour-la-recherche------------this-indexpaymentforsearchpayment-------------publier-lévénement------------event--new-paymentprocessedevent----------------payment-getid----------------payment-getamount----------------payment-getcurrency----------------payment-getorganizationid------------------------------------this-eventbus-publishevent------------this-logger-infopayment-processed-and-indexed-----------------paymentid--payment-getid----------------organizationid--payment-getorganizationid----------------amount--payment-getamount---------------------catch-exception-e-------------this-logger-errorpayment-processing-failed-----------------paymentid--command-getpaymentid----------------error--e-getmessage------------------------throw-e----------------private-function-indexpaymentforsearchpayment-payment-void------------key--paymentpayment-getid--------document--------------paymentid--payment-getid------------organizationid--payment-getorganizationid------------userid--payment-getuserid------------amount--payment-getamount------------currency--payment-getcurrency------------status--payment-getstatus------------description--payment-getdescription------------processedat--payment-getprocessedat-formatc------------metadata--payment-getmetadata------------indexedat--new-datetime-formatc----------------this-writer-store------------key------------document------------organizationid-userid-status-currency------------payment-getorganizationid-------------2-query-side-implementation-query-bus-avec-cachephpphpnamespace-appapplicationquerybususe-appdomainqueryqueryinterfaceuse-appdomainqueryqueryhandlerinterfaceuse-psrcachecacheitempoolinterfaceuse-psrlogloggerinterfaceclass-querybus----private-array-handlers------private-cacheitempoolinterface-cache----private-loggerinterface-logger----public-function-__constructcacheitempoolinterface-cache-loggerinterface-logger------------this-cache--cache--------this-logger--logger--------public-function-registerhandlerstring-queryclass-queryhandlerinterface-handler-void------------this-handlersqueryclass--handler--------public-function-handlequeryinterface-query-mixed------------queryclass--get_classquery----------------if-issetthis-handlersqueryclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-query-queryclass-----------------vérifier-le-cache--------cachekey--this-generatecachekeyquery--------cacheditem--this-cache-getitemcachekey----------------if-cacheditem-ishit-------------this-logger-debugquery-result-served-from-cache-----------------query--queryclass----------------cachekey--cachekey------------------------------------return-cacheditem-get-----------------exécuter-la-requête--------handler--this-handlersqueryclass--------result--handler-handlequery-----------------mettre-en-cache--------cacheditem-setresult--------cacheditem-expiresafter300--5-minutes--------this-cache-savecacheditem----------------this-logger-infoquery-executed-and-cached-------------query--queryclass------------cachekey--cachekey------------------------return-result--------private-function-generatecachekeyqueryinterface-query-string------------return-query_--md5serializequery-----in-memory-reader-avancéphpphpnamespace-appinfrastructureinmemoryqueryuse-appinfrastructureinmemoryinmemorystorageuse-appinfrastructureinmemoryinmemoryindexeruse-psrlogloggerinterfaceuse-psrcachecacheitempoolinterfaceclass-inmemoryreader----private-inmemorystorage-storage----private-inmemoryindexer-indexer----private-loggerinterface-logger----private-cacheitempoolinterface-cache----public-function-__construct--------inmemorystorage-storage--------inmemoryindexer-indexer--------loggerinterface-logger--------cacheitempoolinterface-cache-------------this-storage--storage--------this-indexer--indexer--------this-logger--logger--------this-cache--cache--------public-function-getstring-key-string-cachekey--null-mixed-------------vérifier-le-cache--------if-cachekey-------------cacheditem--this-cache-getitemcachekey------------if-cacheditem-ishit-----------------this-logger-debugdata-served-from-cache---------------------key--key--------------------cachekey--cachekey--------------------------------return-cacheditem-get----------------------------data--this-storage-getkey---------mettre-en-cache--------if-cachekey--data--null-------------cacheditem-setdata------------cacheditem-expiresafter300--5-minutes------------this-cache-savecacheditem----------------return-data--------public-function-searcharray-query-string-cachekey--null-array-------------vérifier-le-cache--------if-cachekey-------------cacheditem--this-cache-getitemcachekey------------if-cacheditem-ishit-----------------this-logger-debugsearch-result-served-from-cache---------------------query--query--------------------cachekey--cachekey--------------------------------return-cacheditem-get----------------------------results--this-performsearchquery---------mettre-en-cache--------if-cachekey-------------cacheditem-setresults------------cacheditem-expiresafter300--5-minutes------------this-cache-savecacheditem----------------this-logger-infosearch-executed-------------query--query------------results--countresults----------------return-results--------public-function-getdocumentstring-id-string-routing--null-array------------key--this-generatekeyid--------data--this-storage-getkey----------------return-data--null--------public-function-getsuggestionsstring-query-string-field--description-int-size--10-array------------results--this-search------------field--field------------text--query------------size--size----------------suggestions----------foreach-results-as-result-------------suggestions------------------text--resultfield------------------score--10----------------------------return-suggestions--------public-function-getanalyticsarray-query-array------------results--this-performsearchquery----------------analytics--------------total--countresults------------bystatus--------------bycurrency--------------totalamount--0------------------------foreach-results-as-result-------------status--resultstatus--unknown------------currency--resultcurrency--unknown------------amount--resultamount--0------------------------analyticsbystatusstatus--analyticsbystatusstatus--0--1------------analyticsbycurrencycurrency--analyticsbycurrencycurrency--0--1------------analyticstotalamount--amount------------------------return-analytics--------private-function-performsearcharray-query-array------------results----------alldata--this-storage-getall--------foreach-alldata-as-key--value-------------if-this-matchesqueryvalue-query-----------------results--value----------------------------return-results--------private-function-matchesquerymixed-value-array-query-bool------------foreach-query-as-field--expectedvalue-------------if-this-fieldmatchesvalue-field-expectedvalue-----------------return-false----------------------------return-true--------private-function-fieldmatchesmixed-value-string-field-mixed-expectedvalue-bool------------fieldvalue--this-getfieldvaluevalue-field----------------if-is_arrayexpectedvalue-------------return-in_arrayfieldvalue-expectedvalue----------------return-fieldvalue--expectedvalue--------private-function-getfieldvaluemixed-value-string-field-mixed------------if-is_arrayvalue-------------return-valuefield--null----------------if-is_objectvalue-------------return-value-field--null----------------return-null--------private-function-generatekeystring-id-string------------return-paymentid-----query-handler-pour-les-paiementsphpphpnamespace-appapplicationquerypaymentuse-appinfrastructureinmemoryqueryinmemoryreaderuse-appdomainpaymentpaymentuse-psrlogloggerinterfaceclass-paymentqueryhandler-implements-queryhandlerinterface----private-inmemoryreader-reader----private-loggerinterface-logger----public-function-__constructinmemoryreader-reader-loggerinterface-logger------------this-reader--reader--------this-logger--logger--------public-function-handlegetpaymentbyidquery-query-payment------------data--this-reader-getdocumentquery-getpaymentid----------------if-data-------------return-null------------------------return-this-datatopaymentdata--------public-function-handlesearchpaymentsquery-query-paymentsearchresult------------searchquery--this-buildsearchqueryquery--------cachekey--this-generatecachekeyquery----------------results--this-reader-searchsearchquery-cachekey----------------payments----------foreach-results-as-data-------------payments--this-datatopaymentdata------------------------return-new-paymentsearchresult------------payments------------countpayments------------query-getpage------------query-getsize----------------public-function-handlegetpaymentstatisticsquery-query-array------------searchquery--------------organizationid--query-getorganizationid------------------------if-query-getfrom--query-getto-------------searchqueryprocessedat------------------gte--query-getfrom-formatc----------------lte--query-getto-formatc------------------------------------return-this-reader-getanalyticssearchquery--------public-function-handlegetpaymentsuggestionsquery-query-array------------return-this-reader-getsuggestions------------query-getquery------------description------------query-getsize----------------private-function-buildsearchquerysearchpaymentsquery-query-array------------searchquery------------------if-query-getorganizationid-------------searchqueryorganizationid--query-getorganizationid------------------------if-query-getstatuses-------------searchquerystatus--query-getstatuses------------------------if-query-getcurrencies-------------searchquerycurrency--query-getcurrencies------------------------if-query-getminamount--query-getmaxamount-------------searchqueryamount--------------if-query-getminamount-----------------searchqueryamountgte--query-getminamount------------------------if-query-getmaxamount-----------------searchqueryamountlte--query-getmaxamount------------------------------------return-searchquery--------private-function-generatecachekeysearchpaymentsquery-query-string------------return-payment_search_--md5serializequery--------private-function-datatopaymentarray-data-payment------------return-new-payment------------datapaymentid------------dataorganizationid------------datauserid------------dataamount------------datacurrency------------datastatus------------datadescription------------new-datetimedataprocessedat------------datametadata---------------3-service-de-projection-service-de-projection-pour-les-analyticsphpphpnamespace-appapplicationserviceinmemoryuse-appdomaineventdomaineventuse-appinfrastructureinmemorycommandinmemorywriteruse-psrlogloggerinterfaceclass-paymentprojectionservice----private-inmemorywriter-writer----private-loggerinterface-logger----public-function-__constructinmemorywriter-writer-loggerinterface-logger------------this-writer--writer--------this-logger--logger--------public-function-handleeventdomainevent-event-void------------switch-event-geteventtype-------------case-paymentprocessed----------------this-handlepaymentprocessedevent----------------break------------case-paymentfailed----------------this-handlepaymentfailedevent----------------break------------case-paymentrefunded----------------this-handlepaymentrefundedevent----------------break----------------private-function-handlepaymentprocesseddomainevent-event-void------------key--paymentevent-getaggregateid--------update--------------status--completed------------processedat--event-gettimestamp-formatc------------updatedat--new-datetime-formatc----------------this-writer-updatekey-update-status--------this-logger-infopayment-processed-projection-updated-------------paymentid--event-getaggregateid------------status--completed----------------private-function-handlepaymentfaileddomainevent-event-void------------key--paymentevent-getaggregateid--------update--------------status--failed------------error--event-getdataerror------------failedat--event-gettimestamp-formatc------------updatedat--new-datetime-formatc----------------this-writer-updatekey-update-status--------this-logger-infopayment-failed-projection-updated-------------paymentid--event-getaggregateid------------status--failed----------------private-function-handlepaymentrefundeddomainevent-event-void------------key--paymentevent-getaggregateid--------update--------------status--refunded------------refundamount--event-getdatarefundamount------------refundedat--event-gettimestamp-formatc------------updatedat--new-datetime-formatc----------------this-writer-updatekey-update-status--------this-logger-infopayment-refunded-projection-updated-------------paymentid--event-getaggregateid------------status--refunded--------------tests-et-validation-tests-dphpphpnamespace-apptestsintegrationinmemoryuse-appapplicationcommandpaymentprocesspaymentcommanduse-appapplicationcommandpaymentprocesspaymentcommandhandleruse-appapplicationquerypaymentgetpaymentbyidqueryuse-appapplicationquerypaymentsearchpaymentsqueryuse-appapplicationquerypaymentpaymentqueryhandleruse-appinfrastructureinmemorycommandinmemorywriteruse-appinfrastructureinmemoryqueryinmemoryreaderuse-appinfrastructureinmemoryinmemorystorageuse-appinfrastructureinmemoryinmemoryindexerclass-inmemorycqrstest-extends-testcase----private-inmemorywriter-writer----private-inmemoryreader-reader----private-processpaymentcommandhandler-commandhandler----private-paymentqueryhandler-queryhandler----protected-function-setup-void------------storage--new-inmemorystorage--------indexer--new-inmemoryindexer----------------this-writer--new-inmemorywriterstorage-indexer-this-createmockloggerinterfaceclass--------this-reader--new-inmemoryreaderstorage-indexer-this-createmockloggerinterfaceclass-this-createmockcacheitempoolinterfaceclass----------------this-commandhandler--new-processpaymentcommandhandler------------this-createmockpaymentrepositoryinterfaceclass------------this-writer------------this-createmockeventbusinterfaceclass------------this-createmockloggerinterfaceclass------------------------this-queryhandler--new-paymentqueryhandlerthis-reader-this-createmockloggerinterfaceclass--------public-function-testcqrsseparation-void-------------exécuter-une-commande--------command--new-processpaymentcommand------------payment-123------------10000------------eur------------org-456------------------------this-commandhandler-handlecommand-----------------vérifier-avec-une-requête--------query--new-getpaymentbyidquerypayment-123--------payment--this-queryhandler-handlequery----------------this-assertnotnullpayment--------this-assertequalspayment-123-payment-getid--------this-assertequals10000-payment-getamount--------public-function-testsearchwithanalytics-void-------------créer-plusieurs-paiements--------payments--------------new-processpaymentcommandpayment-1-10000-eur-org-456------------new-processpaymentcommandpayment-2-20000-usd-org-456------------new-processpaymentcommandpayment-3-30000-eur-org-789------------------------foreach-payments-as-command-------------this-commandhandler-handlecommand-------------------------rechercher-avec-analytics--------searchquery--new-searchpaymentsqueryorg-456-0-10--------result--this-queryhandler-handlesearchquery----------------this-assertcount2-result-getpayments--------this-assertequals2-result-gettotal------performance-et-optimisation-stratégies-d-1-cache-multi-niveauxphppublic-function-searchwithmultilevelcachesearchpaymentsquery-query-paymentsearchresult-----cache-l1-mémoire----if-issetthis-memorycachequery-getcachekey---------return-this-memorycachequery-getcachekey-------------cache-l2-redis----cached--this-redis-getpayment_searchquery-getcachekey----if-cached---------result--paymentsearchresultfromarrayjson_decodecached-true--------this-memorycachequery-getcachekey--result--------return-result-------------in-memory----result--this-searchpaymentsquery---------mettre-en-cache----this-memorycachequery-getcachekey--result----this-redis-setexpayment_searchquery-getcachekey-300-json_encoderesult-toarray--------return-result-2-projections-asynchronesphppublic-function-handleeventasyncdomainevent-event-void-----mettre-en-queue-pour-traitement-asynchrone----this-messagebus-dispatchnew-processprojectioncommandevent-3-index-optimisésphppublic-function-optimizeindexes-void-----nettoyer-les-index-orphelins----this-cleanorphanedindexes---------compacter-les-index----this-compactindexes---------forcer-le-garbage-collection----gc_collect_cycles--critères-d-quand-utiliser-cqrs-avec-in-memory--avantages--scalabilité-maximale--possibilité-de-scaler-indépendamment--performance-optimale--chaque-côté-optimisé-pour-son-usage--flexibilité--projections-multiples-pour-différents-besoins--cache-efficace--mise-en-cache-des-requêtes--maintenabilité--code-plus-clair-et-organisé--inconvénients--complexité-maximale--architecture-très-complexe--volatilité--données-perdues-au-redémarrage--limitation-mémoire--contraint-par-la-ram-disponible--expertise--équipe-très-expérimentée-requise--critères-d--système-très-complexe--besoins-de-scalabilité-maximale--performance-critique--besoins-de-performance-maximale--données-temporaires--cache-sessions-métriques--équipe-très-expérimentée--maîtrise-din-memory-et-cqrs--tests-et-développement--environnements-de-test-rapides--mémoire-suffisante--ram-disponible-pour-toutes-les-données--votre-prochaine-étapehahahugoshortcode32s0hbhbcqrs-avec-in-memory-représente-l"&gt;🎯 &lt;strong&gt;Contexte et Objectifs&lt;/strong&gt;### &lt;strong&gt;L&amp;rsquo;Approche CQRS Complète avec In-Memory&lt;/strong&gt;Nous arrivons maintenant à l&amp;rsquo;approche la plus sophistiquée pour In-Memory : &lt;strong&gt;CQRS complet&lt;/strong&gt;. Cette combinaison offre une architecture hautement scalable et flexible, parfaite pour les systèmes nécessitant performance maximale et séparation claire des responsabilités.#### &lt;strong&gt;Pourquoi CQRS avec In-Memory ?&lt;/strong&gt;- &lt;strong&gt;Séparation totale&lt;/strong&gt; : Commandes et requêtes complètement découplées- &lt;strong&gt;Scalabilité maximale&lt;/strong&gt; : Possibilité de scaler indépendamment chaque côté- &lt;strong&gt;Performance optimale&lt;/strong&gt; : Chaque côté optimisé pour son usage- &lt;strong&gt;Flexibilité&lt;/strong&gt; : Projections multiples pour différents besoins- &lt;strong&gt;Cache efficace&lt;/strong&gt; : Mise en cache des requêtes### &lt;strong&gt;Contexte Gyroscops&lt;/strong&gt;Dans notre écosystème &lt;strong&gt;User → Organization → Workflow → Cloud Resources → Billing&lt;/strong&gt;, CQRS avec In-Memory est idéal pour :- &lt;strong&gt;Cache haute performance&lt;/strong&gt; : Séparation des écritures et lectures de cache- &lt;strong&gt;Sessions utilisateur&lt;/strong&gt; : Gestion optimisée des sessions avec projections- &lt;strong&gt;Métriques en temps réel&lt;/strong&gt; : Collecte et lecture des métriques avec analytics- &lt;strong&gt;Tests et développement&lt;/strong&gt; : Environnements de test rapides et organisés## 🏗️ &lt;strong&gt;Architecture CQRS avec In-Memory&lt;/strong&gt;### &lt;strong&gt;Séparation Complète des Responsabilités&lt;/strong&gt;#### &lt;strong&gt;Command Side (Write)&lt;/strong&gt;- &lt;strong&gt;Command Handlers&lt;/strong&gt; : Traitement des commandes métier- &lt;strong&gt;In-Memory Writer&lt;/strong&gt; : Écriture optimisée en mémoire- &lt;strong&gt;Event Handlers&lt;/strong&gt; : Gestion des événements de domaine- &lt;strong&gt;Command Bus&lt;/strong&gt; : Orchestration des commandes- &lt;strong&gt;Bulk Operations&lt;/strong&gt; : Optimisation des écritures#### &lt;strong&gt;Query Side (Read)&lt;/strong&gt;- &lt;strong&gt;Query Handlers&lt;/strong&gt; : Traitement des requêtes- &lt;strong&gt;In-Memory Reader&lt;/strong&gt; : Requêtes optimisées- &lt;strong&gt;Search Services&lt;/strong&gt; : Services de recherche spécialisés- &lt;strong&gt;Query Bus&lt;/strong&gt; : Orchestration des requêtes- &lt;strong&gt;Caches&lt;/strong&gt; : Optimisation des performances### &lt;strong&gt;Flux de Données Complet&lt;/strong&gt;&lt;code&gt;mermaidgraph TD A[Command] --&amp;gt; B[Command Bus] B --&amp;gt; C[Command Handler] C --&amp;gt; D[In-Memory Writer] D --&amp;gt; E[Data in RAM] E --&amp;gt; F[Index Update] G[Query] --&amp;gt; H[Query Bus] H --&amp;gt; I[Query Handler] I --&amp;gt; J[In-Memory Reader] J --&amp;gt; E E --&amp;gt; K[Search Results] K --&amp;gt; L[Response] M[Event] --&amp;gt; N[Event Handler] N --&amp;gt; D O[Projection] --&amp;gt; P[In-Memory Writer] P --&amp;gt; E&lt;/code&gt;## 💻 &lt;strong&gt;Implémentation Complète&lt;/strong&gt;### &lt;strong&gt;1. Command Side Implementation&lt;/strong&gt;#### &lt;strong&gt;Command Bus avec Middleware&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\CommandBus;use App\Domain\Command\CommandInterface;use App\Domain\Command\CommandHandlerInterface;use Psr\Log\LoggerInterface;class CommandBus{ private array $handlers = []; private array $middleware = []; private LoggerInterface $logger; public function __construct(LoggerInterface $logger) { $this-&amp;gt;logger = $logger; } public function registerHandler(string $commandClass, CommandHandlerInterface $handler): void { $this-&amp;gt;handlers[$commandClass] = $handler; } public function addMiddleware(callable $middleware): void { $this-&amp;gt;middleware[] = $middleware; } public function handle(CommandInterface $command): void { $commandClass = get_class($command); if (!isset($this-&amp;gt;handlers[$commandClass])) { throw new \InvalidArgumentException(&amp;quot;No handler registered for command: $commandClass&amp;quot;); } $handler = $this-&amp;gt;handlers[$commandClass]; // Exécuter les middleware $this-&amp;gt;executeMiddleware($command, function() use ($handler, $command) { $this-&amp;gt;logger-&amp;gt;info('Executing command', [ 'command' =&amp;gt; get_class($command), 'data' =&amp;gt; $command-&amp;gt;toArray() ]); $handler-&amp;gt;handle($command); }); } private function executeMiddleware(CommandInterface $command, callable $next): void { $middleware = array_reverse($this-&amp;gt;middleware); foreach ($middleware as $mw) { $next = function() use ($mw, $command, $next) { return $mw($command, $next); }; } $next(); }}&lt;/code&gt;#### &lt;strong&gt;In-Memory Writer Avancé&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Infrastructure\InMemory\Command;use App\Infrastructure\InMemory\InMemoryStorage;use App\Infrastructure\InMemory\InMemoryIndexer;use Psr\Log\LoggerInterface;class InMemoryWriter{ private InMemoryStorage $storage; private InMemoryIndexer $indexer; private LoggerInterface $logger; private array $bulkBuffer = []; private int $bulkSize; private string $routingField; public function __construct( InMemoryStorage $storage, InMemoryIndexer $indexer, LoggerInterface $logger, int $bulkSize = 100, string $routingField = 'organizationId' ) { $this-&amp;gt;storage = $storage; $this-&amp;gt;indexer = $indexer; $this-&amp;gt;logger = $logger; $this-&amp;gt;bulkSize = $bulkSize; $this-&amp;gt;routingField = $routingField; } public function store(string $key, mixed $value, array $indexFields = [], string $routing = null): void { $this-&amp;gt;bulkBuffer[] = [ 'operation' =&amp;gt; 'store', 'key' =&amp;gt; $key, 'value' =&amp;gt; $value, 'indexFields' =&amp;gt; $indexFields, 'routing' =&amp;gt; $routing ]; if (count($this-&amp;gt;bulkBuffer) &amp;gt;= $this-&amp;gt;bulkSize) { $this-&amp;gt;flushBulk(); } } public function update(string $key, mixed $value, array $indexFields = [], string $routing = null): void { $this-&amp;gt;bulkBuffer[] = [ 'operation' =&amp;gt; 'update', 'key' =&amp;gt; $key, 'value' =&amp;gt; $value, 'indexFields' =&amp;gt; $indexFields, 'routing' =&amp;gt; $routing ]; if (count($this-&amp;gt;bulkBuffer) &amp;gt;= $this-&amp;gt;bulkSize) { $this-&amp;gt;flushBulk(); } } public function delete(string $key, string $routing = null): void { $this-&amp;gt;bulkBuffer[] = [ 'operation' =&amp;gt; 'delete', 'key' =&amp;gt; $key, 'routing' =&amp;gt; $routing ]; if (count($this-&amp;gt;bulkBuffer) &amp;gt;= $this-&amp;gt;bulkSize) { $this-&amp;gt;flushBulk(); } } public function flushBulk(): void { if (empty($this-&amp;gt;bulkBuffer)) { return; } try { foreach ($this-&amp;gt;bulkBuffer as $operation) { switch ($operation['operation']) { case 'store': $this-&amp;gt;storage-&amp;gt;store($operation['key'], $operation['value']); if (!empty($operation['indexFields'])) { $this-&amp;gt;indexer-&amp;gt;addToIndex( $this-&amp;gt;getEntityType($operation['key']), $operation['key'], $operation['value'], $operation['indexFields'] ); } break; case 'update': $this-&amp;gt;storage-&amp;gt;store($operation['key'], $operation['value']); if (!empty($operation['indexFields'])) { $this-&amp;gt;indexer-&amp;gt;removeFromIndex( $this-&amp;gt;getEntityType($operation['key']), $operation['key'] ); $this-&amp;gt;indexer-&amp;gt;addToIndex( $this-&amp;gt;getEntityType($operation['key']), $operation['key'], $operation['value'], $operation['indexFields'] ); } break; case 'delete': $this-&amp;gt;indexer-&amp;gt;removeFromIndex( $this-&amp;gt;getEntityType($operation['key']), $operation['key'] ); $this-&amp;gt;storage-&amp;gt;delete($operation['key']); break; } } $this-&amp;gt;logger-&amp;gt;info('Bulk operations completed', [ 'operations' =&amp;gt; count($this-&amp;gt;bulkBuffer) ]); $this-&amp;gt;bulkBuffer = []; } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Bulk operations failed', [ 'error' =&amp;gt; $e-&amp;gt;getMessage(), 'operations' =&amp;gt; count($this-&amp;gt;bulkBuffer) ]); throw $e; } } private function getEntityType(string $key): string { $parts = explode(':', $key); return $parts[0] ?? 'Unknown'; }}&lt;/code&gt;#### &lt;strong&gt;Command Handler pour les Paiements&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Command\Payment;use App\Domain\Payment\Payment;use App\Domain\Payment\PaymentRepositoryInterface;use App\Infrastructure\InMemory\Command\InMemoryWriter;use App\Domain\Event\EventBusInterface;use Psr\Log\LoggerInterface;class ProcessPaymentCommandHandler implements CommandHandlerInterface{ public function __construct( private PaymentRepositoryInterface $paymentRepository, private InMemoryWriter $writer, private EventBusInterface $eventBus, private LoggerInterface $logger ) {} public function handle(ProcessPaymentCommand $command): void { try { // Charger le paiement $payment = $this-&amp;gt;paymentRepository-&amp;gt;findById($command-&amp;gt;getPaymentId()); if (!$payment) { throw new \InvalidArgumentException(&amp;quot;Payment not found: {$command-&amp;gt;getPaymentId()}&amp;quot;); } // Traiter le paiement $payment-&amp;gt;processPayment($command-&amp;gt;getAmount(), $command-&amp;gt;getCurrency()); // Sauvegarder dans le repository principal $this-&amp;gt;paymentRepository-&amp;gt;save($payment); // Indexer dans In-Memory pour la recherche $this-&amp;gt;indexPaymentForSearch($payment); // Publier l'événement $event = new PaymentProcessedEvent( $payment-&amp;gt;getId(), $payment-&amp;gt;getAmount(), $payment-&amp;gt;getCurrency(), $payment-&amp;gt;getOrganizationId() ); $this-&amp;gt;eventBus-&amp;gt;publish($event); $this-&amp;gt;logger-&amp;gt;info('Payment processed and indexed', [ 'paymentId' =&amp;gt; $payment-&amp;gt;getId(), 'organizationId' =&amp;gt; $payment-&amp;gt;getOrganizationId(), 'amount' =&amp;gt; $payment-&amp;gt;getAmount() ]); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Payment processing failed', [ 'paymentId' =&amp;gt; $command-&amp;gt;getPaymentId(), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } private function indexPaymentForSearch(Payment $payment): void { $key = &amp;quot;Payment:{$payment-&amp;gt;getId()}&amp;quot;; $document = [ 'paymentId' =&amp;gt; $payment-&amp;gt;getId(), 'organizationId' =&amp;gt; $payment-&amp;gt;getOrganizationId(), 'userId' =&amp;gt; $payment-&amp;gt;getUserId(), 'amount' =&amp;gt; $payment-&amp;gt;getAmount(), 'currency' =&amp;gt; $payment-&amp;gt;getCurrency(), 'status' =&amp;gt; $payment-&amp;gt;getStatus(), 'description' =&amp;gt; $payment-&amp;gt;getDescription(), 'processedAt' =&amp;gt; $payment-&amp;gt;getProcessedAt()-&amp;gt;format('c'), 'metadata' =&amp;gt; $payment-&amp;gt;getMetadata(), 'indexedAt' =&amp;gt; (new \DateTime())-&amp;gt;format('c') ]; $this-&amp;gt;writer-&amp;gt;store( $key, $document, ['organizationId', 'userId', 'status', 'currency'], $payment-&amp;gt;getOrganizationId() ); }}&lt;/code&gt;### &lt;strong&gt;2. Query Side Implementation&lt;/strong&gt;#### &lt;strong&gt;Query Bus avec Cache&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\QueryBus;use App\Domain\Query\QueryInterface;use App\Domain\Query\QueryHandlerInterface;use Psr\Cache\CacheItemPoolInterface;use Psr\Log\LoggerInterface;class QueryBus{ private array $handlers = []; private CacheItemPoolInterface $cache; private LoggerInterface $logger; public function __construct(CacheItemPoolInterface $cache, LoggerInterface $logger) { $this-&amp;gt;cache = $cache; $this-&amp;gt;logger = $logger; } public function registerHandler(string $queryClass, QueryHandlerInterface $handler): void { $this-&amp;gt;handlers[$queryClass] = $handler; } public function handle(QueryInterface $query): mixed { $queryClass = get_class($query); if (!isset($this-&amp;gt;handlers[$queryClass])) { throw new \InvalidArgumentException(&amp;quot;No handler registered for query: $queryClass&amp;quot;); } // Vérifier le cache $cacheKey = $this-&amp;gt;generateCacheKey($query); $cachedItem = $this-&amp;gt;cache-&amp;gt;getItem($cacheKey); if ($cachedItem-&amp;gt;isHit()) { $this-&amp;gt;logger-&amp;gt;debug('Query result served from cache', [ 'query' =&amp;gt; $queryClass, 'cacheKey' =&amp;gt; $cacheKey ]); return $cachedItem-&amp;gt;get(); } // Exécuter la requête $handler = $this-&amp;gt;handlers[$queryClass]; $result = $handler-&amp;gt;handle($query); // Mettre en cache $cachedItem-&amp;gt;set($result); $cachedItem-&amp;gt;expiresAfter(300); // 5 minutes $this-&amp;gt;cache-&amp;gt;save($cachedItem); $this-&amp;gt;logger-&amp;gt;info('Query executed and cached', [ 'query' =&amp;gt; $queryClass, 'cacheKey' =&amp;gt; $cacheKey ]); return $result; } private function generateCacheKey(QueryInterface $query): string { return 'query_' . md5(serialize($query)); }}&lt;/code&gt;#### &lt;strong&gt;In-Memory Reader Avancé&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Infrastructure\InMemory\Query;use App\Infrastructure\InMemory\InMemoryStorage;use App\Infrastructure\InMemory\InMemoryIndexer;use Psr\Log\LoggerInterface;use Psr\Cache\CacheItemPoolInterface;class InMemoryReader{ private InMemoryStorage $storage; private InMemoryIndexer $indexer; private LoggerInterface $logger; private CacheItemPoolInterface $cache; public function __construct( InMemoryStorage $storage, InMemoryIndexer $indexer, LoggerInterface $logger, CacheItemPoolInterface $cache ) { $this-&amp;gt;storage = $storage; $this-&amp;gt;indexer = $indexer; $this-&amp;gt;logger = $logger; $this-&amp;gt;cache = $cache; } public function get(string $key, string $cacheKey = null): mixed { // Vérifier le cache if ($cacheKey) { $cachedItem = $this-&amp;gt;cache-&amp;gt;getItem($cacheKey); if ($cachedItem-&amp;gt;isHit()) { $this-&amp;gt;logger-&amp;gt;debug('Data served from cache', [ 'key' =&amp;gt; $key, 'cacheKey' =&amp;gt; $cacheKey ]); return $cachedItem-&amp;gt;get(); } } $data = $this-&amp;gt;storage-&amp;gt;get($key); // Mettre en cache if ($cacheKey &amp;amp;&amp;amp; $data !== null) { $cachedItem-&amp;gt;set($data); $cachedItem-&amp;gt;expiresAfter(300); // 5 minutes $this-&amp;gt;cache-&amp;gt;save($cachedItem); } return $data; } public function search(array $query, string $cacheKey = null): array { // Vérifier le cache if ($cacheKey) { $cachedItem = $this-&amp;gt;cache-&amp;gt;getItem($cacheKey); if ($cachedItem-&amp;gt;isHit()) { $this-&amp;gt;logger-&amp;gt;debug('Search result served from cache', [ 'query' =&amp;gt; $query, 'cacheKey' =&amp;gt; $cacheKey ]); return $cachedItem-&amp;gt;get(); } } $results = $this-&amp;gt;performSearch($query); // Mettre en cache if ($cacheKey) { $cachedItem-&amp;gt;set($results); $cachedItem-&amp;gt;expiresAfter(300); // 5 minutes $this-&amp;gt;cache-&amp;gt;save($cachedItem); } $this-&amp;gt;logger-&amp;gt;info('Search executed', [ 'query' =&amp;gt; $query, 'results' =&amp;gt; count($results) ]); return $results; } public function getDocument(string $id, string $routing = null): ?array { $key = $this-&amp;gt;generateKey($id); $data = $this-&amp;gt;storage-&amp;gt;get($key); return $data ?: null; } public function getSuggestions(string $query, string $field = 'description', int $size = 10): array { $results = $this-&amp;gt;search([ 'field' =&amp;gt; $field, 'text' =&amp;gt; $query, 'size' =&amp;gt; $size ]); $suggestions = []; foreach ($results as $result) { $suggestions[] = [ 'text' =&amp;gt; $result[$field] ?? '', 'score' =&amp;gt; 1.0 ]; } return $suggestions; } public function getAnalytics(array $query): array { $results = $this-&amp;gt;performSearch($query); $analytics = [ 'total' =&amp;gt; count($results), 'byStatus' =&amp;gt; [], 'byCurrency' =&amp;gt; [], 'totalAmount' =&amp;gt; 0 ]; foreach ($results as $result) { $status = $result['status'] ?? 'unknown'; $currency = $result['currency'] ?? 'unknown'; $amount = $result['amount'] ?? 0; $analytics['byStatus'][$status] = ($analytics['byStatus'][$status] ?? 0) + 1; $analytics['byCurrency'][$currency] = ($analytics['byCurrency'][$currency] ?? 0) + 1; $analytics['totalAmount'] += $amount; } return $analytics; } private function performSearch(array $query): array { $results = []; $allData = $this-&amp;gt;storage-&amp;gt;getAll(); foreach ($allData as $key =&amp;gt; $value) { if ($this-&amp;gt;matchesQuery($value, $query)) { $results[] = $value; } } return $results; } private function matchesQuery(mixed $value, array $query): bool { foreach ($query as $field =&amp;gt; $expectedValue) { if (!$this-&amp;gt;fieldMatches($value, $field, $expectedValue)) { return false; } } return true; } private function fieldMatches(mixed $value, string $field, mixed $expectedValue): bool { $fieldValue = $this-&amp;gt;getFieldValue($value, $field); if (is_array($expectedValue)) { return in_array($fieldValue, $expectedValue); } return $fieldValue === $expectedValue; } private function getFieldValue(mixed $value, string $field): mixed { if (is_array($value)) { return $value[$field] ?? null; } if (is_object($value)) { return $value-&amp;gt;$field ?? null; } return null; } private function generateKey(string $id): string { return &amp;quot;Payment:{$id}&amp;quot;; }}&lt;/code&gt;#### &lt;strong&gt;Query Handler pour les Paiements&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Query\Payment;use App\Infrastructure\InMemory\Query\InMemoryReader;use App\Domain\Payment\Payment;use Psr\Log\LoggerInterface;class PaymentQueryHandler implements QueryHandlerInterface{ private InMemoryReader $reader; private LoggerInterface $logger; public function __construct(InMemoryReader $reader, LoggerInterface $logger) { $this-&amp;gt;reader = $reader; $this-&amp;gt;logger = $logger; } public function handle(GetPaymentByIdQuery $query): ?Payment { $data = $this-&amp;gt;reader-&amp;gt;getDocument($query-&amp;gt;getPaymentId()); if (!$data) { return null; } return $this-&amp;gt;dataToPayment($data); } public function handle(SearchPaymentsQuery $query): PaymentSearchResult { $searchQuery = $this-&amp;gt;buildSearchQuery($query); $cacheKey = $this-&amp;gt;generateCacheKey($query); $results = $this-&amp;gt;reader-&amp;gt;search($searchQuery, $cacheKey); $payments = []; foreach ($results as $data) { $payments[] = $this-&amp;gt;dataToPayment($data); } return new PaymentSearchResult( $payments, count($payments), $query-&amp;gt;getPage(), $query-&amp;gt;getSize() ); } public function handle(GetPaymentStatisticsQuery $query): array { $searchQuery = [ 'organizationId' =&amp;gt; $query-&amp;gt;getOrganizationId() ]; if ($query-&amp;gt;getFrom() &amp;amp;&amp;amp; $query-&amp;gt;getTo()) { $searchQuery['processedAt'] = [ 'gte' =&amp;gt; $query-&amp;gt;getFrom()-&amp;gt;format('c'), 'lte' =&amp;gt; $query-&amp;gt;getTo()-&amp;gt;format('c') ]; } return $this-&amp;gt;reader-&amp;gt;getAnalytics($searchQuery); } public function handle(GetPaymentSuggestionsQuery $query): array { return $this-&amp;gt;reader-&amp;gt;getSuggestions( $query-&amp;gt;getQuery(), 'description', $query-&amp;gt;getSize() ); } private function buildSearchQuery(SearchPaymentsQuery $query): array { $searchQuery = []; if ($query-&amp;gt;getOrganizationId()) { $searchQuery['organizationId'] = $query-&amp;gt;getOrganizationId(); } if ($query-&amp;gt;getStatuses()) { $searchQuery['status'] = $query-&amp;gt;getStatuses(); } if ($query-&amp;gt;getCurrencies()) { $searchQuery['currency'] = $query-&amp;gt;getCurrencies(); } if ($query-&amp;gt;getMinAmount() || $query-&amp;gt;getMaxAmount()) { $searchQuery['amount'] = []; if ($query-&amp;gt;getMinAmount()) { $searchQuery['amount']['gte'] = $query-&amp;gt;getMinAmount(); } if ($query-&amp;gt;getMaxAmount()) { $searchQuery['amount']['lte'] = $query-&amp;gt;getMaxAmount(); } } return $searchQuery; } private function generateCacheKey(SearchPaymentsQuery $query): string { return 'payment_search_' . md5(serialize($query)); } private function dataToPayment(array $data): Payment { return new Payment( $data['paymentId'], $data['organizationId'], $data['userId'], $data['amount'], $data['currency'], $data['status'], $data['description'], new \DateTime($data['processedAt']), $data['metadata'] ?? [] ); }}&lt;/code&gt;### &lt;strong&gt;3. Service de Projection&lt;/strong&gt;#### &lt;strong&gt;Service de Projection pour les Analytics&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Service\InMemory;use App\Domain\Event\DomainEvent;use App\Infrastructure\InMemory\Command\InMemoryWriter;use Psr\Log\LoggerInterface;class PaymentProjectionService{ private InMemoryWriter $writer; private LoggerInterface $logger; public function __construct(InMemoryWriter $writer, LoggerInterface $logger) { $this-&amp;gt;writer = $writer; $this-&amp;gt;logger = $logger; } public function handleEvent(DomainEvent $event): void { switch ($event-&amp;gt;getEventType()) { case 'PaymentProcessed': $this-&amp;gt;handlePaymentProcessed($event); break; case 'PaymentFailed': $this-&amp;gt;handlePaymentFailed($event); break; case 'PaymentRefunded': $this-&amp;gt;handlePaymentRefunded($event); break; } } private function handlePaymentProcessed(DomainEvent $event): void { $key = &amp;quot;Payment:{$event-&amp;gt;getAggregateId()}&amp;quot;; $update = [ 'status' =&amp;gt; 'completed', 'processedAt' =&amp;gt; $event-&amp;gt;getTimestamp()-&amp;gt;format('c'), 'updatedAt' =&amp;gt; (new \DateTime())-&amp;gt;format('c') ]; $this-&amp;gt;writer-&amp;gt;update($key, $update, ['status']); $this-&amp;gt;logger-&amp;gt;info('Payment processed projection updated', [ 'paymentId' =&amp;gt; $event-&amp;gt;getAggregateId(), 'status' =&amp;gt; 'completed' ]); } private function handlePaymentFailed(DomainEvent $event): void { $key = &amp;quot;Payment:{$event-&amp;gt;getAggregateId()}&amp;quot;; $update = [ 'status' =&amp;gt; 'failed', 'error' =&amp;gt; $event-&amp;gt;getData()['error'], 'failedAt' =&amp;gt; $event-&amp;gt;getTimestamp()-&amp;gt;format('c'), 'updatedAt' =&amp;gt; (new \DateTime())-&amp;gt;format('c') ]; $this-&amp;gt;writer-&amp;gt;update($key, $update, ['status']); $this-&amp;gt;logger-&amp;gt;info('Payment failed projection updated', [ 'paymentId' =&amp;gt; $event-&amp;gt;getAggregateId(), 'status' =&amp;gt; 'failed' ]); } private function handlePaymentRefunded(DomainEvent $event): void { $key = &amp;quot;Payment:{$event-&amp;gt;getAggregateId()}&amp;quot;; $update = [ 'status' =&amp;gt; 'refunded', 'refundAmount' =&amp;gt; $event-&amp;gt;getData()['refundAmount'], 'refundedAt' =&amp;gt; $event-&amp;gt;getTimestamp()-&amp;gt;format('c'), 'updatedAt' =&amp;gt; (new \DateTime())-&amp;gt;format('c') ]; $this-&amp;gt;writer-&amp;gt;update($key, $update, ['status']); $this-&amp;gt;logger-&amp;gt;info('Payment refunded projection updated', [ 'paymentId' =&amp;gt; $event-&amp;gt;getAggregateId(), 'status' =&amp;gt; 'refunded' ]); }}&lt;/code&gt;## 🧪 &lt;strong&gt;Tests et Validation&lt;/strong&gt;### &lt;strong&gt;Tests d&amp;rsquo;Intégration CQRS&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Tests\Integration\InMemory;use App\Application\Command\Payment\ProcessPaymentCommand;use App\Application\Command\Payment\ProcessPaymentCommandHandler;use App\Application\Query\Payment\GetPaymentByIdQuery;use App\Application\Query\Payment\SearchPaymentsQuery;use App\Application\Query\Payment\PaymentQueryHandler;use App\Infrastructure\InMemory\Command\InMemoryWriter;use App\Infrastructure\InMemory\Query\InMemoryReader;use App\Infrastructure\InMemory\InMemoryStorage;use App\Infrastructure\InMemory\InMemoryIndexer;class InMemoryCqrsTest extends TestCase{ private InMemoryWriter $writer; private InMemoryReader $reader; private ProcessPaymentCommandHandler $commandHandler; private PaymentQueryHandler $queryHandler; protected function setUp(): void { $storage = new InMemoryStorage(); $indexer = new InMemoryIndexer(); $this-&amp;gt;writer = new InMemoryWriter($storage, $indexer, $this-&amp;gt;createMock(LoggerInterface::class)); $this-&amp;gt;reader = new InMemoryReader($storage, $indexer, $this-&amp;gt;createMock(LoggerInterface::class), $this-&amp;gt;createMock(CacheItemPoolInterface::class)); $this-&amp;gt;commandHandler = new ProcessPaymentCommandHandler( $this-&amp;gt;createMock(PaymentRepositoryInterface::class), $this-&amp;gt;writer, $this-&amp;gt;createMock(EventBusInterface::class), $this-&amp;gt;createMock(LoggerInterface::class) ); $this-&amp;gt;queryHandler = new PaymentQueryHandler($this-&amp;gt;reader, $this-&amp;gt;createMock(LoggerInterface::class)); } public function testCqrsSeparation(): void { // Exécuter une commande $command = new ProcessPaymentCommand( 'payment-123', 100.00, 'EUR', 'org-456' ); $this-&amp;gt;commandHandler-&amp;gt;handle($command); // Vérifier avec une requête $query = new GetPaymentByIdQuery('payment-123'); $payment = $this-&amp;gt;queryHandler-&amp;gt;handle($query); $this-&amp;gt;assertNotNull($payment); $this-&amp;gt;assertEquals('payment-123', $payment-&amp;gt;getId()); $this-&amp;gt;assertEquals(100.00, $payment-&amp;gt;getAmount()); } public function testSearchWithAnalytics(): void { // Créer plusieurs paiements $payments = [ new ProcessPaymentCommand('payment-1', 100.00, 'EUR', 'org-456'), new ProcessPaymentCommand('payment-2', 200.00, 'USD', 'org-456'), new ProcessPaymentCommand('payment-3', 300.00, 'EUR', 'org-789') ]; foreach ($payments as $command) { $this-&amp;gt;commandHandler-&amp;gt;handle($command); } // Rechercher avec analytics $searchQuery = new SearchPaymentsQuery('org-456', 0, 10); $result = $this-&amp;gt;queryHandler-&amp;gt;handle($searchQuery); $this-&amp;gt;assertCount(2, $result-&amp;gt;getPayments()); $this-&amp;gt;assertEquals(2, $result-&amp;gt;getTotal()); }}&lt;/code&gt;## 📊 &lt;strong&gt;Performance et Optimisation&lt;/strong&gt;### &lt;strong&gt;Stratégies d&amp;rsquo;Optimisation CQRS&lt;/strong&gt;#### &lt;strong&gt;1. Cache Multi-Niveaux&lt;/strong&gt;&lt;code&gt;phppublic function searchWithMultiLevelCache(SearchPaymentsQuery $query): PaymentSearchResult{ // Cache L1: Mémoire if (isset($this-&amp;gt;memoryCache[$query-&amp;gt;getCacheKey()])) { return $this-&amp;gt;memoryCache[$query-&amp;gt;getCacheKey()]; } // Cache L2: Redis $cached = $this-&amp;gt;redis-&amp;gt;get(&amp;quot;payment_search:{$query-&amp;gt;getCacheKey()}&amp;quot;); if ($cached) { $result = PaymentSearchResult::fromArray(json_decode($cached, true)); $this-&amp;gt;memoryCache[$query-&amp;gt;getCacheKey()] = $result; return $result; } // In-Memory $result = $this-&amp;gt;searchPayments($query); // Mettre en cache $this-&amp;gt;memoryCache[$query-&amp;gt;getCacheKey()] = $result; $this-&amp;gt;redis-&amp;gt;setex(&amp;quot;payment_search:{$query-&amp;gt;getCacheKey()}&amp;quot;, 300, json_encode($result-&amp;gt;toArray())); return $result;}&lt;/code&gt;#### &lt;strong&gt;2. Projections Asynchrones&lt;/strong&gt;&lt;code&gt;phppublic function handleEventAsync(DomainEvent $event): void{ // Mettre en queue pour traitement asynchrone $this-&amp;gt;messageBus-&amp;gt;dispatch(new ProcessProjectionCommand($event));}&lt;/code&gt;#### &lt;strong&gt;3. Index Optimisés&lt;/strong&gt;&lt;code&gt;phppublic function optimizeIndexes(): void{ // Nettoyer les index orphelins $this-&amp;gt;cleanOrphanedIndexes(); // Compacter les index $this-&amp;gt;compactIndexes(); // Forcer le garbage collection gc_collect_cycles();}&lt;/code&gt;## 🎯 &lt;strong&gt;Critères d&amp;rsquo;Adoption&lt;/strong&gt;### &lt;strong&gt;Quand Utiliser CQRS avec In-Memory&lt;/strong&gt;#### &lt;strong&gt;✅ Avantages&lt;/strong&gt;- &lt;strong&gt;Scalabilité maximale&lt;/strong&gt; : Possibilité de scaler indépendamment- &lt;strong&gt;Performance optimale&lt;/strong&gt; : Chaque côté optimisé pour son usage- &lt;strong&gt;Flexibilité&lt;/strong&gt; : Projections multiples pour différents besoins- &lt;strong&gt;Cache efficace&lt;/strong&gt; : Mise en cache des requêtes- &lt;strong&gt;Maintenabilité&lt;/strong&gt; : Code plus clair et organisé#### &lt;strong&gt;❌ Inconvénients&lt;/strong&gt;- &lt;strong&gt;Complexité maximale&lt;/strong&gt; : Architecture très complexe- &lt;strong&gt;Volatilité&lt;/strong&gt; : Données perdues au redémarrage- &lt;strong&gt;Limitation mémoire&lt;/strong&gt; : Contraint par la RAM disponible- &lt;strong&gt;Expertise&lt;/strong&gt; : Équipe très expérimentée requise#### &lt;strong&gt;🎯 Critères d&amp;rsquo;Adoption&lt;/strong&gt;- &lt;strong&gt;Système très complexe&lt;/strong&gt; : Besoins de scalabilité maximale- &lt;strong&gt;Performance critique&lt;/strong&gt; : Besoins de performance maximale- &lt;strong&gt;Données temporaires&lt;/strong&gt; : Cache, sessions, métriques- &lt;strong&gt;Équipe très expérimentée&lt;/strong&gt; : Maîtrise d&amp;rsquo;In-Memory et CQRS- &lt;strong&gt;Tests et développement&lt;/strong&gt; : Environnements de test rapides- &lt;strong&gt;Mémoire suffisante&lt;/strong&gt; : RAM disponible pour toutes les données## 🚀 &lt;strong&gt;Votre Prochaine Étape&lt;/strong&gt;

&lt;div class="chapter-navigation"&gt;
 &lt;h2 class="chapter-nav-title"&gt;🎯 Votre Prochaine Étape&lt;/h2&gt;
 &lt;p class="chapter-nav-subtitle"&gt;Maintenant que vous comprenez les concepts de base et que j'ai partagé mon expérience avec Gyroscops, quel est votre contexte ?&lt;/p&gt;</description></item><item><title>Stockage In-Memory - Event Sourcing</title><link>http://localhost:1313/chapitres/stockage/in-memory/chapitre-43-stockage-in-memory-event-sourcing/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/in-memory/chapitre-43-stockage-in-memory-event-sourcing/</guid><description/></item><item><title>Stockage In-Memory - Event Sourcing + CQS</title><link>http://localhost:1313/chapitres/stockage/in-memory/chapitre-44-stockage-in-memory-event-sourcing-cqs/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/in-memory/chapitre-44-stockage-in-memory-event-sourcing-cqs/</guid><description>&lt;h2 id="-contexte-et-objectifs-pourquoi-event-sourcing--cqs-avec-in-memory-cette-combinaison-offre-le-meilleur-des-deux-mondes--laudit-trail-complet-de-levent-sourcing-avec-la-séparation-optimisée-des-responsabilités-du-cqs-le-tout-sur-une-plateforme-de-performance-maximale-avantages-de-cette-combinaison--audit-trail-complet--historique-de-tous-les-événements--performance-optimisée--séparation-claire-entre-écriture-et-lecture--debugging-avancé--possibilité-de-rejouer-les-événements--flexibilité--requêtes-optimisées-pour-chaque-usage--cache-efficace--mise-en-cache-des-requêtes-contexte-gyroscopsdans-notre-écosystème-user--organization--workflow--cloud-resources--billing-event-sourcing--cqs-avec-in-memory-est-idéal-pour---cache-d--séparation-des-écritures-et-lectures-dévénements--sessions-utilisateur--gestion-optimisée-des-sessions-avec-audit-trail--métriques-en-temps-réel--traçabilité-des-métriques-avec-analytics--tests-et-développement--environnements-de-test-avec-audit-trail-et-performance--architecture-event-sourcing--cqs-séparation-des-responsabilités-côté-commande-write--command-handlers--traitement-des-commandes-métier--event-store--persistance-des-événements-dans-in-memory--event-handlers--gestion-des-événements-de-domaine--bulk-operations--optimisation-des-écritures-côté-requête-read--query-handlers--traitement-des-requêtes--event-search--recherche-dans-les-événements--analytics-services--services-danalytics-temporelles--caches--optimisation-des-performances-flux-de-données-completmermaidgraph-td----acommand----bcommand-handler----b----caggregate----c----devents----d----eevent-store-in-memory----e----fevent-handlers----f----gprojections----g----hread-models--------iquery----jquery-handler----j----kevent-search----k----e----e----lsearch-results----l----mresponse--------nanalytics----oanalytics-service----o----e----e----phistorical-data----p----qanalytics-results--implémentation-pratique-1-command-side-implementation-event-store-in-memory-avancéphpphpnamespace-appinfrastructureeventstoreuse-appdomaineventdomaineventuse-appdomaineventeventstoreinterfaceuse-psrlogloggerinterfaceclass-inmemoryeventstore-implements-eventstoreinterface----private-array-events------private-array-indexes------private-loggerinterface-logger----private-array-bulkbuffer------private-int-bulksize----public-function-__constructloggerinterface-logger-int-bulksize--100------------this-logger--logger--------this-bulksize--bulksize--------public-function-appendeventsstring-aggregateid-array-events-int-expectedversion-void------------try--------------vérifier-la-version-attendue------------lastevent--this-getlasteventaggregateid------------------------if-lastevent--lasteventversion--expectedversion-----------------throw-new-concurrencyexceptionversion-mismatch-------------------------------------préparer-les-événements-pour-linsertion------------version--expectedversion--1------------------------foreach-events-as-event-----------------this-bulkbuffer----------------------eventid--event-getid--------------------aggregateid--aggregateid--------------------aggregatetype--event-getaggregatetype--------------------eventtype--event-geteventtype--------------------eventdata--event-toarray--------------------version--version--------------------timestamp--event-gettimestamp--------------------correlationid--event-getcorrelationid--------------------causationid--event-getcausationid--------------------metadata--event-getmetadata------------------------------------------------if-countthis-bulkbuffer--this-bulksize---------------------this-flushbulk----------------------------------------------------this-flushbulk---------------------catch-exception-e-------------this-logger-errorfailed-to-append-events-----------------aggregateid--aggregateid----------------events--countevents----------------error--e-getmessage------------------------------------throw-e----------------public-function-geteventsstring-aggregateid-int-fromversion--0-array------------events------------------foreach-this-events-as-event-------------if-eventaggregateid--aggregateid--eventversion--fromversion-----------------events--this-deserializeeventevent-------------------------------------trier-par-version--------usortevents-fna-b--a-getversion--b-getversion----------------return-events--------public-function-searcheventsarray-criteria-array------------events------------------foreach-this-events-as-event-------------if-this-matchescriteriaevent-criteria-----------------events--this-deserializeeventevent-------------------------------------trier-par-timestamp--------usortevents-fna-b--a-gettimestamp--b-gettimestamp----------------return-events--------private-function-getlasteventstring-aggregateid-array------------lastevent--null--------lastversion---1----------------foreach-this-events-as-event-------------if-eventaggregateid--aggregateid--eventversion--lastversion-----------------lastevent--event----------------lastversion--eventversion------------------------------------return-lastevent--------private-function-flushbulk-void------------if-emptythis-bulkbuffer-------------return----------------try-------------foreach-this-bulkbuffer-as-eventdata-----------------this-eventseventdataeventid--eventdata----------------this-updateindexeseventdata------------------------this-logger-infobulk-events-inserted-----------------events--countthis-bulkbuffer------------------------this-bulkbuffer-----------catch-exception-e-------------this-logger-errorbulk-events-insertion-failed-----------------error--e-getmessage----------------events--countthis-bulkbuffer------------------------throw-e----------------private-function-updateindexesarray-eventdata-void-------------index-par-type-dévénement--------this-indexeseventtypeeventdataeventtype--eventdataeventid-----------------index-par-agrégat--------this-indexesaggregateideventdataaggregateid--eventdataeventid-----------------index-par-corrélation--------if-eventdatacorrelationid-------------this-indexescorrelationideventdatacorrelationid--eventdataeventid-------------------------index-par-timestamp--------date--eventdatatimestamp-formaty-m-d--------this-indexesdatedate--eventdataeventid--------private-function-matchescriteriaarray-event-array-criteria-bool------------foreach-criteria-as-field--expectedvalue-------------if-this-fieldmatchesevent-field-expectedvalue-----------------return-false------------------------------------return-true--------private-function-fieldmatchesarray-event-string-field-mixed-expectedvalue-bool------------fieldvalue--eventfield--null----------------if-is_arrayexpectedvalue-------------return-in_arrayfieldvalue-expectedvalue------------------------return-fieldvalue--expectedvalue--------private-function-deserializeeventarray-eventdata-domainevent------------eventclass--eventdataeventtype--------return-eventclassfromarrayeventdataeventdata-----command-handler-avec-event-sourcingphpphpnamespace-appapplicationcommandpaymentuse-appdomainpaymentpaymentaggregateuse-appdomaineventeventstoreinterfaceuse-appdomaineventeventbusinterfaceuse-psrlogloggerinterfaceclass-processpaymentcommandhandler----public-function-__construct--------private-eventstoreinterface-eventstore--------private-eventbusinterface-eventbus--------private-loggerinterface-logger---------public-function-handleprocesspaymentcommand-command-void------------try--------------charger-lagrégat-depuis-les-événements------------events--this-eventstore-geteventscommand-getpaymentid------------payment--paymentaggregatefromeventsevents-------------------------exécuter-la-commande------------payment-processpaymentcommand-getamount-command-getcurrency-------------------------sauvegarder-les-événements------------this-eventstore-appendevents----------------command-getpaymentid----------------payment-getuncommittedevents----------------payment-getversion-------------------------------------publier-les-événements------------foreach-payment-getuncommittedevents-as-event-----------------this-eventbus-publishevent-------------------------------------nettoyer-les-événements-non-commités------------payment-markeventsascommitted------------------------this-logger-infopayment-processed-with-event-sourcing-----------------paymentid--command-getpaymentid----------------amount--command-getamount----------------currency--command-getcurrency----------------events--countpayment-getuncommittedevents---------------------------------catch-exception-e-------------this-logger-errorpayment-processing-failed-----------------paymentid--command-getpaymentid----------------error--e-getmessage------------------------------------throw-e-------------2-query-side-implementation-event-search-servicephpphpnamespace-appinfrastructureinmemoryqueryuse-appinfrastructureeventstoreinmemoryeventstoreuse-psrlogloggerinterfaceuse-psrcachecacheitempoolinterfaceclass-eventsearchservice----private-inmemoryeventstore-eventstore----private-loggerinterface-logger----private-cacheitempoolinterface-cache----public-function-__construct--------inmemoryeventstore-eventstore--------loggerinterface-logger--------cacheitempoolinterface-cache-------------this-eventstore--eventstore--------this-logger--logger--------this-cache--cache--------public-function-searcheventsarray-query-string-cachekey--null-array-------------vérifier-le-cache--------if-cachekey-------------cacheditem--this-cache-getitemcachekey------------if-cacheditem-ishit-----------------this-logger-debugevent-search-result-served-from-cache---------------------query--query--------------------cachekey--cachekey--------------------------------return-cacheditem-get----------------------------results--this-eventstore-searcheventsquery---------mettre-en-cache--------if-cachekey-------------cacheditem-setresults------------cacheditem-expiresafter300--5-minutes------------this-cache-savecacheditem----------------this-logger-infoevent-search-executed-------------query--query------------results--countresults----------------return-results--------public-function-geteventbyidstring-eventid-array------------event--this-eventstore-geteventbyideventid----------------if-event-------------return-null------------------------return-------------eventid--event-getid------------aggregateid--event-getaggregateid------------eventtype--event-geteventtype------------timestamp--event-gettimestamp------------data--event-toarray------------metadata--event-getmetadata----------------public-function-geteventsbyaggregatestring-aggregateid-int-fromversion--0-array------------events--this-eventstore-geteventsaggregateid-fromversion----------------results----------foreach-events-as-event-------------results------------------eventid--event-getid----------------aggregateid--event-getaggregateid----------------eventtype--event-geteventtype----------------timestamp--event-gettimestamp----------------data--event-toarray----------------metadata--event-getmetadata------------------------------------return-results--------public-function-geteventsbytypestring-eventtype-datetime-from--null-datetime-to--null-array------------events--this-eventstore-geteventsbytypeeventtype-from-to----------------results----------foreach-events-as-event-------------results------------------eventid--event-getid----------------aggregateid--event-getaggregateid----------------eventtype--event-geteventtype----------------timestamp--event-gettimestamp----------------data--event-toarray----------------metadata--event-getmetadata------------------------------------return-results--------public-function-geteventstatisticsstring-eventtype-datetime-from-datetime-to-array------------events--this-eventstore-geteventsbytypeeventtype-from-to----------------statistics--------------total--countevents------------byhour--------------byday--------------byorganization--------------byuser--------------------------foreach-events-as-event-------------hour--event-gettimestamp-formaty-m-d-h0000------------day--event-gettimestamp-formaty-m-d------------orgid--event-getmetadataorganizationid--unknown------------userid--event-getmetadatauserid--unknown------------------------statisticsbyhourhour--statisticsbyhourhour--0--1------------statisticsbydayday--statisticsbydayday--0--1------------statisticsbyorganizationorgid--statisticsbyorganizationorgid--0--1------------statisticsbyuseruserid--statisticsbyuseruserid--0--1------------------------return-statistics-----query-handler-pour-les-événementsphpphpnamespace-appapplicationquerypaymentuse-appinfrastructureinmemoryqueryeventsearchserviceuse-appdomainpaymentpaymentuse-psrlogloggerinterfaceclass-paymenteventqueryhandler----private-eventsearchservice-eventsearch----private-loggerinterface-logger----public-function-__constructeventsearchservice-eventsearch-loggerinterface-logger------------this-eventsearch--eventsearch--------this-logger--logger--------public-function-handlegetpaymenthistoryquery-query-array------------events--this-eventsearch-geteventsbyaggregatequery-getpaymentid----------------history----------foreach-events-as-event-------------history------------------eventid--eventeventid----------------eventtype--eventeventtype----------------timestamp--eventtimestamp----------------data--eventdata----------------metadata--eventmetadata------------------------------------return-history--------public-function-handlesearchpaymenteventsquery-query-array------------searchquery--------------aggregatetype--payment------------------------if-query-geteventtype-------------searchqueryeventtype--query-geteventtype------------------------if-query-getfrom--query-getto-------------searchquerytimestamp--------------if-query-getfrom-----------------searchquerytimestampgte--query-getfrom------------------------if-query-getto-----------------searchquerytimestamplte--query-getto------------------------------------cachekey--payment_events_--md5serializequery--------results--this-eventsearch-searcheventssearchquery-cachekey----------------events----------foreach-results-as-event-------------events------------------eventid--event-getid----------------aggregateid--event-getaggregateid----------------eventtype--event-geteventtype----------------timestamp--event-gettimestamp----------------data--event-toarray----------------metadata--event-getmetadata------------------------------------return-events--------public-function-handlegetpaymenteventstatisticsquery-query-array------------return-this-eventsearch-geteventstatistics------------query-geteventtype------------query-getfrom------------query-getto----------------public-function-handlereplaypaymenteventsquery-query-payment------------events--this-eventsearch-geteventsbyaggregatequery-getpaymentid-----------------reconstruire-lagrégat-depuis-les-événements--------payment--paymentaggregatefromeventsevents----------------return-payment-topayment-----3-service-d-service-dphpphpnamespace-appapplicationserviceinmemoryuse-appinfrastructureinmemoryqueryeventsearchserviceuse-psrlogloggerinterfaceclass-eventanalyticsservice----private-eventsearchservice-eventsearch----private-loggerinterface-logger----public-function-__constructeventsearchservice-eventsearch-loggerinterface-logger------------this-eventsearch--eventsearch--------this-logger--logger--------public-function-geteventtrendsstring-eventtype-datetime-from-datetime-to-string-interval--day-array------------events--this-eventsearch-geteventsbytypeeventtype-from-to----------------trends----------foreach-events-as-event-------------key--this-getintervalkeyeventtimestamp-interval------------trendskey--trendskey--0--1------------------------ksorttrends--------return-trends--------public-function-geteventcorrelationsstring-correlationid-array------------events--this-eventsearch-geteventsbycorrelationidcorrelationid----------------correlations----------foreach-events-as-event-------------correlations------------------eventtype--eventeventtype----------------aggregateid--eventaggregateid----------------timestamp--eventtimestamp----------------data--eventdata------------------------------------return-correlations--------public-function-geteventheatmapstring-eventtype-datetime-from-datetime-to-array------------events--this-eventsearch-geteventsbytypeeventtype-from-to----------------heatmap--------------byhour--------------byday--------------------------foreach-events-as-event-------------hour--eventtimestamp-formaty-m-d-h0000------------day--eventtimestamp-formaty-m-d------------------------heatmapbyhourhour--heatmapbyhourhour--0--1------------heatmapbydayday--heatmapbydayday--0--1------------------------return-heatmap--------public-function-searcheventdatastring-searchtext-array-filters---array------------query------------------if-issetfiltersaggregatetype-------------queryaggregatetype--filtersaggregatetype------------------------if-issetfilterseventtype-------------queryeventtype--filterseventtype------------------------if-issetfiltersfrom--issetfiltersto-------------querytimestamp--------------if-issetfiltersfrom-----------------querytimestampgte--filtersfrom------------------------if-issetfiltersto-----------------querytimestamplte--filtersto------------------------------------events--this-eventsearch-searcheventsquery-----------------filtrer-par-texte-de-recherche--------if-searchtext-------------events--array_filterevents-functionevent-use-searchtext-----------------data--event-toarray----------------return-striposjson_encodedata-searchtext--false------------------------------------results----------foreach-events-as-event-------------results------------------eventid--event-getid----------------aggregateid--event-getaggregateid----------------eventtype--event-geteventtype----------------timestamp--event-gettimestamp----------------data--event-toarray----------------metadata--event-getmetadata------------------------------------return-results--------private-function-getintervalkeydatetime-timestamp-string-interval-string------------switch-interval-------------case-hour----------------return-timestamp-formaty-m-d-h0000------------case-day----------------return-timestamp-formaty-m-d------------case-week----------------return-timestamp-formaty-w------------case-month----------------return-timestamp-formaty-m------------default----------------return-timestamp-formaty-m-d--------------tests-et-validation-tests-dphpphpnamespace-apptestsintegrationinmemoryuse-appapplicationcommandpaymentprocesspaymentcommanduse-appapplicationcommandpaymentprocesspaymentcommandhandleruse-appapplicationquerypaymentgetpaymenthistoryqueryuse-appapplicationquerypaymentpaymenteventqueryhandleruse-appinfrastructureeventstoreinmemoryeventstoreuse-appinfrastructureinmemoryqueryeventsearchserviceclass-inmemoryeventsourcingcqstest-extends-testcase----private-inmemoryeventstore-eventstore----private-eventsearchservice-eventsearch----private-processpaymentcommandhandler-commandhandler----private-paymenteventqueryhandler-queryhandler----protected-function-setup-void------------this-eventstore--new-inmemoryeventstorethis-createmockloggerinterfaceclass--------this-eventsearch--new-eventsearchservicethis-eventstore-this-createmockloggerinterfaceclass-this-createmockcacheitempoolinterfaceclass----------------this-commandhandler--new-processpaymentcommandhandler------------this-eventstore------------this-createmockeventbusinterfaceclass------------this-createmockloggerinterfaceclass------------------------this-queryhandler--new-paymenteventqueryhandlerthis-eventsearch-this-createmockloggerinterfaceclass--------public-function-testeventsourcingcqsflow-void-------------exécuter-une-commande--------command--new-processpaymentcommand------------payment-123------------10000------------eur------------------------this-commandhandler-handlecommand-----------------vérifier-lhistorique-des-événements--------query--new-getpaymenthistoryquerypayment-123--------history--this-queryhandler-handlequery----------------this-assertnotemptyhistory--------this-assertcount1-history--------this-assertequalspaymentprocessed-history0eventtype--------public-function-testeventsearchwithanalytics-void-------------créer-plusieurs-événements--------commands--------------new-processpaymentcommandpayment-1-10000-eur------------new-processpaymentcommandpayment-2-20000-usd------------new-processpaymentcommandpayment-3-30000-eur------------------------foreach-commands-as-command-------------this-commandhandler-handlecommand-------------------------rechercher-les-événements--------searchquery--new-searchpaymenteventsquery------------new-datetime2024-01-01------------new-datetime2024-12-31------------------------results--this-queryhandler-handlesearchquery----------------this-assertcount3-results--------this-assertequalspaymentprocessed-results0eventtype------performance-et-optimisation-stratégies-d-1-cache-multi-niveauxphppublic-function-searcheventswithcachearray-query-string-cachekey--null-array-----cache-l1-mémoire----if-issetthis-memorycachecachekey---------return-this-memorycachecachekey-------------cache-l2-redis----if-cached--this-redis-getevent_searchcachekey---------result--json_decodecached-true--------this-memorycachecachekey--result--------return-result-------------in-memory----result--this-searcheventsquery---------mettre-en-cache----this-memorycachecachekey--result----this-redis-setexevent_searchcachekey-300-json_encoderesult--------return-result-2-projections-asynchronesphppublic-function-handleeventasyncdomainevent-event-void-----mettre-en-queue-pour-traitement-asynchrone----this-messagebus-dispatchnew-processprojectioncommandevent-3-index-optimisésphppublic-function-optimizeindexes-void-----nettoyer-les-index-orphelins----this-cleanorphanedindexes---------compacter-les-index----this-compactindexes---------forcer-le-garbage-collection----gc_collect_cycles--critères-d-quand-utiliser-event-sourcing--cqs-avec-in-memory--avantages--audit-trail-complet--historique-de-tous-les-événements--performance-optimisée--séparation-claire-entre-écriture-et-lecture--debugging-avancé--possibilité-de-rejouer-les-événements--flexibilité--requêtes-optimisées-pour-chaque-usage--cache-efficace--mise-en-cache-des-requêtes--inconvénients--complexité-élevée--architecture-très-complexe--volatilité--données-perdues-au-redémarrage--limitation-mémoire--contraint-par-la-ram-disponible--expertise--équipe-très-expérimentée-requise--critères-d--audit-trail-critique--besoin-de-traçabilité-complète--performance-importante--besoins-de-performance-élevée--debugging-complexe--besoin-de-rejouer-les-événements--données-temporaires--cache-sessions-métriques--équipe-très-expérimentée--maîtrise-devent-sourcing-cqs-et-in-memory--mémoire-suffisante--ram-disponible-pour-tous-les-événements--votre-prochaine-étapehahahugoshortcode34s0hbhbevent-sourcing--cqs-avec-in-memory-offre-une-approche-sophistiquée-pour-l"&gt;🎯 &lt;strong&gt;Contexte et Objectifs&lt;/strong&gt;### **Pourquoi Event Sourcing + CQS avec In-Memory ?**Cette combinaison offre le meilleur des deux mondes : l&amp;rsquo;audit trail complet de l&amp;rsquo;Event Sourcing avec la séparation optimisée des responsabilités du CQS, le tout sur une plateforme de performance maximale.#### &lt;strong&gt;Avantages de cette Combinaison&lt;/strong&gt;- &lt;strong&gt;Audit trail complet&lt;/strong&gt; : Historique de tous les événements- &lt;strong&gt;Performance optimisée&lt;/strong&gt; : Séparation claire entre écriture et lecture- &lt;strong&gt;Debugging avancé&lt;/strong&gt; : Possibilité de rejouer les événements- &lt;strong&gt;Flexibilité&lt;/strong&gt; : Requêtes optimisées pour chaque usage- &lt;strong&gt;Cache efficace&lt;/strong&gt; : Mise en cache des requêtes### &lt;strong&gt;Contexte Gyroscops&lt;/strong&gt;Dans notre écosystème &lt;strong&gt;User → Organization → Workflow → Cloud Resources → Billing&lt;/strong&gt;, Event Sourcing + CQS avec In-Memory est idéal pour :- &lt;strong&gt;Cache d&amp;rsquo;événements&lt;/strong&gt; : Séparation des écritures et lectures d&amp;rsquo;événements- &lt;strong&gt;Sessions utilisateur&lt;/strong&gt; : Gestion optimisée des sessions avec audit trail- &lt;strong&gt;Métriques en temps réel&lt;/strong&gt; : Traçabilité des métriques avec analytics- &lt;strong&gt;Tests et développement&lt;/strong&gt; : Environnements de test avec audit trail et performance## 🏗️ &lt;strong&gt;Architecture Event Sourcing + CQS&lt;/strong&gt;### &lt;strong&gt;Séparation des Responsabilités&lt;/strong&gt;#### &lt;strong&gt;Côté Commande (Write)&lt;/strong&gt;- &lt;strong&gt;Command Handlers&lt;/strong&gt; : Traitement des commandes métier- &lt;strong&gt;Event Store&lt;/strong&gt; : Persistance des événements dans In-Memory- &lt;strong&gt;Event Handlers&lt;/strong&gt; : Gestion des événements de domaine- &lt;strong&gt;Bulk Operations&lt;/strong&gt; : Optimisation des écritures#### &lt;strong&gt;Côté Requête (Read)&lt;/strong&gt;- &lt;strong&gt;Query Handlers&lt;/strong&gt; : Traitement des requêtes- &lt;strong&gt;Event Search&lt;/strong&gt; : Recherche dans les événements- &lt;strong&gt;Analytics Services&lt;/strong&gt; : Services d&amp;rsquo;analytics temporelles- &lt;strong&gt;Caches&lt;/strong&gt; : Optimisation des performances### &lt;strong&gt;Flux de Données Complet&lt;/strong&gt;&lt;code&gt;mermaidgraph TD A[Command] --&amp;gt; B[Command Handler] B --&amp;gt; C[Aggregate] C --&amp;gt; D[Events] D --&amp;gt; E[Event Store In-Memory] E --&amp;gt; F[Event Handlers] F --&amp;gt; G[Projections] G --&amp;gt; H[Read Models] I[Query] --&amp;gt; J[Query Handler] J --&amp;gt; K[Event Search] K --&amp;gt; E E --&amp;gt; L[Search Results] L --&amp;gt; M[Response] N[Analytics] --&amp;gt; O[Analytics Service] O --&amp;gt; E E --&amp;gt; P[Historical Data] P --&amp;gt; Q[Analytics Results]&lt;/code&gt;## 💻 &lt;strong&gt;Implémentation Pratique&lt;/strong&gt;### &lt;strong&gt;1. Command Side Implementation&lt;/strong&gt;#### &lt;strong&gt;Event Store In-Memory Avancé&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Infrastructure\EventStore;use App\Domain\Event\DomainEvent;use App\Domain\Event\EventStoreInterface;use Psr\Log\LoggerInterface;class InMemoryEventStore implements EventStoreInterface{ private array $events = []; private array $indexes = []; private LoggerInterface $logger; private array $bulkBuffer = []; private int $bulkSize; public function __construct(LoggerInterface $logger, int $bulkSize = 100) { $this-&amp;gt;logger = $logger; $this-&amp;gt;bulkSize = $bulkSize; } public function appendEvents(string $aggregateId, array $events, int $expectedVersion): void { try { // Vérifier la version attendue $lastEvent = $this-&amp;gt;getLastEvent($aggregateId); if ($lastEvent &amp;amp;&amp;amp; $lastEvent['version'] !== $expectedVersion) { throw new ConcurrencyException('Version mismatch'); } // Préparer les événements pour l'insertion $version = $expectedVersion + 1; foreach ($events as $event) { $this-&amp;gt;bulkBuffer[] = [ 'eventId' =&amp;gt; $event-&amp;gt;getId(), 'aggregateId' =&amp;gt; $aggregateId, 'aggregateType' =&amp;gt; $event-&amp;gt;getAggregateType(), 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'eventData' =&amp;gt; $event-&amp;gt;toArray(), 'version' =&amp;gt; $version++, 'timestamp' =&amp;gt; $event-&amp;gt;getTimestamp(), 'correlationId' =&amp;gt; $event-&amp;gt;getCorrelationId(), 'causationId' =&amp;gt; $event-&amp;gt;getCausationId(), 'metadata' =&amp;gt; $event-&amp;gt;getMetadata() ]; if (count($this-&amp;gt;bulkBuffer) &amp;gt;= $this-&amp;gt;bulkSize) { $this-&amp;gt;flushBulk(); } } $this-&amp;gt;flushBulk(); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to append events', [ 'aggregateId' =&amp;gt; $aggregateId, 'events' =&amp;gt; count($events), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } public function getEvents(string $aggregateId, int $fromVersion = 0): array { $events = []; foreach ($this-&amp;gt;events as $event) { if ($event['aggregateId'] === $aggregateId &amp;amp;&amp;amp; $event['version'] &amp;gt;= $fromVersion) { $events[] = $this-&amp;gt;deserializeEvent($event); } } // Trier par version usort($events, fn($a, $b) =&amp;gt; $a-&amp;gt;getVersion() &amp;lt;=&amp;gt; $b-&amp;gt;getVersion()); return $events; } public function searchEvents(array $criteria): array { $events = []; foreach ($this-&amp;gt;events as $event) { if ($this-&amp;gt;matchesCriteria($event, $criteria)) { $events[] = $this-&amp;gt;deserializeEvent($event); } } // Trier par timestamp usort($events, fn($a, $b) =&amp;gt; $a-&amp;gt;getTimestamp() &amp;lt;=&amp;gt; $b-&amp;gt;getTimestamp()); return $events; } private function getLastEvent(string $aggregateId): ?array { $lastEvent = null; $lastVersion = -1; foreach ($this-&amp;gt;events as $event) { if ($event['aggregateId'] === $aggregateId &amp;amp;&amp;amp; $event['version'] &amp;gt; $lastVersion) { $lastEvent = $event; $lastVersion = $event['version']; } } return $lastEvent; } private function flushBulk(): void { if (empty($this-&amp;gt;bulkBuffer)) { return; } try { foreach ($this-&amp;gt;bulkBuffer as $eventData) { $this-&amp;gt;events[$eventData['eventId']] = $eventData; $this-&amp;gt;updateIndexes($eventData); } $this-&amp;gt;logger-&amp;gt;info('Bulk events inserted', [ 'events' =&amp;gt; count($this-&amp;gt;bulkBuffer) ]); $this-&amp;gt;bulkBuffer = []; } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Bulk events insertion failed', [ 'error' =&amp;gt; $e-&amp;gt;getMessage(), 'events' =&amp;gt; count($this-&amp;gt;bulkBuffer) ]); throw $e; } } private function updateIndexes(array $eventData): void { // Index par type d'événement $this-&amp;gt;indexes['eventType'][$eventData['eventType']][] = $eventData['eventId']; // Index par agrégat $this-&amp;gt;indexes['aggregateId'][$eventData['aggregateId']][] = $eventData['eventId']; // Index par corrélation if ($eventData['correlationId']) { $this-&amp;gt;indexes['correlationId'][$eventData['correlationId']][] = $eventData['eventId']; } // Index par timestamp $date = $eventData['timestamp']-&amp;gt;format('Y-m-d'); $this-&amp;gt;indexes['date'][$date][] = $eventData['eventId']; } private function matchesCriteria(array $event, array $criteria): bool { foreach ($criteria as $field =&amp;gt; $expectedValue) { if (!$this-&amp;gt;fieldMatches($event, $field, $expectedValue)) { return false; } } return true; } private function fieldMatches(array $event, string $field, mixed $expectedValue): bool { $fieldValue = $event[$field] ?? null; if (is_array($expectedValue)) { return in_array($fieldValue, $expectedValue); } return $fieldValue === $expectedValue; } private function deserializeEvent(array $eventData): DomainEvent { $eventClass = $eventData['eventType']; return $eventClass::fromArray($eventData['eventData']); }}&lt;/code&gt;#### &lt;strong&gt;Command Handler avec Event Sourcing&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Command\Payment;use App\Domain\Payment\PaymentAggregate;use App\Domain\Event\EventStoreInterface;use App\Domain\Event\EventBusInterface;use Psr\Log\LoggerInterface;class ProcessPaymentCommandHandler{ public function __construct( private EventStoreInterface $eventStore, private EventBusInterface $eventBus, private LoggerInterface $logger ) {} public function handle(ProcessPaymentCommand $command): void { try { // Charger l'agrégat depuis les événements $events = $this-&amp;gt;eventStore-&amp;gt;getEvents($command-&amp;gt;getPaymentId()); $payment = PaymentAggregate::fromEvents($events); // Exécuter la commande $payment-&amp;gt;processPayment($command-&amp;gt;getAmount(), $command-&amp;gt;getCurrency()); // Sauvegarder les événements $this-&amp;gt;eventStore-&amp;gt;appendEvents( $command-&amp;gt;getPaymentId(), $payment-&amp;gt;getUncommittedEvents(), $payment-&amp;gt;getVersion() ); // Publier les événements foreach ($payment-&amp;gt;getUncommittedEvents() as $event) { $this-&amp;gt;eventBus-&amp;gt;publish($event); } // Nettoyer les événements non commités $payment-&amp;gt;markEventsAsCommitted(); $this-&amp;gt;logger-&amp;gt;info('Payment processed with event sourcing', [ 'paymentId' =&amp;gt; $command-&amp;gt;getPaymentId(), 'amount' =&amp;gt; $command-&amp;gt;getAmount(), 'currency' =&amp;gt; $command-&amp;gt;getCurrency(), 'events' =&amp;gt; count($payment-&amp;gt;getUncommittedEvents()) ]); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Payment processing failed', [ 'paymentId' =&amp;gt; $command-&amp;gt;getPaymentId(), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } }}&lt;/code&gt;### &lt;strong&gt;2. Query Side Implementation&lt;/strong&gt;#### &lt;strong&gt;Event Search Service&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Infrastructure\InMemory\Query;use App\Infrastructure\EventStore\InMemoryEventStore;use Psr\Log\LoggerInterface;use Psr\Cache\CacheItemPoolInterface;class EventSearchService{ private InMemoryEventStore $eventStore; private LoggerInterface $logger; private CacheItemPoolInterface $cache; public function __construct( InMemoryEventStore $eventStore, LoggerInterface $logger, CacheItemPoolInterface $cache ) { $this-&amp;gt;eventStore = $eventStore; $this-&amp;gt;logger = $logger; $this-&amp;gt;cache = $cache; } public function searchEvents(array $query, string $cacheKey = null): array { // Vérifier le cache if ($cacheKey) { $cachedItem = $this-&amp;gt;cache-&amp;gt;getItem($cacheKey); if ($cachedItem-&amp;gt;isHit()) { $this-&amp;gt;logger-&amp;gt;debug('Event search result served from cache', [ 'query' =&amp;gt; $query, 'cacheKey' =&amp;gt; $cacheKey ]); return $cachedItem-&amp;gt;get(); } } $results = $this-&amp;gt;eventStore-&amp;gt;searchEvents($query); // Mettre en cache if ($cacheKey) { $cachedItem-&amp;gt;set($results); $cachedItem-&amp;gt;expiresAfter(300); // 5 minutes $this-&amp;gt;cache-&amp;gt;save($cachedItem); } $this-&amp;gt;logger-&amp;gt;info('Event search executed', [ 'query' =&amp;gt; $query, 'results' =&amp;gt; count($results) ]); return $results; } public function getEventById(string $eventId): ?array { $event = $this-&amp;gt;eventStore-&amp;gt;getEventById($eventId); if (!$event) { return null; } return [ 'eventId' =&amp;gt; $event-&amp;gt;getId(), 'aggregateId' =&amp;gt; $event-&amp;gt;getAggregateId(), 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'timestamp' =&amp;gt; $event-&amp;gt;getTimestamp(), 'data' =&amp;gt; $event-&amp;gt;toArray(), 'metadata' =&amp;gt; $event-&amp;gt;getMetadata() ]; } public function getEventsByAggregate(string $aggregateId, int $fromVersion = 0): array { $events = $this-&amp;gt;eventStore-&amp;gt;getEvents($aggregateId, $fromVersion); $results = []; foreach ($events as $event) { $results[] = [ 'eventId' =&amp;gt; $event-&amp;gt;getId(), 'aggregateId' =&amp;gt; $event-&amp;gt;getAggregateId(), 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'timestamp' =&amp;gt; $event-&amp;gt;getTimestamp(), 'data' =&amp;gt; $event-&amp;gt;toArray(), 'metadata' =&amp;gt; $event-&amp;gt;getMetadata() ]; } return $results; } public function getEventsByType(string $eventType, \DateTime $from = null, \DateTime $to = null): array { $events = $this-&amp;gt;eventStore-&amp;gt;getEventsByType($eventType, $from, $to); $results = []; foreach ($events as $event) { $results[] = [ 'eventId' =&amp;gt; $event-&amp;gt;getId(), 'aggregateId' =&amp;gt; $event-&amp;gt;getAggregateId(), 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'timestamp' =&amp;gt; $event-&amp;gt;getTimestamp(), 'data' =&amp;gt; $event-&amp;gt;toArray(), 'metadata' =&amp;gt; $event-&amp;gt;getMetadata() ]; } return $results; } public function getEventStatistics(string $eventType, \DateTime $from, \DateTime $to): array { $events = $this-&amp;gt;eventStore-&amp;gt;getEventsByType($eventType, $from, $to); $statistics = [ 'total' =&amp;gt; count($events), 'byHour' =&amp;gt; [], 'byDay' =&amp;gt; [], 'byOrganization' =&amp;gt; [], 'byUser' =&amp;gt; [] ]; foreach ($events as $event) { $hour = $event-&amp;gt;getTimestamp()-&amp;gt;format('Y-m-d H:00:00'); $day = $event-&amp;gt;getTimestamp()-&amp;gt;format('Y-m-d'); $orgId = $event-&amp;gt;getMetadata()['organizationId'] ?? 'unknown'; $userId = $event-&amp;gt;getMetadata()['userId'] ?? 'unknown'; $statistics['byHour'][$hour] = ($statistics['byHour'][$hour] ?? 0) + 1; $statistics['byDay'][$day] = ($statistics['byDay'][$day] ?? 0) + 1; $statistics['byOrganization'][$orgId] = ($statistics['byOrganization'][$orgId] ?? 0) + 1; $statistics['byUser'][$userId] = ($statistics['byUser'][$userId] ?? 0) + 1; } return $statistics; }}&lt;/code&gt;#### &lt;strong&gt;Query Handler pour les Événements&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Query\Payment;use App\Infrastructure\InMemory\Query\EventSearchService;use App\Domain\Payment\Payment;use Psr\Log\LoggerInterface;class PaymentEventQueryHandler{ private EventSearchService $eventSearch; private LoggerInterface $logger; public function __construct(EventSearchService $eventSearch, LoggerInterface $logger) { $this-&amp;gt;eventSearch = $eventSearch; $this-&amp;gt;logger = $logger; } public function handle(GetPaymentHistoryQuery $query): array { $events = $this-&amp;gt;eventSearch-&amp;gt;getEventsByAggregate($query-&amp;gt;getPaymentId()); $history = []; foreach ($events as $event) { $history[] = [ 'eventId' =&amp;gt; $event['eventId'], 'eventType' =&amp;gt; $event['eventType'], 'timestamp' =&amp;gt; $event['timestamp'], 'data' =&amp;gt; $event['data'], 'metadata' =&amp;gt; $event['metadata'] ]; } return $history; } public function handle(SearchPaymentEventsQuery $query): array { $searchQuery = [ 'aggregateType' =&amp;gt; 'Payment' ]; if ($query-&amp;gt;getEventType()) { $searchQuery['eventType'] = $query-&amp;gt;getEventType(); } if ($query-&amp;gt;getFrom() || $query-&amp;gt;getTo()) { $searchQuery['timestamp'] = []; if ($query-&amp;gt;getFrom()) { $searchQuery['timestamp']['gte'] = $query-&amp;gt;getFrom(); } if ($query-&amp;gt;getTo()) { $searchQuery['timestamp']['lte'] = $query-&amp;gt;getTo(); } } $cacheKey = 'payment_events_' . md5(serialize($query)); $results = $this-&amp;gt;eventSearch-&amp;gt;searchEvents($searchQuery, $cacheKey); $events = []; foreach ($results as $event) { $events[] = [ 'eventId' =&amp;gt; $event-&amp;gt;getId(), 'aggregateId' =&amp;gt; $event-&amp;gt;getAggregateId(), 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'timestamp' =&amp;gt; $event-&amp;gt;getTimestamp(), 'data' =&amp;gt; $event-&amp;gt;toArray(), 'metadata' =&amp;gt; $event-&amp;gt;getMetadata() ]; } return $events; } public function handle(GetPaymentEventStatisticsQuery $query): array { return $this-&amp;gt;eventSearch-&amp;gt;getEventStatistics( $query-&amp;gt;getEventType(), $query-&amp;gt;getFrom(), $query-&amp;gt;getTo() ); } public function handle(ReplayPaymentEventsQuery $query): Payment { $events = $this-&amp;gt;eventSearch-&amp;gt;getEventsByAggregate($query-&amp;gt;getPaymentId()); // Reconstruire l'agrégat depuis les événements $payment = PaymentAggregate::fromEvents($events); return $payment-&amp;gt;toPayment(); }}&lt;/code&gt;### &lt;strong&gt;3. Service d&amp;rsquo;Analytics Avancées&lt;/strong&gt;#### &lt;strong&gt;Service d&amp;rsquo;Analytics des Événements&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Service\InMemory;use App\Infrastructure\InMemory\Query\EventSearchService;use Psr\Log\LoggerInterface;class EventAnalyticsService{ private EventSearchService $eventSearch; private LoggerInterface $logger; public function __construct(EventSearchService $eventSearch, LoggerInterface $logger) { $this-&amp;gt;eventSearch = $eventSearch; $this-&amp;gt;logger = $logger; } public function getEventTrends(string $eventType, \DateTime $from, \DateTime $to, string $interval = 'day'): array { $events = $this-&amp;gt;eventSearch-&amp;gt;getEventsByType($eventType, $from, $to); $trends = []; foreach ($events as $event) { $key = $this-&amp;gt;getIntervalKey($event['timestamp'], $interval); $trends[$key] = ($trends[$key] ?? 0) + 1; } ksort($trends); return $trends; } public function getEventCorrelations(string $correlationId): array { $events = $this-&amp;gt;eventSearch-&amp;gt;getEventsByCorrelationId($correlationId); $correlations = []; foreach ($events as $event) { $correlations[] = [ 'eventType' =&amp;gt; $event['eventType'], 'aggregateId' =&amp;gt; $event['aggregateId'], 'timestamp' =&amp;gt; $event['timestamp'], 'data' =&amp;gt; $event['data'] ]; } return $correlations; } public function getEventHeatmap(string $eventType, \DateTime $from, \DateTime $to): array { $events = $this-&amp;gt;eventSearch-&amp;gt;getEventsByType($eventType, $from, $to); $heatmap = [ 'byHour' =&amp;gt; [], 'byDay' =&amp;gt; [] ]; foreach ($events as $event) { $hour = $event['timestamp']-&amp;gt;format('Y-m-d H:00:00'); $day = $event['timestamp']-&amp;gt;format('Y-m-d'); $heatmap['byHour'][$hour] = ($heatmap['byHour'][$hour] ?? 0) + 1; $heatmap['byDay'][$day] = ($heatmap['byDay'][$day] ?? 0) + 1; } return $heatmap; } public function searchEventData(string $searchText, array $filters = []): array { $query = []; if (isset($filters['aggregateType'])) { $query['aggregateType'] = $filters['aggregateType']; } if (isset($filters['eventType'])) { $query['eventType'] = $filters['eventType']; } if (isset($filters['from']) || isset($filters['to'])) { $query['timestamp'] = []; if (isset($filters['from'])) { $query['timestamp']['gte'] = $filters['from']; } if (isset($filters['to'])) { $query['timestamp']['lte'] = $filters['to']; } } $events = $this-&amp;gt;eventSearch-&amp;gt;searchEvents($query); // Filtrer par texte de recherche if ($searchText) { $events = array_filter($events, function($event) use ($searchText) { $data = $event-&amp;gt;toArray(); return stripos(json_encode($data), $searchText) !== false; }); } $results = []; foreach ($events as $event) { $results[] = [ 'eventId' =&amp;gt; $event-&amp;gt;getId(), 'aggregateId' =&amp;gt; $event-&amp;gt;getAggregateId(), 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'timestamp' =&amp;gt; $event-&amp;gt;getTimestamp(), 'data' =&amp;gt; $event-&amp;gt;toArray(), 'metadata' =&amp;gt; $event-&amp;gt;getMetadata() ]; } return $results; } private function getIntervalKey(\DateTime $timestamp, string $interval): string { switch ($interval) { case 'hour': return $timestamp-&amp;gt;format('Y-m-d H:00:00'); case 'day': return $timestamp-&amp;gt;format('Y-m-d'); case 'week': return $timestamp-&amp;gt;format('Y-W'); case 'month': return $timestamp-&amp;gt;format('Y-m'); default: return $timestamp-&amp;gt;format('Y-m-d'); } }}&lt;/code&gt;## 🧪 &lt;strong&gt;Tests et Validation&lt;/strong&gt;### &lt;strong&gt;Tests d&amp;rsquo;Intégration Event Sourcing + CQS&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Tests\Integration\InMemory;use App\Application\Command\Payment\ProcessPaymentCommand;use App\Application\Command\Payment\ProcessPaymentCommandHandler;use App\Application\Query\Payment\GetPaymentHistoryQuery;use App\Application\Query\Payment\PaymentEventQueryHandler;use App\Infrastructure\EventStore\InMemoryEventStore;use App\Infrastructure\InMemory\Query\EventSearchService;class InMemoryEventSourcingCqsTest extends TestCase{ private InMemoryEventStore $eventStore; private EventSearchService $eventSearch; private ProcessPaymentCommandHandler $commandHandler; private PaymentEventQueryHandler $queryHandler; protected function setUp(): void { $this-&amp;gt;eventStore = new InMemoryEventStore($this-&amp;gt;createMock(LoggerInterface::class)); $this-&amp;gt;eventSearch = new EventSearchService($this-&amp;gt;eventStore, $this-&amp;gt;createMock(LoggerInterface::class), $this-&amp;gt;createMock(CacheItemPoolInterface::class)); $this-&amp;gt;commandHandler = new ProcessPaymentCommandHandler( $this-&amp;gt;eventStore, $this-&amp;gt;createMock(EventBusInterface::class), $this-&amp;gt;createMock(LoggerInterface::class) ); $this-&amp;gt;queryHandler = new PaymentEventQueryHandler($this-&amp;gt;eventSearch, $this-&amp;gt;createMock(LoggerInterface::class)); } public function testEventSourcingCqsFlow(): void { // Exécuter une commande $command = new ProcessPaymentCommand( 'payment-123', 100.00, 'EUR' ); $this-&amp;gt;commandHandler-&amp;gt;handle($command); // Vérifier l'historique des événements $query = new GetPaymentHistoryQuery('payment-123'); $history = $this-&amp;gt;queryHandler-&amp;gt;handle($query); $this-&amp;gt;assertNotEmpty($history); $this-&amp;gt;assertCount(1, $history); $this-&amp;gt;assertEquals('PaymentProcessed', $history[0]['eventType']); } public function testEventSearchWithAnalytics(): void { // Créer plusieurs événements $commands = [ new ProcessPaymentCommand('payment-1', 100.00, 'EUR'), new ProcessPaymentCommand('payment-2', 200.00, 'USD'), new ProcessPaymentCommand('payment-3', 300.00, 'EUR') ]; foreach ($commands as $command) { $this-&amp;gt;commandHandler-&amp;gt;handle($command); } // Rechercher les événements $searchQuery = new SearchPaymentEventsQuery( new \DateTime('2024-01-01'), new \DateTime('2024-12-31') ); $results = $this-&amp;gt;queryHandler-&amp;gt;handle($searchQuery); $this-&amp;gt;assertCount(3, $results); $this-&amp;gt;assertEquals('PaymentProcessed', $results[0]['eventType']); }}&lt;/code&gt;## 📊 &lt;strong&gt;Performance et Optimisation&lt;/strong&gt;### &lt;strong&gt;Stratégies d&amp;rsquo;Optimisation Event Sourcing + CQS&lt;/strong&gt;#### &lt;strong&gt;1. Cache Multi-Niveaux&lt;/strong&gt;&lt;code&gt;phppublic function searchEventsWithCache(array $query, string $cacheKey = null): array{ // Cache L1: Mémoire if (isset($this-&amp;gt;memoryCache[$cacheKey])) { return $this-&amp;gt;memoryCache[$cacheKey]; } // Cache L2: Redis if ($cached = $this-&amp;gt;redis-&amp;gt;get(&amp;quot;event_search:{$cacheKey}&amp;quot;)) { $result = json_decode($cached, true); $this-&amp;gt;memoryCache[$cacheKey] = $result; return $result; } // In-Memory $result = $this-&amp;gt;searchEvents($query); // Mettre en cache $this-&amp;gt;memoryCache[$cacheKey] = $result; $this-&amp;gt;redis-&amp;gt;setex(&amp;quot;event_search:{$cacheKey}&amp;quot;, 300, json_encode($result)); return $result;}&lt;/code&gt;#### &lt;strong&gt;2. Projections Asynchrones&lt;/strong&gt;&lt;code&gt;phppublic function handleEventAsync(DomainEvent $event): void{ // Mettre en queue pour traitement asynchrone $this-&amp;gt;messageBus-&amp;gt;dispatch(new ProcessProjectionCommand($event));}&lt;/code&gt;#### &lt;strong&gt;3. Index Optimisés&lt;/strong&gt;&lt;code&gt;phppublic function optimizeIndexes(): void{ // Nettoyer les index orphelins $this-&amp;gt;cleanOrphanedIndexes(); // Compacter les index $this-&amp;gt;compactIndexes(); // Forcer le garbage collection gc_collect_cycles();}&lt;/code&gt;## 🎯 &lt;strong&gt;Critères d&amp;rsquo;Adoption&lt;/strong&gt;### &lt;strong&gt;Quand Utiliser Event Sourcing + CQS avec In-Memory&lt;/strong&gt;#### &lt;strong&gt;✅ Avantages&lt;/strong&gt;- &lt;strong&gt;Audit trail complet&lt;/strong&gt; : Historique de tous les événements- &lt;strong&gt;Performance optimisée&lt;/strong&gt; : Séparation claire entre écriture et lecture- &lt;strong&gt;Debugging avancé&lt;/strong&gt; : Possibilité de rejouer les événements- &lt;strong&gt;Flexibilité&lt;/strong&gt; : Requêtes optimisées pour chaque usage- &lt;strong&gt;Cache efficace&lt;/strong&gt; : Mise en cache des requêtes#### &lt;strong&gt;❌ Inconvénients&lt;/strong&gt;- &lt;strong&gt;Complexité élevée&lt;/strong&gt; : Architecture très complexe- &lt;strong&gt;Volatilité&lt;/strong&gt; : Données perdues au redémarrage- &lt;strong&gt;Limitation mémoire&lt;/strong&gt; : Contraint par la RAM disponible- &lt;strong&gt;Expertise&lt;/strong&gt; : Équipe très expérimentée requise#### &lt;strong&gt;🎯 Critères d&amp;rsquo;Adoption&lt;/strong&gt;- &lt;strong&gt;Audit trail critique&lt;/strong&gt; : Besoin de traçabilité complète- &lt;strong&gt;Performance importante&lt;/strong&gt; : Besoins de performance élevée- &lt;strong&gt;Debugging complexe&lt;/strong&gt; : Besoin de rejouer les événements- &lt;strong&gt;Données temporaires&lt;/strong&gt; : Cache, sessions, métriques- &lt;strong&gt;Équipe très expérimentée&lt;/strong&gt; : Maîtrise d&amp;rsquo;Event Sourcing, CQS et In-Memory- &lt;strong&gt;Mémoire suffisante&lt;/strong&gt; : RAM disponible pour tous les événements## 🚀 &lt;strong&gt;Votre Prochaine Étape&lt;/strong&gt;

&lt;div class="chapter-navigation"&gt;
 &lt;h2 class="chapter-nav-title"&gt;🎯 Votre Prochaine Étape&lt;/h2&gt;
 &lt;p class="chapter-nav-subtitle"&gt;Maintenant que vous comprenez les concepts de base et que j'ai partagé mon expérience avec Gyroscops, quel est votre contexte ?&lt;/p&gt;</description></item><item><title>Stockage In-Memory - Event Sourcing + CQRS</title><link>http://localhost:1313/chapitres/stockage/in-memory/chapitre-45-stockage-in-memory-event-sourcing-cqrs/</link><pubDate>Thu, 19 Dec 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/chapitres/stockage/in-memory/chapitre-45-stockage-in-memory-event-sourcing-cqrs/</guid><description>&lt;h2 id="-contexte-et-objectifs-lnous-arrivons-maintenant-à-lapproche-la-plus-sophistiquée-et-puissante-pour-in-memory--event-sourcing--cqrs-cette-combinaison-représente-létat-de-lart-en-matière-darchitecture-scalable-pour-la-performance-et-laudit-trail-pourquoi-cette-combinaison---audit-trail-complet--historique-immuable-de-tous-les-événements--scalabilité-maximale--possibilité-de-scaler-indépendamment-chaque-côté--performance-optimale--chaque-côté-optimisé-pour-son-usage--flexibilité-maximale--projections-multiples-pour-différents-besoins--cache-efficace--mise-en-cache-des-requêtes-contexte-gyroscopsdans-notre-écosystème-user--organization--workflow--cloud-resources--billing-event-sourcing--cqrs-avec-in-memory-est-la-solution-ultime-pour---cache-haute-performance--audit-trail-complet-avec-analytics-avancées--sessions-utilisateur--gestion-optimisée-des-sessions-avec-projections--métriques-en-temps-réel--traçabilité-des-métriques-avec-analytics-temporelles--tests-et-développement--environnements-de-test-rapides-et-organisés--architecture-event-sourcing--cqrs-séparation-complète-des-responsabilités-command-side-write--command-handlers--traitement-des-commandes-métier--event-store--persistance-des-événements-dans-in-memory--event-handlers--gestion-des-événements-de-domaine--command-bus--orchestration-des-commandes--bulk-operations--optimisation-des-écritures-query-side-read--query-handlers--traitement-des-requêtes--event-search--recherche-dans-les-événements--analytics-services--services-danalytics-temporelles--query-bus--orchestration-des-requêtes--caches--optimisation-des-performances-flux-de-données-completmermaidgraph-td----acommand----bcommand-bus----b----ccommand-handler----c----daggregate----d----eevents----e----fevent-store-in-memory----f----gevent-bus----g----hevent-handlers----h----iprojections----i----jread-models--------kquery----lquery-bus----l----mquery-handler----m----nevent-search----n----f----f----osearch-results----o----presponse--------qanalytics----ranalytics-service----r----f----f----shistorical-data----s----tanalytics-results--implémentation-complète-1-command-side-implementation-event-store-in-memory-avancéphpphpnamespace-appinfrastructureeventstoreuse-appdomaineventdomaineventuse-appdomaineventeventstoreinterfaceuse-psrlogloggerinterfaceclass-inmemoryeventstore-implements-eventstoreinterface----private-array-events------private-array-indexes------private-loggerinterface-logger----private-array-bulkbuffer------private-int-bulksize----public-function-__constructloggerinterface-logger-int-bulksize--100------------this-logger--logger--------this-bulksize--bulksize--------public-function-appendeventsstring-aggregateid-array-events-int-expectedversion-void------------try--------------vérifier-la-version-attendue------------lastevent--this-getlasteventaggregateid------------------------if-lastevent--lasteventversion--expectedversion-----------------throw-new-concurrencyexceptionversion-mismatch-------------------------------------préparer-les-événements-pour-linsertion------------version--expectedversion--1------------------------foreach-events-as-event-----------------this-bulkbuffer----------------------eventid--event-getid--------------------aggregateid--aggregateid--------------------aggregatetype--event-getaggregatetype--------------------eventtype--event-geteventtype--------------------eventdata--event-toarray--------------------version--version--------------------timestamp--event-gettimestamp--------------------correlationid--event-getcorrelationid--------------------causationid--event-getcausationid--------------------metadata--event-getmetadata------------------------------------------------if-countthis-bulkbuffer--this-bulksize---------------------this-flushbulk----------------------------------------------------this-flushbulk---------------------catch-exception-e-------------this-logger-errorfailed-to-append-events-----------------aggregateid--aggregateid----------------events--countevents----------------error--e-getmessage------------------------------------throw-e----------------public-function-geteventsstring-aggregateid-int-fromversion--0-array------------events------------------foreach-this-events-as-event-------------if-eventaggregateid--aggregateid--eventversion--fromversion-----------------events--this-deserializeeventevent-------------------------------------trier-par-version--------usortevents-fna-b--a-getversion--b-getversion----------------return-events--------public-function-searcheventsarray-criteria-array------------events------------------foreach-this-events-as-event-------------if-this-matchescriteriaevent-criteria-----------------events--this-deserializeeventevent-------------------------------------trier-par-timestamp--------usortevents-fna-b--a-gettimestamp--b-gettimestamp----------------return-events--------private-function-getlasteventstring-aggregateid-array------------lastevent--null--------lastversion---1----------------foreach-this-events-as-event-------------if-eventaggregateid--aggregateid--eventversion--lastversion-----------------lastevent--event----------------lastversion--eventversion------------------------------------return-lastevent--------private-function-flushbulk-void------------if-emptythis-bulkbuffer-------------return----------------try-------------foreach-this-bulkbuffer-as-eventdata-----------------this-eventseventdataeventid--eventdata----------------this-updateindexeseventdata------------------------this-logger-infobulk-events-inserted-----------------events--countthis-bulkbuffer------------------------this-bulkbuffer-----------catch-exception-e-------------this-logger-errorbulk-events-insertion-failed-----------------error--e-getmessage----------------events--countthis-bulkbuffer------------------------throw-e----------------private-function-updateindexesarray-eventdata-void-------------index-par-type-dévénement--------this-indexeseventtypeeventdataeventtype--eventdataeventid-----------------index-par-agrégat--------this-indexesaggregateideventdataaggregateid--eventdataeventid-----------------index-par-corrélation--------if-eventdatacorrelationid-------------this-indexescorrelationideventdatacorrelationid--eventdataeventid-------------------------index-par-timestamp--------date--eventdatatimestamp-formaty-m-d--------this-indexesdatedate--eventdataeventid--------private-function-matchescriteriaarray-event-array-criteria-bool------------foreach-criteria-as-field--expectedvalue-------------if-this-fieldmatchesevent-field-expectedvalue-----------------return-false------------------------------------return-true--------private-function-fieldmatchesarray-event-string-field-mixed-expectedvalue-bool------------fieldvalue--eventfield--null----------------if-is_arrayexpectedvalue-------------return-in_arrayfieldvalue-expectedvalue------------------------return-fieldvalue--expectedvalue--------private-function-deserializeeventarray-eventdata-domainevent------------eventclass--eventdataeventtype--------return-eventclassfromarrayeventdataeventdata-----command-bus-avec-middlewarephpphpnamespace-appapplicationcommandbususe-appdomaincommandcommandinterfaceuse-appdomaincommandcommandhandlerinterfaceuse-psrlogloggerinterfaceclass-commandbus----private-array-handlers------private-array-middleware------private-loggerinterface-logger----public-function-__constructloggerinterface-logger------------this-logger--logger--------public-function-registerhandlerstring-commandclass-commandhandlerinterface-handler-void------------this-handlerscommandclass--handler--------public-function-addmiddlewarecallable-middleware-void------------this-middleware--middleware--------public-function-handlecommandinterface-command-void------------commandclass--get_classcommand----------------if-issetthis-handlerscommandclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-command-commandclass----------------handler--this-handlerscommandclass-----------------exécuter-les-middleware--------this-executemiddlewarecommand-function-use-handler-command-------------this-logger-infoexecuting-command-----------------command--get_classcommand----------------data--command-toarray------------------------------------handler-handlecommand----------------private-function-executemiddlewarecommandinterface-command-callable-next-void------------middleware--array_reversethis-middleware----------------foreach-middleware-as-mw-------------next--function-use-mw-command-next-----------------return-mwcommand-next------------------------------------next-----2-query-side-implementation-query-bus-avec-cachephpphpnamespace-appapplicationquerybususe-appdomainqueryqueryinterfaceuse-appdomainqueryqueryhandlerinterfaceuse-psrcachecacheitempoolinterfaceuse-psrlogloggerinterfaceclass-querybus----private-array-handlers------private-cacheitempoolinterface-cache----private-loggerinterface-logger----public-function-__constructcacheitempoolinterface-cache-loggerinterface-logger------------this-cache--cache--------this-logger--logger--------public-function-registerhandlerstring-queryclass-queryhandlerinterface-handler-void------------this-handlersqueryclass--handler--------public-function-handlequeryinterface-query-mixed------------queryclass--get_classquery----------------if-issetthis-handlersqueryclass-------------throw-new-invalidargumentexceptionno-handler-registered-for-query-queryclass-----------------vérifier-le-cache--------cachekey--this-generatecachekeyquery--------cacheditem--this-cache-getitemcachekey----------------if-cacheditem-ishit-------------this-logger-debugquery-result-served-from-cache-----------------query--queryclass----------------cachekey--cachekey------------------------------------return-cacheditem-get-----------------exécuter-la-requête--------handler--this-handlersqueryclass--------result--handler-handlequery-----------------mettre-en-cache--------cacheditem-setresult--------cacheditem-expiresafter300--5-minutes--------this-cache-savecacheditem----------------this-logger-infoquery-executed-and-cached-------------query--queryclass------------cachekey--cachekey------------------------return-result--------private-function-generatecachekeyqueryinterface-query-string------------return-query_--md5serializequery-----event-search-service-avancéphpphpnamespace-appinfrastructureinmemoryqueryuse-appinfrastructureeventstoreinmemoryeventstoreuse-psrlogloggerinterfaceuse-psrcachecacheitempoolinterfaceclass-eventsearchservice----private-inmemoryeventstore-eventstore----private-loggerinterface-logger----private-cacheitempoolinterface-cache----public-function-__construct--------inmemoryeventstore-eventstore--------loggerinterface-logger--------cacheitempoolinterface-cache-------------this-eventstore--eventstore--------this-logger--logger--------this-cache--cache--------public-function-searcheventsarray-query-string-cachekey--null-array-------------vérifier-le-cache--------if-cachekey-------------cacheditem--this-cache-getitemcachekey------------if-cacheditem-ishit-----------------this-logger-debugevent-search-result-served-from-cache---------------------query--query--------------------cachekey--cachekey--------------------------------return-cacheditem-get----------------------------results--this-eventstore-searcheventsquery---------mettre-en-cache--------if-cachekey-------------cacheditem-setresults------------cacheditem-expiresafter300--5-minutes------------this-cache-savecacheditem----------------this-logger-infoevent-search-executed-------------query--query------------results--countresults----------------return-results--------public-function-geteventstatisticsstring-eventtype-datetime-from-datetime-to-array------------events--this-eventstore-geteventsbytypeeventtype-from-to----------------statistics--------------total--countevents------------byhour--------------byday--------------byorganization--------------byuser--------------------------foreach-events-as-event-------------hour--event-gettimestamp-formaty-m-d-h0000------------day--event-gettimestamp-formaty-m-d------------orgid--event-getmetadataorganizationid--unknown------------userid--event-getmetadatauserid--unknown------------------------statisticsbyhourhour--statisticsbyhourhour--0--1------------statisticsbydayday--statisticsbydayday--0--1------------statisticsbyorganizationorgid--statisticsbyorganizationorgid--0--1------------statisticsbyuseruserid--statisticsbyuseruserid--0--1------------------------return-statistics--------public-function-geteventtrendsstring-eventtype-datetime-from-datetime-to-string-interval--day-array------------events--this-eventstore-geteventsbytypeeventtype-from-to----------------trends----------foreach-events-as-event-------------key--this-getintervalkeyevent-gettimestamp-interval------------trendskey--trendskey--0--1------------------------ksorttrends--------return-trends-----3-service-de-projection-avancé-service-de-projection-pour-les-analyticsphpphpnamespace-appapplicationserviceinmemoryuse-appdomaineventdomaineventuse-appinfrastructureinmemorycommandinmemorywriteruse-psrlogloggerinterfaceclass-paymentprojectionservice----private-inmemorywriter-writer----private-loggerinterface-logger----public-function-__constructinmemorywriter-writer-loggerinterface-logger------------this-writer--writer--------this-logger--logger--------public-function-handleeventdomainevent-event-void------------switch-event-geteventtype-------------case-paymentprocessed----------------this-handlepaymentprocessedevent----------------break------------case-paymentfailed----------------this-handlepaymentfailedevent----------------break------------case-paymentrefunded----------------this-handlepaymentrefundedevent----------------break----------------private-function-handlepaymentprocesseddomainevent-event-void------------key--paymentevent-getaggregateid--------update--------------status--completed------------processedat--event-gettimestamp-formatc------------updatedat--new-datetime-formatc----------------this-writer-updatekey-update-status--------this-logger-infopayment-processed-projection-updated-------------paymentid--event-getaggregateid------------status--completed----------------private-function-handlepaymentfaileddomainevent-event-void------------key--paymentevent-getaggregateid--------update--------------status--failed------------error--event-getdataerror------------failedat--event-gettimestamp-formatc------------updatedat--new-datetime-formatc----------------this-writer-updatekey-update-status--------this-logger-infopayment-failed-projection-updated-------------paymentid--event-getaggregateid------------status--failed----------------private-function-handlepaymentrefundeddomainevent-event-void------------key--paymentevent-getaggregateid--------update--------------status--refunded------------refundamount--event-getdatarefundamount------------refundedat--event-gettimestamp-formatc------------updatedat--new-datetime-formatc----------------this-writer-updatekey-update-status--------this-logger-infopayment-refunded-projection-updated-------------paymentid--event-getaggregateid------------status--refunded--------------tests-et-validation-tests-dphpphpnamespace-apptestsintegrationinmemoryuse-appapplicationcommandpaymentprocesspaymentcommanduse-appapplicationcommandpaymentprocesspaymentcommandhandleruse-appapplicationquerypaymentgetpaymenthistoryqueryuse-appapplicationquerypaymentpaymenteventqueryhandleruse-appinfrastructureeventstoreinmemoryeventstoreuse-appinfrastructureinmemoryqueryeventsearchserviceclass-inmemoryeventsourcingcqrstest-extends-testcase----private-inmemoryeventstore-eventstore----private-eventsearchservice-eventsearch----private-processpaymentcommandhandler-commandhandler----private-paymenteventqueryhandler-queryhandler----protected-function-setup-void------------this-eventstore--new-inmemoryeventstorethis-createmockloggerinterfaceclass--------this-eventsearch--new-eventsearchservicethis-eventstore-this-createmockloggerinterfaceclass-this-createmockcacheitempoolinterfaceclass----------------this-commandhandler--new-processpaymentcommandhandler------------this-eventstore------------this-createmockeventbusinterfaceclass------------this-createmockloggerinterfaceclass------------------------this-queryhandler--new-paymenteventqueryhandlerthis-eventsearch-this-createmockloggerinterfaceclass--------public-function-testeventsourcingcqrsflow-void-------------exécuter-une-commande--------command--new-processpaymentcommand------------payment-123------------10000------------eur------------------------this-commandhandler-handlecommand-----------------vérifier-lhistorique-des-événements--------query--new-getpaymenthistoryquerypayment-123--------history--this-queryhandler-handlequery----------------this-assertnotemptyhistory--------this-assertcount1-history--------this-assertequalspaymentprocessed-history0eventtype--------public-function-testeventsearchwithanalytics-void-------------créer-plusieurs-événements--------commands--------------new-processpaymentcommandpayment-1-10000-eur------------new-processpaymentcommandpayment-2-20000-usd------------new-processpaymentcommandpayment-3-30000-eur------------------------foreach-commands-as-command-------------this-commandhandler-handlecommand-------------------------rechercher-les-événements--------searchquery--new-searchpaymenteventsquery------------new-datetime2024-01-01------------new-datetime2024-12-31------------------------results--this-queryhandler-handlesearchquery----------------this-assertcount3-results--------this-assertequalspaymentprocessed-results0eventtype------performance-et-optimisation-stratégies-d-1-cache-multi-niveauxphppublic-function-searcheventswithcachearray-query-string-cachekey--null-array-----cache-l1-mémoire----if-issetthis-memorycachecachekey---------return-this-memorycachecachekey-------------cache-l2-redis----if-cached--this-redis-getevent_searchcachekey---------result--json_decodecached-true--------this-memorycachecachekey--result--------return-result-------------in-memory----result--this-searcheventsquery---------mettre-en-cache----this-memorycachecachekey--result----this-redis-setexevent_searchcachekey-300-json_encoderesult--------return-result-2-projections-asynchronesphppublic-function-handleeventasyncdomainevent-event-void-----mettre-en-queue-pour-traitement-asynchrone----this-messagebus-dispatchnew-processprojectioncommandevent-3-index-optimisésphppublic-function-optimizeindexes-void-----nettoyer-les-index-orphelins----this-cleanorphanedindexes---------compacter-les-index----this-compactindexes---------forcer-le-garbage-collection----gc_collect_cycles--critères-d-quand-utiliser-event-sourcing--cqrs-avec-in-memory--avantages--audit-trail-complet--historique-immuable-de-tous-les-événements--scalabilité-maximale--possibilité-de-scaler-indépendamment--performance-optimale--chaque-côté-optimisé-pour-son-usage--flexibilité-maximale--projections-multiples-pour-différents-besoins--cache-efficace--mise-en-cache-des-requêtes--inconvénients--complexité-maximale--architecture-très-complexe--volatilité--données-perdues-au-redémarrage--limitation-mémoire--contraint-par-la-ram-disponible--expertise--équipe-très-expérimentée-requise--coût--infrastructure-très-coûteuse--critères-d--système-très-complexe--besoins-de-scalabilité-maximale--audit-trail-critique--besoin-de-traçabilité-complète--performance-critique--besoins-de-performance-maximale--données-temporaires--cache-sessions-métriques--équipe-très-expérimentée--maîtrise-devent-sourcing-cqrs-et-in-memory--budget-important--investissement-en-complexité-justifié--mémoire-suffisante--ram-disponible-pour-tous-les-événements--votre-prochaine-étapehahahugoshortcode35s0hbhbevent-sourcing--cqrs-avec-in-memory-représente-l"&gt;🎯 &lt;strong&gt;Contexte et Objectifs&lt;/strong&gt;### &lt;strong&gt;L&amp;rsquo;Architecture Maximale : Event Sourcing + CQRS avec In-Memory&lt;/strong&gt;Nous arrivons maintenant à l&amp;rsquo;approche la plus sophistiquée et puissante pour In-Memory : &lt;strong&gt;Event Sourcing + CQRS&lt;/strong&gt;. Cette combinaison représente l&amp;rsquo;état de l&amp;rsquo;art en matière d&amp;rsquo;architecture scalable pour la performance et l&amp;rsquo;audit trail.#### &lt;strong&gt;Pourquoi cette Combinaison ?&lt;/strong&gt;- &lt;strong&gt;Audit trail complet&lt;/strong&gt; : Historique immuable de tous les événements- &lt;strong&gt;Scalabilité maximale&lt;/strong&gt; : Possibilité de scaler indépendamment chaque côté- &lt;strong&gt;Performance optimale&lt;/strong&gt; : Chaque côté optimisé pour son usage- &lt;strong&gt;Flexibilité maximale&lt;/strong&gt; : Projections multiples pour différents besoins- &lt;strong&gt;Cache efficace&lt;/strong&gt; : Mise en cache des requêtes### &lt;strong&gt;Contexte Gyroscops&lt;/strong&gt;Dans notre écosystème &lt;strong&gt;User → Organization → Workflow → Cloud Resources → Billing&lt;/strong&gt;, Event Sourcing + CQRS avec In-Memory est la solution ultime pour :- &lt;strong&gt;Cache haute performance&lt;/strong&gt; : Audit trail complet avec analytics avancées- &lt;strong&gt;Sessions utilisateur&lt;/strong&gt; : Gestion optimisée des sessions avec projections- &lt;strong&gt;Métriques en temps réel&lt;/strong&gt; : Traçabilité des métriques avec analytics temporelles- &lt;strong&gt;Tests et développement&lt;/strong&gt; : Environnements de test rapides et organisés## 🏗️ &lt;strong&gt;Architecture Event Sourcing + CQRS&lt;/strong&gt;### &lt;strong&gt;Séparation Complète des Responsabilités&lt;/strong&gt;#### &lt;strong&gt;Command Side (Write)&lt;/strong&gt;- &lt;strong&gt;Command Handlers&lt;/strong&gt; : Traitement des commandes métier- &lt;strong&gt;Event Store&lt;/strong&gt; : Persistance des événements dans In-Memory- &lt;strong&gt;Event Handlers&lt;/strong&gt; : Gestion des événements de domaine- &lt;strong&gt;Command Bus&lt;/strong&gt; : Orchestration des commandes- &lt;strong&gt;Bulk Operations&lt;/strong&gt; : Optimisation des écritures#### &lt;strong&gt;Query Side (Read)&lt;/strong&gt;- &lt;strong&gt;Query Handlers&lt;/strong&gt; : Traitement des requêtes- &lt;strong&gt;Event Search&lt;/strong&gt; : Recherche dans les événements- &lt;strong&gt;Analytics Services&lt;/strong&gt; : Services d&amp;rsquo;analytics temporelles- &lt;strong&gt;Query Bus&lt;/strong&gt; : Orchestration des requêtes- &lt;strong&gt;Caches&lt;/strong&gt; : Optimisation des performances### &lt;strong&gt;Flux de Données Complet&lt;/strong&gt;&lt;code&gt;mermaidgraph TD A[Command] --&amp;gt; B[Command Bus] B --&amp;gt; C[Command Handler] C --&amp;gt; D[Aggregate] D --&amp;gt; E[Events] E --&amp;gt; F[Event Store In-Memory] F --&amp;gt; G[Event Bus] G --&amp;gt; H[Event Handlers] H --&amp;gt; I[Projections] I --&amp;gt; J[Read Models] K[Query] --&amp;gt; L[Query Bus] L --&amp;gt; M[Query Handler] M --&amp;gt; N[Event Search] N --&amp;gt; F F --&amp;gt; O[Search Results] O --&amp;gt; P[Response] Q[Analytics] --&amp;gt; R[Analytics Service] R --&amp;gt; F F --&amp;gt; S[Historical Data] S --&amp;gt; T[Analytics Results]&lt;/code&gt;## 💻 &lt;strong&gt;Implémentation Complète&lt;/strong&gt;### &lt;strong&gt;1. Command Side Implementation&lt;/strong&gt;#### &lt;strong&gt;Event Store In-Memory Avancé&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Infrastructure\EventStore;use App\Domain\Event\DomainEvent;use App\Domain\Event\EventStoreInterface;use Psr\Log\LoggerInterface;class InMemoryEventStore implements EventStoreInterface{ private array $events = []; private array $indexes = []; private LoggerInterface $logger; private array $bulkBuffer = []; private int $bulkSize; public function __construct(LoggerInterface $logger, int $bulkSize = 100) { $this-&amp;gt;logger = $logger; $this-&amp;gt;bulkSize = $bulkSize; } public function appendEvents(string $aggregateId, array $events, int $expectedVersion): void { try { // Vérifier la version attendue $lastEvent = $this-&amp;gt;getLastEvent($aggregateId); if ($lastEvent &amp;amp;&amp;amp; $lastEvent['version'] !== $expectedVersion) { throw new ConcurrencyException('Version mismatch'); } // Préparer les événements pour l'insertion $version = $expectedVersion + 1; foreach ($events as $event) { $this-&amp;gt;bulkBuffer[] = [ 'eventId' =&amp;gt; $event-&amp;gt;getId(), 'aggregateId' =&amp;gt; $aggregateId, 'aggregateType' =&amp;gt; $event-&amp;gt;getAggregateType(), 'eventType' =&amp;gt; $event-&amp;gt;getEventType(), 'eventData' =&amp;gt; $event-&amp;gt;toArray(), 'version' =&amp;gt; $version++, 'timestamp' =&amp;gt; $event-&amp;gt;getTimestamp(), 'correlationId' =&amp;gt; $event-&amp;gt;getCorrelationId(), 'causationId' =&amp;gt; $event-&amp;gt;getCausationId(), 'metadata' =&amp;gt; $event-&amp;gt;getMetadata() ]; if (count($this-&amp;gt;bulkBuffer) &amp;gt;= $this-&amp;gt;bulkSize) { $this-&amp;gt;flushBulk(); } } $this-&amp;gt;flushBulk(); } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Failed to append events', [ 'aggregateId' =&amp;gt; $aggregateId, 'events' =&amp;gt; count($events), 'error' =&amp;gt; $e-&amp;gt;getMessage() ]); throw $e; } } public function getEvents(string $aggregateId, int $fromVersion = 0): array { $events = []; foreach ($this-&amp;gt;events as $event) { if ($event['aggregateId'] === $aggregateId &amp;amp;&amp;amp; $event['version'] &amp;gt;= $fromVersion) { $events[] = $this-&amp;gt;deserializeEvent($event); } } // Trier par version usort($events, fn($a, $b) =&amp;gt; $a-&amp;gt;getVersion() &amp;lt;=&amp;gt; $b-&amp;gt;getVersion()); return $events; } public function searchEvents(array $criteria): array { $events = []; foreach ($this-&amp;gt;events as $event) { if ($this-&amp;gt;matchesCriteria($event, $criteria)) { $events[] = $this-&amp;gt;deserializeEvent($event); } } // Trier par timestamp usort($events, fn($a, $b) =&amp;gt; $a-&amp;gt;getTimestamp() &amp;lt;=&amp;gt; $b-&amp;gt;getTimestamp()); return $events; } private function getLastEvent(string $aggregateId): ?array { $lastEvent = null; $lastVersion = -1; foreach ($this-&amp;gt;events as $event) { if ($event['aggregateId'] === $aggregateId &amp;amp;&amp;amp; $event['version'] &amp;gt; $lastVersion) { $lastEvent = $event; $lastVersion = $event['version']; } } return $lastEvent; } private function flushBulk(): void { if (empty($this-&amp;gt;bulkBuffer)) { return; } try { foreach ($this-&amp;gt;bulkBuffer as $eventData) { $this-&amp;gt;events[$eventData['eventId']] = $eventData; $this-&amp;gt;updateIndexes($eventData); } $this-&amp;gt;logger-&amp;gt;info('Bulk events inserted', [ 'events' =&amp;gt; count($this-&amp;gt;bulkBuffer) ]); $this-&amp;gt;bulkBuffer = []; } catch (\Exception $e) { $this-&amp;gt;logger-&amp;gt;error('Bulk events insertion failed', [ 'error' =&amp;gt; $e-&amp;gt;getMessage(), 'events' =&amp;gt; count($this-&amp;gt;bulkBuffer) ]); throw $e; } } private function updateIndexes(array $eventData): void { // Index par type d'événement $this-&amp;gt;indexes['eventType'][$eventData['eventType']][] = $eventData['eventId']; // Index par agrégat $this-&amp;gt;indexes['aggregateId'][$eventData['aggregateId']][] = $eventData['eventId']; // Index par corrélation if ($eventData['correlationId']) { $this-&amp;gt;indexes['correlationId'][$eventData['correlationId']][] = $eventData['eventId']; } // Index par timestamp $date = $eventData['timestamp']-&amp;gt;format('Y-m-d'); $this-&amp;gt;indexes['date'][$date][] = $eventData['eventId']; } private function matchesCriteria(array $event, array $criteria): bool { foreach ($criteria as $field =&amp;gt; $expectedValue) { if (!$this-&amp;gt;fieldMatches($event, $field, $expectedValue)) { return false; } } return true; } private function fieldMatches(array $event, string $field, mixed $expectedValue): bool { $fieldValue = $event[$field] ?? null; if (is_array($expectedValue)) { return in_array($fieldValue, $expectedValue); } return $fieldValue === $expectedValue; } private function deserializeEvent(array $eventData): DomainEvent { $eventClass = $eventData['eventType']; return $eventClass::fromArray($eventData['eventData']); }}&lt;/code&gt;#### &lt;strong&gt;Command Bus avec Middleware&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\CommandBus;use App\Domain\Command\CommandInterface;use App\Domain\Command\CommandHandlerInterface;use Psr\Log\LoggerInterface;class CommandBus{ private array $handlers = []; private array $middleware = []; private LoggerInterface $logger; public function __construct(LoggerInterface $logger) { $this-&amp;gt;logger = $logger; } public function registerHandler(string $commandClass, CommandHandlerInterface $handler): void { $this-&amp;gt;handlers[$commandClass] = $handler; } public function addMiddleware(callable $middleware): void { $this-&amp;gt;middleware[] = $middleware; } public function handle(CommandInterface $command): void { $commandClass = get_class($command); if (!isset($this-&amp;gt;handlers[$commandClass])) { throw new \InvalidArgumentException(&amp;quot;No handler registered for command: $commandClass&amp;quot;); } $handler = $this-&amp;gt;handlers[$commandClass]; // Exécuter les middleware $this-&amp;gt;executeMiddleware($command, function() use ($handler, $command) { $this-&amp;gt;logger-&amp;gt;info('Executing command', [ 'command' =&amp;gt; get_class($command), 'data' =&amp;gt; $command-&amp;gt;toArray() ]); $handler-&amp;gt;handle($command); }); } private function executeMiddleware(CommandInterface $command, callable $next): void { $middleware = array_reverse($this-&amp;gt;middleware); foreach ($middleware as $mw) { $next = function() use ($mw, $command, $next) { return $mw($command, $next); }; } $next(); }}&lt;/code&gt;### &lt;strong&gt;2. Query Side Implementation&lt;/strong&gt;#### &lt;strong&gt;Query Bus avec Cache&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\QueryBus;use App\Domain\Query\QueryInterface;use App\Domain\Query\QueryHandlerInterface;use Psr\Cache\CacheItemPoolInterface;use Psr\Log\LoggerInterface;class QueryBus{ private array $handlers = []; private CacheItemPoolInterface $cache; private LoggerInterface $logger; public function __construct(CacheItemPoolInterface $cache, LoggerInterface $logger) { $this-&amp;gt;cache = $cache; $this-&amp;gt;logger = $logger; } public function registerHandler(string $queryClass, QueryHandlerInterface $handler): void { $this-&amp;gt;handlers[$queryClass] = $handler; } public function handle(QueryInterface $query): mixed { $queryClass = get_class($query); if (!isset($this-&amp;gt;handlers[$queryClass])) { throw new \InvalidArgumentException(&amp;quot;No handler registered for query: $queryClass&amp;quot;); } // Vérifier le cache $cacheKey = $this-&amp;gt;generateCacheKey($query); $cachedItem = $this-&amp;gt;cache-&amp;gt;getItem($cacheKey); if ($cachedItem-&amp;gt;isHit()) { $this-&amp;gt;logger-&amp;gt;debug('Query result served from cache', [ 'query' =&amp;gt; $queryClass, 'cacheKey' =&amp;gt; $cacheKey ]); return $cachedItem-&amp;gt;get(); } // Exécuter la requête $handler = $this-&amp;gt;handlers[$queryClass]; $result = $handler-&amp;gt;handle($query); // Mettre en cache $cachedItem-&amp;gt;set($result); $cachedItem-&amp;gt;expiresAfter(300); // 5 minutes $this-&amp;gt;cache-&amp;gt;save($cachedItem); $this-&amp;gt;logger-&amp;gt;info('Query executed and cached', [ 'query' =&amp;gt; $queryClass, 'cacheKey' =&amp;gt; $cacheKey ]); return $result; } private function generateCacheKey(QueryInterface $query): string { return 'query_' . md5(serialize($query)); }}&lt;/code&gt;#### &lt;strong&gt;Event Search Service Avancé&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Infrastructure\InMemory\Query;use App\Infrastructure\EventStore\InMemoryEventStore;use Psr\Log\LoggerInterface;use Psr\Cache\CacheItemPoolInterface;class EventSearchService{ private InMemoryEventStore $eventStore; private LoggerInterface $logger; private CacheItemPoolInterface $cache; public function __construct( InMemoryEventStore $eventStore, LoggerInterface $logger, CacheItemPoolInterface $cache ) { $this-&amp;gt;eventStore = $eventStore; $this-&amp;gt;logger = $logger; $this-&amp;gt;cache = $cache; } public function searchEvents(array $query, string $cacheKey = null): array { // Vérifier le cache if ($cacheKey) { $cachedItem = $this-&amp;gt;cache-&amp;gt;getItem($cacheKey); if ($cachedItem-&amp;gt;isHit()) { $this-&amp;gt;logger-&amp;gt;debug('Event search result served from cache', [ 'query' =&amp;gt; $query, 'cacheKey' =&amp;gt; $cacheKey ]); return $cachedItem-&amp;gt;get(); } } $results = $this-&amp;gt;eventStore-&amp;gt;searchEvents($query); // Mettre en cache if ($cacheKey) { $cachedItem-&amp;gt;set($results); $cachedItem-&amp;gt;expiresAfter(300); // 5 minutes $this-&amp;gt;cache-&amp;gt;save($cachedItem); } $this-&amp;gt;logger-&amp;gt;info('Event search executed', [ 'query' =&amp;gt; $query, 'results' =&amp;gt; count($results) ]); return $results; } public function getEventStatistics(string $eventType, \DateTime $from, \DateTime $to): array { $events = $this-&amp;gt;eventStore-&amp;gt;getEventsByType($eventType, $from, $to); $statistics = [ 'total' =&amp;gt; count($events), 'byHour' =&amp;gt; [], 'byDay' =&amp;gt; [], 'byOrganization' =&amp;gt; [], 'byUser' =&amp;gt; [] ]; foreach ($events as $event) { $hour = $event-&amp;gt;getTimestamp()-&amp;gt;format('Y-m-d H:00:00'); $day = $event-&amp;gt;getTimestamp()-&amp;gt;format('Y-m-d'); $orgId = $event-&amp;gt;getMetadata()['organizationId'] ?? 'unknown'; $userId = $event-&amp;gt;getMetadata()['userId'] ?? 'unknown'; $statistics['byHour'][$hour] = ($statistics['byHour'][$hour] ?? 0) + 1; $statistics['byDay'][$day] = ($statistics['byDay'][$day] ?? 0) + 1; $statistics['byOrganization'][$orgId] = ($statistics['byOrganization'][$orgId] ?? 0) + 1; $statistics['byUser'][$userId] = ($statistics['byUser'][$userId] ?? 0) + 1; } return $statistics; } public function getEventTrends(string $eventType, \DateTime $from, \DateTime $to, string $interval = 'day'): array { $events = $this-&amp;gt;eventStore-&amp;gt;getEventsByType($eventType, $from, $to); $trends = []; foreach ($events as $event) { $key = $this-&amp;gt;getIntervalKey($event-&amp;gt;getTimestamp(), $interval); $trends[$key] = ($trends[$key] ?? 0) + 1; } ksort($trends); return $trends; }}&lt;/code&gt;### &lt;strong&gt;3. Service de Projection Avancé&lt;/strong&gt;#### &lt;strong&gt;Service de Projection pour les Analytics&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Application\Service\InMemory;use App\Domain\Event\DomainEvent;use App\Infrastructure\InMemory\Command\InMemoryWriter;use Psr\Log\LoggerInterface;class PaymentProjectionService{ private InMemoryWriter $writer; private LoggerInterface $logger; public function __construct(InMemoryWriter $writer, LoggerInterface $logger) { $this-&amp;gt;writer = $writer; $this-&amp;gt;logger = $logger; } public function handleEvent(DomainEvent $event): void { switch ($event-&amp;gt;getEventType()) { case 'PaymentProcessed': $this-&amp;gt;handlePaymentProcessed($event); break; case 'PaymentFailed': $this-&amp;gt;handlePaymentFailed($event); break; case 'PaymentRefunded': $this-&amp;gt;handlePaymentRefunded($event); break; } } private function handlePaymentProcessed(DomainEvent $event): void { $key = &amp;quot;Payment:{$event-&amp;gt;getAggregateId()}&amp;quot;; $update = [ 'status' =&amp;gt; 'completed', 'processedAt' =&amp;gt; $event-&amp;gt;getTimestamp()-&amp;gt;format('c'), 'updatedAt' =&amp;gt; (new \DateTime())-&amp;gt;format('c') ]; $this-&amp;gt;writer-&amp;gt;update($key, $update, ['status']); $this-&amp;gt;logger-&amp;gt;info('Payment processed projection updated', [ 'paymentId' =&amp;gt; $event-&amp;gt;getAggregateId(), 'status' =&amp;gt; 'completed' ]); } private function handlePaymentFailed(DomainEvent $event): void { $key = &amp;quot;Payment:{$event-&amp;gt;getAggregateId()}&amp;quot;; $update = [ 'status' =&amp;gt; 'failed', 'error' =&amp;gt; $event-&amp;gt;getData()['error'], 'failedAt' =&amp;gt; $event-&amp;gt;getTimestamp()-&amp;gt;format('c'), 'updatedAt' =&amp;gt; (new \DateTime())-&amp;gt;format('c') ]; $this-&amp;gt;writer-&amp;gt;update($key, $update, ['status']); $this-&amp;gt;logger-&amp;gt;info('Payment failed projection updated', [ 'paymentId' =&amp;gt; $event-&amp;gt;getAggregateId(), 'status' =&amp;gt; 'failed' ]); } private function handlePaymentRefunded(DomainEvent $event): void { $key = &amp;quot;Payment:{$event-&amp;gt;getAggregateId()}&amp;quot;; $update = [ 'status' =&amp;gt; 'refunded', 'refundAmount' =&amp;gt; $event-&amp;gt;getData()['refundAmount'], 'refundedAt' =&amp;gt; $event-&amp;gt;getTimestamp()-&amp;gt;format('c'), 'updatedAt' =&amp;gt; (new \DateTime())-&amp;gt;format('c') ]; $this-&amp;gt;writer-&amp;gt;update($key, $update, ['status']); $this-&amp;gt;logger-&amp;gt;info('Payment refunded projection updated', [ 'paymentId' =&amp;gt; $event-&amp;gt;getAggregateId(), 'status' =&amp;gt; 'refunded' ]); }}&lt;/code&gt;## 🧪 &lt;strong&gt;Tests et Validation&lt;/strong&gt;### &lt;strong&gt;Tests d&amp;rsquo;Intégration Event Sourcing + CQRS&lt;/strong&gt;&lt;code&gt;php&amp;lt;?phpnamespace App\Tests\Integration\InMemory;use App\Application\Command\Payment\ProcessPaymentCommand;use App\Application\Command\Payment\ProcessPaymentCommandHandler;use App\Application\Query\Payment\GetPaymentHistoryQuery;use App\Application\Query\Payment\PaymentEventQueryHandler;use App\Infrastructure\EventStore\InMemoryEventStore;use App\Infrastructure\InMemory\Query\EventSearchService;class InMemoryEventSourcingCqrsTest extends TestCase{ private InMemoryEventStore $eventStore; private EventSearchService $eventSearch; private ProcessPaymentCommandHandler $commandHandler; private PaymentEventQueryHandler $queryHandler; protected function setUp(): void { $this-&amp;gt;eventStore = new InMemoryEventStore($this-&amp;gt;createMock(LoggerInterface::class)); $this-&amp;gt;eventSearch = new EventSearchService($this-&amp;gt;eventStore, $this-&amp;gt;createMock(LoggerInterface::class), $this-&amp;gt;createMock(CacheItemPoolInterface::class)); $this-&amp;gt;commandHandler = new ProcessPaymentCommandHandler( $this-&amp;gt;eventStore, $this-&amp;gt;createMock(EventBusInterface::class), $this-&amp;gt;createMock(LoggerInterface::class) ); $this-&amp;gt;queryHandler = new PaymentEventQueryHandler($this-&amp;gt;eventSearch, $this-&amp;gt;createMock(LoggerInterface::class)); } public function testEventSourcingCqrsFlow(): void { // Exécuter une commande $command = new ProcessPaymentCommand( 'payment-123', 100.00, 'EUR' ); $this-&amp;gt;commandHandler-&amp;gt;handle($command); // Vérifier l'historique des événements $query = new GetPaymentHistoryQuery('payment-123'); $history = $this-&amp;gt;queryHandler-&amp;gt;handle($query); $this-&amp;gt;assertNotEmpty($history); $this-&amp;gt;assertCount(1, $history); $this-&amp;gt;assertEquals('PaymentProcessed', $history[0]['eventType']); } public function testEventSearchWithAnalytics(): void { // Créer plusieurs événements $commands = [ new ProcessPaymentCommand('payment-1', 100.00, 'EUR'), new ProcessPaymentCommand('payment-2', 200.00, 'USD'), new ProcessPaymentCommand('payment-3', 300.00, 'EUR') ]; foreach ($commands as $command) { $this-&amp;gt;commandHandler-&amp;gt;handle($command); } // Rechercher les événements $searchQuery = new SearchPaymentEventsQuery( new \DateTime('2024-01-01'), new \DateTime('2024-12-31') ); $results = $this-&amp;gt;queryHandler-&amp;gt;handle($searchQuery); $this-&amp;gt;assertCount(3, $results); $this-&amp;gt;assertEquals('PaymentProcessed', $results[0]['eventType']); }}&lt;/code&gt;## 📊 &lt;strong&gt;Performance et Optimisation&lt;/strong&gt;### &lt;strong&gt;Stratégies d&amp;rsquo;Optimisation Event Sourcing + CQRS&lt;/strong&gt;#### &lt;strong&gt;1. Cache Multi-Niveaux&lt;/strong&gt;&lt;code&gt;phppublic function searchEventsWithCache(array $query, string $cacheKey = null): array{ // Cache L1: Mémoire if (isset($this-&amp;gt;memoryCache[$cacheKey])) { return $this-&amp;gt;memoryCache[$cacheKey]; } // Cache L2: Redis if ($cached = $this-&amp;gt;redis-&amp;gt;get(&amp;quot;event_search:{$cacheKey}&amp;quot;)) { $result = json_decode($cached, true); $this-&amp;gt;memoryCache[$cacheKey] = $result; return $result; } // In-Memory $result = $this-&amp;gt;searchEvents($query); // Mettre en cache $this-&amp;gt;memoryCache[$cacheKey] = $result; $this-&amp;gt;redis-&amp;gt;setex(&amp;quot;event_search:{$cacheKey}&amp;quot;, 300, json_encode($result)); return $result;}&lt;/code&gt;#### &lt;strong&gt;2. Projections Asynchrones&lt;/strong&gt;&lt;code&gt;phppublic function handleEventAsync(DomainEvent $event): void{ // Mettre en queue pour traitement asynchrone $this-&amp;gt;messageBus-&amp;gt;dispatch(new ProcessProjectionCommand($event));}&lt;/code&gt;#### &lt;strong&gt;3. Index Optimisés&lt;/strong&gt;&lt;code&gt;phppublic function optimizeIndexes(): void{ // Nettoyer les index orphelins $this-&amp;gt;cleanOrphanedIndexes(); // Compacter les index $this-&amp;gt;compactIndexes(); // Forcer le garbage collection gc_collect_cycles();}&lt;/code&gt;## 🎯 &lt;strong&gt;Critères d&amp;rsquo;Adoption&lt;/strong&gt;### &lt;strong&gt;Quand Utiliser Event Sourcing + CQRS avec In-Memory&lt;/strong&gt;#### &lt;strong&gt;✅ Avantages&lt;/strong&gt;- &lt;strong&gt;Audit trail complet&lt;/strong&gt; : Historique immuable de tous les événements- &lt;strong&gt;Scalabilité maximale&lt;/strong&gt; : Possibilité de scaler indépendamment- &lt;strong&gt;Performance optimale&lt;/strong&gt; : Chaque côté optimisé pour son usage- &lt;strong&gt;Flexibilité maximale&lt;/strong&gt; : Projections multiples pour différents besoins- &lt;strong&gt;Cache efficace&lt;/strong&gt; : Mise en cache des requêtes#### &lt;strong&gt;❌ Inconvénients&lt;/strong&gt;- &lt;strong&gt;Complexité maximale&lt;/strong&gt; : Architecture très complexe- &lt;strong&gt;Volatilité&lt;/strong&gt; : Données perdues au redémarrage- &lt;strong&gt;Limitation mémoire&lt;/strong&gt; : Contraint par la RAM disponible- &lt;strong&gt;Expertise&lt;/strong&gt; : Équipe très expérimentée requise- &lt;strong&gt;Coût&lt;/strong&gt; : Infrastructure très coûteuse#### &lt;strong&gt;🎯 Critères d&amp;rsquo;Adoption&lt;/strong&gt;- &lt;strong&gt;Système très complexe&lt;/strong&gt; : Besoins de scalabilité maximale- &lt;strong&gt;Audit trail critique&lt;/strong&gt; : Besoin de traçabilité complète- &lt;strong&gt;Performance critique&lt;/strong&gt; : Besoins de performance maximale- &lt;strong&gt;Données temporaires&lt;/strong&gt; : Cache, sessions, métriques- &lt;strong&gt;Équipe très expérimentée&lt;/strong&gt; : Maîtrise d&amp;rsquo;Event Sourcing, CQRS et In-Memory- &lt;strong&gt;Budget important&lt;/strong&gt; : Investissement en complexité justifié- &lt;strong&gt;Mémoire suffisante&lt;/strong&gt; : RAM disponible pour tous les événements## 🚀 &lt;strong&gt;Votre Prochaine Étape&lt;/strong&gt;

&lt;div class="chapter-navigation"&gt;
 &lt;h2 class="chapter-nav-title"&gt;🎯 Votre Prochaine Étape&lt;/h2&gt;
 &lt;p class="chapter-nav-subtitle"&gt;Maintenant que vous comprenez les concepts de base et que j'ai partagé mon expérience avec Gyroscops, quel est votre contexte ?&lt;/p&gt;</description></item></channel></rss>